---
title: 第 3 章 - GUIX の機能の概要
description: この章では、高パフォーマンスの GUIX ユーザー インターフェイス製品の機能の概要について説明します。
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 2a53da048b18d35b6b15a4ad8d4138e1a2acd4e8
ms.sourcegitcommit: 95f4ae0842a486fec8f10d1480203695faa9592d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/09/2021
ms.locfileid: "111875250"
---
# <a name="chapter-3---functional-overview-of-guix"></a>第 3 章 - GUIX の機能の概要

この章では、高パフォーマンスの GUIX ユーザー インターフェイス製品の機能の概要について説明します。 

## <a name="execution-overview"></a>実行の概要

GUIX では、イベント ドリブン プログラミング モデルを実装しています。 つまり、GUIX フレームワークは主に、GUIX イベント キューにプッシュされたイベントの受信によって起動されます。 これらのイベントの処理は、GUIX システムの初期化中に作成された ThreadX スレッドである GUIX スレッドのコンテキストで実行されます。

GUIX アプリケーションでは、GUIX API 関数を呼び出してウィンドウと子ウィジェットを作成することによってユーザー インターフェイスを定義し、各ウィンドウまたはウィジェットの種類の色、スタイル、フォント、その他のさまざまな属性を定義するために使用される追加の API 関数を呼び出して、これらのウィジェットの外観をカスタマイズします。 ユーザー インターフェイス画面の外観を作成するために GUIX Studio を使用している場合は、GUIX API 関数を呼び出してディスプレイを作成するこの作業の多くが GUIX Studio アプリケーションによって自動的に実行されます。

GUIX アプリケーションでは、GUIX イベント キューから取得されたイベントを処理することによって、システム ユーザーや外部のビジネス ロジックと対話します。
これらのイベントは通常 GUIX ウィジェットによって生成されますが、外部スレッドでも作成できます。 一般的な GUIX ボタンがプッシュされると、そのボタンによって、そのボタンの親ウィンドウにイベントが送信されます。 アプリケーション プログラムでは、ボタン プッシュ イベント用のハンドラーを提供することによって、そのボタンのプッシュに対処します。

追加の GUIX スレッドは多くの場合、入力ドライバーなどのために作成されます。 一般的なタッチ スクリーン入力ドライバーは、メインの GUIX スレッドの外部にあるスタンドアロン スレッドとして実行されます。 タッチ入力ドライバーでは、イベントを GUIX イベント キューに送信することによってタッチ情報を GUIX スレッドに送信します。

アニメーションなどの多くのユーザー インターフェイス操作には正確なタイミング情報が必要なため、GUIX では、簡単で、使いやすいタイマー インターフェイスも実装しています。 このタイマー インターフェイスは ThreadX タイマー サービスに基づいて構築されており、システムの起動時に自動的に構成されます。

GUIX ソフトウェアの大部分は、ハードウェアのどのような依存関係からも独立しています。 このフレームワークには、ハードウェア固有の入力ドライバーとハードウェア固有のグラフィックス ドライバーが必要です。 これらのハードウェア固有のドライバーが実装される方法の詳細については、後の第 5 章を参照してください。

## <a name="initialization"></a>初期化 

サービス ***gx_system_initialize*** は、他のどの GUIX サービスよりも前に呼び出す必要があります。 GUIX システムの初期化は、ThreadX の ***tx_application_define*** ルーチン (初期化コンテキスト) またはアプリケーション スレッドから呼び出すことができます。 ***gx_system_initialize*** 関数では、GUIX イベント キューを作成し、GUIX タイマー機能を初期化し、メインの GUIX システム スレッドを作成し、アプリケーションの実行中に GUIX によって管理されるさまざまなデータ構造体を初期化します。

***gx_system_initialize*** から戻ったら、アプリケーションはディスプレイ、キャンバス、ウィンドウ、ウィジェットを作成し、すべての GUIX オブジェクトのプロパティをカスタマイズする準備が整っています。 GUIX オブジェクト作成 API の多くは、***tx_application_define*** またはアプリケーション スレッドから呼び出すことができます。

## <a name="application-interface-calls"></a>アプリケーション インターフェイスの呼び出し 

アプリケーションからの呼び出しは、主に ***tx_application_define*** (初期化コンテキスト) またはアプリケーション スレッドから実行されます。 どのようなコンテキストから呼び出すことができるかを確認するには、第 4 章で説明されている各 GUIX API の「許可元」セクションを参照してください。

ほとんどの場合、負荷の高いアクティビティの処理は、すべてのイベント処理とウィジェットまたはウィンドウの描画を含め、内部 GUIX スレッドに遅延されます。

GUIX API 関数は、どのスレッドからでも、いつでも呼び出すことができます。
ただし、通常は、タイム クリティカルなビジネス ロジックをユーザー インターフェイスのロジックから分離する方が適切なアーキテクチャであると見なされます。 ユーザー インターフェイスの描画操作は、表示サイズや CPU パフォーマンスによっては長い時間がかかる場合があるため、通常は、タイム クリティカルなスレッドをその描画操作が完了するまで遅延させたくありません。

## <a name="internal-guix-thread"></a>内部 GUIX スレッド 

先に説明したように、GUIX には GUI 処理の大部分を実行する内部スレッドがあります。 このスレッドは、***gx_system_initialize** _ に続けて _*_gx_system_start_** を呼び出すことによって、アプリケーション ソフトウェアによって作成されます。

内部 GUIX スレッドの優先度は `#define GX_SYSTEM_THREAD_PRIORITY` によって決定されます。 この値の既定値は 16 (中レベルの優先度) ですが、gx_port.h または gx_user.h ヘッダー ファイルでこの値を指定し、既定値をオーバーライドすることによって変更できます。

GUIX スレッドのタイム スライスも同様に `#define GX_SYSTEM_THREAD_TIMESLICE` によって定義されます。この既定値は 10 ms です。

システム スレッドのスタック サイズは `#define GX_THREAD_STACK_SIZE` (***gx_port.h*** ヘッダー ファイルにあります) によって決定されますが、gx_user.h ヘッダー ファイルでこの値を指定することによってオーバーライドすることもできます。

内部 GUIX スレッドの実行ループは 3 つのアクションで構成されています。
最初に、GUIX では GUIX イベント キューからイベントを取得し、GUIX ウィンドウおよびウィジェットで処理するためにこれらのイベントをディスパッチします。 イベントは通常、定期的なタイマー、タッチ スクリーンやキーパッドなどの入力デバイスのほか、GUIX ウィジェットでユーザー入力を処理するときはそのウィジェット自体によって GUIX イベント キューにプッシュされます。 次に、すべてのイベントが処理された後、GUIX では画面の更新が必要かどうかを判定し、その場合は、主にダーティとマークされているこれらのウィンドウやウィジェットの描画関数を呼び出すことによって、ディスプレイ グラフィックス データを更新するために必要な処理を実行します。 最後に、GUIX では、新しい 1 つまたは複数の入力イベントが到着するまで GUIX スレッドを中断します。

## <a name="event-processing"></a>イベント処理 

タッチまたはペン入力イベントは、タッチまたはペン入力のピクセル位置の下にある最上位のウィンドウまたはウィジェットを決定し、そのウィンドウまたはウィジェットのイベント処理関数を呼び出すことによって処理されます。 ウィジェットは、ペン入力イベントを認識している場合、そのウィジェットの種類に合わせてイベントを処理します。 そうでない場合、最上位のウィジェットは、タッチまたはペン入力イベントを処理のためにそのウィジェットの親に渡します。 このチェーンの上方へのイベントの受け渡しは、そのイベントが処理されるか、またはそのイベントがルート ウィンドウに到達する (この場合、そのイベントは破棄されます) まで続行されます。

キーパッド イベントは、入力フォーカスのあるウィンドウまたはウィジェットに送信されます。 入力フォーカスの状態は、GUIX gx_system コンポーネントによって管理されます。

タイマー イベントは常に、タイマーを所有するウィンドウまたはウィジェットに処理のためにディスパッチされます。

内部的に生成されたイベント (ボタン クリック イベントやスライダー値変更イベントなど) は常に、イベントを生成しているウィジェットの親に送信されます。 その親によってイベントが処理されない場合、そのイベントは、タッチまたはペン入力イベントと同様にチェーンの上方に渡されます。

## <a name="drawing"></a>描画 

すべてのイベント処理が完了すると、GUIX 内部スレッドではディスプレイの更新が必要かどうかを判定し、その場合は、適切なウィンドウまたはウィジェット描画関数が呼び出されます。 描画が完了すると、GUIX 内部スレッドでは単純に、そのイベント キュー上で次の処理対象 GUIX イベントを待ちます。

GUIX では、ウィジェットやキャンバスごとに再描画する必要のある領域である "*ダーティ領域*" の概念を実装しています。 ウィジェットは、以前にダーティとマークされている領域にしか描画できません。 ウィジェット描画関数が呼び出されると、すべての描画操作が、以前に定義されたダーティな四角形に内部的にクリップされます。
この領域の外部に描画しようとしても無視されます。

ウィジェットとウィンドウは、API 関数 ***gx_system_dirty_mark*** を呼び出すことによって、それ自体をダーティとマークします。 この関数では、ウィジェットまたはウィンドウ全体を再描画が必要としてマークします。 2 番目の関数である ***gx_system_dirty_partial_add*** は、ウィンドウまたはウィジェットの一部のみをダーティとマークするための別の方法として呼び出すことができます。

ウィジェットをダーティとマークした後、これらのウィジェットをすべての入力イベントが処理されたときにのみ再描画するというこのモデルは、"*遅延描画*" と呼ばれます。 GUIX 遅延描画アルゴリズムとダーティ リストのメンテナンスは、描画の効率を向上させるように設計されています。 描画操作は通常、コストが高いため、GUIX では不必要な描画を可能な限り防ごうとします。

描画は、GUIX "*キャンバス*" に対して行われます。 キャンバスは、グラフィックス データを保持するために予約されているメモリ領域です。 キャンバスは、システム アーキテクチャやメモリ制約に応じて、ハードウェア フレーム バッファーに直接リンクされている場合といない場合があります。 何らかの描画を実行するには、まず ***gx_canvas_drawing_initiate*** API 関数を呼び出すことによって、キャンバスを描画用に開いておく必要があります。 この API では描画用のキャンバスを準備し、現在の "*描画コンテキスト*" を確立します。 GUIX がシステム キャンバスの更新を実行すると、そのキャンバスが描画用に開かれ、ウィジェット レベルの描画 API が呼び出される前に描画コンテキストが確立されます。 そのため、ウィジェットがウィジェット描画関数内でキャンバスへの描画を開始する必要はありません。

ただし、アプリケーションが標準の GUIX 遅延描画アルゴリズムのフローの外部でキャンバスへの即時描画を実行しようとする場合、そのアプリケーションでは他のどの描画 API 関数よりも前に ***gx_canvas_drawing_initiate*** を直接呼び出す必要があり、即時描画が完了したら ***gx_canvas_drawing_complete*** を呼び出す必要があります。

## <a name="user-input"></a>ユーザー入力 

GUIX では、イベントの種類が事前に定義されたタッチ スクリーン、マウス、キーボード デバイスをサポートしています。 カスタム イベントの種類を定義するか、またはカスタム入力デバイスを定義済みのイベントの種類にマップすることによって、追加の入力デバイスを利用できます。

これらのデバイスに関連付けられているアクションは、内部 GUIX スレッドによって処理されるイベントに変換されます。 タッチ スクリーンをサポートするために記述されたドライバー レベルのソフトウェアでは、ペンダウン、ペンアップ、ペンドラッグ操作のイベントを準備して GUIX イベント キューに送信する必要があります。 同様に、キーパッド入力ドライバーでは、キー押下およびキー リリース入力のイベントを生成する必要があります。

## <a name="modal-dialog-execution"></a>モーダル ダイアログ実行 

モーダル ダイアログ実行とは、他の GUIX ウィンドウまたはウィジェットでユーザー入力を受信できるようにするには何らかの方法で閉じる必要があるウィンドウをユーザーに表示することを指します。 モーダル ダイアログでは、タッチまたはマウス入力イベントの x、y 位置には関係なく、ダイアログ ウィンドウが表示されている間にすべてのユーザー入力をキャプチャします。

モーダル ダイアログは、まず ***gx_window_create*** を呼び出して通常の方法でウィンドウを作成し、次に GUIX API 関数 ***gx_window_execute*** を呼び出すことにより、アプリケーション ソフトウェアによってトリガーされます。

***gx_window_execute*** 関数が呼び出されると、GUIX はローカルのイベント処理ループに入ります。 ***gx_window_execute*** 関数は、ユーザー入力によって、または ***gx_window_close*** を呼び出すことによってダイアログ ウィンドウが閉じられるまで呼び出し元に戻りません。 このため、GUIX 内部スレッド以外のどのスレッドからも ***gx_window_execute*** 関数を呼び出さないようにすることが非常に重要です。

## <a name="periodic-processing"></a>定期的な処理 

表示効果、スプライト アニメーション、アプリケーションの定期的な要求に対するサポートなどを提供するために、GUIX では 1 つの ThreadX タイマーを使用します。 この 1 つのタイマーは、時間に関連する GUIX のすべてのニーズを起動するために使用されます。 既定では、GUIX の内部タイマーの処理の頻度は、**_gx_api.h_** で定義されている定数 **GX_SYSTEM_TIMER_MS** を使用して 20ms に設定されます。ただし、この定数が以前に gx_port.h または gx_user.h ヘッダーで定義されている場合を除きます。 この既定の頻度は、GUIX ライブラリを構築するときにコンパイル オプションを使用してアプリケーションで、または ***gx_user.h*** で明示的に再定義することによって変更できます。

> [!IMPORTANT]
> GUIX タイマーの頻度が RTOS タイマー刻みで表され、定数 **GX_SYSTEM_TIMER_TICKS** によって定義されることに注意してください。 **GX_SYSTEM_TIMER_TICKS** の値は、**GX_SYSTEM_TIMER_MS** と **TX_TIMER_TICKS_PER_SECOND** を使用して計算されます。 ユーザーは、これらの値のいずれかを ***gx_port.h** _ または _ *_gx_user.h_** で再定義して GUIX タイマーの頻度と解像度を調整できます。

## <a name="display-driver"></a>ディスプレイ ドライバー 

ディスプレイ ドライバーは、GUIX コア コードに一連の描画関数を提供する処理を担当します。 これらの各描画関数の実装はドライバーによって決定され、可能な場合、この実装ではハードウェア アクセラレータのサポートを利用します。 一般に、描画関数は、メモリ バッファーにピクセル データを書き込むことによって機能します。このバッファーは物理フレーム バッファー、またはドライバーのアーキテクチャによってはセカンダリ バッファーである場合があります。 多くのドライバーでは 2 つのフレーム バッファーを使用するダブル バッファリングを実装し、これらのバッファーはバッファー切り替え関数を呼び出すことによって切り替えられます。 GUIX では、これらの関数を適切な時刻に内部的に呼び出します。 メモリに制約のあるシステムの場合は、描画関数が 1 つのメモリ フレーム バッファーにしか書き込めないことがあります。

GUIX では、低レベルの各描画関数の既定のソフトウェア実装を、すべてのサポート色深度および形式で提供します。 これらの関数は、**GX_DISPLAY** 構造体内に保持されている関数ポインター経由で呼び出されます。 ハードウェア固有のドライバーが作成されると、このドライバーでは通常、これらの関数ポインターのいくつかをターゲット ハードウェアに固有の関数で上書きします。

標準的なハードウェア ディスプレイ ドライバーは、まず、必要な色深度および形式に対する既定の GUIX ディスプレイ ドライバーを作成することによって実装されます。
次に、このハードウェア ドライバーでは、特定のハードウェア実装のために最適化またはカスタマイズする必要のある関数を置き換えます。

GUIX では、1 bpp モノクロから 32 bpp a:r:g:b 形式までのピクセル色形式をサポートしています。 GUIX ではまた、r:g:b と b:g:r のバイト順、パックされたピクセルとワード単位で揃えたピクセルの形式、アルファ チャネルなど、幅広い各色深度カテゴリ内の多くのバリエーションもサポートしています。 現在、25 の個別の色形式がサポートされていますが、このリストはハードウェア ベンダーが新しいバリエーションを提供するにつれて増えていきます。

## <a name="display-memory-architectures"></a>ディスプレイ メモリ アーキテクチャ

さまざまなハードウェア ターゲットやディスプレイでは、ターゲットのメモリ制約やアプリケーションの機能要件に応じて、多様なディスプレイ メモリ アーキテクチャが利用されます。 ここでは、いくつかの一般的なメモリ アーキテクチャの概要を、各アーキテクチャの簡単な説明と共に示します。

モデル 1) フレーム バッファーなし、グラフィックス データを外部 GRAM に保持:

![フレーム バッファーなし、グラフィックス データを外部 GRAM に保持](./media/guix/user-guide/no-frame-buffer.png)

このモデルでは、CPU にローカルなメモリ内にフレーム バッファー用のメモリは存在しません。 すべてのグラフィックス データが、ディスプレイ自体に組み込まれた外部 GRAM に格納されます。 外部 GRAM へのインターフェイスはパラレルでもシリアルでもかまいません。 この種類のアーキテクチャは非常に低コストですが、グラフィックス データが更新されたときに望ましくないティアリング効果が発生することがあります。

モデル 2) 1 つのローカル フレーム バッファー:

![1 つのローカル フレーム バッファー](./media/guix/user-guide/one-local-frame-buffer.png)

このモデルでは、グラフィックス データ用のメモリは、CPU から直接アクセスできるランダム アクセス メモリから割り当てられます。 グラフィックス データを (タイミング信号と共に) ローカル メモリからディスプレイに繰り返し転送するには、専用のハードウェアが存在する必要があります。 このモデルは、グラフィックス メモリが CPU で使用できるローカル SRAM または DRAM のブロックである点でモデル 1 とは異なります。 これは、スタックやプログラム変数が存在しているのと同じメモリである可能性があります。

モデル 3) ローカル フレーム バッファー + 外部 GRAM:

![ローカル フレーム バッファー + 外部 GRAM](./media/guix/user-guide/local-frame-buffer-external-gram.png)

モデル 3 は、最初の 2 つの組み合わせです。 このモデルでは、1 つのフレーム バッファーを保持するための十分なローカル メモリが存在します。 さらに、ディスプレイ デバイスが外部 GRAM を提供し、GRAM で提供されるデータを使用してそれ自体を自動的に更新します。 このアーキテクチャでは、ローカル フレーム バッファーの変更された部分を (多くの場合は、オンボード DMA チャネルを利用して) 1 回のブロック転送で外部 GRAM に転送できるため、更新の効率が向上するというメリットがあります。 このモデルではまた、完成したグラフィックス コンテンツのみが外部 GRAM にコピーされるため、最初の 2 つのモデルのどちらにも存在する可能性があるティアリングやちらつきも解消されます。

モデル 4) ピンポン フレーム バッファー:

![ピンポン フレーム バッファー](./media/guix/user-guide/ping-pong-frame-buffers.png)

モデル 4 では、2 つのローカル フレーム バッファーを提供するための十分なメモリが存在します。 この場合、GUIX では 1 つのフレーム バッファーをアクティブなフレーム バッファーとして、もう一方を作業用フレーム バッファーとして扱います。 ディスプレイの更新または描画操作が進行中のとき、それは作業用バッファーで実行されます。 描画操作が完了すると、バッファーが切り替えられ、作業用バッファーがアクティブなバッファーになり、アクティブなバッファーが作業用バッファーになります。 このモデルではまた、バッファーが 1 つのシステムで観察される可能性がある画面のちらつきやティアリングも解消されます。

モデル 5) キャンバス合成を使用したピンポン バッファー:

![キャンバス合成を使用したピンポン バッファー](./media/guix/user-guide/ping-pong-buffers-canvas-composting.png)

モデル 5 では、使用可能なメモリの上限まで、任意の数のキャンバスを作成できます。 アプリケーションでの定義に従ってキャンバスをオーバーレイまたはブレンドすることにより、キャンバス合成を作成できます。 画面の更新操作の後に新しい合成が作成されると、標準のピンポン バッファー アーキテクチャと同じ操作で、アクティブな合成バッファーと作業用の合成バッファーが切り替えられます。 モデル 5 では、キャンバスを最終的な出力の合成にブレンドすることによって、画面のフェードおよびブレンド操作を実行する機能が追加されます。

モデル 6) 外部 GRAM を使用したキャンバス合成:

![外部 GRAM を使用したキャンバス合成](./media/guix/user-guide/canvas-compositing-external-gram.png)

モデル 6 は、モデル 5 に対する若干のバリエーションです。ここでは、1 つの合成バッファーのみが必要とされ、その合成バッファーが外部 GRAM に転送されます。 このモデルではまた、全画面表示のブレンドとオーバーレイもサポートされます。

## <a name="string-encoding"></a>文字列エンコード 

GUIX では、既定では UTF8 形式の文字列エンコードをサポートしています。 UTF8 文字列エンコードのサポートは、***gx_user.h*** ヘッダー ファイルで **GX_DISABLE_UTF8_SUPPORT** を定義することによって無効にすることができます。 UTF8 エンコードが無効になっている場合、GUIX では、標準の 8 ビット ASCII に加えてラテン-1 コード ページ文字エンコードのみを内部的に使用します。 UTF8 文字列エンコードを無効にすると、GUIX ライブラリの占有領域がわずかに小さくなり、文字列処理やテキスト描画関数のランタイム実行がわずかに高速になります。

UTF8 文字列エンコードには、次の特徴があります。

  - ASCII 文字列に標準の 7 ビット ASCII エンコードより大きな記憶域スペースは必要ありません。

  - ほとんどの ANSI-C 文字列関数は、変更なしで UTF8 文字列エンコードで動作します。

世界中のすべてのアクティブな文字セット (漢字文字セットを含む) は、UTF8 文字列エンコードを使用して表すことができます。

### <a name="static-and-dynamic-strings"></a>静的文字列と動的文字列 

テキスト表示をサポートする GUIX ウィジェットに割り当てられた文字列は、通常は、後で説明されている GUIX 文字列テーブルの一部として定数ストレージに配置される静的に定義された文字列定数である場合と、***sprintf** _ や _*_gx_utility_ltoa_** などのサービスを使用して実行時に生成される文字列である動的に定義された文字列である場合があります。

動的文字列の例には、GUIX プロンプト ウィジェットに数字として表示される値や、ユーザーの場所と書式設定に基づいて動的に書式設定された "時刻/日付" 文字列などが含まれます。 **GX_PROMPT** または **GX_TEXT_BUTTON ウィジェット** などの GUIX ウィジェットに割り当てられる文字列を実行時に作成する場合は、ランタイムで生成されるこれらの文字列 (
グローバルな文字配列) 用のストレージを静的に割り当てることを選択する必要があります。あるいは、動的メモリ アロケーター関数を定義してインストールし、割り当てられたテキスト文字列のプライベート コピーを作成するようこれらのウィジェットに指示する **GX_STYLE_TEXT_COPY** スタイルを使用することもできます。

一時ストレージ (自動文字配列など) を使用して、動的に生成される文字列を保持した後、この文字列を **GX_STYLE_TEXT_COPY** スタイルが設定されていないウィジェットに割り当てることはプログラミング エラーです。 このスタイルが有効になっていない場合、このウィジェットでは単純に、指定された文字列ポインターをコピーします。その文字列データは静的に割り当てる必要があります。そうしないと、ウィジェット文字列ポインターがガベージ データを指し、予測不可能な結果が生成される可能性があります。

### <a name="passing-gx_string-arguments"></a>GX_STRING 引数の受け渡し 

GX_STRING パラメーターを受け付ける GUIX API 関数では、常に **GX_STRING.gx_string_ptr** フィールドによって指し示されている文字列の長さが **GX_STRING.gx_string_length** フィールドの値に一致していることを確認します。 これらの 2 つのフィールドに整合性がない場合は、**GX_INVALID_STRING_LENGTH** エラーが返され、呼び出された API は文字列の割り当てを受け付けずに戻ります。

安全性を考慮して、GUIX ソフトウェアでは、***strlen** _ や _*_strcpy_** などの標準の C 文字列関数を決して内部的に使用しません。 これらの関数は、文字列データが動的に取得された場合、悪意のある攻撃を受けやすいことが知られています。これは多くの場合、接続されているアプリケーションで発生します。

リリース 5.6 より前の GUIX ライブラリ リリースでは、パラメーターとして (`GX_CONST GX_CHAR *text`) を受け付ける API 関数が定義されていました。 下位互換性のために引き続きサポートされていますが、これらの関数は廃止され、入力パラメーターとして (`GX_CONST GX_STRING *string`) を受け付ける、推奨される API 関数に置き換えられています。

既定では、非推奨のテキスト処理 API が有効になっています。これにより、以前に記述されたすべてのアプリケーションを、GUIX ライブラリへの最新の更新プログラムでクリーンにビルドできます。 この非推奨のテキスト処理 API を無効にするには、**_gx_user.h_ *_ ヘッダー ファイルに定義 **GX_DISABLE_DEPRECATED_STRING_API** を追加する必要があります。すべての新しいアプリケーションで _* GX_DISABLE_DEPRECATED_STRING_API** を定義し、置き換え後の API 関数のみを使用する必要があります。 GUIX ライブラリ バージョン リリース 5.6 以降で GUIX Studio によって生成されたすべての出力ファイルでは、置き換え後の API 関数のみを利用します。

次の表は、非推奨の API 関数名と新しく定義された置き換え後の API 関数名の一覧を示しています。

| **非推奨の関数名**              | **置き換え後の関数名**                              |
| ------------------------------------------ | ----------------------------------------------- |
| gx_binres_language_table_load          | gx_binres_language_table_load_ext          |
| gx_canvas_rotated_text_draw            | gx_canvas_rotated_text_draw_ext            |
| gx_canvas_text_draw                     | gx_canvas_text_draw_ext                     |
| gx_context_string_get                   | gx_context_string_get_ext                   |
| gx_display_language_table_get          | gx_display_language_table_get_ext          |
| gx_display_language_table_set          | gx_display_language_table_set_ext          |
| gx_display_string_get                   | gx_display_string_get_ext                   |
| gx_display_string_table_get            | gx_display_string_table_get_ext            |
| gx_multi_line_text_button_text_set   | gx_multi_line_text_button_text_set_ext   |
| gx_multi_line_text_input_char_insert | gx_multi_line_text_input_char_insert_ext |
| gx_multi_line_text_input_text_set    | gx_multi_line_text_input_text_set_ext    |
| gx_multi_line_text_view_text_set     | gx_multi_line_text_view_text_set_ext     |
| gx_prompt_text_get                      | gx_prompt_text_get_ext                      |
| gx_prompt_text_set                      | gx_prompt_text_set_ext                      |
| gx_single_line_text_input_text_set   | gx_single_line_text_input_text_set_ext   |
| gx_system_string_width_get             | gx_system_string_width_get_ext             |
| gx_system_version_string_get           | gx_system_version_string_get_ext           |
| gx_text_button_text_get                | gx_text_button_text_get_ext                |
| gx_text_button_text_set                | gx_text_button_text_set_ext                |
| gx_text_scroll_wheel_callback_set     | gx_text_scroll_wheel_callback_set_ext     |
| gx_utility_string_to_alphamap          | gx_utility_string_to_alphamap_ext          |
| gx_widget_string_get                    | gx_widget_string_get_ext                    |
| gx_widget_text_blend                    | gx_widget_text_blend_ext                    |
| gx_widget_text_draw                     | gx_widget_text_draw_ext                     |

### <a name="guix-string-table"></a>GUIX 文字列テーブル 

GUIX の文字列テーブルと文字列リソースは、GUIX ディスプレイ インスタンスに登録されています。

マルチディスプレイ システム内の各ディスプレイには独自の文字列テーブルがあり、各ディスプレイは独自の選択された言語で動作できます。また、その他の GUIX リソースの種類 (色、フォント、ピクセルマップ) も、これらのリソースの種類が各ディスプレイの色形式と色深度に固有のものであるため、GUIX ディスプレイ コンポーネントによって管理されます。

アプリケーション文字列テーブルは手動で作成できますが、ディスプレイ文字列テーブルはほとんどの場合、プロジェクト リソース ファイルの一部として GUIX Studio アプリケーションによって定義されます。 使用可能な言語もまた、リソース ヘッダー ファイルで定義されます。 ディスプレイ文字列テーブルは、アプリケーション文字列へのポインターの複数列テーブルです。 文字列テーブルの各列は、そのアプリケーションでサポートされている 1 つの言語を表します。
アプリケーションが 1 つの言語 (英語など) のみをサポートしている場合は、文字列テーブルの列が 1 つだけになります。 その場合でも、アプリケーション ソフトウェアを変更することなく、追加の言語のサポートをいつでも追加できます。

アクティブな文字列テーブルは、***gx_display_string_table_set*** API 関数を呼び出すことによって割り当てられます。 この関数は、GUIX Studio で生成されたスタートアップ コードによって自動的に呼び出されますが、アクティブな文字列テーブルを変更するために、アプリケーションで直接呼び出すこともできます。

アクティブな言語は、***gx_display_active_language_set*** API 関数を呼び出すことによって割り当てられます。 この関数によって、ディスプレイ文字列テーブルのどの列がアクティブであるかが決定されます。

この関数が呼び出されると、**GX_EVENT_LANGUAGE_CHANGE** イベントがすべての表示される GUIX ウィジェットに送信され、それらを新しくアクティブになった文字列データが表示されるように更新できます。

ウィジェットとアプリケーション ソフトウェアでは、文字列 ID 値と ***gx_display_string_get_ext*** または ***gx_widget_string_get_ext*** API 関数を使用して、静的に定義された文字列を解決します。 これらの関数は、指定された文字列 ID と現在アクティブな言語に関連付けられている **GX_STRING** を返します。

### <a name="bi-directional-text-display"></a>双方向テキストの表示 

GUIX には、双方向テキストをサポートするための 2 つの方式が用意されています。

1 つのオプションでは、双方向テキストの並べ替えを GUIX Studio アプリケーション内で行います。 このオプションを使用する場合、双方向テキストをその表示順序で出力ファイルに生成する処理は GUIX Studio が担当します。 このソリューションは実行時のパフォーマンスに影響を与えず、GUIX ランタイム ライブラリへのどのような追加も必要ありません。 GUIX Studio で表示順序の双方向テキスト文字列を生成できるようにするには、GUIX Studio の言語構成ダイアログで **[表示順序の双方向テキストを生成する]** チェックボックスをオンにする必要があります。

![言語の構成](./media/guix/user-guide/configure-languages.png)

これらのオプションが選択されている場合、生成されたリソース ファイルには表示順序で生成された双方向文字列が含まれ、GUIX ランタイム ライブラリ内での追加の処理は必要ありません。

2 番目のオプションでは、双方向テキストの並べ替えを実行時に行います。 このオプションは、GUIX Studio アプリケーションによって生成されるのではなく、動的に定義される双方向テキスト文字列を処理する必要があるアプリケーションのためにサポートされています。 この場合、各テキスト文字列を描画する前に双方向テキストを並べ替える処理は GUIX ランタイム ライブラリが担当します。 このソリューションは、実行時のパフォーマンスとメモリに影響を与えます。 双方向テキストの並べ替えプロセスのための十分な動的メモリが使用可能である必要があります。 このソリューションでは、GUIX ライブラリを構築するときに条件付きの GX_DYNAMIC_BIDI_TEXT_SUPPORT が定義されている必要があります。 双方向テキストのサポートを実行時に有効または無効にするために、2 つの API 関数 ***gx_system_bidi_text_enable*** と ***gx_system_bidi_text_disable*** が用意されています。

**GX_DYNAMIC_BIDI_TEXT_SUPPORT** を使用すると同時に、表示順序の双方向テキストを生成するように GUIX Studio を構成するべきではありません。 双方向テキスト文字列の処理の方式として、どちらか 1 つだけを選択する必要があります。

## <a name="memory-usage"></a>メモリ使用量 

GUIX は、アプリケーション プログラムと共存しています。 その結果、GUIX の静的メモリ (つまり固定メモリ) の使用量は、開発ツール (コンパイラ、リンカー、ロケーターなど) によって決定されます。 動的メモリ (つまり実行時メモリ) の使用量は、アプリケーションによって直接制御されます。

### <a name="static-memory-usage"></a>静的メモリの使用量 

ほとんどの開発ツールでは、アプリケーション プログラム イメージを "*命令*"、"*定数*"、"*初期化されたデータ*"、"*初期化されていないデータ*"、"*GUIX スレッド スタック*" の 5 つの基本的な領域に分割します。  下の図は、これらのメモリ領域の 1 つの考えられるレイアウトを示しています。

![メモリ レイアウト](./media/guix/user-guide/memory-area-example.png)

これは例にすぎないことを理解することが重要です。 実際の静的メモリのレイアウトは、プロセッサ、開発ツール、基になるハードウェア、アプリケーション自体などに固有のものです。

命令領域には、そのプログラムのすべてのプロセッサ命令が含まれています。 この領域は多くの場合 ROM 内にあります。

定数領域には、各種のコンパイルされた定数が含まれています。GUIX では、既定の設定とすべてのアプリケーション リソース (イメージ、文字列、フォント、色) が含まれています。 さらに、この領域には、初期化されたデータ領域の "初期のコピー" も含まれています。 コンパイラの初期化プロセス中に、定数領域のこの部分は、RAM 内のグローバルな初期化されたデータを設定するために使用されます。 定数領域は一般に最も大きく、通常は命令領域の後にあり、多くの場合は ROM 内にあります。

GUIX ピクセルマップとフォントには通常、大量の定数データ ストレージが必要です。 これらの大きな静的データ領域は通常、ROM またはフラッシュ内に保持されます。

GUIX スレッド スタックは、***gx_system.h*** ファイルの初期化されていないデータ領域内で (グローバル変数として) 次のように定義されます。

```C
_gx_system_thread_stack[GX_THREAD_STACK_SIZE];
```

**GX_THREAD_STACK_SIZE** は **_gx_port.h_** で定義されますが、このシンボルを ***gx_user.h*** ヘッダー ファイルで定義することによって、あるいはプロジェクト オプションまたはコマンド ライン パラメーターを使用してアプリケーションでオーバーライドできます。 このスタック サイズは、最悪のケースのイベント処理や入れ子になった描画呼び出しを処理できるだけの十分な大きさにする必要があります。

### <a name="dynamic-memory-usage"></a>動的メモリの使用量 

先に説明したように、動的メモリの使用量は、アプリケーションによって直接制御されます。 キャンバスなどに関連付けられているコントロール ブロックとメモリは、ターゲットのメモリ領域内のどこにでも配置できます。 これにより、さまざまな種類の物理メモリを実行時に簡単に利用できるようになるため、これは重要な機能です。

たとえば、ターゲットのハードウェア環境に、高速なメモリと低速なメモリの両方が存在するとします。 アプリケーションが描画のために追加のパフォーマンスを必要としている場合は、最高のパフォーマンスを得るために、キャンバス メモリを高速なメモリ領域に明示的に配置できます。

いくつかのオプションの GUIX サービスおよび機能には、一般にヒープと呼ばれる、ランタイム動的メモリ割り当てメカニズムが必要です。 これらのサービスおよび機能は完全にオプションであり、多くの GUIX アプリケーションではヒープを使用せず、ランタイム メモリ割り当てメカニズムも定義しません。

ランタイム メモリ割り当てを必要とするサービスを使用する予定がある場合は、メモリを動的に割り当てたり解放したりする必要が発生したときに GUIX から呼び出す関数をインストールする必要があります。 この場合でも、動的メモリ プールの場所をアプリケーションから制御できるように、これらの関数を必要に応じて実装できます。 動的メモリ割り当てのサポートをインストールするには、プログラムの起動中にアプリケーションで API サービス ***gx_system_memory_allocator_set*** を呼び出して、メモリ割り当ておよびメモリ解放サービスを定義する必要があります。 完全な例については、この API のドキュメントを参照してください。

ランタイム メモリ割り当ておよび割り当て解除サービスを必要とする GUIX サービスには、次のものが含まれます。

  - 外部ストレージから GUIX ランタイム環境へのバイナリ リソースの読み込み。

  - ソフトウェア ランタイム jpeg 画像デコーダー。

  - ソフトウェア ランタイム png 画像デコーダー。

  - GX_STYLE_TEXT_COPY でのテキスト ウィジェットの使用。

  - 実行時のピクセルマップのサイズ変更および回転の各ユーティリティ関数。
  - ランタイムでの画面とウィジェット コントロール ブロックの割り当て。

小規模なアプリケーションの場合、GUIX リソースは通常、アプリケーション イメージの一部としてコンパイルされ、静的にリンクされるため、バイナリ リソースのインストールは必要ありません。 バイナリ リソースを使用すると、アプリケーションでは、フラッシュ ドライブや URL などの一部の保存場所から読み込まれたリソース (フォント、イメージ、言語) を実行時にインストールできます。

ランタイム jpeg および png デコーダーはオプション コンポーネントです。 ほとんどの GUIX アプリケーションでは、GUIX Studio ツールで、必要なすべてのイメージ ファイルを事前にデコードし、それを独自の GUIX ピクセルマップ データ リソースとして格納できます。 これらのサービスは、jpeg または PNG イメージからピクセルマップ形式へのランタイム変換を必要とするアプリケーションの完全性のために提供されています。

**GX_STYLE_TEXT_COPY** を使用すると、ユーザーは特定の 1 つまたは複数のウィジェットに、動的に割り当てられたテキストの独自のプライベート コピーが保持されるように指定できます。 このオプションを使用するには、その使用の前に、メモリ割り当てメカニズムをインストールする必要があります。 テキストの種類のウィジェットが作成されるときにこのスタイル フラグが指定されて **<span class="underline">いない</span>** 場合は、動的に作成され、割り当てられたすべてのテキスト文字列に対してアプリケーションで静的ストレージ領域を割り当てる必要があります。 この場合、ランタイムで生成された文字列データを保持するために自動変数を使用しないでください。 **GX_STYLE_TEXT_COPY** スタイルが有効になっている場合は、各ウィジェットで割り当てられたテキストの独自のコピーが作成されるため、GUIX ウィジェットに割り当てられた文字列データを保持するために自動変数を使用できます。

ピクセルマップ サイズ変更および回転ユーティリティ関数は、結果として得られた変換されたピクセルマップを、アプリケーションで使用できる新しいピクセルマップとして返します。
これらのサービスが使用されている場合は、ランタイムで生成されたこれらのピクセルマップ データ ブロックを保持するための十分な動的メモリが使用可能である必要があります。

最後に、GUIX 画面とウィジェットのコントロール ブロックは、静的または動的に割り当てることができます。 小規模なアプリケーションの場合は、プログラムの起動中にすべてのアプリケーション画面を作成し、静的に割り当てられたコントロール ブロックを使用することが一般的です。 大規模なアプリケーションの場合は、画面と子ウィジェット コントロールを必要に応じて動的に作成することが一般的です。 動的に割り当てられたコントロール ブロックは、GUIX Studio のプロパティ ビューで **[ランタイム割り当て]** チェックボックスをオンにするか、または標準 API を使用してウィジェットを作成するときにスタイル フラグ **GX_STYLE_DYNAMICALLY_ALLOCATED** を渡すことによって指定されます。 動的に割り当てられたウィジェット コントロール ブロックを使用するには、先に説明したように、メモリ割り当ておよび割り当て解除サービスが定義されている必要があります。

## <a name="guix-components"></a>GUIX コンポーネント 

GUIX API は、GUIX システムの基本コンポーネントに対応した、いくつかの基本的なグループに分割および整理されています。 基本コンポーネントには、次のものが含まれます。

| Components  | 説明  |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GX_SYSTEM  | GUIX システム コンポーネント。初期化、イベント、タイマー、文字列テーブル、表示されるウィジェットの階層管理を担当します。                                                                                                                                                                                                                                                                      |
| GX_CANVAS  | 描画領域。 キャンバスは、ハードウェア フレーム バッファーの薄い抽象化である場合があります。また、純粋なメモリ キャンバスである可能性もあります。 キャンバスの種類は、gx_canvas_create API 関数に渡されるパラメーターによって決定されます。                                                                                                                                                                                   |
| GX_CONTEXT | 描画コンテキスト コンポーネント。 描画コンテキストには、画面、キャンバス、ブラシのほか、現在の描画操作のクリッピング領域に関する情報が含まれています。                                                                                                                                                                                                                                      |
| GX_DISPLAY | アプリケーションや GUIX ウィジェットでキャンバスへの描画を実行できるようにするための API とドライバー レベルの実装を提供します。 GX_DISPLAY は、各キャンバスの必要な色形式を使用して、そのキャンバスにグラフィックスを適切にレンダリングするために実装されます。 GX_DISPLAY コンポーネントではまた、各ディスプレイにリンクされているキャンバスに描画するウィジェットで使用できるリソース (色、フォント、ピクセルマップ) も管理します。 |
| GX_WIDGET  | 基本的な表示されるウィジェット オブジェクトとそれに関連付けられている API。 GUIX ウィジェットの種類はすべて、基本的な GX_WIDGET の種類に基づいているか、またはそれから派生しています。                                                                                                                                                                                                                                                                      |
| GX_UTILITY | このグループには、四角形を操作するためのユーティリティ関数、文字列変換のための関数、ANSI 以外の数学関数が含まれています。                                                                                                                                                                                                                                                         |

これらの基本的なコンポーネントに加えて、GUIX には、ライブラリで提供されている各種類のウィジェットに固有の API が含まれています。 これらの API は、このユーザー ガイドの第 4 章「GUIX サービスの説明」で説明されています。

## <a name="guix-system-component"></a>GUIX システム コンポーネント

GUIX システム コンポーネントは、UI アプリケーションに対してグローバルないくつかのサービスを提供します。 これらのサービスには、"*初期化、イベント管理、ディスプレイ管理、リソース管理、タイマー管理*" のほか、"*ウィジェット管理*" が含まれます。 各サービスはアプリケーション プログラムの構成に不可欠であり、これらのサービスは次の各サブセクションでより詳細に説明されています。

### <a name="initialization"></a>初期化 

GUIX の初期化は、サービス ***gx_system_initialize*** を呼び出すアプリケーションによって実現されます。これは、ThreadX の ***tx_application_define*** ルーチン (初期化コンテキスト) またはアプリケーション スレッドからアプリケーションによって呼び出される可能性があります。 ***gx_system_initialize*** 関数では、すべてのグローバルな GUIX データ構造体を初期化し、GUIX システム ミューテックス、イベント キュー、タイマー、スレッドを作成します。 ***gx_system_initialize*** から戻ったら、アプリケーションは GUIX を使用できます。

### <a name="thread-processing"></a>スレッド処理 

内部 GUIX スレッドは、初期化中に作成され、GUIX でのほとんどの処理を担当します。 このスレッドでの処理では、まず、基になるディスプレイ ドライバーに必要な追加の初期化をすべて完了します。 これが完了すると、GUIX スレッドはループに入ります。ここでは、まず GUIX イベント キューに存在するすべてのイベントを処理してから、必要に応じて画面を更新します。 画面の更新では、何が表示され、ダーティ (つまり、再描画する必要がある) とマークされているかに基づいて、必要な GUIX 描画関数を実行します。 イベントが存在せず、ディスプレイ上に更新すべきものが何も残されていない場合、GUIX スレッドは中断し、次の GUIX イベントが到着するまで待ちます。

### <a name="rtos-binding"></a>RTOS バインド 

GUIX システム コンポーネントは、既定では、スレッド サービス、イベント キュー サービス、タイマー サービスなどのサービスのために ThreadX リアルタイム オペレーティング システムを利用するように構成されます。 GUIX は、プリプロセッサ ディレクティブ GX_DISABLE_THREADX_BINDING を使用し、GUIX ライブラリを再構築することによって、他のオペレーティング システムに簡単に移植できます。 これにより、GUIX ソース コードから ThreadX の依存関係が削除され、アプリケーション開発者は、ターゲット システムによって提供される任意の RTOS を使用して必要なオペレーティング システム サービスを実装できるようになります。 「[付録 F - GUIX RTOS バインド サービス](appendix-f.md)」では、GUIX を ThreadX オペレーティング システム以外のオペレーティング システムに移植するために実装する必要があるサービスについて説明しています。

### <a name="multithread-safety"></a>マルチスレッド セーフ 

GUIX API は、GUIX のスレッド コンテキストやその他のアプリケーション スレッドから使用できます。 アプリケーション スレッドでは、イベントを送受信したり、共有変数にアクセスしたり、GUIX API 関数を使用したりすることによって GUIX スレッドを操作できます。 GUIX では、マルチスレッド リソースの保護のために内部の ThreadX ミューテックスを使用します。 さらに、GUIX では画面の更新操作が開始された後に、表示されるウィジェットの内部構造体が変更されないようにします。 表示されるオブジェクトのツリーを変更するような API は、描画操作の進行中にはブロックされ、画面の更新が完了すると解放されます。

### <a name="system-timers"></a>システム タイマー 

GUIX は、アプリケーションに定期的なタイマーを提供します。これは多くの場合、GUIX ウィンドウに表示されるデータの定期的な更新に使用されます。 これは、ThreadX の定期的なタイマーを使用して実現されます。これもまた、画面のフェード イン/アウトなどの GUIX システム レベルの効果を実行するために使用されます。

アプリケーションではタイマーを作成し、GUIX によって内部的に使用されているのと同じタイマー機能を利用できます。 当然ながら、アプリケーションでは、必要に応じて ThreadX タイマーを直接作成して使用することもできます。 GUIX タイマーの利点は、非常に使いやすく、GUIX イベント ドリブン処理システム内で動作するように事前に構成されていることです。

GUIX タイマーを作成して開始するには、アプリケーションで関数 ***gx_system_timer_start*** を呼び出す必要があります。 この関数へのパラメーターには、呼び出し元のウィジェットへのポインター、タイマー ID (1 つのウィジェットで多数のタイマーを開始できます)、初期タイムアウト値と再スケジュールのタイムアウト値が含まれます。 再スケジュールのタイムアウト値が 0 である場合、タイマーは 1 回だけ動作し、有効期限が切れるとアクティブなタイマーの一覧から自身を削除します。

開始されると、GUIX タイマーは GX_EVENT_TIMEOUT イベントをタイマー所有者に、タイマーの再スケジュールの値に応じて 1 回または定期的に送信します。 GUIX タイマーは、API 関数 ***gx_system_timer_stop*** を呼び出すことによって停止できます。

### <a name="pen-speed-configuration"></a>ペン速度の構成 

GUIX システム コンポーネントでは、ペン速度の追跡に関連した構成情報を保持します。 GUIX では、タッチ入力ドライバー (存在する場合) によって生成された PEN_DOWN イベントの速度と距離に基づいて **GX_EVENT_VERTICAL_FLICK** および **GX_EVENT_HORIZONTAL_FLICK** イベントが内部的に生成されます。 アプリケーションでは、**_gx_system_pen_configure_** API 関数を使用して、これらの内部的に生成されたイベントをトリガーするために必要な最小の距離と速度を構成できます。

### <a name="screen-stack"></a>画面スタック 

GUIX システム コンポーネントは、GUIX 画面スタックに関連したサービスを提供します。これは、アプリケーションが実行時に画面をプッシュ/ポップしたり、取得したりできる仮想ウィジェット スタックをサポートするオプション機能です。 画面スタックは、ユーザーがメニュー システム内のさまざまな状態に多様なルートを通って到達する可能性のある、複雑なメニュー システムを管理するために役立ちます。 メニュー システム内の以前の状態への復帰は、まず以前の画面状態をプッシュしてから新しい画面を表示し、現在の画面が閉じられたら新しい画面で画面スタックから以前の状態をポップできるようにすることによって簡単に実行できます。

### <a name="clipboard-maintenance"></a>クリップボードのメンテナンス 

GUIX では、ランタイム実行中にテキストのコピーと貼り付けを行うためのクリップボードをサポートしています。 このサポートは、GUIX システム コンポーネントによって提供されます。

### <a name="dirty-list-maintenance"></a>ダーティ リストのメンテナンス 

GUIX では、ダーティなウィジェット、つまり、表示されているが、状態変更のため、または新しく表示されるために再描画する必要があるウィジェットの一覧を保持しています。 このダーティ リストを使用すると、UI が変更されるたびにキャンバス更新を実行するのではなく、GUIX でキャンバス更新操作を 1 回実行するだけで UI の状態への現在のすべての変更を反映させることができるため、描画パフォーマンスが向上します。
このダーティ リストもまた、GUIX システム コンポーネントによって管理されます。

### <a name="animation-control-block-pool"></a>アニメーション コントロール ブロック プール 

アプリケーションは多くの場合、複数のアニメーション シーケンスを、たいていは並列に実行しようとします。 GUIX では、アニメーション コントロール ブロックのプールを保持しており、アプリケーションはそこから割り当てて使用できます。 これにより、アプリケーションは、これらのコントロール ブロックの静的な定義から解放されます。アプリケーションで定義する可能性のあるアニメーションごとに固有のアニメーション コントロール ブロックを定義するのではなく、コントロール ブロックを何回も再利用できるようになります。 アニメーション コントロール ブロック プールもまた、GUIX システム コンポーネントによって管理されます。

### <a name="system-error-handling"></a>システム エラーの処理 

GUIX システム エラー ハンドラーは、アプリケーションが、API の観点からは特定しにくい可能性がある GUIX 内部のシステム エラーを検出できるよう支援することを目的にしています。 GUIX の内部でシステム エラーが発生するたびに、内部の ***_gx_system_error_process*** 関数が呼び出されます。 この関数では、提供されたエラー コードを保存し、検出されたシステム エラーの合計数を増分します。 システム エラーの変数は、次のように定義されています。

UINT **_gx_system_last_error**;

ULONG **_gx_system_error_count**;

GUIX アプリケーションの動作がおかしい場合は、デバッガーでエラー カウント変数を確認してみると役立ちます。 これが設定されている場合は、問題の適切なトラブルシューティング方法として、***_gx_system_error_process*** 関数でブレークポイントを設定し、それがいつ、どこから呼び出されているかを確認します。

## <a name="guix-canvas-component"></a>GUIX キャンバス コンポーネント

キャンバス コンポーネントは、キャンバスに関連するすべての処理を担当します。 キャンバスは、実質的には仮想フレーム バッファーです。 アプリケーションでは、グラフィカル出力を生成するために、少なくとも 1 つのキャンバスを作成する必要があります。
一般には、システムでサポートされている物理ディスプレイごとに少なくとも 1 つのキャンバスを作成します。

GUIX 描画はすべて、キャンバス上で実行されます。 より単純な、またはメモリに制約のあるシステムでは、表示されるフレーム バッファーに直接リンクされた 1 つのキャンバスしか存在しない可能性があるのに対して、より多くのメモリがあり、グラフィックスの要件がより高度なシステムでは複数のキャンバスが必要になる可能性があります。 1 つのディスプレイで複数のキャンバスを使用できるようにすると、画面やウィンドウのフェード イン/フェード アウト効果などの機能が有効になります。
キャンバスは、簡易またはマネージドの 2 つの主な種類のどちらかにすることができます。

簡易キャンバスは、アプリケーションによって使用されるオフスクリーンの描画領域です。
GUIX では簡易キャンバスを直接には操作しませんが、アプリケーションでは、簡易キャンバスを使用して複雑な描画をオフスクリーン バッファーにレンダリングした後、必要に応じてこのオフスクリーン バッファーを使用して、表示されるキャンバスを更新できます。

マネージド キャンバスは、GUIX によってハードウェア フレーム バッファー内に自動的に表示されます。 マネージド キャンバスは、複数のマネージド キャンバスをサポートするための十分なメモリを備えたシステムでの合成キャンバスの構築に含まれます。 マネージド キャンバスには GUIX によって管理される Z オーダーがあり、すべてのマネージド キャンバスでビューのクリッピングが適用されます。

キャンバスは、より汎用的であるという点で、フレーム バッファーとは異なります。 メモリに制約のあるシステムでは、1 つのキャンバスしか存在しない可能性があり、このキャンバス用のメモリは表示されるフレーム バッファー メモリであることがあります。 ただし、より高度なグラフィカル オーバーレイと複数のキャンバスをサポートしているより複雑なシステムの場合は、マネージド キャンバスのそれぞれに、ハードウェア フレーム バッファー メモリとは異なる独自のメモリ領域が割り当てられています。
これらのマネージド キャンバスは、フレーム バッファーの更新または切り替え操作中に、表示されるフレーム バッファーにレンダリングされます。

複数のグラフィックス レイヤー (複数のオーバーレイされたフレーム バッファー) をサポートしているハードウェアの場合は、アプリケーションで ***gx_canvas_hardware_layer_bind*** API を使用して、1 つ以上のキャンバスをハードウェア グラフィックス レイヤーにバインドできます。 このサービスでは、キャンバスにそれが特定のハードウェア グラフィックス レイヤーにリンクされていることを通知します。リンクされると、このキャンバスでは、キャンバスの可視性 ( gx_canvas_show、gx_canvas_hide)、キャンバス アルファ ブレンド (***gx_canvas_alpha_set***)、ディスプレイ内のキャンバス オフセット (***gx_canvas_offset_set***) に対するハードウェア サポートを利用しようとします。

最も単純な単一キャンバスまたは単一フレーム バッファー構成以外のアーキテクチャの場合、キャンバスのサイズはアプリケーションによって決定されるため、フレーム バッファーの固定サイズとは異なる可能性があります。
また、アプリケーションによって選択されたオフセットに位置する可能性もあります。 その他の情報 (Z オーダーなど) はキャンバス内に保持されます。 キャンバスの描画が完了すると、そのキャンバスの内容は、ディスプレイ ドライバーによって物理ディスプレイに転送されます。 個別のキャンバスおよびフレーム バッファー メモリ領域のための十分なメモリがない一部のシステムでは、キャンバス更新が実際には、ディスプレイ ドライバー経由で物理ディスプレイに対して直接行われます。

### <a name="canvas-creation"></a>キャンバスの作成 

キャンバス オブジェクトは、初期化中に作成することも、アプリケーション スレッドの実行中の任意の時点で作成することもできます。 アプリケーションで作成できるキャンバス オブジェクトの数に制限はありません。 ただし、ほとんどのアプリケーションでは、すべての GUIX 描画のために 1 つのキャンバス オブジェクトのみを作成します。

### <a name="canvas-control-block"></a>キャンバス コントロール ブロック 

各キャンバス オブジェクトの特性は、そのコントロール ブロック **GX_CANVAS** 内にあり、**_gx_api.h_** で定義されています。 キャンバス オブジェクトに必要なメモリはアプリケーションによって提供され、メモリ内のどこにでも配置できます。 ただし、キャンバス オブジェクト コントロール ブロックと描画領域は、すべての関数のスコープ外に定義することによってグローバル構造体にすることが最も一般的です。

### <a name="canvas-alpha-channel"></a>キャンバス アルファ チャネル

GUIX では、前景色と背景色の多くのレベルでのアルファ ブレンドをサポートしています。これには、ピクセルあたりのブレンド比率を指定するビットマップ アルファ チャネル、16 bpp 以上の色深度でブラシのブレンド比率を指定するブラシ アルファ、オーバーレイ キャンバスのブレンド比率を指定するキャンバス アルファが含まれます。

キャンバスのアルファ値は、フレーム バッファー内に表示するために合成されている複数のキャンバスが存在する場合に使用されます。 キャンバスの Z オーダーで、あるキャンバスが他のキャンバスの上になっている場合は、そのキャンバスを背後のキャンバスとブレンドするようにキャンバス アルファ値を設定できます。 キャンバスのアルファ値のすばやい変更は、"フェード イン" の画面の切り替え効果を実現するために使用されますが、キャンバス アルファは多くの方法で使用できます。

キャンバスが gx_canvas_hardware_layer_bind() を使用することによってハードウェア グラフィックス レイヤーにバインドされている場合、GUIX では、ハードウェア サポートを利用したキャンバス アルファ ブレンドを実装して、オーバーレイ キャンバスのブレンドに関連したソフトウェア オーバーヘッドを最小限に抑えようとします。

アルファ値の範囲は 0 ～ 255 です。ここで、0 の値はそのピクセルが完全に透明であることを示し、0 を超える値は大きいほど透明度が低下します。キャンバス アルファ値は、キャンバス ブレンドに対するハードウェア支援が提供されていない限り、16 bpp 以上で実行されている画面ドライバーでしかサポートされません。

### <a name="canvas-offset"></a>キャンバス オフセット 

キャンバスは、***gx_canvas_offset_set*** API サービスを呼び出すことによって、表示されるフレーム バッファー内のオフセットを設定できます。 キャンバス オフセットは通常、スプライト アニメーションを実装するために使用されます。 キャンバスが ***gx_canvas_hardware_layer_bind*** API 関数を呼び出すことによってハードウェア グラフィックス レイヤーにバインドされている場合、GUIX では、ハードウェア サポートを利用したキャンバス オフセットの変更を実装して、キャンバス位置のシフトに関連したソフトウェア オーバーヘッドを最小限に抑えようとします。

### <a name="canvas-drawing"></a>キャンバスの描画 

GUIX キャンバス コンポーネントは、アプリケーションに完全な描画 API を提供します。 ***gx_canvas_line_draw*** や ***gx_canvas_pixelmap_draw*** などの描画 API を呼び出すには、***gx_canvas_drawing_initiate*** API 関数を呼び出すことによって、ターゲット キャンバスを描画用に開いておく必要があります。 この関数では描画用のキャンバスを準備し、"***描画コンテキスト***" を作成します。

キャンバスにレンダリングする描画 API (***gx_canvas_line_draw** _ や _*_gx_canvas_text_draw_*_ など) では、現在の描画コンテキスト内のブラシのパラメーターを使用して線のスタイル、幅、色を定義します。 これらのブラシ パラメーターは、_*_gx_canvas_drawing_initiate_** を呼び出すことによって描画コンテキストが確立された後に、_*_gx_context_brush_define_*_、 _*_gx_context_brush_set_**、***gx_context_brush_style_set**_ や同様の API 関数を呼び出すことによって変更されます。

GUIX が遅延キャンバス更新操作の一部としてウィンドウおよびウィジェット描画関数を呼び出すと、そのウィジェット描画関数を呼び出す前に、ターゲット キャンバスが描画用に開かれます。 そのため、標準のウィジェット描画関数でターゲット キャンバスを開く必要はありません。これは自動的に実行されています。

場合によっては、アプリケーションでキャンバスへの強制的な即時描画が必要になることがあります。 この場合、アプリケーションでは次の手順を実行できます。

1. ***gx_canvas_drawing_initiate*** API 関数を呼び出し、ターゲット キャンバスと、アプリケーションで描画するそのキャンバス内の四角形を渡します。 

2. 任意の数のキャンバス描画 API を呼び出して、目的の描画を実現します。

3. ***gx_canvas_drawing_complete*** API 関数を呼び出して、描画が完了したことを通知します。 これにより、システムのメモリ アーキテクチャに応じて、表示されるフレーム バッファーにキャンバスがフラッシュされるか、またはバッファーの切り替え操作がトリガーされるか、あるいはその両方が行われます。

### <a name="drawing-apis"></a>描画 API 

すべてのビジュアル要素を画面上に描画するために GUIX に必要な、いくつかのプリンシパル描画プリミティブが存在します。 これらの描画 API は、通常はカスタム ウィジェット描画関数の一部として、アプリケーション ソフトウェアでも呼び出すことができます。 これらの GUIX キャンバス描画 API では、パラメーターの検証とクリッピングを実行した後、クリップされた描画座標を、ハードウェアと色形式固有の描画の実装のためにディスプレイ ドライバーに渡します。 これらの描画 API 関数は、次のように定義されています。

- gx_canvas_alpha_set
- gx_canvas_arc_draw
- gx_canvas_block_move
- gx_canvas_circle_draw
- gx_canvas_ellipse_draw
- gx_canvas_glyphs_draw
- gx_canvas_hardware_layer_bind
- gx_canvas_hide
- gx_canvas_line_draw
- gx_canvas_offset_set
- gx_canvas_pie_draw
- gx_canvas_pixel_draw
- gx_canvas_pixelmap_blend
- gx_canvas_pixelmap_rotate
- gx_canvas_pixelmap_tile
- gx_canvas_polygon_draw
- gx_canvas_rectangle_draw
- gx_canvas_rotated_text_draw
- gx_canvas_shift
- gx_canvas_show
- gx_canvas_text_draw

描画 API は GUIX Canvas API 経由で呼び出され、すべての描画が gx_canvas_* API 関数を使用して実行されます。 描画は、現在の描画コンテキスト内の現在のブラシを使用して実行されます。 上記のどの図形描画関数でも、現在のブラシの定義に従って、輪郭の描画、単色塗りつぶし、またはピクセルマップ塗りつぶしを行うことができます。 図形の輪郭の幅、色、または塗りつぶしを変更するには、gx_context_brush_* API 関数を使用して、現在の描画コンテキスト内のブラシを定義します。

上記のアプリケーション レベルの描画 API ではキャンバスへの実際の描画を行わず、代わりに、ディスプレイ ドライバー レベルの描画関数を呼び出す前に呼び出し元のパラメーターを確認します。 ドライバー レベルの描画関数では、実際にピクセル データをキャンバス メモリに書き込みます。

GUIX は、1、2、4、8、16、24、32 ビット/ピクセル (bpp) を含む、さまざまな色深度のためのストックまたは汎用のディスプレイ ドライバー描画関数を提供します。 場合によっては、既定のソフトウェアによる描画の実装が、2D 描画アクセラレータを提供するハードウェア ターゲット向けのハードウェア アクセラレータによる実装に置き換えられます。

### <a name="color-depth"></a>色の解像度 

GUIX では、最大 32 bpp の色深度のほか、モノクロとグレースケールをサポートしています。 色深度のサポートの種類は主に、基になる物理ディスプレイの機能によって決定され、キャンバスの描画領域に必要なメモリの量にも影響を与えます。 色深度のサポートの一覧を、その色深度内でのバリエーションの簡単な説明と共に次に示します。

| 色&nbsp;形式       | 説明                                                                                                   |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| 1 ビット モノクロ   | 1 ビット/ピクセルの圧縮形式。                                                                                                   |
| 2 ビット グレースケール    | 4 つのグレー レベル、圧縮された 4 ピクセル/バイト。                                                                                      |
| 4 ビット グレースケール    | 16 のグレー レベル、圧縮された 2 ピクセル/バイト。                                                                                      |
| 4 ビット カラー        | VGA 形式の平面メモリ構成。                                                                                         |
| 8 ビット グレースケール    | 256 のグレー レベル                                                                                                                  |
| 8 ビット パレット モード | パレット インデックスとして使用される 1 バイト/ピクセル                                                                                           |
| 8 ビット r:g:b モード   | 使用頻度の低い 2:3:2 r:g:b 形式。                                                                                         |
| 16 ビット             | 各ピクセルに 2 バイトが必要です。 r:g:b または b:g:r のバイト順にできます。 通常は 5:6:5 構造ですが、5:5:5 構造または 4:4:4:4 a:r:g:b 構造にすることもできます。 |
| 24 ビット             | 各ピクセルに 3 (圧縮形式) または 4 (非圧縮形式) バイトが必要です。 ハードウェアの必要に応じて、r:g:b または b:g:r のバイト順にできます。 |
| 32 ビット             | 各ピクセルにアルファ チャネルを含む 4 バイトが必要です。 a:r:g:b または b:g:r: のバイト順にでき、ハードウェアによって決定されます。              |

### <a name="mouse-support"></a>マウスのサポート 

GUIX では、任意の希望するキャンバスへのマウス カーソルの描画をサポートしています。 マウス カーソルはソフトウェアで描画できます。または、ハードウェア カーソル オーバーレイでサポートされる場合もあります。 どちらにしても、マウス カーソルのサポートに関してアプリケーションに提供される API は、ソフトウェアまたはハードウェアのどちらのマウス カーソル描画を使用していても同じです。

GUIX でのマウスのサポートは、GUIX ライブラリを構築する前に gx_user.h ヘッダー ファイルで `#define GX_MOUSE_SUPPORT` が定義されている場合にのみ有効になります。

アプリケーションでは、***gx_canvas_mouse_define*** API 関数を使用して、マウス カーソルとホットスポットを定義する必要があります。 この API では、カーソル イメージが描画されるキャンバスへのポインターと、マウス カーソル イメージとそのイメージの左上隅を基準としたマウス イメージのホットスポットを定義する **GX_MOUSE_CURSOR_INFO** 構造体へのポインターを受け付けます。

## <a name="guix-display-component"></a>GUIX ディスプレイ コンポーネント 

ディスプレイ コンポーネントは、内部に 1 つ以上のキャンバス、ウィジェット、ウィンドウを含むすべてのディスプレイ オブジェクトの処理を管理するため、GUIX の基本コンポーネントです。 ディスプレイ コンポーネントはまた、一連の関数ポインター経由で各ディスプレイに関連付けられている基になるハードウェア画面ドライバーも操作します。

### <a name="display-creation"></a>ディスプレイの作成 

ディスプレイ オブジェクトは、初期化中に作成することも、アプリケーション スレッドの実行中の任意の時点で作成することもできます。 通常、アプリケーションでは、各物理画面を管理するために 1 つのディスプレイ オブジェクトを作成します。 使用可能なアプリケーションと物理ディスプレイを定義するために GUIX Studio を使用したことがある場合は、gx_studio_display_configure API 関数を使用して、各ディスプレイを作成および初期化します。

### <a name="display-control-block"></a>ディスプレイ コントロール ブロック 

各ディスプレイ オブジェクトの特性は、そのコントロール ブロック ***GX_DISPLAY** _ 内にあり、_*_gx_api.h_** で定義されています。 ディスプレイ オブジェクトに必要なメモリはアプリケーションによって提供され、メモリ内のどこにでも配置できます。 ただし、ディスプレイ コントロール ブロックは、すべての関数のスコープ外に定義することによってグローバル構造体にすることが最も一般的です。

### <a name="resource-management"></a>リソース管理 

リソースは、アプリケーションで必要な UI コンポーネントですが、アプリケーション コードではありません。 リソースはアプリケーション データであり、通常は静的に定義されます。 リソースの種類には、ピクセルマップ、フォント、色、文字列が含まれます。 これらのリソースは、通常はどのアプリケーション ソフトウェアも変更することなく、いつでも変更できます。 アプリケーション ソフトウェアを変更するには通常、そのソフトウェアの関連する再テストと検証が必要になるため、リソースの格納やリソースへの参照をアプリケーション ソフトウェアから分離された状態に維持することにより、UI の外観をアプリケーション コードの変更なしで変更できるようにすることが重要です。

GUIX の ***display*** モジュールは、ディスプレイの色深度および形式に依存しているすべてのリソースのリソース管理機能を提供します。 これらの機能には、アクティブなピクセルマップ テーブル、アクティブなフォント テーブル、アクティブなカラー テーブルの管理が含まれます。 文字列リソースは通常、色深度および形式に基づいて変更する必要がないため、文字列テーブル リソースは GUIX システム モジュールによって管理されます。

アプリケーション ソフトウェアでは、対応するリソース テーブルへのインデックスであるリソース ID でリソースを参照します。 これにより、そのテーブルを変更できるようになります。たとえば、製品が "日中モード" から "夜間モード" に変わるとカラー テーブルが変更される可能性がありますが、カラー ID 値は同じままになります。

アプリケーション リソースは、GUIX Studio アプリケーションによってリソース ファイル (または一連のリソース ファイル) に書き込まれます。 新しい GUIX Studio プロジェクトを作成すると、既定の色、ピクセルマップ、フォントが自動的に提供されますが、これらの既定値は、アプリケーションの外観を定義するときに簡単に置き換えることができます。

色、フォント、ピクセルマップのリソース ID は、アクティブなディスプレイ コンポーネントが認識されるまで実際の色、フォント、またはピクセルマップの値に解決できない点に注意することが重要です。 GUIX のアーキテクチャでは複数のアクティブなディスプレイをサポートしているため、リソース ID をリソース値に解決できるのは、ウィジェットとそれに関連付けられたリソース ID を特定のディスプレイに解決できる場合だけです。 この性質は動的バインドと呼ばれます。 テキストの色などのプロパティのリソース ID (リソース ID **GX_COLOR_ID_TEXT** など) は、あるディスプレイで使用されるときは白の 16 ビット R:G:B 値に解決される可能性がありますが、別のディスプレイで使用されるときは同じカラー ID がモノクロの黒のカラー値に解決される可能性があります。

実際には、このリソース ID のリソース値への動的バインドは、アプリケーション ソフトウェアと GUIX 内部コンポーネントではほとんどの場合、アクティブな描画コンテキスト内でのみリソース ID をリソース値に解決することを示しています。 アクティブな描画コンテキストは、現在アクティブなディスプレイを指定するため、GUIX で各リソース ID を特定のリソース値に解決できます。 アプリケーション ソフトウェアで、描画コンテキストの外部にある特定のリソース値を検索する必要がある場合は、これを表示されるウィジェットに対しても実行できます。 表示されるウィジェットは、同様にそのウィジェットのアクティブなキャンバスとディスプレイを解決するために使用できるルート ウィンドウにリンクされています。

ウィジェットが作成されたが、まだ表示されていない (つまり、ルート ウィンドウまたはその他の表示される親にリンクされていていない) 場合は、そのウィジェットに関連付けられているどのリソース ID も、特定のディスプレイに割り当てられたリソース テーブルへのインデックスを直接作成する以外の方法で特定のリソース値に解決することはできません。 特定のリソース テーブルへのこの直接のアクセスはアプリケーション ソフトウェアで安全に実行できますが、内部の GUIX ライブラリ ソフトウェアで実行されることはありません。

### <a name="widget-defaults"></a>ウィジェットの既定値 

GUIX ディスプレイ コンポーネントはまた、さまざまなウィジェット属性の既定の定義も提供します。 アプリケーションによって特に指定されない限り、ウィジェットまたはウィンドウは、これらのシステム属性を使用して作成されます。 これらのシステム属性は主に、システム リソース テーブル内に保持されているフォント、色、ビットマップで構成されます。 既定のスクロール バーの外観の追加の属性もまた、GUIX ディスプレイ コンポーネントによって管理されます。

既定の色設定は、各ディスプレイに割り当てられたカラー テーブルと、事前に定義された既定のカラー ID によって定義されます。 これらの既定のカラー ID には、次のものが含まれます。

| カラー ID | 説明 |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| GX_COLOR_ID_CANVAS | 既定のキャンバス (つまり、ディスプレイの背景) の色 |
| GX_COLOR_ID_WIDGET_FILL | 既定のウィジェットの塗りつぶしの色 |
| GX_COLOR_ID_WINDOW_FILL | 既定のウィンドウの塗りつぶしの色 |
| GX_COLOR_ID_DISABLED_FILL | 既定の無効になっているウィジェットの塗りつぶしの色 |
| GX_COLOR_ID_DEFAULT_BORDER | 既定のウィジェットの境界線の色 |
| GX_COLOR_ID_WINDOW_BORDER | 既定のウィンドウの境界線の色 |
| GX_COLOR_ID_TEXT | 既定のテキストの色 |
| GX_COLOR_ID_SELECTED_TEXT | 既定の選択されているテキストの色 |
| GX_COLOR_ID_DISABLED_TEXT | 既定の無効になっているテキストの色 |
| GX_COLOR_ID_SELECTED_TEXT_FILL | 既定の選択されているテキストの塗りつぶしの色 |
| GX_COLOR_ID_READONLY_TEXT | 既定の読み取り専用テキストの色 |
| GX_COLOR_ID_READONLY_FILL | 既定の読み取り専用テキストの塗りつぶしの色 |
| GX_COLOR_ID_SCROLL_FILL |    スクロール バーの塗りつぶしの色 |
| GX_COLOR_ID_SCROLL_BUTTON | スクロール バー ボタンの塗りつぶしの色 |
| GX_COLOR_ID_SHADOW | 既定の影の色 |
| GX_COLOR_ID_SHINE | 既定の強調表示の色 |
| GX_COLOR_ID_BUTTON_BORDER | ボタン ウィジェットの境界線の色 |
| GX_COLOR_ID_BUTTON_UPPER | ボタン ウィジェットの上部の塗りつぶしの色 |
| GX_COLOR_ID_BUTTON_LOWER | ボタン ウィジェットの下部の塗りつぶしの色 |
| GX_COLOR_ID_BUTTON_TEXT | ボタン ウィジェットのテキストの色 |
| GX_COLOR_ID_TEXT_INPUT_TEXT | テキスト入力ウィジェットのテキストの色 |
| GX_COLOR_ID_TEXT_INPUT_FILL | テキスト入力の塗りつぶしの色 |
| GX_COLOR_ID_SLIDER_TICK | スライダーの目盛を描画するために使用される色 |
| GX_COLOR_ID_SLIDER_GROOVE_BOTTOM | スライダーの溝を描画するために使用される色 |
| GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE | 針の輪郭を描画するために使用される色 |
| GX_COLOR_ID_SLIDER_NEEDLE_FILL | スライダーの針を塗りつぶすために使用される色 |
| GX_COLOR_ID_SLIDER_NEEDLE_LINE1 | 針の強調表示を描画するために使用される色 |
| GX_COLOR_ID_SLIDER_NEEDLE_LINE2 | 針の影を描画するために使用される色 |

これらのカラー ID 値は、各ディスプレイに割り当てられたカラー テーブルの定義に従って、特定のカラー値にマップされます。 これらの既定値は、***gx_display_color_table_set*** API 関数を呼び出すことによって、1 つのディスプレイのグループとして変更できます。 GUIX Studio を使用している場合は、アプリケーションが ***gx_studio_display_configure*** 関数を呼び出すと、ディスプレイ カラー テーブルが自動的に初期化されます。

GUIX ディスプレイ コンポーネントではまた、既定のフォント テーブルも保持します。 既定のフォント テーブルでは、アプリケーションによって特に指定されない限り、ウィジェットの種類ごとに使用されるフォントを定義します。 事前に定義されたディスプレイ フォント テーブル ID には、次の値が含まれます。

| フォント&nbsp;ID | 説明 |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------|
| GX_FONT_ID_DEFAULT | 特定のフォントが定義されていないときに使用される既定のフォント |
| GX_FONT_ID_BUTTON | ボタン上のすべてのテキストに使用される既定のフォント |
| GX_FONT_ID_TEXT_INPUT | テキスト編集フィールドに使用される既定のフォント |

テキストの種類のウィジェットによって使用されるフォント ID は、テキスト関連のウィジェットの種類ごとに提供されている **gx_<widget_type>_font_set** API を使用して再割り当てすることができます。 フォント テーブル全体は、**gx_display_font_table_set** API 関数を呼び出して再割り当てすることができます。

### <a name="scrollbar-appearance"></a>スクロール バーの外観 

GUIX ディスプレイではまた、そのディスプレイの既定のスクロール バーの外観設定も保持します。 これらの設定は、以下に定義されている **GX_SCROLLBAR_APPEARANCE** 構造体によって定義されます。 GUIX ディスプレイでは、垂直スクロール バー用の 1 つのスクロール バー外観構造体と、水平スクロール バー用の 2 番目の構造体を保持します。 アプリケーションでは、**GX_SCROLLBAR_APPEARANCE** 構造体を初期化し、API 関数 ***gx_display_scroll_appearance_set*** を呼び出すことによって、任意のディスプレイの既定のスクロール バーの外観を変更できます。

```c
typedef struct GX_SCROLLBAR_APPEARANCE_STRUCT
{
    GX_VALUE       gx_scroll_width;
    GX_VALUE       gx_scroll_thumb_width;
    GX_VALUE       gx_scroll_thumb_travel_min;
    GX_VALUE       gx_scroll_thumb_travel_max;
    GX_UBYTE       gx_scroll_thumb_border_style;
    GX_RESOURCE_ID gx_scroll_fill_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_pixelmap;
    GX_RESOURCE_ID gx_scroll_up_pixelmap;
    GX_RESOURCE_ID gx_scroll_down_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_color;
    GX_RESOURCE_ID gx_scroll_thumb_border_color;
    GX_RESOURCE_ID gx_scroll_button_color;
} GX_SCROLLBAR_APPEARANCE;
```
| GX_SCROLLBAR_APPEARANCE 構造体のメンバー | 説明 |
| --- | --- |
| gx_scroll_width | 垂直スクロール バーの幅または水平スクロール バーの高さ (ピクセル単位)。 |
| gx_scroll_thumb_width | エレベーター ボタンと終了ボタンの幅 (ピクセル単位)。 |
| gx_scroll_thumb_travel_max | スクロール バーの端から親指ボタンの最大移動ポイントまでのオフセット。 |
| gx_scroll_fill_pixelmap | スクロールの背景を塗りつぶすために使用されるピクセルマップ。 |
| gx_scroll_thumb_pixelmap | スクロールの親指ボタンを描画するために使用されるピクセルマップ。 |
| gx_scroll_up_pixelmap | 上にスクロール ボタンを描画するために使用されるピクセルマップ。 |
| gx_scroll_down_pixelmap | 下にスクロール ボタンを描画するために使用されるピクセルマップ。 |
| gx_scroll_fill_color | スクロール バーの背景を塗りつぶすために使用される色のカラー ID。 |
| gx_scroll_button_color | スクロール バーの親指ボタンを塗りつぶすために使用される色のカラー ID。 |

フォント、色、スタイルのこれらの既定の設定に加えて、アプリケーションではウィジェットの種類ごとに提供されている API を使用して、必要に応じてケースバイケースで任意のパラメーターを指定できます。

### <a name="skinning-and-themes"></a>スキニングとテーマ

スキニングを使用すると、GUIX ウィジェットおよびウィンドウで、その基本外観を簡単に変更できます。つまり、1 か所の "スキン" を変更すると、関連付けられているすべてのウィジェットおよびウィンドウの基本外観が変更されます。

GUIX アプリケーションを再スキニングするには、GUIX ディスプレイ リソース テーブルに新しい色、フォント、またはピクセルマップ テーブルを指定する必要があります。 すべての GUIX ウィジェットが自身の色、ビットマップ、またはフォントをリソース ID で参照しているため、新しいリソース テーブルを指定すると、すべての GUIX ウィジェットが、目的のディスプレイに自身を描画したときに自動的に新しい色やピクセルマップを使用し始めます。

魅力的な外観を提供するために連携して機能するように設計された新しい一連のフォント、色、ピクセルマップは "*テーマ*" と呼ばれます。 テーマでは、一連のリソース テーブルと、各リソース テーブルのサイズを定義します。 GUIX Studio アプリケーションを使用して、任意のディスプレイ用の任意の数のテーマを定義できます。 作成されたディスプレイに初期のテーマをインストールする、GUIX Studio で生成された関数 ***gx_studio_display_configure*** に開始テーマ インデックスを渡す必要があります。 任意のディスプレイのアクティブなテーマは、関数 ***gx_display_theme_install*** を呼び出すことによって、いつでも変更できます。

### <a name="root-window"></a>ルート ウィンドウ

アプリケーションによって作成された表示されるキャンバスごとに、アプリケーションでは、そのキャンバス用の 1 つのルート ウィンドウも作成する必要があります。 この特殊なウィンドウは基本的に、最上位のすべてのアプリケーション ウィンドウおよびウィジェットのコンテナーとして機能します。 ルート ウィンドウでは、キャンバスの背景を描画します。ルート ウィンドウは **GX_WINDOW** クラスから派生しているため、ルート ウィンドウにも壁紙がある場合があります。 ディスプレイまたはキャンバスの背景色を変更するには、単純に、そのキャンバスにアタッチされているルート ウィンドウの塗りつぶしの色を変更します。

GUIX Studio で生成された ***gx_studio_display_configure*** という名前の関数を使用してディスプレイを構成する場合は、この初期化関数の一部として、各ディスプレイのキャンバスとルート ウィンドウが自動的に作成されます。

### <a name="anti-aliasing"></a>アンチエイリアシング 

アンチエイリアシングは、直線、曲線、フォントを滑らかにするために使用される GUIX のオプション機能です。 アンチエイリアシングは、16 bpp 以上の色深度を利用したディスプレイ ドライバーで動作している場合にのみサポートされます。

アンチエイリアスされた線描画は、アクティブなブラシで **GX_BRUSH_ALIAS** フラッシュを設定することによって有効になります。 これは、直接描画された線だけでなく、多角形または円の境界として描画された線にも適用されます。

アンチエイリアスされたテキスト描画は、GUIX スタジオ アプリケーションによって生成されるアンチエイリアスされたフォントを使用することによって有効になります。 フォントを作成する場合は、アンチエイリアスされたフォントとバイナリ フォントのどちらを生成するかを指定します。
GUIX のアンチエイリアスされたフォントでは、ピクセルごとに 16 レベルの透明度を利用します。

### <a name="clipping"></a>クリッピング 

クリッピングは、GUIX ディスプレイ コンポーネントによって内部的に、またウィンドウおよびウィジェット レイヤーでは GUIX ウィジェットによって管理される親子アーキテクチャによってサポートされます。 どのウィンドウまたはウィジェットもそのウィジェットの領域の外部に描画することを許可されず、さらにウィジェットは、そのウィジェットの親の領域の外部に描画することを許可されません。

これにより、ウィジェットがキャンバス メモリの外部にあるピクセル座標に描画することも防止されます。これは、メモリ破損やシステム障害につながる可能性があります。 ウィジェットは、そのウィジェットの領域やウィジェットの親領域の外部に、またはキャンバスの範囲を超えて描画することを許可されません。

さらに、ウィジェットは、以前にダーティとマークされている領域にしか描画できません。 これにより、たとえばウィンドウの隅だけが表示されているときに、ウィンドウ全体が描画されることが防止されます。 ウィンドウの実際に更新する必要がある部分だけがダーティとマークされるため、ウィンドウ描画関数では、そのダーティ領域内のピクセルだけを実際に更新します。

GUIX ディスプレイ コンポーネントでは、ドライバー レベルの描画関数を呼び出す前に、これらのクリッピング アルゴリズムを適用します。

### <a name="views"></a>ビュー 

GUIX では常に、各ルート ウィンドウと、そのルート ウィンドウの各子ウィンドウの一連のビューを保持します。 ビューは、ウィンドウの位置や Z オーダーが変更されるに従って変化する、動的で、かつ実行時に決定されるクリッピング領域です。
GUIX では、前景のウィンドウまたはウィジェットの上に背景のウィンドウまたはウィジェットが描画されないようにするためにビューを使用します。 ビューでは Z オーダーの規範が適用されます。 さらに、ビューは、背景のウィンドウがキャンバスの表示不可能などの領域にも描画されないようにするという点で効率のために重要です。 あるウィンドウが別のウィンドウに完全に覆われている場合、その覆われているウィンドウは、キャンバスに描画することをまったく許可されません (たとえ、それを試みていた場合でも)。

### <a name="display-driver-interface"></a>Display driver interface (ディスプレイ ドライバー インターフェイス) 

GUIX ディスプレイ ドライバーは、基になる物理画面へのすべての操作を担当します。 これらのディスプレイ ドライバーには、初期化、描画、フレーム バッファーの表示の 3 つの基本的な機能があります。
初期化は、物理ディスプレイ ハードウェアの準備、物理ディスプレイ ハードウェアのプロパティの GUIX への通知、使用される特定の描画関数の GUIX への通知を担当します。 メイン ディスプレイ ドライバーの初期化は、GUIX ***gx_display_create*** 関数から呼び出されます。 さらに、GUIX スレッドでも、そのスレッド コンテキストからセカンダリ ディスプレイ ドライバーの初期化を呼び出します。 このセカンダリ ディスプレイ ドライバーは、ドライバーの初期化中に RTOS サービスが必要になる場合 (デバイスの割り込みや、初期化プロセス内のステップ間の遅延のための ***tx_thread_sleep*** 要求など) にのみ必要です。

初期化が完了すると、ディスプレイ ドライバーは、物理ディスプレイ ハードウェアで実行できるすべての直接の描画を担当します。
最後に、ディスプレイ ドライバーはフレーム バッファーの表示を担当します。

## <a name="guix-widget-component"></a>GUIX ウィジェット コンポーネント

GUIX ウィジェットは、表示されるグラフィック要素です。 タイマーや数値演算ユーティリティ関数など、表示されない GUIX コンポーネントも存在します。
ただし、表示されるコンポーネントはすべて、基本的な GUIX ウィジェット コンポーネントから派生しています。 GUIX ウィジェットは、GUIX ディスプレイの主要な構成要素です。その他のグラフィック要素はすべて、基本ウィジェット機能から派生しています。

GUIX ウィジェットは、継承が完全にサポートされた、オブジェクト指向の方法で実装されます。 これは、ANSI C を使用して実現されます。これにより、メモリや処理の要件が可能な限り最小限になります。 ある特定のウィジェット (**GX_BUTTON** など) が別のウィジェット (基本 **GX_WIDGET** など) "*から派生している*" と話す場合、それは、**GX_BUTTON** 制御構造体に **GX_WIDGET** のすべてのメンバー変数と関数ポインターが含まれ、さらに **GX_BUTTON** に固有のいくつかの変数が追加されていることを示します。 GUIX では、より複雑なウィジェットが常に、その前のより単純なウィジェットに基づくように、このようにウィジェットのレイヤーを構築しています。 この派生の階層モデルにより、ウィジェット パラメーターを変更するために使用される API の学習がより簡単になります。 ボタンの色を変更する場合は、ウィジェットの色を変更するために使用するのと同じ API (つまり、***gx_widget_fill_color_set***) を使用します。

表示されるウィジェットの構成は、子ウィジェットをその親にリンクするツリー構造リストを使用して、親 - 子という形で管理されます。 子は、描画できるビューや描画対象のキャンバスなどの特性をその親から継承します。
子ウィジェットはそれ自身の子ウィジェットを持つことができます。その子ウィジェットも、さまざまな特性を親から継承します。 どのウィジェットの特性も、各種の GUIX API 呼び出しを使用して明示的に再定義できます。

### <a name="widget-creation"></a>ウィジェットの作成 

ウィジェット オブジェクトは、初期化中に作成することも、アプリケーション スレッドの実行中の任意の時点で作成することもできます。 アプリケーションで作成できるウィジェット オブジェクトの数に制限はありません。 また、ウィジェットが持つことができる子の数にも (ターゲット ハードウェアのメモリ制限内で) 制限はありません。

ウィジェットの種類ごとに、独自の作成関数 (***gx_button_create** _ や _*_gx_prompt_create_** など) があります。 これらの関数への最初の 3 つのパラメーター、つまり、ウィジェット制御構造体へのポインター、ウィジェット名への文字列ポインター、ウィジェットの親へのポインターは常に同じです。 各作成関数には、その特定のウィジェットの種類の要件に応じて、任意の数の追加パラメーターがある場合があります。

### <a name="widget-control-block"></a>ウィジェット コントロール ブロック 

各ウィジェット オブジェクトの特性は、そのコントロール ブロック **GX_WIDGET** 内にあり、**_gx_api.h_** で定義されています。 ウィジェット オブジェクトに必要なメモリはアプリケーションによって提供され、メモリ内のどこにでも配置できます。 ただし、ウィジェット オブジェクト コントロール ブロックは、すべての関数のスコープ外に定義することによってグローバル構造体にすることが最も一般的です。 GUIX Studio を使用している場合、ウィジェット コントロール ブロックは、Studio で生成された仕様ファイル内で静的に割り当てるか、またはアプリケーションで動的に割り当てることができます。

### <a name="dynamic-widget-control-block-allocation-and-de-allocation"></a>ウィジェット コントロール ブロックの動的な割り当ておよび割り当て解除 

コントロール ブロックの動的な割り当てを使用している場合は、ウィジェット コントロール ブロックに必要なメモリの割り当てと解放のために GUIX で使用する 2 つの関数を定義する必要があります。 メモリ管理のための関数は、***gx_system_memory_allocator_set*** API 関数を使用して GUIX システム コンポーネントに渡されます。 この関数を使用すると、GUIX に次の 2 つの関数ポインターを渡すことができます。1 つ目はメモリ割り当て関数へのポインター、2 つ目はメモリ解放関数へのポインターです。 ほとんどの場合、これらの関数は ThreadX バイト プールを使用して実装しますが、GUIX の設計を使用すると、希望する任意の方法で動的メモリ管理を実装できます。

ウィジェットの動的な割り当ては、ほとんどの場合、Studio のウィジェットのプロパティ フィールドで [動的割り当て] オプションが選択されているときに、Studio で生成されたアプリケーション仕様ファイル内で使用されます。 ただし、コントロール ブロックの動的な割り当てはアプリケーション内でも使用できます。 アプリケーション内でコントロール ブロックの動的な割り当てを使用する場合は、***gx_widget_allocate** _ API 関数を呼び出して、ウィジェット コントロール ブロックを割り当てる必要があります。 次に、ウィジェットを作成するときに、ウィジェット作成関数に必ず _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** スタイル フラグを (その他のすべての必要なスタイル フラグと共に) 渡すようにしてください。 このフラグは、そのウィジェットをウィジェットの状態フィールドで [動的割り当て] とマークするために使用されます。 このウィジェットが後で **_gx_widget_delete_** を使用して削除された場合、GUIX ではこの状態フィールドをチェックし、メモリ割り当て解除関数を自動的に呼び出してメモリ リークが発生しないようにします。

> [!IMPORTANT]
> 動的に割り当てられたコントロール ブロックを使用して作成されるウィジェットは、メモリ損失を防ぐために **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** スタイル フラグを使用して作成する必要があります。

### <a name="types"></a>種類

GUIX には、完全に機能する、豊富な一連の組み込みウィジェットが用意されています。 先に説明したように、特殊なウィジェットはすべて、基本ウィジェットから派生しています。 GUIX の組み込みウィジェットの一覧を次に示します。

**GX_TYPE_WIDGET**

**GX_TYPE_BUTTON**

**GX_TYPE_TEXT_BUTTON**

**GX_TYPE_MULTI_LINE_TEXT_BUTTON**

**GX_TYPE_RADIO_BUTTON**

**GX_TYPE_CHECKBOX**

**GX_TYPE_PIXELMAP_BUTTON**

**GX_TYPE_ICON_BUTTON**

**GX_TYPE_ICON**

**GX_TYPE_SPRITE**

**GX_TYPE_SLIDER**

**GX_TYPE_PIXELMAP_SLIDER**

**GX_TYPE_VERTICAL_SCROLL**

**GX_TYPE_HORIZONTAL_SCROLL**

**GX_TYPE_PROGRESS_BAR**

**GX_TYPE_PROMPT**

**GX_TYPE_NUMERIC_PROMPT**

**GX_TYPE_PIXELMAP_PROMPT**

**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**

**GX_TYPE_SINGLE_LINE_TEXT_INPUT**

**GX_TYPE_MULTI_LINE_TEXT_VIEW**

**GX_TYPE_MULTI_LINE_TEXT_INPUT**

**GX_TYPE_WINDOW**

**GX_TYPE_ROOT_WINDOW**

**GX_TYPE_VERTICAL_LIST**

**GX_TYPE_HORIZONTAL_LIST**

**GX_TYPE_POPUP_LIST**

**GX_TYPE_DROP_LIST**

**GX_TYPE_LINE_CHART**

**GX_TYPE_DIALOG**

**GX_TYPE_KEYBOARD**

**GX_TYPE_SCROLL_WHEEL**

**GX_TYPE_TEXT_SCROLL_WHEEL**

**GX_TYPE_STRING_SCROLL_WHEEL**

**GX_TYPE_NUMERIC_SCROLL_WHEEL**

**GX_TYPE_CIRCULAR_GAUGE**

**GX_TYPE_RADIAL_PROGRESS_BAR**

**GX_TYPE_RADIAL_SLIDER**

**GX_TYPE_MENU_LIST**

**GX_TYPE_MENU**

**GX_TYPE_ACCORDION_MENU**

**GX_TYPE_TREE_VIEW**


### <a name="styles"></a>スタイル

ウィジェット スタイルは、境界線プロパティ (浮き出し、くぼんだ、細い、太い、境界線なし) や、前に一覧表示した特定のウィジェットの種類のプロパティなどの要素で構成されています。 ウィジェット スタイル フラグは、任意のウィジェットの外観を変更するための最も簡単な方法です。
初期のウィジェット スタイルは常に、そのウィジェットの種類に固有の作成関数に渡されるパラメーターです。

### <a name="colors"></a>色 

ウィジェットでは、システム カラー テーブルで定義されている色を使用して自身を描画します。
カラー ID は、キャンバスの背景、既定のウィジェットの塗りつぶしの色、ボタンの塗りつぶしの色、テキスト ウィジェットの塗りつぶしの色、ウィンドウの塗りつぶしの色、その他のいくつかの既定のカラー値に対して定義されます。 さらに、**GX_WINDOW** オブジェクトでは、ウィンドウ クライアントが塗りつぶされたときのビットマップまたは壁紙の表示をサポートしています。

既定の配色を変更するための最も簡単な方法は、GUIX Studio を使用して、要件を満たす配色を作成または定義することです。
また、GX_COLOR 値の配列を作成し、gx_system_color_table_set API 関数を呼び出すことによって、配色を手動で定義することもできます。

### <a name="event-notification"></a>イベント通知 

GUIX イベントは、特定のアクションを実行するために 1 つ以上のウィジェットに対して行われる要求、またはウィジェットにユーザー入力や内部のシステム状態変更を通知するための通知です。 たとえば、ウィジェットがフォーカスを取得すると、**GX_EVENT_FOCUS_GAINED** が ***gx_system_event_send*** API サービス経由でそのウィジェットに送信されます。

イベントは GUIX イベント キュー経由で渡され、各イベントは **GX_EVENT** データ構造体のインスタンスです。 **GX_EVENT** データ構造体は ***gx_api.h*** で定義されますが、この構造体の最も重要なフィールドは、**gx_event_type**、**gx_event_sender**、**gx_event_target**、**gx_event_payload** です。

**gx_event_type** フィールドは、特定のイベント クラスを識別するために使用されます。 イベントの種類は、これが、たとえば **GX_EVENT_PEN_DOWN** イベントまたは **GX_EVENT_TIMER** イベントのどちらであるかを示します。 **gx_event_payload** は、さまざまなデータ フィールドの和集合であり、すべてがどのイベントの種類でも有効であるとは限りません。
まず、イベントの種類のフィールドを使用してから、その他のイベント データ フィールドを調べます。

イベントが子ウィジェットの通知である場合、**gx_event_sender** フィールドには、そのイベントを生成したウィジェットの ID が含まれています。

**gx_event_target** フィールドを使用すると、ユーザー定義イベントを特定のウィンドウまたはウィジェットにルーティングできます。 イベントを特定のウィンドウに送信する場合は、そのウィンドウに (明確に識別できる) 一意の ID 値を割り当て、イベントを構築するときにそのウィンドウの ID 値を **gx_event_target** フィールドに設定する必要があります。 ターゲットの ID がわからないか、または単に入力フォーカスを持つウィジェットにイベントをルーティングするだけの場合は、**gx_event_target** フィールドを確実に 0 に設定してください。

最後に、**gx_event_payload** フィールドは、さまざまなデータの種類の和集合です。 **GX_EVENT_PEN_DOWN** および **GX_EVENT_PEN_UP** イベントの場合、**gx_event_pointdata** フィールドには、ペン位置の x、y ピクセル座標が含まれています。 タイマー イベントの場合、**gx_event_timer_id** フィールドには、有効期限が切れたタイマーの ID が含まれています。 その他のペイロード データ フィールドは、他のイベントの種類に利用されます。 事前に定義されたイベントの種類とそのペイロード フィールドの完全な一覧は、「[付録 E - GUIX イベントの説明](appendix-e.md)」で定義されています。

アプリケーションではまた、定数 **GX_FIRST_APP_EVENT** の後に数値で始めて、独自のカスタム イベントを追加することもできます。 この定数の後のすべてのイベント番号が、そのアプリケーションの使用のために予約されます。 当然ながら、このアプリケーションのウィジェット イベント ハンドラーには、このようなアプリケーション イベントの処理が含まれている必要があります。

### <a name="event-processing"></a>イベント処理 

すべてのウィジェットには、***gx_<widget-type>_event_process*** という名前の既定のウィジェット イベント処理関数があります。 ほとんどの場合、アプリケーションは、特定のどのウィジェットのイベント処理にも関与する必要がありません。 ただし、アプリケーションにカスタム イベント処理または補足的なイベント処理が必要な状況では、アプリケーションが GUIX API ***gx_widget_event_process_set*** を使用して、既定の処理関数を独自の処理関数でオーバーライドできます。 この関数では、既定のイベント処理関数を API で指定されているイベント処理関数でオーバーライドします。

> [!IMPORTANT]
> アプリケーション イベント処理関数では、既定の ***gx_widget_event_process*** の処理を直接呼び出すだけで、既定の処理を利用できます (つまり、処理を複製する必要はありません)。

イベント処理は、内部の GUIX システム スレッドのコンテキストから排他的に呼び出されます。 この方法では、イベント処理を実行するためのスタックの要件が GUIX スレッドにのみ適用されます。

### <a name="implementing-custom-event-processing-example"></a>カスタム イベント処理の実装 (例) 

GUIX システムの任意のウィジェットまたはウィンドウに対して独自のイベント処理関数を提供できます。 独自のカスタムのウィジェットの種類を作成している場合は通常、そのウィジェット作成関数でカスタム イベント ハンドラーをインストールします。 既存のウィジェットまたはウィンドウの操作を拡張または変更しているだけである場合は、そのウィジェットまたはウィンドウが作成された後に gx_widget_event_process_set API 関数を呼び出すことができます。 子コントロールによって生成されたイベントを処理するために、最上位レベルのウィンドウ (画面とも呼ばれます) には、ほぼ常に独自のイベント処理を提供します。 画面の子コントロールによって生成されたイベントの処理は、GUIX アプリケーションに機能を追加するための主な方法です。

例として、"main_menu" という名前の最上位レベルの画面を定義するとします。
この画面は、GUIX Studio を使用して定義することも、アプリケーション コードで作成することもできます。 GUIX Studio 内でこの画面を定義する場合は、その画面に対する Studio のプロパティ フィールドにイベント ハンドラーの名前を入力するだけで、Studio で生成された仕様コードによってそのイベント ハンドラーが自動的にインストールされます。 この場合は、カスタム イベント ハンドラー ***main_menu_event_handler*** を呼び出しますが、それは次のようにコーディングされます。

```C
int main_menu_item; /* example: variable to keep track of selected item */

UINT main_menu_event_handler(GX_WINDOW *main_screen, GX_EVENT *event_ptr)
{
    UINT status = GX_SUCCESS;

    switch(event_ptr->gx_event_type)
    {
    /* this is an example for catching events from a child button */
    case GX_SIGNAL(IDB_CHILD_BUTTON, GX_EVENT_CLICKED):
        /* insert your button handler code here */
        break;

    case GX_EVENT_SHOW:
        /* add functionality to the show event handler */
        /* first, do default processing */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */

        /* now add my own processing */
        main_menu_item = 0;
        break;

    default:
        /* pass all other events to base processing function */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */
        break;
    }
    return status;
}
```

上記の例では、**GX_EVENT_SHOW** (ウィジェットに状態変更を通知するために内部的に生成されたイベント) などのシステム イベントの場合、通常の処理が確実に実行されるようにするには、アプリケーションでこれらのイベントを基本ウィジェット イベント処理関数に渡す必要がある点に注意することが重要です。 アプリケーションでは、その後、必要に応じて追加のロジックを追加できます。 また、アプリケーションによって処理されないすべてのイベント (上記の既定のケース) も基本イベント処理関数に渡す必要があります。 この例は **GX_WINDOW** に基づいた最上位レベルの画面のものであったため、既定のイベント処理関数は gx_window_event_process です。

### <a name="drawing-function"></a>描画関数 

ウィジェットの描画はすべて、イベント処理とは別に実行されます。 描画は通常、CPU サイクルの点から見てコストが高いため、この方が効率的です。 遅延描画アルゴリズムの実装によって、未処理のイベントとそれに関連付けられた表示の変更をすべて完了してから描画を実行することが可能になります。これにより、描画の浪費が解消されます。 イベント処理と同様に、ほとんどのウィジェットには、***gx_<widget-type>_draw*** という名前の既定のウィジェット描画関数があります。ここで、xxx はウィジェットの種類です。 ほとんどの場合、アプリケーションは、特定のどのウィジェットの描画関数にも関与する必要がありません。 ただし、アプリケーションにカスタム描画または補足的な描画が必要な状況では、アプリケーションが GUIX API ***gx_widget_draw_set*** を使用して、既定の描画関数を独自の描画関数でオーバーライドできます。 この関数を使用すると、アプリケーションでは、任意のウィジェットに対して独自のカスタマイズされた描画関数を提供できます。 これにより、アプリケーションはさらに、新しいウィジェットの種類の全体を定義できるようになります。

> [!IMPORTANT]
> アプリケーション描画関数では、オーバーライドされた描画関数から直接呼び出すだけで、既定の描画を利用できます (つまり、コードを複製する必要はありません)。

ウィジェット描画は、内部の GUIX システム スレッドのコンテキストから排他的に呼び出されます。 この方法では、描画を実行するためのタイミングとスタックの要件が GUIX スレッドにのみ適用されます。

### <a name="implementing-custom-drawing-example"></a>カスタム描画の実装 (例) 

どのウィジェットの描画関数も、GX_WIDGET コントロール ブロックのメンバーである間接関数ポインターを通して参照されます。 GUIX Studio を使用してウィジェットを定義する場合は、ウィジェットのプロパティの [描画関数] パラメーターに関数の名前を入力するだけで、独自の関数ポインターをインストールできます。そのウィジェットが作成されると、Studio によって関数ポインターが自動的にインストールされます。 アプリケーション コードでウィジェットを作成する場合は、そのウィジェットが作成された後に、***gx_widget_draw_set*** API 関数を使用してカスタム描画関数をインストールする必要があります。

この例では、ボタンの外観をカスタマイズする場合を想定してみましょう。 このボタンは **GX_TEXT_BUTTON** と非常に似ていますが、ボタンが押されているときはボタンの中央右側の部分に小さな緑色の "LED_ON" ビットマップを、ボタンが押されていないときは小さな "LED_OFF" ビットマップを描画する処理を追加します。 ここで作成しようとしているのは次の図のようなボタンです。

!["オン" の場合の緑色のボタンのスクリーンショット。](./media/guix/image4.jpg) カスタム ボタン "オン"

!["オフ" の場合の赤色のボタンのスクリーンショット。](./media/guix/image5.jpg) カスタム ボタン "オフ"

この場合は、次のようなボタン描画関数を記述します。

```C
UINT my_button_draw(GX_TEXT_BUTTON *button)
{
    GX_PIXELMAP *map;
    ULONG button_style;
    INT xpos;
    INT ypos;

    /* first, do the normal text button drawing */
    gx_text_button_draw(button);

    /* now add our extra pixelmap */

    gx_widget_style_get(button, &button_style);

    if (button_style & GX_STYLE_BUTTON_PUSHED)
    {
        /* use the ON pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_ON, &map);
    }
    else
    {
        /* use the OFF pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_OFF, &map);
    }
    if (map)
    {
        /* draw it 20 pixels in from right edge */
        xpos = button->gx_widget_size.gx_rectangle_right;
        xpos -= map->gx_pixelmap_width + 20;

        /* and draw 10 pixels from the top edge */
        ypos = button->gx_widget_size.gx_rectangle_top + 10;

        /* draw the extra pixelmap on top of the button */
        gx_canvas_pixelmap_draw(xpos, ypos, map);
    }
}
```

## <a name="guix-drawing-context-component"></a>GUIX 描画コンテキスト コンポーネント 

描画コンテキストは、GUIX によって各キャンバス更新操作が実行されるとき、実行時に動的に作成されます。 描画コンテキストによって、キャンバス、画面ドライバー、現在の描画操作を実行するために使用されるブラシが結び付けられます。

描画コンテキストは、**GX_DRAW_CONTEXT** 構造体によって定義されます。
この構造体には、現在の描画操作のクリッピングとビューを定義する変数、現在のキャンバスを定義する変数、使用されている現在の画面ドライバーを定義する変数が含まれています。 また、**GX_DRAW_CONTEXT** 構造体には、描画に使用されるブラシも保持されます。 描画コンテキスト ブラシは、カスタム描画関数で直接操作するメンバーです。 ブラシ構造体は、次のコードに示すように定義されます。

```C
typedef struct GX_BRUSH_STRUCT
{
    GX_PIXELMAP *gx_brush_pixelmap;
    GX_FONT     *gx_brush_font;
    ULONG        gx_brush_line_pattern;
    ULONG        gx_brush_pattern_mask;
    GX_COLOR     gx_brush_fill_color;  
    GX_COLOR     gx_brush_line_color;  
    UINT         gx_brush_style;
    GX_VALUE     gx_brush_width;
    UCHAR        gx_brush_alpha;  
} GX_BRUSH;
```

**gx_brush_pixelmap** フィールドでは、四角形と多角形の塗りつぶしに使用するピクセルマップを定義します。 このメンバーは、**gx_brush_style** に **GX_BRUSH_PIXELMAP** スタイルが含まれていない限り使用されません。

**gx_brush_font** メンバーでは、テキスト描画に使用されるフォントを定義します。
**gx_brush_line_pattern** メンバーでは、破線に使用されるパターンを定義します。
**gx_brush_style** メンバーは、ブラシ属性を完全に定義するために OR で結合できる一連のスタイル フラグです。 使用可能なブラシ スタイル フラグには、次のものが含まれます。

**GX_BRUSH_OUTLINE**  
**GX_BRUSH_SOLID_FILL**  
**GX_BRUSH_PIXELMAP_FILL**  
**GX_BRUSH_ALIAS**  
**GX_BRUSH_UNDERLINE**  
**GX_BRUSH_ROUND**

**gx_brush_width** メンバーでは、線描画での線の幅、または輪郭のある図形の描画での輪郭の幅を定義します。

**gx_brush_line_color** メンバーでは、線描画とテキスト描画での前景色を定義します。

**gx_brush_fill_color** メンバーでは、図形の塗りつぶしに使用される単色塗りつぶしの色を定義します。 GUIX コンテキスト コンポーネントは、アクティブなコンテキスト内の現在のブラシを非常に簡単に変更できるように設計された一連の API を提供します。 これらの API には、**gx_context_brush_define**、**gx_context_line_color_set**、**gx_context_fill_color_set**、**gx_context_font_set**、その他多数が含まれます。

親オブジェクトの描画コンテキストは、そのオブジェクトの子によって継承されます。 実際には、子オブジェクトの描画関数が呼び出されたときに、そのオブジェクトによって親描画コンテキストの複製が継承されます。 子は、親の描画に影響を与えることなくそのコンテキストを変更できますが、必要に応じて、ブラシの色やスタイルなどの情報を親から継承することもできます。

## <a name="guix-window-component"></a>GUIX ウィンドウ コンポーネント 

ウィンドウ コンポーネントは、GUIX でのすべてのウィンドウ処理を担当します。 GUIX ウィンドウは基本的に、1 つ以上の子ウィジェットを含むことができる個別のディスプレイ領域です。 GUIX では、ウィンドウは実際には、基本ウィジェット オブジェクトの特殊な形式にすぎません。

GUIX ウィンドウは、継承が完全にサポートされた、オブジェクト指向の方法で実装されます。 これは、ANSI C を使用して実現されます。これにより、メモリや処理の要件が可能な限り最小限になります。

GUIX ウィンドウは、主に水平および垂直スクロールのサポートを追加することによって、GUIX ウィジェットの機能を拡張します。 GUIX ウィンドウ オブジェクトでは、スクロール バーを自動的に作成して表示し、スクロール バーの入力に応答できます。 また、移動可能なウィンドウには、ペン入力イベントに基づいてウィンドウを移動またはドラッグできるようにするためのイベント処理も組み込まれています。
最後に、GUIX ウィンドウでは入力フォーカスを受け取ると、そのウィンドウをウィンドウ Z オーダーの前面に移動することによって応答します。

GUIX ウィンドウでは、"*クライアント領域*" の概念を保持しています。これは、ウィンドウの境界線やスクロール バーなどのクライアント以外のオブジェクトが使用可能な領域から削除された後のウィンドウの内側の部分です。 クライアント領域の子ウィジェットがウィンドウ クライアント領域にクリップされるのに対して、スクロール バーなどのクライアント以外の子はクライアント領域の外部に描画することを許可されますが、引き続きそのウィンドウの外側のディメンションにはクリップされます。

ウィンドウは、親 - 子という形で管理されます。ここで、子は特性をその親から継承します。 子ウィンドウはそれ自身の子ウィンドウを持つことができます。その子ウィンドウも、さまざまな特性を親から継承します。 どのウィンドウの特性も、各種の GUIX API 呼び出しを使用して明示的に再定義できます。

### <a name="window-creation"></a>ウィンドウの作成 

ウィンドウ オブジェクトは、初期化中に作成することも、アプリケーション スレッドの実行中の任意の時点で作成することもできます。 アプリケーションで作成できるウィンドウ オブジェクトの数に制限はありません。 また、ウィンドウが持つことができる子の数にも制限はありません。

### <a name="window-control-block"></a>ウィンドウ コントロール ブロック 

各ウィンドウ オブジェクトの特性は、そのコントロール ブロック **GX_WINDOW** 内にあり、**_gx_api.h_** で定義されています。 ウィンドウ オブジェクトに必要なメモリはアプリケーションによって提供され、メモリ内のどこにでも配置できます。 ただし、ウィンドウ オブジェクト コントロール ブロックは、すべての関数のスコープ外に定義することによってグローバル構造体にすることが最も一般的です。

### <a name="root-window"></a>ルート ウィンドウ 

GUIX では、ルート ウィンドウと呼ばれるものがキャンバスごとに必要です。 ルート ウィンドウは境界線がなく、それがアタッチされているキャンバスと同じディメンションを持っています。 これは主に、すべての第 1 レベルのウィジェットおよびウィンドウのコンテナーとして使用されます。 ルート ウィンドウは通常、画面とキャンバスの作成のすぐ後に、API 関数 ***gx_window_root_create*** を使用してアプリケーションによって作成されます。 Studio で生成された関数 gx_studio_display_configure を使用する場合は、ルート ウィンドウのアドレスを、この関数への最後のパラメーターとして渡された場所に返すことができます。

ルート ウィンドウは既定では移動不可能になっており、最も単純なケースでは、ルート ウィンドウはキャンバスのサイズになります。 ルート ウィンドウでは、実質的にディスプレイの背景を描画するため、ディスプレイの背景色を変更したり、背景壁紙を表示したりするには、ルート ウィンドウに色または壁紙を割り当てます。

ルート ウィンドウが移動可能な場合は、子ウィンドウの場合のようにキャンバス上の位置を変更するのではなく、キャンバス自体を移動することによってルート ウィンドウを移動します。
この機能により、GUIX ルート ウィンドウでは、ハードウェア オフセット レジスタを備えた複数のフレーム バッファーをサポートするハードウェアを利用できるようになります。

### <a name="background"></a>バックグラウンド 

ウィンドウの背景は、単色またはビットマップ イメージのどちらかです。 システム レベルでは、一連の初期ウィンドウの既定値を提供する既定のウィンドウの背景があります。 当然ながら、ウィンドウの背景はすべて、GUIX API を使用して変更できます。

ウィンドウの単色の背景を変更するには、***gx_widget_fill_color_set*** API を使用します。 ウィンドウに背景壁紙を割り当てるには、***gx_window_wallpaper_set*** API を使用します。

### <a name="scrolling"></a>スクロール 

GUIX では、ウィンドウの子を表示するために必要な領域がそのウィンドウの現在のサイズ (水平または垂直、あるいはその両方) を超えた場合、標準のウィンドウ スクロールをサポートしています。 スクロールを有効にするには、アプリケーションで目的のスクロール バーを作成し、それをウィンドウにアタッチする必要があります。

GUIX ウィンドウ コンポーネントは、ウィンドウ クライアント領域のサイズとすべての子ウィジェットの範囲に基づいた既定のスクロール実装を提供します。 また、アプリケーションで特定のウィンドウの ***gx_window_scroll_info_get*** 関数をオーバーライドすることによって、独自のスクロール実装と解釈を提供することもできます。

### <a name="event-notification"></a>イベント通知 

既定のウィンドウ イベント処理関数は、主にスクロールおよびサイズ変更イベントの処理で GX_WIDGET のイベント処理とは異なります。 GX_WINDOW には、スクロールおよびサイズ変更イベントの既定のハンドラーが用意されています。

アプリケーションではまた、定数 **GX_FIRST_APP_EVENT** の後に数値で始めて、独自のカスタム イベントを追加することもできます。 この定数の後のすべてのイベント番号が、そのアプリケーションの使用のために予約されます。 当然ながら、このアプリケーションのウィンドウ イベント ハンドラーには、このようなアプリケーション イベントの処理が含まれている必要があります。

### <a name="event-processing"></a>イベント処理 

その他のすべてのウィジェットの種類と同様に、すべてのウィンドウには、***gx_window_event_process*** という名前の既定のウィンドウ イベント処理関数があります。 このイベント処理関数は通常、ユーザーが作成したウィンドウの独自のイベント ハンドラーでオーバーライドします。 この方法で、イベントに応答したり、ウィンドウの子コントロールによって生成されたイベントに基づいてアクションを実行したりします。

そのイベント ハンドラーをオーバーライドする場合は、イベント ハンドラーに追加している任意のアクションに加えて既定のイベント処理を実行できるようにするために、忘れずに GUIX システム イベントの基本 ***gx_window_event_process*** 関数を呼び出すことが重要です。 たとえば、**GX_EVENT_SHOW** イベントのカスタム ハンドラーを提供しても、このイベントを ***gx_window_event_process*** に渡さないと、そのウィンドウは表示されません。
ウィンドウのカスタム イベント ハンドラーを提供するには、***gx_widget_event_process_set*** 関数を使用して、そのイベント ハンドラーのアドレスを定義します。 この関数では、既定のイベント処理関数を API で指定されているイベント処理関数でオーバーライドします。

> [!IMPORTANT]
> アプリケーション イベント処理関数では、既定の ***gx_window_event_process*** を直接呼び出すだけで、既定の処理を利用できます (つまり、処理を複製する必要はありません)。

イベント処理は、内部の GUIX システム スレッドのコンテキストから排他的に呼び出されます。 この方法では、イベント処理を実行するためのスタックの要件が GUIX スレッドにのみ適用されます。

## <a name="guix-image-reader-component"></a>GUIX イメージ リーダー コンポーネント 

イメージ リーダー コンポーネントは、未加工の圧縮されたイメージを GUIX ピクセルマップ形式に展開するためのユーティリティと API 関数を提供します。 JPEG および PNG 形式の未加工のイメージ データがサポートされ、将来のリリースのために追加の形式が予約されています。

大部分の GUIX アプリケーションには GUIX イメージ リーダー コンポーネントが必要ないことに注意してください。 ほとんどのアプリケーションは、JPEG および PNG 形式のグラフィックス資産を GUIX と互換性のある **GX_PIXELMAP** リソースに変換するために GUIX Studio アプリケーションに依存しています。 GUIX イメージ リーダー コンポーネントは、未加工のグラフィックス資産が実行時にしか認識されない場合、またはシステム ストレージの制約のためにリソースを **GX_PIXELMAP** 形式で格納できない場合に利用されます。 JPEG および PNG 形式のイメージ データは一般に **GX_PIXELMAP** 形式よりコンパクトですが、これらのイメージの種類の展開および色空間の変換の動的な実行に関連した非常に大きなランタイム オーバーヘッドが発生します。

未加工の形式の JPEG または PNG イメージが gx_canvas_pixelmap_draw API 関数に渡された場合、GUIX では、その JPEG または PNG データを動的に展開して描画します。 これがランタイム描画速度に重大な悪影響を与えることに注意してください。ハードウェアで支援された JPEG または PNG の展開をサポートするハードウェア ターゲットを使用していない限り、RAW 形式のイメージ データを gx_canvas_pixelmap_draw 関数に渡すことはお勧めできません。

> [!IMPORTANT]
> 未加工の JPEG または PNG 形式のイメージを gx_canvas_pixelmap_draw API に渡すと、ほとんどのターゲット ハードウェアで重大なランタイム オーバーヘッドが発生します。

別の方法として、イメージ リーダー コンポーネントを使用して、未加工の JPEG および PNG データを実行時に GX_PIXELMAP 形式に変換することもできます。
この方法で生成されたピクセルマップは、Studio によって生成され、リソース ファイル内に含まれているピクセルマップと同様に使用したり、描画したりできます。 これにより、アプリケーションでは、イメージの展開、ディザリング、色空間の変換などをイメージが描画されるたびに実行するのではなく、これらの操作を (通常はプログラムの起動中に) 1 回実行するだけで済むようになります。

イメージ リーダー コンポーネント関数には、次のものが含まれます。

***gx_image_reader_create***  
***gx_image_reader_palette_set***  
***gx_image_reader_start***

## <a name="guix-animation-component"></a>GUIX アニメーション コンポーネント 

GUIX アニメーション コンポーネントは、画面とウィジェットの切り替えを自動化するために使用される一連の関数およびサービスです。 GUIX アニメーション コンポーネントでは、任意のウィジェットの種類のフェード イン、フェード アウト、移動、またはスライドの種類のアニメーションをサポートしています。

フェードの種類のアニメーションは、フェードするウィジェットの内部アルファ値を変化させるか (**GX_BRUSH_ALPHA_SUPPORT** が有効になっている場合)、またはウィジェットのいずれかのコレクションを別のメモリ キャンバスに描画する (これにより、背景とブレンドされます) ことによってサポートできます。 複数のハードウェア グラフィックス レイヤーをサポートするハードウェア ターゲットの場合、スムーズなフェード効果のサポートは、このキャンバス ブレンドのアプローチを使用することによって最適に実現されます。多くの場合、コア CPU 帯域幅はほとんど必要ありません。 複数のグラフィックス レイヤーをサポートしていないハードウェア ターゲットの場合は、16 bpp 以上の色深度で動作しているとき、GUIX ブラシのアルファ値を使用したブレンドがサポートされます。

アニメーションで別の描画キャンバスを使用する必要がある場合、GUIX アニメーション コンポーネントは、この目的のために API サービス gx_animation_canvas_define を提供します。 他のアニメーションの種類では別のキャンバスは必要ありませんが、使用可能になっている場合は利用します。 これにより、複数のハードウェア サーフェスに対する基になるハードウェア サポートの考えられる最高の使用が可能になります。

アニメーションを制御する変数は、2 つのコントロール ブロックによって定義されます。 1 つ目は、アニメーション コントローラーを定義する **GX_ANIMATION** コントロール ブロックです。 アニメーション コントローラーは、ユーザーが定義したアニメーション シーケンスを実行する駆動エンジンです。 1 つのアニメーション コントローラーを何回も再利用して、多くの異なるアニメーション シーケンスを実行できます。 複数のアニメーション シーケンスを同時に実行する必要がある場合は、複数の **GX_ANIMATION** アニメーション コントローラーを作成できます。

GUIX システム コンポーネントは、**GX_ANIMATION** 制御構造体の再利用可能なブロックを提供できます。これは、アプリケーションでアニメーションが必要になったときに要求することができ、アニメーション シーケンスが完了すると自動的にシステム プールに返されます。 これにより、アプリケーションは、実装される可能性があるアニメーションごとに **GX_ANIMATION** 構造体を静的に定義する処理から解放されます。 この **GX_ANIMATION** 構造体のプールのサイズは、定数 **GX_ANIMATION_POOL_SIZE** によって定義されます。この既定値は 6 です。つまり、既定では、システム プールから 6 つの同時アニメーションを割り当てることができます。 この定数は当然、それを超える数の同時アニメーションが必要になった場合は gx_user.h ヘッダー ファイルで再定義できます。 **GX_ANIMATION_POOL_SIZE** が 0 に設定されている場合は、GUIX システム コンポーネントによってアニメーション プールやそれに関連するサービスは提供されません。

アニメーションを定義するために使用される 2 つ目のコントロール ブロックまたは構造体は、**GX_ANIMATION_INFO** 構造体です。 この構造体は、特定の 1 つのアニメーション シーケンスを定義するために使用されます。 この情報構造体は、gx_animation_start API サービスを使用してアニメーション シーケンスを開始するときにアニメーション コントローラーに渡します。 **GX_ANIMATION_INFO** 構造体には、次のフィールドが含まれています。

```C
typedef struct GX_ANIMATION_INFO_STRUCT
{
    GX_WIDGET *gx_animation_target;
    GX_WIDGET *gx_animation_parent;
    GX_WIDGET *gx_animation_screen_list;
    USHORT gx_animation_style;
    USHORT gx_animation_id;
    USHORT gx_animation_start_delay;
    USHORT gx_animation_frame_interval;
    GX_POINT gx_animation_start_position;
    GX_POINT gx_animation_end_position;
    GX_UBYTE gx_animation_start_alpha;
    GX_UBYTE gx_animation_end_alpha;
    GX_UBYTE gx_animation_steps;
} GX_ANIMATION_INFO;
```

**gx_animation_target** メンバーでは、アニメーション コントローラーで処理するターゲット ウィジェットを定義します。

**gx_animation_parent** メンバーでは、アニメーション シーケンスが完了したしたときにターゲット ウィジェットがアタッチされる親ウィジェット (存在する場合) を定義します。 gx_animation_parent はまた、アニメーションが完了したときに生成される GX_ANIMATION_COMPLETE イベントの受信者でもあります。

**gx_animation_screen_list** メンバーでは、ペン入力によって開始される画面スライド アニメーションのウィジェットの一覧を定義します。 このウィジェットの一覧は GX_NULL ポインターで終了する必要があり、一覧内の各ウィジェットの x、y ディメンションは gx_animation_parent と同じである必要があります。

**gx_animation_style** は、実行されるアニメーションの種類とそれに関連付けられたオプションを定義するビットマスクです。 アニメーション スタイルのフラグには、次のものが含まれます。

| アニメーション&nbsp;スタイルのフラグ | 説明 |
| --- | --- |
| GX_ANIMATION_TRANSLATE | スライドまたはフェードの種類のアニメーションを要求します。 |
| GX_ANIMATION_SCREEN_DRAG | ペン入力によって開始される画面ドラッグ アニメーションを要求します。 |

次のフラグは、**SCREEN_DRAG** の種類のアニメーションと組み合わせて使用できます。

| 画面ドラッグのフラグ | 説明 |
| --- | --- |
| GX_ANIMATION_WRAP | 画面の一覧を最後まで行ったら先頭に折り返す必要があります。 |
| GX_ANIMATION_HORIZONTAL | 水平方向に許可される画面ドラッグ。  |
| GX_ANIMATION_VERTICAL | 垂直方向に許可される画面ドラッグ。 |

次のフラグは、平行移動アニメーションと組み合わせて使用できます。

| 平行移動アニメーションのフラグ | 説明 |
| --- | --- |
| GX_ANIMATION_DETACH | アニメーションが完了したら、アニメーション ターゲットをアニメーションの親からデタッチします。 このターゲットが動的に割り当てられ、GUIX Studio で生成された自動イベント処理によって作成されている場合、そのターゲットはデタッチされた後に削除されます。 |
| GX_ANIMATION_TRANSLATE | アニメーションの種類は、タイマーによって開始されるアニメーションです。 アプリケーションでターゲット ウィジェットの開始および終了位置と開始および終了アルファ値を定義すると、アニメーション マネージャーでは、アニメーションを実行するための推進力として機能するタイマーを作成します。
| GX_ANIMATION_SCREEN_DRAG | このアニメーションの種類がペン入力イベントによって開始されるという点で、**TRANSLATE** アニメーションとは異なります。 このアニメーションの種類では、タッチ スクリーン入力を追跡して、ユーザーが入力タッチ スクリーン上でペンまたはスタイラスをドラッグしたらターゲット ウィジェットをスワイプします。 この種類のアニメーションを利用するには、アプリケーションで **_gx_animation_drag_enable_** API を呼び出して、このアニメーションを有効にする必要があります。 |

**gx_animation_id** 値は、**GX_ANIMATION_COMPLETE** イベントの event.gx_event_sender フィールドでアニメーションの親に戻されます。 この値は、複数ある可能性がある子アニメーションのどれが完了を報告しているかを特定するために、アニメーションの親によって使用されます。 この値は 0 である場合があり、ID 値が 0 のアニメーションによって **ANIMATION_COMPLETE** イベントが生成されることはありません。

**gx_animation_start_delay** 値は、**_gx_animation_start_ *_ が呼び出されてから実際にアニメーションを実行するまで遅延させるタイマー刻みの数を示す GUIX ティック数です。この値を 0 にして、_* _gx_animation_start_** を呼び出した後すぐにアニメーションを開始することができます。

**gx_animation_frame_interval** フィールドでは、アニメーション シーケンスの各フレーム間で遅延させる GUIX タイマー刻みの数 (基になる OS ティック レートの倍数) を定義します。 最小値は 1 です。

**gx_animation_start_position** では、平行移動アニメーションでのターゲット ウィジェットの左上の開始点を定義します。

**gx_animation_end_position** では、平行移動の種類のアニメーションでのターゲット ウィジェットの左上の終了位置を定義します。

**gx_animation_start_alpha** フィールドでは、平行移動の種類のアニメーションでの開始キャンバス アルファ値を定義します。

**gx_animation_end_alpha** フィールドでは、平行移動の種類のアニメーションでの終了キャンバス アルファ値を定義します。

**gx_animation_steps** フィールドでは、コントローラーが平行移動アニメーションで実行する必要があるステップまたはフレームの数を定義します。 ステップ数を大きくすると、より滑らかなスライドまたはフェードの外観が生成されますが、必要になるシステム帯域幅も大きくなります。

アプリケーションでアニメーション効果を実装するには、まず ***gx_animation_create*** を呼び出して、アニメーション コントローラーを初期化する必要があります。 アニメーションでセカンダリ キャンバスを使用する場合は、gx_animation_canvas_define を呼び出してこのキャンバスを初期化します。 次に、**GX_ANIMATION_INFO** 構造体を初期化して、実行されるアニメーションの特定の種類とその他のアニメーション パラメーターを定義する必要があります。 最後に、gx_animation_start を呼び出して、アニメーション シーケンスをトリガーします。

アニメーション コントローラーは、アニメーション シーケンスを完了すると、親ウィジェットに **GX_ANIMATION_COMPLETE** イベントを送信して、その時点でアニメーション キャンバスのすべての望ましいクリーンアップを実行できるようにします。

## <a name="guix-utility-component"></a>GUIX ユーティリティ コンポーネント 

ユーティリティ コンポーネントは、GUIX のすべての一般的なユーティリティ関数を担当します。 これらは、有効なユーティリティであり、さらにアプリケーションまたは内部の GUIX コード内のどこからでも呼び出すことができる一般的な関数です。 ユーティリティ コンポーネント関数には、次のものが含まれます。

***gx_utility_canvas_to_bmp***

***gx_utility_circle_point_get***

***gx_utility_alphamap_create***

***gx_utility_gradient_create***

***gx_utility_gradient_delete***

***gx_utlity_ltoa***

***gx_utility_math_acos***

***gx_utility_math_asin***

***gx_utility_math_cos***

***gx_utility_math_sin***

***gx_utility_math_sqrt***

***gx_utility_pixelmap_resize***

***gx_utility_pixelmap_rotate***

***gx_utility_pixelmap_simple_rotate***

***gx_utility_rectangle_center***

***gx_utility_rectangle_center_find***

***gx_utility_rectangle_combine***

***gx_utility_rectangle_compare***

***gx_utility_rectangle_define***

***gx_utility_rectangle_overlap_detect***

***gx_utility_rectangle_point_detect***

***gx_utility_rectangle_resize***

***gx_utility_rectangle_shift***

***gx_utility_string_to_alphamap***
