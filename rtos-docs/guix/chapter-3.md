---
title: 第 3 章 - GUIX の機能の概要
description: この章では、高パフォーマンスの GUIX ユーザー インターフェイス製品の機能の概要について説明します。
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 53ffc900debd3bfaa1a38d792ddf294b2ce92461
ms.sourcegitcommit: 60ad844b58639d88830f2660ab0c4ff86b92c10f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/07/2021
ms.locfileid: "106550305"
---
# <a name="chapter-3---functional-overview-of-guix"></a><span data-ttu-id="0f5ac-103">第 3 章 - GUIX の機能の概要</span><span class="sxs-lookup"><span data-stu-id="0f5ac-103">Chapter 3 - Functional Overview of GUIX</span></span>

<span data-ttu-id="0f5ac-104">この章では、高パフォーマンスの GUIX ユーザー インターフェイス製品の機能の概要について説明します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-104">This chapter contains a functional overview of the high-performance GUIX user interface product.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="0f5ac-105">実行の概要</span><span class="sxs-lookup"><span data-stu-id="0f5ac-105">Execution Overview</span></span>

<span data-ttu-id="0f5ac-106">GUIX では、イベント ドリブン プログラミング モデルを実装しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-106">GUIX implements an event driven programming model.</span></span> <span data-ttu-id="0f5ac-107">つまり、GUIX フレームワークは主に、GUIX イベント キューにプッシュされたイベントの受信によって起動されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-107">This means that the GUIX framework is primarily driven by the receipt of events pushed into the GUIX event queue.</span></span> <span data-ttu-id="0f5ac-108">これらのイベントの処理は、GUIX システムの初期化中に作成された ThreadX スレッドである GUIX スレッドのコンテキストで実行されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-108">The processing of these events takes place in the context of the GUIX thread, which is a ThreadX thread created during GUIX system initialization.</span></span>

<span data-ttu-id="0f5ac-109">GUIX アプリケーションでは、GUIX API 関数を呼び出してウィンドウと子ウィジェットを作成することによってユーザー インターフェイスを定義し、各ウィンドウまたはウィジェットの種類の色、スタイル、フォント、その他のさまざまな属性を定義するために使用される追加の API 関数を呼び出して、これらのウィジェットの外観をカスタマイズします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-109">GUIX applications define the user interface by calling GUIX API functions to create windows and child widgets, and customize the appearance of these widgets by calling additional API functions used to define colors, styles, fonts, and various other attributes of each window or widget type.</span></span> <span data-ttu-id="0f5ac-110">ユーザー インターフェイス画面の外観を作成するために GUIX Studio を使用している場合は、GUIX API 関数を呼び出してディスプレイを作成するこの作業の多くが GUIX Studio アプリケーションによって自動的に実行されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-110">If you are using GUIX Studio to create the appearance of your user-interface screens, much of this work of calling GUIX API functions to create your display is done for you by the GUIX Studio application.</span></span>

<span data-ttu-id="0f5ac-111">GUIX アプリケーションでは、GUIX イベント キューから取得されたイベントを処理することによって、システム ユーザーや外部のビジネス ロジックと対話します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-111">GUIX applications interact with the system user and with external business logic by handling events retrieved from the GUIX event queue.</span></span>
<span data-ttu-id="0f5ac-112">これらのイベントは通常 GUIX ウィジェットによって生成されますが、外部スレッドでも作成できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-112">These events are usually produced by GUIX widgets, but they can also be created by external threads.</span></span> <span data-ttu-id="0f5ac-113">一般的な GUIX ボタンがプッシュされると、そのボタンによって、そのボタンの親ウィンドウにイベントが送信されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-113">When a typical GUIX button is pushed, that button sends an event to the button’s parent window.</span></span> <span data-ttu-id="0f5ac-114">アプリケーション プログラムでは、ボタン プッシュ イベント用のハンドラーを提供することによって、そのボタンのプッシュに対処します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-114">Your application program will act on that button push by providing a handler for the button push event.</span></span>

<span data-ttu-id="0f5ac-115">追加の GUIX スレッドは多くの場合、入力ドライバーなどのために作成されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-115">Additional GUIX threads are often created for things such as input drivers.</span></span> <span data-ttu-id="0f5ac-116">一般的なタッチ スクリーン入力ドライバーは、メインの GUIX スレッドの外部にあるスタンドアロン スレッドとして実行されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-116">A typical touch screen input driver is executed as a standalone thread external to the main GUIX thread.</span></span> <span data-ttu-id="0f5ac-117">タッチ入力ドライバーでは、イベントを GUIX イベント キューに送信することによってタッチ情報を GUIX スレッドに送信します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-117">The touch input driver sends touch information into the GUIX thread by sending events into the GUIX event queue.</span></span>

<span data-ttu-id="0f5ac-118">アニメーションなどの多くのユーザー インターフェイス操作には正確なタイミング情報が必要なため、GUIX では、簡単で、使いやすいタイマー インターフェイスも実装しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-118">Since many user-interface operations such as animations require accurate timing information, GUIX also implements a simple and easy to use timer interface.</span></span> <span data-ttu-id="0f5ac-119">このタイマー インターフェイスは ThreadX タイマー サービスに基づいて構築されており、システムの起動時に自動的に構成されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-119">This timer interface is built upon the ThreadX timer service, and is configured automatically at system startup.</span></span>

<span data-ttu-id="0f5ac-120">GUIX ソフトウェアの大部分は、ハードウェアのどのような依存関係からも独立しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-120">The vast majority of the GUIX software is independent of any hardware dependencies.</span></span> <span data-ttu-id="0f5ac-121">このフレームワークには、ハードウェア固有の入力ドライバーとハードウェア固有のグラフィックス ドライバーが必要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-121">The framework does require hardware-specific input drivers and hardware-specific graphics drivers.</span></span> <span data-ttu-id="0f5ac-122">これらのハードウェア固有のドライバーが実装される方法の詳細については、後の第 5 章を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-122">The details of how these hardware specific drivers are implemented are deferred to chapter 5.</span></span>

## <a name="initialization"></a><span data-ttu-id="0f5ac-123">初期化</span><span class="sxs-lookup"><span data-stu-id="0f5ac-123">Initialization</span></span> 

<span data-ttu-id="0f5ac-124">サービス ***gx_system_initialize*** は、他のどの GUIX サービスよりも前に呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-124">The service ***gx_system_initialize*** must be called before any other GUIX service is called.</span></span> <span data-ttu-id="0f5ac-125">GUIX システムの初期化は、ThreadX の ***tx_application_define*** ルーチン (初期化コンテキスト) またはアプリケーション スレッドから呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-125">GUIX system initialization can be called from the ThreadX ***tx_application_define*** routine (initialization context) or from application threads.</span></span> <span data-ttu-id="0f5ac-126">***gx_system_initialize*** 関数では、GUIX イベント キューを作成し、GUIX タイマー機能を初期化し、メインの GUIX システム スレッドを作成し、アプリケーションの実行中に GUIX によって管理されるさまざまなデータ構造体を初期化します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-126">The ***gx_system_initialize*** function creates the GUIX event queue, initializes the GUIX timer facility, creates the main GUIX system thread, and initializes various data structures maintained by GUIX during the execution of your application.</span></span>

<span data-ttu-id="0f5ac-127">***gx_system_initialize*** から戻ったら、アプリケーションはディスプレイ、キャンバス、ウィンドウ、ウィジェットを作成し、すべての GUIX オブジェクトのプロパティをカスタマイズする準備が整っています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-127">After ***gx_system_initialize*** returns, the application is ready to create displays, canvases, windows, widgets, and customize the properties of all GUIX objects.</span></span> <span data-ttu-id="0f5ac-128">GUIX オブジェクト作成 API の多くは、***tx_application_define*** またはアプリケーション スレッドから呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-128">Much of the GUIX object creation API can be called from ***tx_application_define*** or from application threads.</span></span>

## <a name="application-interface-calls"></a><span data-ttu-id="0f5ac-129">アプリケーション インターフェイスの呼び出し</span><span class="sxs-lookup"><span data-stu-id="0f5ac-129">Application Interface Calls</span></span> 

<span data-ttu-id="0f5ac-130">アプリケーションからの呼び出しは、主に ***tx_application_define*** (初期化コンテキスト) またはアプリケーション スレッドから実行されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-130">Calls from the application are largely made from ***tx_application_define*** (initialization context) or from application threads.</span></span> <span data-ttu-id="0f5ac-131">どのようなコンテキストから呼び出すことができるかを確認するには、第 4 章で説明されている各 GUIX API の「許可元」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-131">Please see the “Allowed From” section of each GUIX API described in Chapter 4 to determine what context it may be called from.</span></span>

<span data-ttu-id="0f5ac-132">ほとんどの場合、負荷の高いアクティビティの処理は、すべてのイベント処理とウィジェットまたはウィンドウの描画を含め、内部 GUIX スレッドに遅延されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-132">For the most part, processing intensive activities are deferred to the internal GUIX thread, including all event processing and widget/window drawing.</span></span>

<span data-ttu-id="0f5ac-133">GUIX API 関数は、どのスレッドからでも、いつでも呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-133">The GUIX API functions can be called from any thread at any time.</span></span>
<span data-ttu-id="0f5ac-134">ただし、通常は、タイム クリティカルなビジネス ロジックをユーザー インターフェイスのロジックから分離する方が適切なアーキテクチャであると見なされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-134">However it is usually considered to be better architecture to separate your time-critical business logic from your user interface logic.</span></span> <span data-ttu-id="0f5ac-135">ユーザー インターフェイスの描画操作は、表示サイズや CPU パフォーマンスによっては長い時間がかかる場合があるため、通常は、タイム クリティカルなスレッドをその描画操作が完了するまで遅延させたくありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-135">Since the user interface drawing operations can sometimes take a long time depending on your display size and CPU performance, you normally would not want to have time-critical threads delayed waiting for a drawing operation to complete.</span></span>

## <a name="internal-guix-thread"></a><span data-ttu-id="0f5ac-136">内部 GUIX スレッド</span><span class="sxs-lookup"><span data-stu-id="0f5ac-136">Internal GUIX Thread</span></span> 

<span data-ttu-id="0f5ac-137">先に説明したように、GUIX には GUI 処理の大部分を実行する内部スレッドがあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-137">As mentioned, GUIX has an internal thread that performs the bulk of the GUI processing.</span></span> <span data-ttu-id="0f5ac-138">このスレッドは、***gx_system_initialize** _ に続けて _*_gx_system_start_\*\* を呼び出すことによって、アプリケーション ソフトウェアによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-138">This thread is created by the application software by calling ***gx_system_initialize** _ followed by _*_gx_system_start_\*\*.</span></span>

<span data-ttu-id="0f5ac-139">内部 GUIX スレッドの優先度は `#define GX_SYSTEM_THREAD_PRIORITY` によって決定されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-139">The priority of the internal GUIX thread is determined by the `#define GX_SYSTEM_THREAD_PRIORITY`.</span></span> <span data-ttu-id="0f5ac-140">この値の既定値は 16 (中レベルの優先度) ですが、gx_port.h または gx_user.h ヘッダー ファイルでこの値を指定し、既定値をオーバーライドすることによって変更できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-140">This value defaults to 16 (middle priority) but can be modified by specifying this value in the gx_port.h or gx_user.h header file, overriding the default value.</span></span>

<span data-ttu-id="0f5ac-141">GUIX スレッドのタイム スライスも同様に `#define GX_SYSTEM_THREAD_TIMESLICE` によって定義されます。この既定値は 10 ms です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-141">The GUIX thread time slice is similarly defined by the `#define GX_SYSTEM_THREAD_TIMESLICE`, which defaults to the value 10 ms.</span></span>

<span data-ttu-id="0f5ac-142">システム スレッドのスタック サイズは `#define GX_THREAD_STACK_SIZE` (***gx_port.h*** ヘッダー ファイルにあります) によって決定されますが、gx_user.h ヘッダー ファイルでこの値を指定することによってオーバーライドすることもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-142">The stack sie of the system thread is determined by the `#define GX_THREAD_STACK_SIZE`, which is found in the ***gx_port.h*** header file, but can also be overridden by specifying this value in your gx_user.h header file.</span></span>

<span data-ttu-id="0f5ac-143">内部 GUIX スレッドの実行ループは 3 つのアクションで構成されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-143">The internal GUIX thread execution loop is composed of three actions.</span></span>
<span data-ttu-id="0f5ac-144">最初に、GUIX では GUIX イベント キューからイベントを取得し、GUIX ウィンドウおよびウィジェットで処理するためにこれらのイベントをディスパッチします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-144">First, GUIX retrieves events from the GUIX event queue and dispatches those events for processing by the GUIX windows and widgets.</span></span> <span data-ttu-id="0f5ac-145">イベントは通常、定期的なタイマー、タッチ スクリーンやキーパッドなどの入力デバイスのほか、GUIX ウィジェットでユーザー入力を処理するときはそのウィジェット自体によって GUIX イベント キューにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-145">Events are typically pushed into the GUIX event queue by periodic timers, input devices such as a touch screen or keypad, and by GUIX widgets themselves as they process user input.</span></span> <span data-ttu-id="0f5ac-146">次に、すべてのイベントが処理された後、GUIX では画面の更新が必要かどうかを判定し、その場合は、主にダーティとマークされているこれらのウィンドウやウィジェットの描画関数を呼び出すことによって、ディスプレイ グラフィックス データを更新するために必要な処理を実行します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-146">Next, after all events have been processed, GUIX determines if a screen refresh is needed, and if so performs the processing necessary to update the display graphics data, mainly by calling the drawing functions of those windows and widgets which have been marked as dirty.</span></span> <span data-ttu-id="0f5ac-147">最後に、GUIX では、新しい 1 つまたは複数の入力イベントが到着するまで GUIX スレッドを中断します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-147">Finally, GUIX suspends the GUIX thread until a new input event or events arrive.</span></span>

## <a name="event-processing"></a><span data-ttu-id="0f5ac-148">イベント処理</span><span class="sxs-lookup"><span data-stu-id="0f5ac-148">Event Processing</span></span> 

<span data-ttu-id="0f5ac-149">タッチまたはペン入力イベントは、タッチまたはペン入力のピクセル位置の下にある最上位のウィンドウまたはウィジェットを決定し、そのウィンドウまたはウィジェットのイベント処理関数を呼び出すことによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-149">Touch or pen input events are processed by determining the top-most window or widget beneath the touch or pen input pixel position and calling that window/widget’s event processing function.</span></span> <span data-ttu-id="0f5ac-150">ウィジェットは、ペン入力イベントを認識している場合、そのウィジェットの種類に合わせてイベントを処理します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-150">If the widget understands pen input events, it will process the event as appropriate for that widget type.</span></span> <span data-ttu-id="0f5ac-151">そうでない場合、最上位のウィジェットは、タッチまたはペン入力イベントを処理のためにそのウィジェットの親に渡します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-151">If not, the top-most widget will pass the touch or pen input event to the widget's parent for processing.</span></span> <span data-ttu-id="0f5ac-152">このチェーンの上方へのイベントの受け渡しは、そのイベントが処理されるか、またはそのイベントがルート ウィンドウに到達する (この場合、そのイベントは破棄されます) まで続行されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-152">This passing of the event up the chain continues until either the event is handled or the event arrives at the root window, in which case the event is discarded.</span></span>

<span data-ttu-id="0f5ac-153">キーパッド イベントは、入力フォーカスのあるウィンドウまたはウィジェットに送信されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-153">Keypad events are sent to the window/widget that has input focus.</span></span> <span data-ttu-id="0f5ac-154">入力フォーカスの状態は、GUIX gx_system コンポーネントによって管理されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-154">Input focus status is maintained by the GUIX gx_system component.</span></span>

<span data-ttu-id="0f5ac-155">タイマー イベントは常に、タイマーを所有するウィンドウまたはウィジェットに処理のためにディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-155">Timer events are always dispatched to the window or widget that owns the timer for processing.</span></span>

<span data-ttu-id="0f5ac-156">内部的に生成されたイベント (ボタン クリック イベントやスライダー値変更イベントなど) は常に、イベントを生成しているウィジェットの親に送信されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-156">Internally generated events, such as button click events or slider value change events, are always sent to the parent of the widget generating the event.</span></span> <span data-ttu-id="0f5ac-157">その親によってイベントが処理されない場合、そのイベントは、タッチまたはペン入力イベントと同様にチェーンの上方に渡されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-157">If the parent does not process the event, it is passed up the chain similar to touch or pen input events.</span></span>

## <a name="drawing"></a><span data-ttu-id="0f5ac-158">描画</span><span class="sxs-lookup"><span data-stu-id="0f5ac-158">Drawing</span></span> 

<span data-ttu-id="0f5ac-159">すべてのイベント処理が完了すると、GUIX 内部スレッドではディスプレイの更新が必要かどうかを判定し、その場合は、適切なウィンドウまたはウィジェット描画関数が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-159">Once all the event processing is complete, the GUIX internal thread determines if any display update is needed and if so the appropriate window/widget drawing functions are called.</span></span> <span data-ttu-id="0f5ac-160">描画が完了すると、GUIX 内部スレッドでは単純に、そのイベント キュー上で次の処理対象 GUIX イベントを待ちます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-160">When drawing is complete, the GUIX internal thread simply waits on its event queue for the next GUIX event to process.</span></span>

<span data-ttu-id="0f5ac-161">GUIX では、ウィジェットやキャンバスごとに再描画する必要のある領域である "*ダーティ領域*" の概念を実装しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-161">GUIX implements the concept of *dirty areas*, which are areas that need to be re-drawn, for each widget and canvas.</span></span> <span data-ttu-id="0f5ac-162">ウィジェットは、以前にダーティとマークされている領域にしか描画できません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-162">A widget can only draw to areas that have previously been marked as dirty.</span></span> <span data-ttu-id="0f5ac-163">ウィジェット描画関数が呼び出されると、すべての描画操作が、以前に定義されたダーティな四角形に内部的にクリップされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-163">When a widget drawing function is called, all drawing operations are internally clipped to the previously defined dirty rectangle.</span></span>
<span data-ttu-id="0f5ac-164">この領域の外部に描画しようとしても無視されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-164">Attempts to draw outside of this area are ignored.</span></span>

<span data-ttu-id="0f5ac-165">ウィジェットとウィンドウは、API 関数 ***gx_system_dirty_mark*** を呼び出すことによって、それ自体をダーティとマークします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-165">Widgets and windows mark themselves as dirty by calling the API function ***gx_system_dirty_mark***.</span></span> <span data-ttu-id="0f5ac-166">この関数では、ウィジェットまたはウィンドウ全体を再描画が必要としてマークします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-166">This function marks the entire widget or window as needing to be redrawn.</span></span> <span data-ttu-id="0f5ac-167">2 番目の関数である ***gx_system_dirty_partial_add*** は、ウィンドウまたはウィジェットの一部のみをダーティとマークするための別の方法として呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-167">A second function, ***gx_system_dirty_partial_add***, can be invoked as an alternative to mark only a portion of a window or widget as dirty.</span></span>

<span data-ttu-id="0f5ac-168">ウィジェットをダーティとマークした後、これらのウィジェットをすべての入力イベントが処理されたときにのみ再描画するというこのモデルは、"*遅延描画*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-168">This model of marking widgets as dirty and then redrawing those widgets only when all input events have been processed is referred to as *deferred drawing*.</span></span> <span data-ttu-id="0f5ac-169">GUIX 遅延描画アルゴリズムとダーティ リストのメンテナンスは、描画の効率を向上させるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-169">The GUIX deferred drawing algorithm and dirty list maintenance is designed to improve drawing efficiency.</span></span> <span data-ttu-id="0f5ac-170">描画操作は通常、コストが高いため、GUIX では不必要な描画を可能な限り防ごうとします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-170">Since drawing operations are typically expensive, GUIX works hard to prevent unnecessary drawing.</span></span>

<span data-ttu-id="0f5ac-171">描画は、GUIX "*キャンバス*" に対して行われます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-171">Drawing is done to a GUIX *canvas*.</span></span> <span data-ttu-id="0f5ac-172">キャンバスは、グラフィックス データを保持するために予約されているメモリ領域です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-172">A canvas is a memory area reserved to hold graphics data.</span></span> <span data-ttu-id="0f5ac-173">キャンバスは、システム アーキテクチャやメモリ制約に応じて、ハードウェア フレーム バッファーに直接リンクされている場合といない場合があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-173">A canvas may or may not be directly linked to the hardware frame buffer, depending on the system architecture and memory constraints.</span></span> <span data-ttu-id="0f5ac-174">何らかの描画を実行するには、まず ***gx_canvas_drawing_initiate*** API 関数を呼び出すことによって、キャンバスを描画用に開いておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-174">Before any drawing can occur, a canvas must first be opened for drawing by calling the ***gx_canvas_drawing_initiate*** API function.</span></span> <span data-ttu-id="0f5ac-175">この API では描画用のキャンバスを準備し、現在の "*描画コンテキスト*" を確立します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-175">This API prepares a canvas for drawing and established the current *drawing context*.</span></span> <span data-ttu-id="0f5ac-176">GUIX がシステム キャンバスの更新を実行すると、そのキャンバスが描画用に開かれ、ウィジェット レベルの描画 API が呼び出される前に描画コンテキストが確立されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-176">When GUIX performs a system canvas refresh, the canvas is opened for drawing and the drawing context established before the widget-level drawing APIs are invoked.</span></span> <span data-ttu-id="0f5ac-177">そのため、ウィジェットがウィジェット描画関数内でキャンバスへの描画を開始する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-177">Therefore widgets do not need to initiate drawing on a canvas within the widget drawing function.</span></span>

<span data-ttu-id="0f5ac-178">ただし、アプリケーションが標準の GUIX 遅延描画アルゴリズムのフローの外部でキャンバスへの即時描画を実行しようとする場合、そのアプリケーションでは他のどの描画 API 関数よりも前に ***gx_canvas_drawing_initiate*** を直接呼び出す必要があり、即時描画が完了したら ***gx_canvas_drawing_complete*** を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-178">However, if an application desires to perform immediate drawing to a canvas, outside the flow of the standard GUIX deferred drawing algorithm, the application must directly invoke the ***gx_canvas_drawing_initiate*** prior to calling any other drawing API functions, and must call ***gx_canvas_drawing_complete*** once the immediate drawing has been completed.</span></span>

## <a name="user-input"></a><span data-ttu-id="0f5ac-179">ユーザー入力</span><span class="sxs-lookup"><span data-stu-id="0f5ac-179">User Input</span></span> 

<span data-ttu-id="0f5ac-180">GUIX では、イベントの種類が事前に定義されたタッチ スクリーン、マウス、キーボード デバイスをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-180">GUIX supports touch screen, mouse, and keyboard devices with predefined event types.</span></span> <span data-ttu-id="0f5ac-181">カスタム イベントの種類を定義するか、またはカスタム入力デバイスを定義済みのイベントの種類にマップすることによって、追加の入力デバイスを利用できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-181">Additional input devices can be utilized by defining custom event types, or by mapping the custom input device to the predefined event types.</span></span>

<span data-ttu-id="0f5ac-182">これらのデバイスに関連付けられているアクションは、内部 GUIX スレッドによって処理されるイベントに変換されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-182">Actions associated with these devices are translated into events that are processed by the internal GUIX thread.</span></span> <span data-ttu-id="0f5ac-183">タッチ スクリーンをサポートするために記述されたドライバー レベルのソフトウェアでは、ペンダウン、ペンアップ、ペンドラッグ操作のイベントを準備して GUIX イベント キューに送信する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-183">Driver level software written to support a touch screen must prepare and send to the GUIX event queue events for pen-down, pen-up, and pen-drag operations.</span></span> <span data-ttu-id="0f5ac-184">同様に、キーパッド入力ドライバーでは、キー押下およびキー リリース入力のイベントを生成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-184">Similarly a keypad input driver must generate events for key press and key release input.</span></span>

## <a name="modal-dialog-execution"></a><span data-ttu-id="0f5ac-185">モーダル ダイアログ実行</span><span class="sxs-lookup"><span data-stu-id="0f5ac-185">Modal Dialog Execution</span></span> 

<span data-ttu-id="0f5ac-186">モーダル ダイアログ実行とは、他の GUIX ウィンドウまたはウィジェットでユーザー入力を受信できるようにするには何らかの方法で閉じる必要があるウィンドウをユーザーに表示することを指します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-186">Modal dialog execution refers to presenting a window to the user that must be closed in some way before any other GUIX windows or widgets can receive user input.</span></span> <span data-ttu-id="0f5ac-187">モーダル ダイアログでは、タッチまたはマウス入力イベントの x、y 位置には関係なく、ダイアログ ウィンドウが表示されている間にすべてのユーザー入力をキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-187">Modal dialogs capture all user input while the dialog window is displayed, regardless of the x,y position of touch or mouse input events.</span></span>

<span data-ttu-id="0f5ac-188">モーダル ダイアログは、まず ***gx_window_create*** を呼び出して通常の方法でウィンドウを作成し、次に GUIX API 関数 ***gx_window_execute*** を呼び出すことにより、アプリケーション ソフトウェアによってトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-188">Modal dialogs are triggered by the application software by first creating the window in the normal way by calling ***gx_window_create***, and then calling the GUIX API function ***gx_window_execute.***</span></span>

<span data-ttu-id="0f5ac-189">***gx_window_execute*** 関数が呼び出されると、GUIX はローカルのイベント処理ループに入ります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-189">When the ***gx_window_execute*** function is called, GUIX enters a local event processing loop.</span></span> <span data-ttu-id="0f5ac-190">***gx_window_execute*** 関数は、ユーザー入力によって、または ***gx_window_close*** を呼び出すことによってダイアログ ウィンドウが閉じられるまで呼び出し元に戻りません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-190">The ***gx_window_execute*** function does not return to the caller until the dialog window is closed, either by user input or by calling ***gx_window_close***.</span></span> <span data-ttu-id="0f5ac-191">このため、GUIX 内部スレッド以外のどのスレッドからも ***gx_window_execute*** 関数を呼び出さないようにすることが非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-191">For this reason, it is very important never to call the ***gx_window_execute*** function from any thread other than the GUIX internal thread.</span></span>

## <a name="periodic-processing"></a><span data-ttu-id="0f5ac-192">定期的な処理</span><span class="sxs-lookup"><span data-stu-id="0f5ac-192">Periodic Processing</span></span> 

<span data-ttu-id="0f5ac-193">表示効果、スプライト アニメーション、アプリケーションの定期的な要求に対するサポートなどを提供するために、GUIX では 1 つの ThreadX タイマーを使用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-193">In order to provide display effects, sprite animation, and support for application periodic requests, GUIX uses one ThreadX timer.</span></span> <span data-ttu-id="0f5ac-194">この 1 つのタイマーは、時間に関連する GUIX のすべてのニーズを起動するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-194">This single timer is used to drive all GUIX time-related needs.</span></span> <span data-ttu-id="0f5ac-195">既定では、GUIX の内部タイマーの処理の頻度は、**_gx_api.h_** で定義されている定数 **GX_SYSTEM_TIMER_MS** を使用して 20ms に設定されます。ただし、この定数が以前に gx_port.h または gx_user.h ヘッダーで定義されている場合を除きます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-195">By default, the frequency for the GUIX internal timer processing is set to 20ms via the constant **GX_SYSTEM_TIMER_MS**, which is defined in **_gx_api.h_**, unless the constant is previously defined in gx_port.h or gx_user.h header.</span></span> <span data-ttu-id="0f5ac-196">この既定の頻度は、GUIX ライブラリを構築するときにコンパイル オプションを使用してアプリケーションで、または ***gx_user.h*** で明示的に再定義することによって変更できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-196">The default frequency may be changed by the application via a compilation option when building the GUIX library or by explicitly redefining it in ***gx_user.h***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0f5ac-197">GUIX タイマーの頻度が RTOS タイマー刻みで表され、定数 **GX_SYSTEM_TIMER_TICKS** によって定義されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-197">Note that the GUIX timer frequency is expressed in RTOS timer ticks, and is defined by the constant **GX_SYSTEM_TIMER_TICKS**.</span></span> <span data-ttu-id="0f5ac-198">**GX_SYSTEM_TIMER_TICKS** の値は、**GX_SYSTEM_TIMER_MS** と **TX_TIMER_TICKS_PER_SECOND** を使用して計算されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-198">The value of **GX_SYSTEM_TIMER_TICKS** is calculated using **GX_SYSTEM_TIMER_MS** and **TX_TIMER_TICKS_PER_SECOND**.</span></span> <span data-ttu-id="0f5ac-199">ユーザーは、これらの値のいずれかを ***gx_port.h** _ または _ *_gx_user.h_** で再定義して GUIX タイマーの頻度と解像度を調整できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-199">The user can re-define any of these values in the ***gx_port.h** _ or _ *_gx_user.h_** to adjust the GUIX timer frequency and resolution.</span></span>

## <a name="display-driver"></a><span data-ttu-id="0f5ac-200">ディスプレイ ドライバー</span><span class="sxs-lookup"><span data-stu-id="0f5ac-200">Display Driver</span></span> 

<span data-ttu-id="0f5ac-201">ディスプレイ ドライバーは、GUIX コア コードに一連の描画関数を提供する処理を担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-201">Display drivers are responsible for providing a set of drawing functions to the core GUIX code.</span></span> <span data-ttu-id="0f5ac-202">これらの各描画関数の実装はドライバーによって決定され、可能な場合、この実装ではハードウェア アクセラレータのサポートを利用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-202">The implementation of each of these drawing functions is determined by the driver, and when possible the implementation will leverage hardware acceleration support.</span></span> <span data-ttu-id="0f5ac-203">一般に、描画関数は、メモリ バッファーにピクセル データを書き込むことによって機能します。このバッファーは物理フレーム バッファー、またはドライバーのアーキテクチャによってはセカンダリ バッファーである場合があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-203">In general the drawing function works by writing pixel data to a memory buffer, which may be the physical frame buffer or it may be a secondary buffer depending on the driver architecture.</span></span> <span data-ttu-id="0f5ac-204">多くのドライバーでは 2 つのフレーム バッファーを使用するダブル バッファリングを実装し、これらのバッファーはバッファー切り替え関数を呼び出すことによって切り替えられます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-204">Many drivers implement double buffering using two frame buffers, and these buffers are toggled by invoking the buffer toggle function.</span></span> <span data-ttu-id="0f5ac-205">GUIX では、これらの関数を適切な時刻に内部的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-205">GUIX calls these functions internally at the appropriate times.</span></span> <span data-ttu-id="0f5ac-206">メモリに制約のあるシステムの場合は、描画関数が 1 つのメモリ フレーム バッファーにしか書き込めないことがあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-206">For memory constrained systems, the drawing functions may only write to a single memory frame buffer.</span></span>

<span data-ttu-id="0f5ac-207">GUIX では、低レベルの各描画関数の既定のソフトウェア実装を、すべてのサポート色深度および形式で提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-207">GUIX provides default software implementations of each low-level drawing function at every support color depth and format.</span></span> <span data-ttu-id="0f5ac-208">これらの関数は、**GX_DISPLAY** 構造体内に保持されている関数ポインター経由で呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-208">These functions are invoked via function pointers maintained within the **GX_DISPLAY** structure.</span></span> <span data-ttu-id="0f5ac-209">ハードウェア固有のドライバーが作成されると、このドライバーでは通常、これらの関数ポインターのいくつかをターゲット ハードウェアに固有の関数で上書きします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-209">When hardware-specific drivers are created, they typically will overwrite some number of these function pointers with functions that are specific to the target hardware.</span></span>

<span data-ttu-id="0f5ac-210">標準的なハードウェア ディスプレイ ドライバーは、まず、必要な色深度および形式に対する既定の GUIX ディスプレイ ドライバーを作成することによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-210">A typical hardware display driver is implemented by first creating the default GUIX display driver for the required color depth and format.</span></span>
<span data-ttu-id="0f5ac-211">次に、このハードウェア ドライバーでは、特定のハードウェア実装のために最適化またはカスタマイズする必要のある関数を置き換えます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-211">Then the hardware driver will replace those functions that need to be optimized or customized for the particular hardware implementation.</span></span>

<span data-ttu-id="0f5ac-212">GUIX では、1 bpp モノクロから 32 bpp a:r:g:b 形式までのピクセル色形式をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-212">GUIX support pixel color formats ranging from 1-bpp monochrome to 32-bpp a:r:g:b format.</span></span> <span data-ttu-id="0f5ac-213">GUIX ではまた、r:g:b と b:g:r のバイト順、パックされたピクセルとワード単位で揃えたピクセルの形式、アルファ チャネルなど、幅広い各色深度カテゴリ内の多くのバリエーションもサポートしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-213">GUIX also supports many variations within each broad color-depth category, such as r:g:b versus b:g:r byte order, packed pixel versus word-aligned pixel formats, and alpha channels.</span></span> <span data-ttu-id="0f5ac-214">現在、25 の個別の色形式がサポートされていますが、このリストはハードウェア ベンダーが新しいバリエーションを提供するにつれて増えていきます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-214">There are currently 25 distinct color formats supported, but this list grows as hardware vendors deliver new variations.</span></span>

## <a name="display-memory-architectures"></a><span data-ttu-id="0f5ac-215">ディスプレイ メモリ アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="0f5ac-215">Display Memory Architectures</span></span>

<span data-ttu-id="0f5ac-216">さまざまなハードウェア ターゲットやディスプレイでは、ターゲットのメモリ制約やアプリケーションの機能要件に応じて、多様なディスプレイ メモリ アーキテクチャが利用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-216">Various hardware targets and displays utilize a variety of different display memory architectures, depending on the memory constraints of the target and the functionality requirements of the application.</span></span> <span data-ttu-id="0f5ac-217">ここでは、いくつかの一般的なメモリ アーキテクチャの概要を、各アーキテクチャの簡単な説明と共に示します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-217">We will outline some of the common memory architectures here with a brief description of each.</span></span>

<span data-ttu-id="0f5ac-218">モデル 1) フレーム バッファーなし、グラフィックス データを外部 GRAM に保持:</span><span class="sxs-lookup"><span data-stu-id="0f5ac-218">Model 1) No frame buffer, graphics data held in external GRAM:</span></span>

![フレーム バッファーなし、グラフィックス データを外部 GRAM に保持](./media/guix/user-guide/no-frame-buffer.png)

<span data-ttu-id="0f5ac-220">このモデルでは、CPU にローカルなメモリ内にフレーム バッファー用のメモリは存在しません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-220">In the model above, no memory for a frame buffer exists in memory local to the CPU.</span></span> <span data-ttu-id="0f5ac-221">すべてのグラフィックス データが、ディスプレイ自体に組み込まれた外部 GRAM に格納されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-221">All graphics data is stored in an external GRAM which is incorporated into the display itself.</span></span> <span data-ttu-id="0f5ac-222">外部 GRAM へのインターフェイスはパラレルでもシリアルでもかまいません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-222">The interface to the external GRAM can be parallel or serial.</span></span> <span data-ttu-id="0f5ac-223">この種類のアーキテクチャは非常に低コストですが、グラフィックス データが更新されたときに望ましくないティアリング効果が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-223">This type of architecture is very low cost; however it can exhibit unwanted tearing effect when the graphics data is updated.</span></span>

<span data-ttu-id="0f5ac-224">モデル 2) 1 つのローカル フレーム バッファー:</span><span class="sxs-lookup"><span data-stu-id="0f5ac-224">Model 2) One local frame buffer:</span></span>

![1 つのローカル フレーム バッファー](./media/guix/user-guide/one-local-frame-buffer.png)

<span data-ttu-id="0f5ac-226">このモデルでは、グラフィックス データ用のメモリは、CPU から直接アクセスできるランダム アクセス メモリから割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-226">In this model, memory for the graphics data is allocated from a random-access memory that is directly accessible the CPU.</span></span> <span data-ttu-id="0f5ac-227">グラフィックス データを (タイミング信号と共に) ローカル メモリからディスプレイに繰り返し転送するには、専用のハードウェアが存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-227">Dedicated hardware must be present to repeatedly transmit the graphics data (along with timing signals) from the local memory to the display.</span></span> <span data-ttu-id="0f5ac-228">このモデルは、グラフィックス メモリが CPU で使用できるローカル SRAM または DRAM のブロックである点でモデル 1 とは異なります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-228">This model differs from model 1 in that the graphics memory is a block of the local SRAM or DRAM available to the CPU.</span></span> <span data-ttu-id="0f5ac-229">これは、スタックやプログラム変数が存在しているのと同じメモリである可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-229">This may be the same memory in which stack and program variables live.</span></span>

<span data-ttu-id="0f5ac-230">モデル 3) ローカル フレーム バッファー + 外部 GRAM:</span><span class="sxs-lookup"><span data-stu-id="0f5ac-230">Model 3) Local frame buffer + external GRAM:</span></span>

![ローカル フレーム バッファー + 外部 GRAM](./media/guix/user-guide/local-frame-buffer-external-gram.png)

<span data-ttu-id="0f5ac-232">モデル 3 は、最初の 2 つの組み合わせです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-232">Model 3 is a combination of the first two.</span></span> <span data-ttu-id="0f5ac-233">このモデルでは、1 つのフレーム バッファーを保持するための十分なローカル メモリが存在します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-233">In this model, sufficient local memory exists to hold one frame buffer.</span></span> <span data-ttu-id="0f5ac-234">さらに、ディスプレイ デバイスが外部 GRAM を提供し、GRAM で提供されるデータを使用してそれ自体を自動的に更新します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-234">In addition, the display device provides an external GRAM and automatically refreshes itself using the data provided in the GRAM.</span></span> <span data-ttu-id="0f5ac-235">このアーキテクチャでは、ローカル フレーム バッファーの変更された部分を (多くの場合は、オンボード DMA チャネルを利用して) 1 回のブロック転送で外部 GRAM に転送できるため、更新の効率が向上するというメリットがあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-235">This architecture benefits from improved update efficiency because we can transfer the modified portion of the local frame buffer to the external GRAM in one block transfer, often utilizing onboard DMA channels.</span></span> <span data-ttu-id="0f5ac-236">このモデルではまた、完成したグラフィックス コンテンツのみが外部 GRAM にコピーされるため、最初の 2 つのモデルのどちらにも存在する可能性があるティアリングやちらつきも解消されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-236">This model also eliminates the tearing and flicker that can be present in either of the first two models, because only completed graphics contents is copied to the external GRAM.</span></span>

<span data-ttu-id="0f5ac-237">モデル 4) ピンポン フレーム バッファー:</span><span class="sxs-lookup"><span data-stu-id="0f5ac-237">Model 4) Ping-pong frame buffers:</span></span>

![ピンポン フレーム バッファー](./media/guix/user-guide/ping-pong-frame-buffers.png)

<span data-ttu-id="0f5ac-239">モデル 4 では、2 つのローカル フレーム バッファーを提供するための十分なメモリが存在します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-239">In model 4, sufficient memory is present to provide two local frame buffers.</span></span> <span data-ttu-id="0f5ac-240">この場合、GUIX では 1 つのフレーム バッファーをアクティブなフレーム バッファーとして、もう一方を作業用フレーム バッファーとして扱います。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-240">In this case, GUIX treats one frame buffer as the active frame buffer, and the other as the working frame buffer.</span></span> <span data-ttu-id="0f5ac-241">ディスプレイの更新または描画操作が進行中のとき、それは作業用バッファーで実行されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-241">When a display update or drawing operation is in progress, it takes place in the working buffer.</span></span> <span data-ttu-id="0f5ac-242">描画操作が完了すると、バッファーが切り替えられ、作業用バッファーがアクティブなバッファーになり、アクティブなバッファーが作業用バッファーになります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-242">When the drawing operation completes, the buffers are toggled, and the working buffer becomes the active buffer and the active buffer becomes the working buffer.</span></span> <span data-ttu-id="0f5ac-243">このモデルではまた、バッファーが 1 つのシステムで観察される可能性がある画面のちらつきやティアリングも解消されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-243">This model also eliminates screen flicker and tearing that can be observed in a single buffered system.</span></span>

<span data-ttu-id="0f5ac-244">モデル 5) キャンバス合成を使用したピンポン バッファー:</span><span class="sxs-lookup"><span data-stu-id="0f5ac-244">Model 5) Ping-pong buffers with canvas compositing:</span></span>

![キャンバス合成を使用したピンポン バッファー](./media/guix/user-guide/ping-pong-buffers-canvas-composting.png)

<span data-ttu-id="0f5ac-246">モデル 5 では、使用可能なメモリの上限まで、任意の数のキャンバスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-246">In model 5, any number of canvases can be created, up to the limits of available memory.</span></span> <span data-ttu-id="0f5ac-247">アプリケーションでの定義に従ってキャンバスをオーバーレイまたはブレンドすることにより、キャンバス合成を作成できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-247">The canvases can be overlaid or blended together as defined by the application to create the canvas composite.</span></span> <span data-ttu-id="0f5ac-248">画面の更新操作の後に新しい合成が作成されると、標準のピンポン バッファー アーキテクチャと同じ操作で、アクティブな合成バッファーと作業用の合成バッファーが切り替えられます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-248">When a new composite is created after a screen refresh operation, the active and working composite buffers are toggled in an operation identical to the standard ping-pong buffer architecture.</span></span> <span data-ttu-id="0f5ac-249">モデル 5 では、キャンバスを最終的な出力の合成にブレンドすることによって、画面のフェードおよびブレンド操作を実行する機能が追加されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-249">Model 5 adds the ability to perform screen fade and blending operations by blending the canvases into the final output composite.</span></span>

<span data-ttu-id="0f5ac-250">モデル 6) 外部 GRAM を使用したキャンバス合成:</span><span class="sxs-lookup"><span data-stu-id="0f5ac-250">Model 6) Canvas compositing with external GRAM:</span></span>

![外部 GRAM を使用したキャンバス合成](./media/guix/user-guide/canvas-compositing-external-gram.png)

<span data-ttu-id="0f5ac-252">モデル 6 は、モデル 5 に対する若干のバリエーションです。ここでは、1 つの合成バッファーのみが必要とされ、その合成バッファーが外部 GRAM に転送されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-252">Model 6 is a slight variation on Model 5, in which only one composite buffer is required and the composite buffer is then transferred to external GRAM.</span></span> <span data-ttu-id="0f5ac-253">このモデルではまた、全画面表示のブレンドとオーバーレイもサポートされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-253">This model also supports full screen blending and overlays.</span></span>

## <a name="string-encoding"></a><span data-ttu-id="0f5ac-254">文字列エンコード</span><span class="sxs-lookup"><span data-stu-id="0f5ac-254">String Encoding</span></span> 

<span data-ttu-id="0f5ac-255">GUIX では、既定では UTF8 形式の文字列エンコードをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-255">GUIX by default supports UTF8 format string encoding.</span></span> <span data-ttu-id="0f5ac-256">UTF8 文字列エンコードのサポートは、***gx_user.h*** ヘッダー ファイルで **GX_DISABLE_UTF8_SUPPORT** を定義することによって無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-256">Support for UTF8 string encoding can be disabled by defining **GX_DISABLE_UTF8_SUPPORT** in the ***gx_user.h*** header file.</span></span> <span data-ttu-id="0f5ac-257">UTF8 エンコードが無効になっている場合、GUIX では、標準の 8 ビット ASCII に加えてラテン-1 コード ページ文字エンコードのみを内部的に使用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-257">If UTF8 encoding is disabled, GUIX will internally use only standard 8-bit ASCII plus Latin-1 code page character encoding.</span></span> <span data-ttu-id="0f5ac-258">UTF8 文字列エンコードを無効にすると、GUIX ライブラリの占有領域がわずかに小さくなり、文字列処理やテキスト描画関数のランタイム実行がわずかに高速になります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-258">Disabling UTF8 string encoding results in a slightly smaller GUIX library footprint and slightly faster runtime execution of string handling and text drawing functions.</span></span>

<span data-ttu-id="0f5ac-259">UTF8 文字列エンコードには、次の特徴があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-259">UTF8 string encoding has the following traits:</span></span>

  - <span data-ttu-id="0f5ac-260">ASCII 文字列に標準の 7 ビット ASCII エンコードより大きな記憶域スペースは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-260">ASCII strings take no more storage space than standard 7-bit ASCII encoding.</span></span>

  - <span data-ttu-id="0f5ac-261">ほとんどの ANSI-C 文字列関数は、変更なしで UTF8 文字列エンコードで動作します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-261">Most ANSI-C string functions work with UTF8 string encoding without modification.</span></span>

<span data-ttu-id="0f5ac-262">世界中のすべてのアクティブな文字セット (漢字文字セットを含む) は、UTF8 文字列エンコードを使用して表すことができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-262">All active character sets in the world, including Kanji character sets, can be represented using UTF8 string encoding.</span></span>

### <a name="static-and-dynamic-strings"></a><span data-ttu-id="0f5ac-263">静的文字列と動的文字列</span><span class="sxs-lookup"><span data-stu-id="0f5ac-263">Static and Dynamic Strings</span></span> 

<span data-ttu-id="0f5ac-264">テキスト表示をサポートする GUIX ウィジェットに割り当てられた文字列は、通常は、後で説明されている GUIX 文字列テーブルの一部として定数ストレージに配置される静的に定義された文字列定数である場合と、***sprintf** _ や _*_gx_utility_ltoa_\*\* などのサービスを使用して実行時に生成される文字列である動的に定義された文字列である場合があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-264">The strings assigned to your GUIX widgets which support text display can be statically defined string constants, which are normally placed in constant storage as part of the GUIX String table described below, and dynamically defined strings, which are strings generated at runtime using services such as ***sprintf** _ or _*_gx_utility_ltoa_\*\*.</span></span>

<span data-ttu-id="0f5ac-265">動的文字列の例には、GUIX プロンプト ウィジェットに数字として表示される値や、ユーザーの場所と書式設定に基づいて動的に書式設定された "時刻/日付" 文字列などが含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-265">Examples of dynamic strings might include a value displayed as a number within a GUIX prompt widget, or a “time / date” string which is dynamically formatted based on the user’s location and format preferences.</span></span> <span data-ttu-id="0f5ac-266">**GX_PROMPT** または **GX_TEXT_BUTTON ウィジェット** などの GUIX ウィジェットに割り当てられる文字列を実行時に作成する場合は、ランタイムで生成されるこれらの文字列 (</span><span class="sxs-lookup"><span data-stu-id="0f5ac-266">If you create strings at runtime which will be assigned to GUIX widgets such as **GX_PROMPT** or **GX_TEXT_BUTTON widgets**, you must choose to either statically allocate the storage for these runtime generated strings (i.e</span></span>
<span data-ttu-id="0f5ac-267">グローバルな文字配列) 用のストレージを静的に割り当てることを選択する必要があります。あるいは、動的メモリ アロケーター関数を定義してインストールし、割り当てられたテキスト文字列のプライベート コピーを作成するようこれらのウィジェットに指示する **GX_STYLE_TEXT_COPY** スタイルを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-267">global character arrays), or you can define and install a dynamic memory allocator function and use the **GX_STYLE_TEXT_COPY** style, which instructs those widgets to create a private copy of text strings assigned.</span></span>

<span data-ttu-id="0f5ac-268">一時ストレージ (自動文字配列など) を使用して、動的に生成される文字列を保持した後、この文字列を **GX_STYLE_TEXT_COPY** スタイルが設定されていないウィジェットに割り当てることはプログラミング エラーです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-268">It is a programming error to use temporary storage, such as an automatic character array, to hold a dynamically generated string and then assign this string to a widget that does not have the **GX_STYLE_TEXT_COPY** style.</span></span> <span data-ttu-id="0f5ac-269">このスタイルが有効になっていない場合、このウィジェットでは単純に、指定された文字列ポインターをコピーします。その文字列データは静的に割り当てる必要があります。そうしないと、ウィジェット文字列ポインターがガベージ データを指し、予測不可能な結果が生成される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-269">When this style is not enabled, the widget simply copies the provided string pointer, and the string data must be statically allocated or the widget string pointer will likely end up pointing at garbage data producing unpredictable results.</span></span>

### <a name="passing-gx_string-arguments"></a><span data-ttu-id="0f5ac-270">GX_STRING 引数の受け渡し</span><span class="sxs-lookup"><span data-stu-id="0f5ac-270">Passing GX_STRING arguments</span></span> 

<span data-ttu-id="0f5ac-271">GX_STRING パラメーターを受け付ける GUIX API 関数では、常に **GX_STRING.gx_string_ptr** フィールドによって指し示されている文字列の長さが **GX_STRING.gx_string_length** フィールドの値に一致していることを確認します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-271">The GUIX API functions which accept a GX_STRING parameter always verify that the length of the string pointed to by the **GX_STRING.gx_string_ptr** field match the value of the **GX_STRING.gx_string_length** field.</span></span> <span data-ttu-id="0f5ac-272">これらの 2 つのフィールドに整合性がない場合は、**GX_INVALID_STRING_LENGTH** エラーが返され、呼び出された API は文字列の割り当てを受け付けずに戻ります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-272">If the two fields are not consistent, a **GX_INVALID_STRING_LENGTH** error is returned and the API called returns without accepting the string assignment.</span></span>

<span data-ttu-id="0f5ac-273">安全性を考慮して、GUIX ソフトウェアでは、***strlen** _ や _*_strcpy_\*\* などの標準の C 文字列関数を決して内部的に使用しません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-273">For safety considerations the GUIX software never internally uses the standard C string functions such as ***strlen** _ or _*_strcpy_\*\*.</span></span> <span data-ttu-id="0f5ac-274">これらの関数は、文字列データが動的に取得された場合、悪意のある攻撃を受けやすいことが知られています。これは多くの場合、接続されているアプリケーションで発生します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-274">These functions have been known to be susceptible to malicious attacks when string data is acquired dynamically which is often the case with connected applications.</span></span>

<span data-ttu-id="0f5ac-275">リリース 5.6 より前の GUIX ライブラリ リリースでは、パラメーターとして (`GX_CONST GX_CHAR *text`) を受け付ける API 関数が定義されていました。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-275">GUIX library releases prior to release 5.6 defined API functions which accepted (`GX_CONST GX_CHAR *text`) as a parameter.</span></span> <span data-ttu-id="0f5ac-276">下位互換性のために引き続きサポートされていますが、これらの関数は廃止され、入力パラメーターとして (`GX_CONST GX_STRING *string`) を受け付ける、推奨される API 関数に置き換えられています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-276">These functions, while still supported for backwards compatibility, have been obsoleted and replaced by the preferred API functions which accept (`GX_CONST GX_STRING *string`) as an input parameter.</span></span>

<span data-ttu-id="0f5ac-277">既定では、非推奨のテキスト処理 API が有効になっています。これにより、以前に記述されたすべてのアプリケーションを、GUIX ライブラリへの最新の更新プログラムでクリーンにビルドできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-277">By default, the deprecated text handling API is enabled allowing all previously written applications to build cleanly with the latest updates to the GUIX library.</span></span> <span data-ttu-id="0f5ac-278">この非推奨のテキスト処理 API を無効にするには、**_gx_user.h_ *_ ヘッダー ファイルに定義 **GX_DISABLE_DEPRECATED_STRING_API** を追加する必要があります。すべての新しいアプリケーションで _* GX_DISABLE_DEPRECATED_STRING_API** を定義し、置き換え後の API 関数のみを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-278">To disable the the deprecated text handling API, the definition **GX_DISABLE_DEPRECATED_STRING_API** should be added to the **_gx_user.h_*_ header file. All new applications should define _\* GX_DISABLE_DEPRECATED_STRING_API*\* and should use only the replacement API functions.</span></span> <span data-ttu-id="0f5ac-279">GUIX ライブラリ バージョン リリース 5.6 以降で GUIX Studio によって生成されたすべての出力ファイルでは、置き換え後の API 関数のみを利用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-279">All output files generated by GUIX Studio for GUIX library version release 5.6 or later will utilize only the replacement API functions.</span></span>

<span data-ttu-id="0f5ac-280">次の表は、非推奨の API 関数名と新しく定義された置き換え後の API 関数名の一覧を示しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-280">The following table lists the deprecated and newly defined replacement API function names:</span></span>

| <span data-ttu-id="0f5ac-281">**非推奨の関数名**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-281">**Deprecated Function Name**</span></span>              | <span data-ttu-id="0f5ac-282">**置き換え後の関数名**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-282">**Replaced With**</span></span>                              |
| ------------------------------------------ | ----------------------------------------------- |
| <span data-ttu-id="0f5ac-283">gx_binres_language_table_load</span><span class="sxs-lookup"><span data-stu-id="0f5ac-283">gx_binres_language_table_load</span></span>          | <span data-ttu-id="0f5ac-284">gx_binres_language_table_load_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-284">gx_binres_language_table_load_ext</span></span>          |
| <span data-ttu-id="0f5ac-285">gx_canvas_rotated_text_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-285">gx_canvas_rotated_text_draw</span></span>            | <span data-ttu-id="0f5ac-286">gx_canvas_rotated_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-286">gx_canvas_rotated_text_draw_ext</span></span>            |
| <span data-ttu-id="0f5ac-287">gx_canvas_text_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-287">gx_canvas_text_draw</span></span>                     | <span data-ttu-id="0f5ac-288">gx_canvas_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-288">gx_canvas_text_draw_ext</span></span>                     |
| <span data-ttu-id="0f5ac-289">gx_context_string_get</span><span class="sxs-lookup"><span data-stu-id="0f5ac-289">gx_context_string_get</span></span>                   | <span data-ttu-id="0f5ac-290">gx_context_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-290">gx_context_string_get_ext</span></span>                   |
| <span data-ttu-id="0f5ac-291">gx_display_language_table_get</span><span class="sxs-lookup"><span data-stu-id="0f5ac-291">gx_display_language_table_get</span></span>          | <span data-ttu-id="0f5ac-292">gx_display_language_table_get_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-292">gx_display_language_table_get_ext</span></span>          |
| <span data-ttu-id="0f5ac-293">gx_display_language_table_set</span><span class="sxs-lookup"><span data-stu-id="0f5ac-293">gx_display_language_table_set</span></span>          | <span data-ttu-id="0f5ac-294">gx_display_language_table_set_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-294">gx_display_language_table_set_ext</span></span>          |
| <span data-ttu-id="0f5ac-295">gx_display_string_get</span><span class="sxs-lookup"><span data-stu-id="0f5ac-295">gx_display_string_get</span></span>                   | <span data-ttu-id="0f5ac-296">gx_display_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-296">gx_display_string_get_ext</span></span>                   |
| <span data-ttu-id="0f5ac-297">gx_display_string_table_get</span><span class="sxs-lookup"><span data-stu-id="0f5ac-297">gx_display_string_table_get</span></span>            | <span data-ttu-id="0f5ac-298">gx_display_string_table_get_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-298">gx_display_string_table_get_ext</span></span>            |
| <span data-ttu-id="0f5ac-299">gx_multi_line_text_button_text_set</span><span class="sxs-lookup"><span data-stu-id="0f5ac-299">gx_multi_line_text_button_text_set</span></span>   | <span data-ttu-id="0f5ac-300">gx_multi_line_text_button_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-300">gx_multi_line_text_button_text_set_ext</span></span>   |
| <span data-ttu-id="0f5ac-301">gx_multi_line_text_input_char_insert</span><span class="sxs-lookup"><span data-stu-id="0f5ac-301">gx_multi_line_text_input_char_insert</span></span> | <span data-ttu-id="0f5ac-302">gx_multi_line_text_input_char_insert_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-302">gx_multi_line_text_input_char_insert_ext</span></span> |
| <span data-ttu-id="0f5ac-303">gx_multi_line_text_input_text_set</span><span class="sxs-lookup"><span data-stu-id="0f5ac-303">gx_multi_line_text_input_text_set</span></span>    | <span data-ttu-id="0f5ac-304">gx_multi_line_text_input_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-304">gx_multi_line_text_input_text_set_ext</span></span>    |
| <span data-ttu-id="0f5ac-305">gx_multi_line_text_view_text_set</span><span class="sxs-lookup"><span data-stu-id="0f5ac-305">gx_multi_line_text_view_text_set</span></span>     | <span data-ttu-id="0f5ac-306">gx_multi_line_text_view_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-306">gx_multi_line_text_view_text_set_ext</span></span>     |
| <span data-ttu-id="0f5ac-307">gx_prompt_text_get</span><span class="sxs-lookup"><span data-stu-id="0f5ac-307">gx_prompt_text_get</span></span>                      | <span data-ttu-id="0f5ac-308">gx_prompt_text_get_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-308">gx_prompt_text_get_ext</span></span>                      |
| <span data-ttu-id="0f5ac-309">gx_prompt_text_set</span><span class="sxs-lookup"><span data-stu-id="0f5ac-309">gx_prompt_text_set</span></span>                      | <span data-ttu-id="0f5ac-310">gx_prompt_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-310">gx_prompt_text_set_ext</span></span>                      |
| <span data-ttu-id="0f5ac-311">gx_single_line_text_input_text_set</span><span class="sxs-lookup"><span data-stu-id="0f5ac-311">gx_single_line_text_input_text_set</span></span>   | <span data-ttu-id="0f5ac-312">gx_single_line_text_input_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-312">gx_single_line_text_input_text_set_ext</span></span>   |
| <span data-ttu-id="0f5ac-313">gx_system_string_width_get</span><span class="sxs-lookup"><span data-stu-id="0f5ac-313">gx_system_string_width_get</span></span>             | <span data-ttu-id="0f5ac-314">gx_system_string_width_get_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-314">gx_system_string_width_get_ext</span></span>             |
| <span data-ttu-id="0f5ac-315">gx_system_version_string_get</span><span class="sxs-lookup"><span data-stu-id="0f5ac-315">gx_system_version_string_get</span></span>           | <span data-ttu-id="0f5ac-316">gx_system_version_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-316">gx_system_version_string_get_ext</span></span>           |
| <span data-ttu-id="0f5ac-317">gx_text_button_text_get</span><span class="sxs-lookup"><span data-stu-id="0f5ac-317">gx_text_button_text_get</span></span>                | <span data-ttu-id="0f5ac-318">gx_text_button_text_get_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-318">gx_text_button_text_get_ext</span></span>                |
| <span data-ttu-id="0f5ac-319">gx_text_button_text_set</span><span class="sxs-lookup"><span data-stu-id="0f5ac-319">gx_text_button_text_set</span></span>                | <span data-ttu-id="0f5ac-320">gx_text_button_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-320">gx_text_button_text_set_ext</span></span>                |
| <span data-ttu-id="0f5ac-321">gx_text_scroll_wheel_callback_set</span><span class="sxs-lookup"><span data-stu-id="0f5ac-321">gx_text_scroll_wheel_callback_set</span></span>     | <span data-ttu-id="0f5ac-322">gx_text_scroll_wheel_callback_set_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-322">gx_text_scroll_wheel_callback_set_ext</span></span>     |
| <span data-ttu-id="0f5ac-323">gx_utility_string_to_alphamap</span><span class="sxs-lookup"><span data-stu-id="0f5ac-323">gx_utility_string_to_alphamap</span></span>          | <span data-ttu-id="0f5ac-324">gx_utility_string_to_alphamap_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-324">gx_utility_string_to_alphamap_ext</span></span>          |
| <span data-ttu-id="0f5ac-325">gx_widget_string_get</span><span class="sxs-lookup"><span data-stu-id="0f5ac-325">gx_widget_string_get</span></span>                    | <span data-ttu-id="0f5ac-326">gx_widget_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-326">gx_widget_string_get_ext</span></span>                    |
| <span data-ttu-id="0f5ac-327">gx_widget_text_blend</span><span class="sxs-lookup"><span data-stu-id="0f5ac-327">gx_widget_text_blend</span></span>                    | <span data-ttu-id="0f5ac-328">gx_widget_text_blend_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-328">gx_widget_text_blend_ext</span></span>                    |
| <span data-ttu-id="0f5ac-329">gx_widget_text_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-329">gx_widget_text_draw</span></span>                     | <span data-ttu-id="0f5ac-330">gx_widget_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="0f5ac-330">gx_widget_text_draw_ext</span></span>                     |

### <a name="guix-string-table"></a><span data-ttu-id="0f5ac-331">GUIX 文字列テーブル</span><span class="sxs-lookup"><span data-stu-id="0f5ac-331">GUIX String Table</span></span> 

<span data-ttu-id="0f5ac-332">GUIX の文字列テーブルと文字列リソースは、GUIX ディスプレイ インスタンスに登録されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-332">The GUIX string table and string resources are registered with a GUIX display instance.</span></span>

<span data-ttu-id="0f5ac-333">マルチディスプレイ システム内の各ディスプレイには独自の文字列テーブルがあり、各ディスプレイは独自の選択された言語で動作できます。また、その他の GUIX リソースの種類 (色、フォント、ピクセルマップ) も、これらのリソースの種類が各ディスプレイの色形式と色深度に固有のものであるため、GUIX ディスプレイ コンポーネントによって管理されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-333">Each display in a multi-display system has its own string table, and each display can run in its own selected language.The other GUIX resource types (colors, fonts, and pixelmaps) are also maintained by the GUIX Display component, since these resource types are specific to each display color format and color depth.</span></span>

<span data-ttu-id="0f5ac-334">アプリケーション文字列テーブルは手動で作成できますが、ディスプレイ文字列テーブルはほとんどの場合、プロジェクト リソース ファイルの一部として GUIX Studio アプリケーションによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-334">While you can manually create your application string table, most often the display string table is defined by the GUIX Studio application as part of your project resource file.</span></span> <span data-ttu-id="0f5ac-335">使用可能な言語もまた、リソース ヘッダー ファイルで定義されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-335">The available languages are also defined in the resource header file.</span></span> <span data-ttu-id="0f5ac-336">ディスプレイ文字列テーブルは、アプリケーション文字列へのポインターの複数列テーブルです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-336">The display string table is a multi-column table of pointers to application strings.</span></span> <span data-ttu-id="0f5ac-337">文字列テーブルの各列は、そのアプリケーションでサポートされている 1 つの言語を表します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-337">Each column of the string table represents one language supported by the application.</span></span>
<span data-ttu-id="0f5ac-338">アプリケーションが 1 つの言語 (英語など) のみをサポートしている場合は、文字列テーブルの列が 1 つだけになります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-338">If your application supports only one language, for example English, then your string table will have only one column.</span></span> <span data-ttu-id="0f5ac-339">その場合でも、アプリケーション ソフトウェアを変更することなく、追加の言語のサポートをいつでも追加できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-339">Still, you can add support for additional languages at any time without modifying your application software.</span></span>

<span data-ttu-id="0f5ac-340">アクティブな文字列テーブルは、***gx_display_string_table_set*** API 関数を呼び出すことによって割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-340">The active string table is assigned by calling the ***gx_display_string_table_set*** API function.</span></span> <span data-ttu-id="0f5ac-341">この関数は、GUIX Studio で生成されたスタートアップ コードによって自動的に呼び出されますが、アクティブな文字列テーブルを変更するために、アプリケーションで直接呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-341">This function is called automatically by the GUIX Studio generated startup code, but can also be called directly by the application to change the active string table.</span></span>

<span data-ttu-id="0f5ac-342">アクティブな言語は、***gx_display_active_language_set*** API 関数を呼び出すことによって割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-342">The active language is assigned by calling the ***gx_display_active_language_set*** API function.</span></span> <span data-ttu-id="0f5ac-343">この関数によって、ディスプレイ文字列テーブルのどの列がアクティブであるかが決定されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-343">This function determines which column of the display string table is active.</span></span>

<span data-ttu-id="0f5ac-344">この関数が呼び出されると、**GX_EVENT_LANGUAGE_CHANGE** イベントがすべての表示される GUIX ウィジェットに送信され、それらを新しくアクティブになった文字列データが表示されるように更新できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-344">When this function is invoked, a **GX_EVENT_LANGUAGE_CHANGE** event is sent to all visible GUIX widgets, allowing them to update to display the newly active string data.</span></span>

<span data-ttu-id="0f5ac-345">ウィジェットとアプリケーション ソフトウェアでは、文字列 ID 値と ***gx_display_string_get_ext*** または ***gx_widget_string_get_ext*** API 関数を使用して、静的に定義された文字列を解決します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-345">Widgets and application software resolve statically defined strings using string ID values and the ***gx_display_string_get_ext*** or ***gx_widget_string_get_ext*** API functions.</span></span> <span data-ttu-id="0f5ac-346">これらの関数は、指定された文字列 ID と現在アクティブな言語に関連付けられている **GX_STRING** を返します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-346">These functions return the **GX_STRING** associated with a given string ID and the currently active language.</span></span>

### <a name="bi-directional-text-display"></a><span data-ttu-id="0f5ac-347">双方向テキストの表示</span><span class="sxs-lookup"><span data-stu-id="0f5ac-347">Bi-directional Text Display</span></span> 

<span data-ttu-id="0f5ac-348">GUIX には、双方向テキストをサポートするための 2 つの方式が用意されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-348">GUIX provide two strategies for bi-directional text support.</span></span>

<span data-ttu-id="0f5ac-349">1 つのオプションでは、双方向テキストの並べ替えを GUIX Studio アプリケーション内で行います。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-349">One option is to do bidi text reordering within the GUIX Studio application.</span></span> <span data-ttu-id="0f5ac-350">このオプションを使用する場合、双方向テキストをその表示順序で出力ファイルに生成する処理は GUIX Studio が担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-350">Using this option GUIX Studio is responsible for generating bidi text to the output file in its display order.</span></span> <span data-ttu-id="0f5ac-351">このソリューションは実行時のパフォーマンスに影響を与えず、GUIX ランタイム ライブラリへのどのような追加も必要ありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-351">This solution has zero impact on the runtime performance and does not require any additions to the GUIX runtime library.</span></span> <span data-ttu-id="0f5ac-352">GUIX Studio で表示順序の双方向テキスト文字列を生成できるようにするには、GUIX Studio の言語構成ダイアログで **[表示順序の双方向テキストを生成する]** チェックボックスをオンにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-352">To allow GUIX Studio to generate displayorder bidi text strings, you should select the **Generate Bidi Text in Display Order** checkbox in the GUIX Studio language configuration dialog:</span></span>

![言語の構成](./media/guix/user-guide/configure-languages.png)

<span data-ttu-id="0f5ac-354">これらのオプションが選択されている場合、生成されたリソース ファイルには表示順序で生成された双方向文字列が含まれ、GUIX ランタイム ライブラリ内での追加の処理は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-354">With these options selected, the generated resource file will contain Bidi strings generated in display order, and no extra processing is required within the GUIX runtime library.</span></span>

<span data-ttu-id="0f5ac-355">2 番目のオプションでは、双方向テキストの並べ替えを実行時に行います。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-355">The second option is to do bidi text reordering at runtime.</span></span> <span data-ttu-id="0f5ac-356">このオプションは、GUIX Studio アプリケーションによって生成されるのではなく、動的に定義される双方向テキスト文字列を処理する必要があるアプリケーションのためにサポートされています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-356">This option is supported for those applications that must handle bidi text string that are dynamically defined, and not generated by the GUIX Studio application.</span></span> <span data-ttu-id="0f5ac-357">この場合、各テキスト文字列を描画する前に双方向テキストを並べ替える処理は GUIX ランタイム ライブラリが担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-357">In this case the GUIX runtime library is responsible for reordering the bidi text before drawing each text string.</span></span> <span data-ttu-id="0f5ac-358">このソリューションは、実行時のパフォーマンスとメモリに影響を与えます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-358">This solution has a runtime performance and memory impact.</span></span> <span data-ttu-id="0f5ac-359">双方向テキストの並べ替えプロセスのための十分な動的メモリが使用可能である必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-359">Sufficient dynamic memory must be available for bidi text reordering process.</span></span> <span data-ttu-id="0f5ac-360">このソリューションでは、GUIX ライブラリを構築するときに条件付きの GX_DYNAMIC_BIDI_TEXT_SUPPORT が定義されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-360">This solution requires that the conditional GX_DYNAMIC_BIDI_TEXT_SUPPORT be defined when building the GUIX library.</span></span> <span data-ttu-id="0f5ac-361">双方向テキストのサポートを実行時に有効または無効にするために、2 つの API 関数 ***gx_system_bidi_text_enable*** と ***gx_system_bidi_text_disable*** が用意されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-361">Two API functions ***gx_system_bidi_text_enable*** and ***gx_system_bidi_text_disable*** are provided to enable/disable bidi text support at runtime.</span></span>

<span data-ttu-id="0f5ac-362">**GX_DYNAMIC_BIDI_TEXT_SUPPORT** を使用すると同時に、表示順序の双方向テキストを生成するように GUIX Studio を構成するべきではありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-362">You should not use both **GX_DYNAMIC_BIDI_TEXT_SUPPORT** and configure GUIX Studio to generate Bidi text in display order.</span></span> <span data-ttu-id="0f5ac-363">双方向テキスト文字列の処理の方式として、どちらか 1 つだけを選択する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-363">You must select one strategy or the other for bidi text string handling.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="0f5ac-364">メモリ使用量</span><span class="sxs-lookup"><span data-stu-id="0f5ac-364">Memory Usage</span></span> 

<span data-ttu-id="0f5ac-365">GUIX は、アプリケーション プログラムと共存しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-365">GUIX resides along with the application program.</span></span> <span data-ttu-id="0f5ac-366">その結果、GUIX の静的メモリ (つまり固定メモリ) の使用量は、開発ツール (コンパイラ、リンカー、ロケーターなど) によって決定されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-366">As a result, the static memory (or fixed memory) usage of GUIX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="0f5ac-367">動的メモリ (つまり実行時メモリ) の使用量は、アプリケーションによって直接制御されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-367">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="0f5ac-368">静的メモリの使用量</span><span class="sxs-lookup"><span data-stu-id="0f5ac-368">Static Memory Usage</span></span> 

<span data-ttu-id="0f5ac-369">ほとんどの開発ツールでは、アプリケーション プログラム イメージを "*命令*"、"*定数*"、"*初期化されたデータ*"、"*初期化されていないデータ*"、"*GUIX スレッド スタック*" の 5 つの基本的な領域に分割します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-369">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and the *GUIX thread stack*.</span></span> <span data-ttu-id="0f5ac-370">X ページの図 X は、これらのメモリ領域の例を示しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-370">Figure X on page X shows an example of these memory areas.</span></span>

<span data-ttu-id="0f5ac-371">これは例にすぎないことを理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-371">It is important to understand that this only an example.</span></span> <span data-ttu-id="0f5ac-372">実際の静的メモリのレイアウトは、プロセッサ、開発ツール、基になるハードウェア、アプリケーション自体などに固有のものです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-372">The actual static memory layout is specific to the processor, development tools, underlying hardware, and the application itself.</span></span>

<span data-ttu-id="0f5ac-373">命令領域には、そのプログラムのすべてのプロセッサ命令が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-373">The instruction area contains all of the program’s processor instructions.</span></span> <span data-ttu-id="0f5ac-374">この領域は多くの場合 ROM 内にあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-374">This area is often located in ROM.</span></span>

<span data-ttu-id="0f5ac-375">定数領域には、各種のコンパイルされた定数が含まれています。GUIX では、既定の設定とすべてのアプリケーション リソース (イメージ、文字列、フォント、色) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-375">The constant area contains various compiled constants, which in GUIX contains default settings and all application resources (images, strings, fonts, and colors).</span></span> <span data-ttu-id="0f5ac-376">さらに、この領域には、初期化されたデータ領域の "初期のコピー" も含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-376">In addition, this area contains the “initial copy” of the initialized data area.</span></span> <span data-ttu-id="0f5ac-377">コンパイラの初期化プロセス中に、定数領域のこの部分は、RAM 内のグローバルな初期化されたデータを設定するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-377">During the compiler’s initialization process, this portion of the constant area is used to set up the global initialized data in RAM.</span></span> <span data-ttu-id="0f5ac-378">定数領域は一般に最も大きく、通常は命令領域の後にあり、多くの場合は ROM 内にあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-378">The constant area is typically the largest and usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="0f5ac-379">GUIX ピクセルマップとフォントには通常、大量の定数データ ストレージが必要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-379">GUIX pixelmaps and fonts typically require large amounts of constant data storage.</span></span> <span data-ttu-id="0f5ac-380">これらの大きな静的データ領域は通常、ROM またはフラッシュ内に保持されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-380">These large static data areas are normally kept in ROM or FLASH.</span></span>

<span data-ttu-id="0f5ac-381">GUIX スレッド スタックは、***gx_system.h*** ファイルの初期化されていないデータ領域内で (グローバル変数として) 次のように定義されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-381">The GUIX thread stack is defined within the uninitialized data area (as a global variable) in ***gx_system.h*** file as follows:</span></span>

```C
_gx_system_thread_stack[GX_THREAD_STACK_SIZE];
```

<span data-ttu-id="0f5ac-382">**GX_THREAD_STACK_SIZE** は **_gx_port.h_** で定義されますが、このシンボルを ***gx_user.h*** ヘッダー ファイルで定義することによって、あるいはプロジェクト オプションまたはコマンド ライン パラメーターを使用してアプリケーションでオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-382">**GX_THREAD_STACK_SIZE** is defined in **_gx_port.h_**, but may be overridden by the application by defining this symbol in the ***gx_user.h*** header file or via project options or command line parameters.</span></span> <span data-ttu-id="0f5ac-383">このスタック サイズは、最悪のケースのイベント処理や入れ子になった描画呼び出しを処理できるだけの十分な大きさにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-383">The stack size must be large enough to handle the worst case event handling and nested drawing calls.</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="0f5ac-384">動的メモリの使用量</span><span class="sxs-lookup"><span data-stu-id="0f5ac-384">Dynamic Memory Usage</span></span> 

<span data-ttu-id="0f5ac-385">先に説明したように、動的メモリの使用量は、アプリケーションによって直接制御されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-385">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="0f5ac-386">キャンバスなどに関連付けられているコントロール ブロックとメモリは、ターゲットのメモリ領域内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-386">Control blocks and memory associated with canvases, etc. can be placed anywhere in the target’s memory space.</span></span> <span data-ttu-id="0f5ac-387">これにより、さまざまな種類の物理メモリを実行時に簡単に利用できるようになるため、これは重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-387">This is an important feature because it facilitates easy utilization of different types of physical memory – at run-time.</span></span>

<span data-ttu-id="0f5ac-388">たとえば、ターゲットのハードウェア環境に、高速なメモリと低速なメモリの両方が存在するとします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-388">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="0f5ac-389">アプリケーションが描画のために追加のパフォーマンスを必要としている場合は、最高のパフォーマンスを得るために、キャンバス メモリを高速なメモリ領域に明示的に配置できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-389">If the application needs extra performance for drawing, the canvas memory can be explicitly placed in the high-speed memory area for best performance.</span></span>

<span data-ttu-id="0f5ac-390">いくつかのオプションの GUIX サービスおよび機能には、一般にヒープと呼ばれる、ランタイム動的メモリ割り当てメカニズムが必要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-390">Several optional GUIX services and features require a runtime dynamic memory allocation mechanism, commonly referred to as a heap.</span></span> <span data-ttu-id="0f5ac-391">これらのサービスおよび機能は完全にオプションであり、多くの GUIX アプリケーションではヒープを使用せず、ランタイム メモリ割り当てメカニズムも定義しません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-391">These services and features are completely optional, and many GUIX applications do not use any heap and do not define a runtime memory allocation mechanism.</span></span>

<span data-ttu-id="0f5ac-392">ランタイム メモリ割り当てを必要とするサービスを使用する予定がある場合は、メモリを動的に割り当てたり解放したりする必要が発生したときに GUIX から呼び出す関数をインストールする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-392">If you will be using services which require runtime memory allocation, you must install functions which GUIX will call when memory must be dynamically allocated or freed.</span></span> <span data-ttu-id="0f5ac-393">この場合でも、動的メモリ プールの場所をアプリケーションから制御できるように、これらの関数を必要に応じて実装できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-393">You can implement these functions as you prefer, so that even in this case the location of the dynamic memory pool is under application control.</span></span> <span data-ttu-id="0f5ac-394">動的メモリ割り当てのサポートをインストールするには、プログラムの起動中にアプリケーションで API サービス ***gx_system_memory_allocator_set*** を呼び出して、メモリ割り当ておよびメモリ解放サービスを定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-394">To install support for dynamic memory allocation, the application should invoke the API service ***gx_system_memory_allocator_set*** during program startup to define your memory allocation and memory free services.</span></span> <span data-ttu-id="0f5ac-395">完全な例については、この API のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-395">Refer to the documentation of this API for a complete example.</span></span>

<span data-ttu-id="0f5ac-396">ランタイム メモリ割り当ておよび割り当て解除サービスを必要とする GUIX サービスには、次のものが含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-396">GUIX services which require a runtime memory allocation and de-allocation service include:</span></span>

  - <span data-ttu-id="0f5ac-397">外部ストレージから GUIX ランタイム環境へのバイナリ リソースの読み込み。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-397">Loading binary resources from external storage into the GUIX runtime environment.</span></span>

  - <span data-ttu-id="0f5ac-398">ソフトウェア ランタイム jpeg イメージ デコーダー。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-398">The software runtime jpeg image decoder.</span></span>

  - <span data-ttu-id="0f5ac-399">ソフトウェア ランタイム png イメージ デコーダー。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-399">The software runtime png image decoder.</span></span>

  - <span data-ttu-id="0f5ac-400">GX_STYLE_TEXT_COPY でのテキスト ウィジェットの使用。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-400">Using text widgets with GX_STYLE_TEXT_COPY.</span></span>

  - <span data-ttu-id="0f5ac-401">ランタイム ピクセルマップ サイズ変更および回転ユーティリティ関数。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-401">Runtime pixemap resize and rotation utility functions.</span></span>
  - <span data-ttu-id="0f5ac-402">ランタイムでの画面とウィジェット コントロール ブロックの割り当て。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-402">Runtime screen and widget control block allocation.</span></span>

<span data-ttu-id="0f5ac-403">小規模なアプリケーションの場合、GUIX リソースは通常、アプリケーション イメージの一部としてコンパイルされ、静的にリンクされるため、バイナリ リソースのインストールは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-403">For smaller applications, GUIX resources are usually compiled and statically linked as part of the application image, and binary resource installation is not required.</span></span> <span data-ttu-id="0f5ac-404">バイナリ リソースを使用すると、アプリケーションでは、フラッシュ ドライブや URL などの一部の保存場所から読み込まれたリソース (フォント、イメージ、言語) を実行時にインストールできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-404">Binary resources allow an application to install resources (fonts, images, languages) at runtime loaded from some storage location, such as a flash drive or a URL.</span></span>

<span data-ttu-id="0f5ac-405">ランタイム jpeg および png デコーダーはオプション コンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-405">The runtime jpeg and png decoders are optional components.</span></span> <span data-ttu-id="0f5ac-406">ほとんどの GUIX アプリケーションでは、GUIX Studio ツールで、必要なすべてのイメージ ファイルを事前にデコードし、それを独自の GUIX ピクセルマップ データ リソースとして格納できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-406">Most GUIX applications allow the GUIX Studio tool to pre-decode all required image files, and store them as proprietary GUIX Pixemap data resources.</span></span> <span data-ttu-id="0f5ac-407">これらのサービスは、jpeg または PNG イメージからピクセルマップ形式へのランタイム変換を必要とするアプリケーションの完全性のために提供されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-407">These services are provided for completeness for those applications that require runtime conversion of jpeg and/or PNG images to pixelmap format.</span></span>

<span data-ttu-id="0f5ac-408">**GX_STYLE_TEXT_COPY** を使用すると、ユーザーは特定の 1 つまたは複数のウィジェットに、動的に割り当てられたテキストの独自のプライベート コピーが保持されるように指定できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-408">**GX_STYLE_TEXT_COPY** allows the user to specify that a particular widget or widgets will keep it’s own private copy of dynamically assigned text.</span></span> <span data-ttu-id="0f5ac-409">このオプションを使用するには、その使用の前に、メモリ割り当てメカニズムをインストールする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-409">Using this option requires that the memory allocation mechanism be installed prior to use.</span></span> <span data-ttu-id="0f5ac-410">テキストの種類のウィジェットが作成されるときにこのスタイル フラグが指定されて **<span class="underline">いない</span>** 場合は、動的に作成され、割り当てられたすべてのテキスト文字列に対してアプリケーションで静的ストレージ領域を割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-410">If this style flag is **<span class="underline">not</span>** provided when a text type widget is created, the application must allocate static storage areas for all dynamically created and assigned text strings.</span></span> <span data-ttu-id="0f5ac-411">この場合、ランタイムで生成された文字列データを保持するために自動変数を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-411">Automatic variables should not be used in this case to hold runtime generated string data.</span></span> <span data-ttu-id="0f5ac-412">**GX_STYLE_TEXT_COPY** スタイルが有効になっている場合は、各ウィジェットで割り当てられたテキストの独自のコピーが作成されるため、GUIX ウィジェットに割り当てられた文字列データを保持するために自動変数を使用できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-412">If the **GX_STYLE_TEXT_COPY** style is enabled, automatic variables may be used to hold string data assigned to GUIX widgets, since each widget will create its own copy of the assigned text.</span></span>

<span data-ttu-id="0f5ac-413">ピクセルマップ サイズ変更および回転ユーティリティ関数は、結果として得られた変換されたピクセルマップを、アプリケーションで使用できる新しいピクセルマップとして返します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-413">Pixelmap resize and rotation utility functions return the resulting translated pixelmap as a new pixelmap available to the application.</span></span>
<span data-ttu-id="0f5ac-414">これらのサービスが使用されている場合は、ランタイムで生成されたこれらのピクセルマップ データ ブロックを保持するための十分な動的メモリが使用可能である必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-414">Sufficient dynamic memory must be available to hold these runtime generated pixelmap data blocks if these services are used.</span></span>

<span data-ttu-id="0f5ac-415">最後に、GUIX 画面とウィジェットのコントロール ブロックは、静的または動的に割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-415">Finally, the control blocks for the GUIX screens and widgets can be statically or dynamically allocated.</span></span> <span data-ttu-id="0f5ac-416">小規模なアプリケーションの場合は、プログラムの起動中にすべてのアプリケーション画面を作成し、静的に割り当てられたコントロール ブロックを使用することが一般的です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-416">For smaller applications, it is common to create all application screens during program startup and use statically allocated control blocks.</span></span> <span data-ttu-id="0f5ac-417">大規模なアプリケーションの場合は、画面と子ウィジェット コントロールを必要に応じて動的に作成することが一般的です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-417">For large applications, it is common to create the screen and child widget controls dynamically on an as-needed bases.</span></span> <span data-ttu-id="0f5ac-418">動的に割り当てられたコントロール ブロックは、GUIX Studio のプロパティ ビューで **[ランタイム割り当て]** チェックボックスをオンにするか、または標準 API を使用してウィジェットを作成するときにスタイル フラグ **GX_STYLE_DYNAMICALLY_ALLOCATED** を渡すことによって指定されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-418">Dynamically allocated control blocks are specified by selecting the **Runtime Allocate** checkbox in the GUIX Studio properties view, or by passing in the style flag **GX_STYLE_DYNAMICALLY_ALLOCATED** when creating a widget via the standard API.</span></span> <span data-ttu-id="0f5ac-419">動的に割り当てられたウィジェット コントロール ブロックを使用するには、先に説明したように、メモリ割り当ておよび割り当て解除サービスが定義されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-419">Using dynamically allocated widget control blocks requires that memory allocation and deallocation services are defined as described above.</span></span>

## <a name="guix-components"></a><span data-ttu-id="0f5ac-420">GUIX コンポーネント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-420">GUIX Components</span></span> 

<span data-ttu-id="0f5ac-421">GUIX API は、GUIX システムの基本コンポーネントに対応した、いくつかの基本的なグループに分割および整理されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-421">The GUIX APIs are divided and organized into several basic groups which correspond to fundamental components of the GUIX system.</span></span> <span data-ttu-id="0f5ac-422">基本コンポーネントには、次のものが含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-422">The fundamental components include:</span></span>

| <span data-ttu-id="0f5ac-423">Components</span><span class="sxs-lookup"><span data-stu-id="0f5ac-423">Components</span></span>  | <span data-ttu-id="0f5ac-424">説明</span><span class="sxs-lookup"><span data-stu-id="0f5ac-424">Description</span></span>  |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="0f5ac-425">GX_SYSTEM</span><span class="sxs-lookup"><span data-stu-id="0f5ac-425">GX_SYSTEM</span></span>  | <span data-ttu-id="0f5ac-426">GUIX システム コンポーネント。初期化、イベント、タイマー、文字列テーブル、表示されるウィジェットの階層管理を担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-426">The GUIX system component, responsible for initialization, events, timers, string tables, and visible widget hierarchy management.</span></span>                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="0f5ac-427">GX_CANVAS</span><span class="sxs-lookup"><span data-stu-id="0f5ac-427">GX_CANVAS</span></span>  | <span data-ttu-id="0f5ac-428">描画領域。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-428">A drawing area.</span></span> <span data-ttu-id="0f5ac-429">キャンバスは、ハードウェア フレーム バッファーの薄い抽象化である場合があります。また、純粋なメモリ キャンバスである可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-429">A Canvas can be a thin abstraction of the hardware frame buffer, or it might also be a pure memory canvas.</span></span> <span data-ttu-id="0f5ac-430">キャンバスの種類は、gx_canvas_create API 関数に渡されるパラメーターによって決定されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-430">The canvas type is determined by parameters passed to the gx_canvas_create API function.</span></span>                                                                                                                                                                                   |
| <span data-ttu-id="0f5ac-431">GX_CONTEXT</span><span class="sxs-lookup"><span data-stu-id="0f5ac-431">GX_CONTEXT</span></span> | <span data-ttu-id="0f5ac-432">描画コンテキスト コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-432">The drawing context component.</span></span> <span data-ttu-id="0f5ac-433">描画コンテキストには、画面、キャンバス、ブラシのほか、現在の描画操作のクリッピング領域に関する情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-433">The drawing context contains information about the screen, canvas, and brush, and clipping area for the current drawing operations.</span></span>                                                                                                                                                                                                                                      |
| <span data-ttu-id="0f5ac-434">GX_DISPLAY</span><span class="sxs-lookup"><span data-stu-id="0f5ac-434">GX_DISPLAY</span></span> | <span data-ttu-id="0f5ac-435">アプリケーションや GUIX ウィジェットでキャンバスへの描画を実行できるようにするための API とドライバー レベルの実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-435">Provides the APIs and driver-level implementations to allow your application and the GUIX widgets to perform drawing on a canvas.</span></span> <span data-ttu-id="0f5ac-436">GX_DISPLAY は、各キャンバスの必要な色形式を使用して、そのキャンバスにグラフィックスを適切にレンダリングするために実装されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-436">GX_DISPLAY is implemented to correctly render graphics on each canvas using that canvas’ required color format.</span></span> <span data-ttu-id="0f5ac-437">GX_DISPLAY コンポーネントではまた、各ディスプレイにリンクされているキャンバスに描画するウィジェットで使用できるリソース (色、フォント、ピクセルマップ) も管理します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-437">The GX_DISPLAY component also manages the resources (colors, fonts, and pixelmaps) available to widgets drawing to canvases linked to each display.</span></span> |
| <span data-ttu-id="0f5ac-438">GX_WIDGET</span><span class="sxs-lookup"><span data-stu-id="0f5ac-438">GX_WIDGET</span></span>  | <span data-ttu-id="0f5ac-439">基本的な表示されるウィジェット オブジェクトとそれに関連付けられている API。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-439">The basic visible widget object and associated APIs.</span></span> <span data-ttu-id="0f5ac-440">GUIX ウィジェットの種類はすべて、基本的な GX_WIDGET の種類に基づいているか、またはそれから派生しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-440">All GUIX widget types are based on or derived from the basic GX_WIDGET type.</span></span>                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="0f5ac-441">GX_UTILITY</span><span class="sxs-lookup"><span data-stu-id="0f5ac-441">GX_UTILITY</span></span> | <span data-ttu-id="0f5ac-442">このグループには、四角形を操作するためのユーティリティ関数、文字列変換のための関数、ANSI 以外の数学関数が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-442">Utility functions for working with rectangles, functions for string conversion, and non-ANSI mathematical functions are included in this group.</span></span>                                                                                                                                                                                                                                                         |

<span data-ttu-id="0f5ac-443">これらの基本的なコンポーネントに加えて、GUIX には、ライブラリで提供されている各種類のウィジェットに固有の API が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-443">In addition to these basic components, GUIX includes APIs unique to each type of widget provided in the library.</span></span> <span data-ttu-id="0f5ac-444">これらの API は、このユーザー ガイドの第 4 章「GUIX サービスの説明」で説明されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-444">These APIs are described in Chapter 4 of this User Guide, “Description of GUIX Services”.</span></span>

## <a name="guix-system-component"></a><span data-ttu-id="0f5ac-445">GUIX システム コンポーネント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-445">GUIX System Component</span></span>

<span data-ttu-id="0f5ac-446">GUIX システム コンポーネントは、UI アプリケーションに対してグローバルないくつかのサービスを提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-446">The GUIX system component provides several services that are global to the UI application.</span></span> <span data-ttu-id="0f5ac-447">これらのサービスには、"*初期化、イベント管理、ディスプレイ管理、リソース管理、タイマー管理*" のほか、"*ウィジェット管理*" が含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-447">These services include: *initialization, event management, display management, resource management, timer management,* and *widget management*.</span></span> <span data-ttu-id="0f5ac-448">各サービスはアプリケーション プログラムの構成に不可欠であり、これらのサービスは次の各サブセクションでより詳細に説明されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-448">Each service is essential to the organization of your application program, and these services are described in more detail in the following sub-sections.</span></span>

### <a name="initialization"></a><span data-ttu-id="0f5ac-449">初期化</span><span class="sxs-lookup"><span data-stu-id="0f5ac-449">Initialization</span></span> 

<span data-ttu-id="0f5ac-450">GUIX の初期化は、サービス ***gx_system_initialize*** を呼び出すアプリケーションによって実現されます。これは、ThreadX の ***tx_application_define*** ルーチン (初期化コンテキスト) またはアプリケーション スレッドからアプリケーションによって呼び出される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-450">GUIX initialization is accomplished by the application calling the service ***gx_system_initialize***, which may be called by the application from the ThreadX ***tx_application_define*** routine (initialization context) or from application threads.</span></span> <span data-ttu-id="0f5ac-451">***gx_system_initialize*** 関数では、すべてのグローバルな GUIX データ構造体を初期化し、GUIX システム ミューテックス、イベント キュー、タイマー、スレッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-451">The ***gx_system_initialize*** function initializes all global GUIX data structures and creates the GUIX system mutex, event queue, timer, and thread.</span></span> <span data-ttu-id="0f5ac-452">***gx_system_initialize*** から戻ったら、アプリケーションは GUIX を使用できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-452">Once ***gx_system_initialize*** returns, the application can use GUIX.</span></span>

### <a name="thread-processing"></a><span data-ttu-id="0f5ac-453">スレッド処理</span><span class="sxs-lookup"><span data-stu-id="0f5ac-453">Thread Processing</span></span> 

<span data-ttu-id="0f5ac-454">内部 GUIX スレッドは、初期化中に作成され、GUIX でのほとんどの処理を担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-454">The internal GUIX thread – created during initialization – is responsible for most of the processing in GUIX.</span></span> <span data-ttu-id="0f5ac-455">このスレッドでの処理では、まず、基になるディスプレイ ドライバーに必要な追加の初期化をすべて完了します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-455">The processing in this thread first completes any additional initialization required by the underlying display driver.</span></span> <span data-ttu-id="0f5ac-456">これが完了すると、GUIX スレッドはループに入ります。ここでは、まず GUIX イベント キューに存在するすべてのイベントを処理してから、必要に応じて画面を更新します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-456">Once this is complete, the GUIX thread enters a loop which first processes all events present in the GUIX event queue and then refreshes the screen if required.</span></span> <span data-ttu-id="0f5ac-457">画面の更新では、何が表示され、ダーティ (つまり、再描画する必要がある) とマークされているかに基づいて、必要な GUIX 描画関数を実行します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-457">The screen refresh executes the necessary GUIX drawing functions, based on what is visible and has been marked as dirty meaning it needs to be redrawn.</span></span> <span data-ttu-id="0f5ac-458">イベントが存在せず、ディスプレイ上に更新すべきものが何も残されていない場合、GUIX スレッドは中断し、次の GUIX イベントが到着するまで待ちます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-458">When there are no events and nothing left to refresh on the display, the GUIX thread will suspend, waiting for the next GUIX event to arrive.</span></span>

### <a name="rtos-binding"></a><span data-ttu-id="0f5ac-459">RTOS バインド</span><span class="sxs-lookup"><span data-stu-id="0f5ac-459">RTOS Binding</span></span> 

<span data-ttu-id="0f5ac-460">GUIX システム コンポーネントは、既定では、スレッド サービス、イベント キュー サービス、タイマー サービスなどのサービスのために ThreadX リアルタイム オペレーティング システムを利用するように構成されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-460">The GUIX system component is by default configured to utilize the ThreadX real time operating system for services such as thread services, event queue services, and timer services.</span></span> <span data-ttu-id="0f5ac-461">GUIX は、プリプロセッサ ディレクティブ GX_DISABLE_THREADX_BINDING を使用し、GUIX ライブラリを再構築することによって、他のオペレーティング システムに簡単に移植できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-461">GUIX can easily be ported to other operating systems by using the preprocessor directive GX_DISABLE_THREADX_BINDING and re-building the GUIX library.</span></span> <span data-ttu-id="0f5ac-462">これにより、GUIX ソース コードから ThreadX の依存関係が削除され、アプリケーション開発者は、ターゲット システムによって提供される任意の RTOS を使用して必要なオペレーティング システム サービスを実装できるようになります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-462">This removes the ThreadX dependencies from the GUIX source code, and allows the application developer to implement the required operating system services using whatever RTOS is provided by the target system.</span></span> <span data-ttu-id="0f5ac-463">「[付録 F - GUIX RTOS バインド サービス](appendix-f.md)」では、GUIX を ThreadX オペレーティング システム以外のオペレーティング システムに移植するために実装する必要があるサービスについて説明しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-463">[Appendix F - GUIX RTOS Binding Services](appendix-f.md) describes the services that need to be implemented to port GUIX to an operating system other than the ThreadX operating system.</span></span>

### <a name="multithread-safety"></a><span data-ttu-id="0f5ac-464">マルチスレッド セーフ</span><span class="sxs-lookup"><span data-stu-id="0f5ac-464">Multithread Safety</span></span> 

<span data-ttu-id="0f5ac-465">GUIX API は、GUIX のスレッド コンテキストやその他のアプリケーション スレッドから使用できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-465">The GUIX API is available from the GUIX thread context as well as other application threads.</span></span> <span data-ttu-id="0f5ac-466">アプリケーション スレッドでは、イベントを送受信したり、共有変数にアクセスしたり、GUIX API 関数を使用したりすることによって GUIX スレッドを操作できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-466">Application threads can interact with the GUIX thread by sending and receiving events, by access to shared variables, and through use of the GUIX API functions.</span></span> <span data-ttu-id="0f5ac-467">GUIX では、マルチスレッド リソースの保護のために内部の ThreadX ミューテックスを使用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-467">GUIX uses an internal ThreadX mutex for multi-thread resource protection.</span></span> <span data-ttu-id="0f5ac-468">さらに、GUIX では画面の更新操作が開始された後に、表示されるウィジェットの内部構造体が変更されないようにします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-468">In addition, GUIX prevents the internal structure of visible widgets from being modified once a screen refresh operation has begun.</span></span> <span data-ttu-id="0f5ac-469">表示されるオブジェクトのツリーを変更するような API は、描画操作の進行中にはブロックされ、画面の更新が完了すると解放されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-469">APIs which would modify the tree of visible objects are blocked while drawing operations are in progress, and released once the screen refresh is complete.</span></span>

### <a name="system-timers"></a><span data-ttu-id="0f5ac-470">システム タイマー</span><span class="sxs-lookup"><span data-stu-id="0f5ac-470">System Timers</span></span> 

<span data-ttu-id="0f5ac-471">GUIX は、アプリケーションに定期的なタイマーを提供します。これは多くの場合、GUIX ウィンドウに表示されるデータの定期的な更新に使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-471">GUIX provides the application with periodic timers, which are often used for periodic update of data displayed in GUIX windows.</span></span> <span data-ttu-id="0f5ac-472">これは、ThreadX の定期的なタイマーを使用して実現されます。これもまた、画面のフェード イン/アウトなどの GUIX システム レベルの効果を実行するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-472">This is accomplished via a ThreadX periodic timer, which is also used to perform GUIX system-level effects like screen fade in/out, etc.</span></span>

<span data-ttu-id="0f5ac-473">アプリケーションではタイマーを作成し、GUIX によって内部的に使用されているのと同じタイマー機能を利用できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-473">The application can create timers and utilize the same timer facility that is used internally by GUIX.</span></span> <span data-ttu-id="0f5ac-474">当然ながら、アプリケーションでは、必要に応じて ThreadX タイマーを直接作成して使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-474">Of course the application can also directly create and use ThreadX timers if required.</span></span> <span data-ttu-id="0f5ac-475">GUIX タイマーの利点は、非常に使いやすく、GUIX イベント ドリブン処理システム内で動作するように事前に構成されていることです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-475">The advantage of the GUIX timers is that they are very easy to use and are pre-configured to work within the GUIX event-driven processing system.</span></span>

<span data-ttu-id="0f5ac-476">GUIX タイマーを作成して開始するには、アプリケーションで関数 ***gx_system_timer_start*** を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-476">To create and start a GUIX timer, the application should invoke the function ***gx_system_timer_start***.</span></span> <span data-ttu-id="0f5ac-477">この関数へのパラメーターには、呼び出し元のウィジェットへのポインター、タイマー ID (1 つのウィジェットで多数のタイマーを開始できます)、初期タイムアウト値と再スケジュールのタイムアウト値が含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-477">The parameters to this function include a pointer to the calling widget, the timer id (allowing one widget to start many timers), and the initial and reschedule timeout values.</span></span> <span data-ttu-id="0f5ac-478">再スケジュールのタイムアウト値が 0 である場合、タイマーは 1 回だけ動作し、有効期限が切れるとアクティブなタイマーの一覧から自身を削除します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-478">If the reschedule timeout value is 0, the timer will only run one time and will delete itself from the active timer list once it expires.</span></span>

<span data-ttu-id="0f5ac-479">開始されると、GUIX タイマーは GX_EVENT_TIMEOUT イベントをタイマー所有者に、タイマーの再スケジュールの値に応じて 1 回または定期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-479">Once started, the GUIX timer will send GX_EVENT_TIMEOUT events to the timer owner, either once or periodically depending on the timer reschedule value.</span></span> <span data-ttu-id="0f5ac-480">GUIX タイマーは、API 関数 ***gx_system_timer_stop*** を呼び出すことによって停止できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-480">A GUIX timer can be stopped by calling the API function ***gx_system_timer_stop***.</span></span>

### <a name="pen-speed-configuration"></a><span data-ttu-id="0f5ac-481">ペン速度の構成</span><span class="sxs-lookup"><span data-stu-id="0f5ac-481">Pen Speed Configuration</span></span> 

<span data-ttu-id="0f5ac-482">GUIX システム コンポーネントでは、ペン速度の追跡に関連した構成情報を保持します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-482">The GUIX system component holds configuration information related to pen speed tracking.</span></span> <span data-ttu-id="0f5ac-483">GUIX では、タッチ入力ドライバー (存在する場合) によって生成された PEN_DOWN イベントの速度と距離に基づいて **GX_EVENT_VERTICAL_FLICK** および **GX_EVENT_HORIZONTAL_FLICK** イベントが内部的に生成されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-483">GUIX internally generated **GX_EVENT_VERTICAL_FLICK** and **GX_EVENT_HORIZONTAL_FLICK** events based on the speed and distance of PEN_DOWN events generated by the touch input driver, if any.</span></span> <span data-ttu-id="0f5ac-484">アプリケーションでは、**_gx_system_pen_configure_** API 関数を使用して、これらの内部的に生成されたイベントをトリガーするために必要な最小の距離と速度を構成できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-484">The application can configure the minimum distance and speed required to trigger these internally generated events using the **_gx_system_pen_configure_** API function.</span></span>

### <a name="screen-stack"></a><span data-ttu-id="0f5ac-485">画面スタック</span><span class="sxs-lookup"><span data-stu-id="0f5ac-485">Screen Stack</span></span> 

<span data-ttu-id="0f5ac-486">GUIX システム コンポーネントは、GUIX 画面スタックに関連したサービスを提供します。これは、アプリケーションが実行時に画面をプッシュ/ポップしたり、取得したりできる仮想ウィジェット スタックをサポートするオプション機能です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-486">The GUIX system component provides services related to the GUIX screen stack, which is an optional functionality supporting a virtual widget stack onto which screens can be pushed, popped, and retrieved at runtime by the application.</span></span> <span data-ttu-id="0f5ac-487">画面スタックは、ユーザーがメニュー システム内のさまざまな状態に多様なルートを通って到達する可能性のある、複雑なメニュー システムを管理するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-487">The screen stack is useful for managing complex menu systems, wherein the route by which the user may arrive at various states in the menu system is varied.</span></span> <span data-ttu-id="0f5ac-488">メニュー システム内の以前の状態への復帰は、まず以前の画面状態をプッシュしてから新しい画面を表示し、現在の画面が閉じられたら新しい画面で画面スタックから以前の状態をポップできるようにすることによって簡単に実行できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-488">Returning to the previous state in the menu system can be easily done by first pushing the previous screen state, then displaying the new screen, and allowing the new screen to pop the previous state from the screen stack when the current screen is dismissed.</span></span>

### <a name="clipboard-maintenance"></a><span data-ttu-id="0f5ac-489">クリップボードのメンテナンス</span><span class="sxs-lookup"><span data-stu-id="0f5ac-489">Clipboard Maintenance</span></span> 

<span data-ttu-id="0f5ac-490">GUIX では、ランタイム実行中にテキストのコピーと貼り付けを行うためのクリップボードをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-490">GUIX supports a clipboard for copying and pasting text during runtime execution.</span></span> <span data-ttu-id="0f5ac-491">このサポートは、GUIX システム コンポーネントによって提供されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-491">This support is provided by the GUIX System component.</span></span>

### <a name="dirty-list-maintenance"></a><span data-ttu-id="0f5ac-492">ダーティ リストのメンテナンス</span><span class="sxs-lookup"><span data-stu-id="0f5ac-492">Dirty List Maintenance</span></span> 

<span data-ttu-id="0f5ac-493">GUIX では、ダーティなウィジェット、つまり、表示されているが、状態変更のため、または新しく表示されるために再描画する必要があるウィジェットの一覧を保持しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-493">GUIX maintains a list of dirty widgets, meaning widgets that are visible and need to be redrawn due to status changes or being made newly visible.</span></span> <span data-ttu-id="0f5ac-494">このダーティ リストを使用すると、UI が変更されるたびにキャンバス更新を実行するのではなく、GUIX でキャンバス更新操作を 1 回実行するだけで UI の状態への現在のすべての変更を反映させることができるため、描画パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-494">This dirty list improves drawing performance by allowing GUIX to do one canvas refresh operation to reflect all current changes to the UI status, rather than doing a canvas refresh as each UI change is made.</span></span>
<span data-ttu-id="0f5ac-495">このダーティ リストもまた、GUIX システム コンポーネントによって管理されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-495">This dirty list is also maintained by the GUIX system component.</span></span>

### <a name="animation-control-block-pool"></a><span data-ttu-id="0f5ac-496">アニメーション コントロール ブロック プール</span><span class="sxs-lookup"><span data-stu-id="0f5ac-496">Animation Control Block Pool</span></span> 

<span data-ttu-id="0f5ac-497">アプリケーションは多くの場合、複数のアニメーション シーケンスを、たいていは並列に実行しようとします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-497">Applications often desire to execute multiple animation sequences, often in parallel.</span></span> <span data-ttu-id="0f5ac-498">GUIX では、アニメーション コントロール ブロックのプールを保持しており、アプリケーションはそこから割り当てて使用できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-498">GUIX maintains a pool of animation control blocks from which the application can allocate and use.</span></span> <span data-ttu-id="0f5ac-499">これにより、アプリケーションは、これらのコントロール ブロックの静的な定義から解放されます。アプリケーションで定義する可能性のあるアニメーションごとに固有のアニメーション コントロール ブロックを定義するのではなく、コントロール ブロックを何回も再利用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-499">This frees the application from statically defining these control blocks and allows them to be reused at different times, rather than defining a unique animation control block for every animation that the application might define.</span></span> <span data-ttu-id="0f5ac-500">アニメーション コントロール ブロック プールもまた、GUIX システム コンポーネントによって管理されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-500">The animation control block pool is also maintained by the GUIX system component.</span></span>

### <a name="system-error-handling"></a><span data-ttu-id="0f5ac-501">システム エラーの処理</span><span class="sxs-lookup"><span data-stu-id="0f5ac-501">System Error Handling</span></span> 

<span data-ttu-id="0f5ac-502">GUIX システム エラー ハンドラーは、アプリケーションが、API の観点からは特定しにくい可能性がある GUIX 内部のシステム エラーを検出できるよう支援することを目的にしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-502">The GUIX system error handler is intended to assist the application in finding internal system errors in GUIX that might be more difficult to determine from the API perspective.</span></span> <span data-ttu-id="0f5ac-503">GUIX の内部でシステム エラーが発生するたびに、内部の ***_gx_system_error_process*** 関数が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-503">Whenever a system error occurs inside of GUIX the internal ***_gx_system_error_process*** function is called.</span></span> <span data-ttu-id="0f5ac-504">この関数では、提供されたエラー コードを保存し、検出されたシステム エラーの合計数を増分します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-504">This function saves the error code provided and increments the total number of system errors detected.</span></span> <span data-ttu-id="0f5ac-505">システム エラーの変数は、次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-505">The system error variables are defined as follows:</span></span>

<span data-ttu-id="0f5ac-506">UINT **_gx_system_last_error**;</span><span class="sxs-lookup"><span data-stu-id="0f5ac-506">UINT **_gx_system_last_error**;</span></span>

<span data-ttu-id="0f5ac-507">ULONG **_gx_system_error_count**;</span><span class="sxs-lookup"><span data-stu-id="0f5ac-507">ULONG **_gx_system_error_count**;</span></span>

<span data-ttu-id="0f5ac-508">GUIX アプリケーションの動作がおかしい場合は、デバッガーでエラー カウント変数を確認してみると役立ちます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-508">If the GUIX application is behaving strangely, it is useful to look at the error count variable in the debugger.</span></span> <span data-ttu-id="0f5ac-509">これが設定されている場合は、問題の適切なトラブルシューティング方法として、***_gx_system_error_process*** 関数でブレークポイントを設定し、それがいつ、どこから呼び出されているかを確認します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-509">If it is set, a good way to troubleshoot the problem is to set a breakpoint in the ***_gx_system_error_process*** function and see when/where it is being called from.</span></span>

## <a name="guix-canvas-component"></a><span data-ttu-id="0f5ac-510">GUIX キャンバス コンポーネント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-510">GUIX Canvas Component</span></span>

<span data-ttu-id="0f5ac-511">キャンバス コンポーネントは、キャンバスに関連するすべての処理を担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-511">The canvas component is responsible for all canvas related processing.</span></span> <span data-ttu-id="0f5ac-512">キャンバスは、実質的には仮想フレーム バッファーです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-512">A canvas is effectively a virtual frame buffer.</span></span> <span data-ttu-id="0f5ac-513">アプリケーションでは、グラフィカル出力を生成するために、少なくとも 1 つのキャンバスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-513">Your application must create at least one canvas in order to produce graphical output.</span></span>
<span data-ttu-id="0f5ac-514">一般には、システムでサポートされている物理ディスプレイごとに少なくとも 1 つのキャンバスを作成します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-514">Typically, you would create at least one canvas for each physical display supported by your system.</span></span>

<span data-ttu-id="0f5ac-515">GUIX 描画はすべて、キャンバス上で実行されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-515">All GUIX drawing takes place on a canvas.</span></span> <span data-ttu-id="0f5ac-516">より単純な、またはメモリに制約のあるシステムでは、表示されるフレーム バッファーに直接リンクされた 1 つのキャンバスしか存在しない可能性があるのに対して、より多くのメモリがあり、グラフィックスの要件がより高度なシステムでは複数のキャンバスが必要になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-516">In simpler or memory constrained systems, there will likely be only one canvas which might be directly linked to the visible frame buffer, whereas systems with more memory and more advanced graphics requirements might require multiple canvases.</span></span> <span data-ttu-id="0f5ac-517">1 つのディスプレイで複数のキャンバスを使用できるようにすると、画面やウィンドウのフェード イン/フェード アウト効果などの機能が有効になります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-517">Making multiple canvases available for one display enables features such as screen and window fade-in and fade-out effects.</span></span>
<span data-ttu-id="0f5ac-518">キャンバスは、簡易またはマネージドの 2 つの主な種類のどちらかにすることができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-518">Canvases can be one of two main types, simple or managed.</span></span>

<span data-ttu-id="0f5ac-519">簡易キャンバスは、アプリケーションによって使用されるオフスクリーンの描画領域です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-519">A simple canvas is an off-screen drawing area used by the application.</span></span>
<span data-ttu-id="0f5ac-520">GUIX では簡易キャンバスを直接には操作しませんが、アプリケーションでは、簡易キャンバスを使用して複雑な描画をオフスクリーン バッファーにレンダリングした後、必要に応じてこのオフスクリーン バッファーを使用して、表示されるキャンバスを更新できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-520">GUIX does nothing directly with a simple canvas, but the application can use a simple canvas to render complex drawing to an off-screen buffer, and then use this off-screen buffer to refresh the visible canvas when needed.</span></span>

<span data-ttu-id="0f5ac-521">マネージド キャンバスは、GUIX によってハードウェア フレーム バッファー内に自動的に表示されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-521">A managed canvas is automatically displayed within the hardware frame buffer by GUIX.</span></span> <span data-ttu-id="0f5ac-522">マネージド キャンバスは、複数のマネージド キャンバスをサポートするための十分なメモリを備えたシステムでの合成キャンバスの構築に含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-522">A managed canvas is included in building a composite canvas for those systems with enough memory to support multiple managed canvases.</span></span> <span data-ttu-id="0f5ac-523">マネージド キャンバスには GUIX によって管理される Z オーダーがあり、すべてのマネージド キャンバスでビューのクリッピングが適用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-523">Managed canvases have a Z-order maintained by GUIX, and view clipping is enforced on all managed canvases.</span></span>

<span data-ttu-id="0f5ac-524">キャンバスは、より汎用的であるという点で、フレーム バッファーとは異なります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-524">A canvas differs from a frame buffer in that it is more generic.</span></span> <span data-ttu-id="0f5ac-525">メモリに制約のあるシステムでは、1 つのキャンバスしか存在しない可能性があり、このキャンバス用のメモリは表示されるフレーム バッファー メモリであることがあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-525">In memory constrained systems, there may be only one canvas and the memory for this canvas might be the visible frame buffer memory.</span></span> <span data-ttu-id="0f5ac-526">ただし、より高度なグラフィカル オーバーレイと複数のキャンバスをサポートしているより複雑なシステムの場合は、マネージド キャンバスのそれぞれに、ハードウェア フレーム バッファー メモリとは異なる独自のメモリ領域が割り当てられています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-526">However, for more complex systems supporting more advanced graphical overlays and multiple canvases, the managed canvases are each allocated their own memory areas which are distinct from the hardware frame buffer memory.</span></span>
<span data-ttu-id="0f5ac-527">これらのマネージド キャンバスは、フレーム バッファーの更新または切り替え操作中に、表示されるフレーム バッファーにレンダリングされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-527">These managed canvases are rendered into the visible frame buffer during the frame buffer refresh or toggle operation.</span></span>

<span data-ttu-id="0f5ac-528">複数のグラフィックス レイヤー (複数のオーバーレイされたフレーム バッファー) をサポートしているハードウェアの場合は、アプリケーションで ***gx_canvas_hardware_layer_bind*** API を使用して、1 つ以上のキャンバスをハードウェア グラフィックス レイヤーにバインドできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-528">For hardware supporting multiple graphics layers, i.e. multiple overlayed frame buffers, the application can bind one or more canvases to the hardware graphics layers using the ***gx_canvas_hardware_layer_bind*** API.</span></span> <span data-ttu-id="0f5ac-529">このサービスでは、キャンバスにそれが特定のハードウェア グラフィックス レイヤーにリンクされていることを通知します。リンクされると、このキャンバスでは、キャンバスの可視性 (</span><span class="sxs-lookup"><span data-stu-id="0f5ac-529">This service informs the canvas that it is linked to a particular hardware graphics layer, and once linked this canvas will attempt to utilize hardware support for canvas visibility (i.e</span></span> <span data-ttu-id="0f5ac-530">gx_canvas_show、gx_canvas_hide)、キャンバス アルファ ブレンド (***gx_canvas_alpha_set***)、ディスプレイ内のキャンバス オフセット (***gx_canvas_offset_set***) に対するハードウェア サポートを利用しようとします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-530">gx_canvas_show, gx_canvas_hide), canvas alpha blending (i.e. ***gx_canvas_alpha_set***) and canvas offset within the display (***gx_canvas_offset_set***).</span></span>

<span data-ttu-id="0f5ac-531">最も単純な単一キャンバスまたは単一フレーム バッファー構成以外のアーキテクチャの場合、キャンバスのサイズはアプリケーションによって決定されるため、フレーム バッファーの固定サイズとは異なる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-531">For architectures other than the simplest single canvas/single frame buffer organization, the size of a canvas is determined by the application and may be different than the fixed size of a frame buffer.</span></span>
<span data-ttu-id="0f5ac-532">また、アプリケーションによって選択されたオフセットに位置する可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-532">It may also be at an offset selected by the application.</span></span> <span data-ttu-id="0f5ac-533">その他の情報 (Z オーダーなど) はキャンバス内に保持されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-533">Other information, such as Z-order is maintained within the canvas.</span></span> <span data-ttu-id="0f5ac-534">キャンバスの描画が完了すると、そのキャンバスの内容は、ディスプレイ ドライバーによって物理ディスプレイに転送されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-534">When the canvas drawing is complete, the contents of the canvas are transferred to the physical display by the display driver.</span></span> <span data-ttu-id="0f5ac-535">個別のキャンバスおよびフレーム バッファー メモリ領域のための十分なメモリがない一部のシステムでは、キャンバス更新が実際には、ディスプレイ ドライバー経由で物理ディスプレイに対して直接行われます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-535">In some systems that don’t have enough memory for a separate canvas and frame buffer memory areas, the canvas update is actually made directly to the physical display via the display driver.</span></span>

### <a name="canvas-creation"></a><span data-ttu-id="0f5ac-536">キャンバスの作成</span><span class="sxs-lookup"><span data-stu-id="0f5ac-536">Canvas Creation</span></span> 

<span data-ttu-id="0f5ac-537">キャンバス オブジェクトは、初期化中に作成することも、アプリケーション スレッドの実行中の任意の時点で作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-537">A canvas object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="0f5ac-538">アプリケーションで作成できるキャンバス オブジェクトの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-538">There is no limit on the number of canvas objects that can be created by an application.</span></span> <span data-ttu-id="0f5ac-539">ただし、ほとんどのアプリケーションでは、すべての GUIX 描画のために 1 つのキャンバス オブジェクトのみを作成します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-539">Most applications, however, will create only one canvas object for all GUIX drawing.</span></span>

### <a name="canvas-control-block"></a><span data-ttu-id="0f5ac-540">キャンバス コントロール ブロック</span><span class="sxs-lookup"><span data-stu-id="0f5ac-540">Canvas Control Block</span></span> 

<span data-ttu-id="0f5ac-541">各キャンバス オブジェクトの特性は、そのコントロール ブロック **GX_CANVAS** 内にあり、**_gx_api.h_** で定義されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-541">The characteristics of each canvas object are found in its control block **GX_CANVAS** and is defined in **_gx_api.h_**.</span></span> <span data-ttu-id="0f5ac-542">キャンバス オブジェクトに必要なメモリはアプリケーションによって提供され、メモリ内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-542">The memory required for a canvas object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="0f5ac-543">ただし、キャンバス オブジェクト コントロール ブロックと描画領域は、すべての関数のスコープ外に定義することによってグローバル構造体にすることが最も一般的です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-543">However, it is most common to make the canvas object control block and the drawing area a global structure by defining them outside the scope of any function.</span></span>

### <a name="canvas-alpha-channel"></a><span data-ttu-id="0f5ac-544">キャンバス アルファ チャネル</span><span class="sxs-lookup"><span data-stu-id="0f5ac-544">Canvas Alpha Channel</span></span>

<span data-ttu-id="0f5ac-545">GUIX では、前景色と背景色の多くのレベルでのアルファ ブレンドをサポートしています。これには、ピクセルあたりのブレンド比率を指定するビットマップ アルファ チャネル、16 bpp 以上の色深度でブラシのブレンド比率を指定するブラシ アルファ、オーバーレイ キャンバスのブレンド比率を指定するキャンバス アルファが含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-545">GUIX supports alpha-blending of foreground and background colors on many levels, including bitmap alpha channel which specifies a blending ratio per pixel, brush alpha which specifies the blending ratio for a brush at 16 bpp and higher color depths, and canvas alpha which specifies the blending ratio for an overlay canvas.</span></span>

<span data-ttu-id="0f5ac-546">キャンバスのアルファ値は、フレーム バッファー内に表示するために合成されている複数のキャンバスが存在する場合に使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-546">The alpha value of a canvas is used when there are multiple canvases which are composited together for display within the frame buffer.</span></span> <span data-ttu-id="0f5ac-547">キャンバスの Z オーダーで、あるキャンバスが他のキャンバスの上になっている場合は、そのキャンバスを背後のキャンバスとブレンドするようにキャンバス アルファ値を設定できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-547">If the canvas Z-order is such that a canvas is above other canvases, then the canvas alpha value can be set to blend the canvas with those that lie behind.</span></span> <span data-ttu-id="0f5ac-548">キャンバスのアルファ値のすばやい変更は、"フェード イン" の画面の切り替え効果を実現するために使用されますが、キャンバス アルファは多くの方法で使用できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-548">Rapidly modifying the alpha value of a canvas is used to provide “fade in” screen transition effects, but the canvas alpha can be used in many ways.</span></span>

<span data-ttu-id="0f5ac-549">キャンバスが gx_canvas_hardware_layer_bind() を使用することによってハードウェア グラフィックス レイヤーにバインドされている場合、GUIX では、ハードウェア サポートを利用したキャンバス アルファ ブレンドを実装して、オーバーレイ キャンバスのブレンドに関連したソフトウェア オーバーヘッドを最小限に抑えようとします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-549">If a canvas is bound to a hardware graphics layer using gx_canvas_hardware_layer_bind(), GUIX will attempt to implement canvas alpha blending utilizing hardware support, minimizing the software overhead associated with blending an overlay canvas.</span></span>

<span data-ttu-id="0f5ac-550">アルファ値の範囲は 0 ～ 255 です。ここで、0 の値はそのピクセルが完全に透明であることを示し、0 を超える値は大きいほど透明度が低下します。キャンバス アルファ値は、キャンバス ブレンドに対するハードウェア支援が提供されていない限り、16 bpp 以上で実行されている画面ドライバーでしかサポートされません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-550">Alpha values range from 0 through 255, where a value of 0 means the pixel is fully transparent and values greater than 0 are increasing less transparent canvas alpha value can only be supported for screen drivers running at 16-bpp and higher unless hardware assistance for canvas blending is provided.</span></span>

### <a name="canvas-offset"></a><span data-ttu-id="0f5ac-551">キャンバス オフセット</span><span class="sxs-lookup"><span data-stu-id="0f5ac-551">Canvas Offset</span></span> 

<span data-ttu-id="0f5ac-552">キャンバスは、***gx_canvas_offset_set*** API サービスを呼び出すことによって、表示されるフレーム バッファー内のオフセットを設定できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-552">A canvas can be offset within the visible frame buffer by invoking the ***gx_canvas_offset_set*** API service.</span></span> <span data-ttu-id="0f5ac-553">キャンバス オフセットは通常、スプライト アニメーションを実装するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-553">Canvas offsets are usually used to implement sprite animations.</span></span> <span data-ttu-id="0f5ac-554">キャンバスが ***gx_canvas_hardware_layer_bind*** API 関数を呼び出すことによってハードウェア グラフィックス レイヤーにバインドされている場合、GUIX では、ハードウェア サポートを利用したキャンバス オフセットの変更を実装して、キャンバス位置のシフトに関連したソフトウェア オーバーヘッドを最小限に抑えようとします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-554">If a canvas is bound to a hardware graphics layer by invoking the ***gx_canvas_hardware_layer_bind*** API function, GUIX will attempt to implement canvas offset changes utilizing hardware support, minimizing the software overhead associated with shifting the canvas position.</span></span>

### <a name="canvas-drawing"></a><span data-ttu-id="0f5ac-555">キャンバスの描画</span><span class="sxs-lookup"><span data-stu-id="0f5ac-555">Canvas Drawing</span></span> 

<span data-ttu-id="0f5ac-556">GUIX キャンバス コンポーネントは、アプリケーションに完全な描画 API を提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-556">The GUIX canvas component provides a full drawing API to the application.</span></span> <span data-ttu-id="0f5ac-557">***gx_canvas_line_draw*** や ***gx_canvas_pixelmap_draw*** などの描画 API を呼び出すには、***gx_canvas_drawing_initiate*** API 関数を呼び出すことによって、ターゲット キャンバスを描画用に開いておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-557">Before the drawing APIs such as ***gx_canvas_line_draw*** or ***gx_canvas_pixelmap_draw*** can be invoked, the target canvas must be opened for drawing by invoking the ***gx_canvas_drawing_initiate*** API function.</span></span> <span data-ttu-id="0f5ac-558">この関数では描画用のキャンバスを準備し、"***描画コンテキスト***" を作成します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-558">This function prepares a canvas for drawing and creates a ***drawing context***.</span></span>

<span data-ttu-id="0f5ac-559">キャンバスにレンダリングする描画 API (***gx_canvas_line_draw** _ や _*_gx_canvas_text_draw_\*_ など) では、現在の描画コンテキスト内のブラシのパラメーターを使用して線のスタイル、幅、色を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-559">The drawing APIs that render to the canvas, such as ***gx_canvas_line_draw** _ or _*_gx_canvas_text_draw_\*_, use parameters found in the current drawing context brush to define the line style, width, and colors.</span></span> <span data-ttu-id="0f5ac-560">これらのブラシ パラメーターは、_*_gx_canvas_drawing_initiate_*\* を呼び出すことによって描画コンテキストが確立された後に、_*_gx_context_brush_define_*_、 _*_gx_context_brush_set_\*\*、\*\*\*gx_context_brush_style_set*\*_ や同様の API 関数を呼び出すことによって変更されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-560">These brush parameters are modified by calling the _*_gx_context_brush_define_*_, _\*_gx_context_brush_set_\*\*, \***gx_context_brush_style_set**_, and similar API functions after a drawing context has been established by calling _\*_gx_canvas_drawing_initiate_\*\*.</span></span>

<span data-ttu-id="0f5ac-561">GUIX が遅延キャンバス更新操作の一部としてウィンドウおよびウィジェット描画関数を呼び出すと、そのウィジェット描画関数を呼び出す前に、ターゲット キャンバスが描画用に開かれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-561">When GUIX invokes the window and widget drawing functions as part of a deferred canvas refresh operation, the target canvas is opened for drawing prior to calling the widget drawing function(s).</span></span> <span data-ttu-id="0f5ac-562">そのため、標準のウィジェット描画関数でターゲット キャンバスを開く必要はありません。これは自動的に実行されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-562">Therefore the standard widget drawing functions are not required to open the target canvas, this has been done for them.</span></span>

<span data-ttu-id="0f5ac-563">場合によっては、アプリケーションでキャンバスへの強制的な即時描画が必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-563">In some cases the application may want to force immediate drawing to a canvas.</span></span> <span data-ttu-id="0f5ac-564">この場合、アプリケーションでは次の手順を実行できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-564">In this case, the application can perform the following steps.</span></span>

1. <span data-ttu-id="0f5ac-565">***gx_canvas_drawing_initiate*** API 関数を呼び出し、ターゲット キャンバスと、アプリケーションで描画するそのキャンバス内の四角形を渡します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-565">Call the ***gx_canvas_drawing_initiate*** API function, passing in the target canvas and rectangle within that canvas on which the application wants to draw.</span></span> 

2. <span data-ttu-id="0f5ac-566">任意の数のキャンバス描画 API を呼び出して、目的の描画を実現します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-566">Call any number of canvas drawing APIs to accomplish the desired drawing.</span></span>

3. <span data-ttu-id="0f5ac-567">***gx_canvas_drawing_complete*** API 関数を呼び出して、描画が完了したことを通知します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-567">Call the ***gx_canvas_drawing_complete*** API function to signal that drawing has been completed.</span></span> <span data-ttu-id="0f5ac-568">これにより、システムのメモリ アーキテクチャに応じて、表示されるフレーム バッファーにキャンバスがフラッシュされるか、またはバッファーの切り替え操作がトリガーされるか、あるいはその両方が行われます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-568">This flushes the canvas to the visible frame buffer and/or triggers a buffer toggle operation, depending on the system memory architecture.</span></span>

### <a name="drawing-apis"></a><span data-ttu-id="0f5ac-569">描画 API</span><span class="sxs-lookup"><span data-stu-id="0f5ac-569">Drawing APIs</span></span> 

<span data-ttu-id="0f5ac-570">すべてのビジュアル要素を画面上に描画するために GUIX に必要な、いくつかのプリンシパル描画プリミティブが存在します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-570">There are several principal drawing primitives that are required by GUIX to draw all the visual elements on the screen.</span></span> <span data-ttu-id="0f5ac-571">これらの描画 API は、通常はカスタム ウィジェット描画関数の一部として、アプリケーション ソフトウェアでも呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-571">These drawing APIs can also be invoked by application software, usually as part of a custom widget drawing function.</span></span> <span data-ttu-id="0f5ac-572">これらの GUIX キャンバス描画 API では、パラメーターの検証とクリッピングを実行した後、クリップされた描画座標を、ハードウェアと色形式固有の描画の実装のためにディスプレイ ドライバーに渡します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-572">These GUIX canvas drawing APIs perform parameter validation and clipping, and then pass the clipped drawing coordinates down to the display driver for hardware and color-format specific drawing implementations.</span></span> <span data-ttu-id="0f5ac-573">これらの描画 API 関数は、次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-573">These drawing API functions are defined as follows.</span></span>

- <span data-ttu-id="0f5ac-574">gx_canvas_alpha_set</span><span class="sxs-lookup"><span data-stu-id="0f5ac-574">gx_canvas_alpha_set</span></span>
- <span data-ttu-id="0f5ac-575">gx_canvas_arc_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-575">gx_canvas_arc_draw</span></span>
- <span data-ttu-id="0f5ac-576">gx_canvas_block_move</span><span class="sxs-lookup"><span data-stu-id="0f5ac-576">gx_canvas_block_move</span></span>
- <span data-ttu-id="0f5ac-577">gx_canvas_circle_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-577">gx_canvas_circle_draw</span></span>
- <span data-ttu-id="0f5ac-578">gx_canvas_ellipse_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-578">gx_canvas_ellipse_draw</span></span>
- <span data-ttu-id="0f5ac-579">gx_canvas_glyphs_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-579">gx_canvas_glyphs_draw</span></span>
- <span data-ttu-id="0f5ac-580">gx_canvas_hardware_layer_bind</span><span class="sxs-lookup"><span data-stu-id="0f5ac-580">gx_canvas_hardware_layer_bind</span></span>
- <span data-ttu-id="0f5ac-581">gx_canvas_hide</span><span class="sxs-lookup"><span data-stu-id="0f5ac-581">gx_canvas_hide</span></span>
- <span data-ttu-id="0f5ac-582">gx_canvas_line_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-582">gx_canvas_line_draw</span></span>
- <span data-ttu-id="0f5ac-583">gx_canvas_offset_set</span><span class="sxs-lookup"><span data-stu-id="0f5ac-583">gx_canvas_offset_set</span></span>
- <span data-ttu-id="0f5ac-584">gx_canvas_pie_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-584">gx_canvas_pie_draw</span></span>
- <span data-ttu-id="0f5ac-585">gx_canvas_pixel_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-585">gx_canvas_pixel_draw</span></span>
- <span data-ttu-id="0f5ac-586">gx_canvas_pixelmap_blend</span><span class="sxs-lookup"><span data-stu-id="0f5ac-586">gx_canvas_pixelmap_blend</span></span>
- <span data-ttu-id="0f5ac-587">gx_canvas_pixelmap_rotate</span><span class="sxs-lookup"><span data-stu-id="0f5ac-587">gx_canvas_pixelmap_rotate</span></span>
- <span data-ttu-id="0f5ac-588">gx_canvas_pixelmap_tile</span><span class="sxs-lookup"><span data-stu-id="0f5ac-588">gx_canvas_pixelmap_tile</span></span>
- <span data-ttu-id="0f5ac-589">gx_canvas_polygon_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-589">gx_canvas_polygon_draw</span></span>
- <span data-ttu-id="0f5ac-590">gx_canvas_rectangle_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-590">gx_canvas_rectangle_draw</span></span>
- <span data-ttu-id="0f5ac-591">gx_canvas_rotated_text_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-591">gx_canvas_rotated_text_draw</span></span>
- <span data-ttu-id="0f5ac-592">gx_canvas_shift</span><span class="sxs-lookup"><span data-stu-id="0f5ac-592">gx_canvas_shift</span></span>
- <span data-ttu-id="0f5ac-593">gx_canvas_show</span><span class="sxs-lookup"><span data-stu-id="0f5ac-593">gx_canvas_show</span></span>
- <span data-ttu-id="0f5ac-594">gx_canvas_text_draw</span><span class="sxs-lookup"><span data-stu-id="0f5ac-594">gx_canvas_text_draw</span></span>

<span data-ttu-id="0f5ac-595">描画 API は GUIX Canvas API 経由で呼び出され、すべての描画が gx_canvas_\* API 関数を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-595">The drawing API is invoked via the GUIX Canvas API, and all drawing is done using gx_canvas_\* API functions.</span></span> <span data-ttu-id="0f5ac-596">描画は、現在の描画コンテキスト内の現在のブラシを使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-596">Drawing is done using the current brush in the current drawing context.</span></span> <span data-ttu-id="0f5ac-597">上記のどの図形描画関数でも、現在のブラシの定義に従って、輪郭の描画、単色塗りつぶし、またはピクセルマップ塗りつぶしを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-597">Any of the shape drawing functions above can be outlined, solid color filled, or pixelmap filled as defined by the current brush.</span></span> <span data-ttu-id="0f5ac-598">図形の輪郭の幅、色、または塗りつぶしを変更するには、gx_context_brush_\* API 関数を使用して、現在の描画コンテキスト内のブラシを定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-598">To modify the shape outline width, color, or fill, use the gx_context_brush_\* API functions to define the brush within the current drawing context.</span></span>

<span data-ttu-id="0f5ac-599">上記のアプリケーション レベルの描画 API ではキャンバスへの実際の描画を行わず、代わりに、ディスプレイ ドライバー レベルの描画関数を呼び出す前に呼び出し元のパラメーターを確認します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-599">The above application level drawing APIs don’t do actual drawing to the canvas, but instead verify the caller’s parameters before invoking the display driver level drawing function.</span></span> <span data-ttu-id="0f5ac-600">ドライバー レベルの描画関数では、実際にピクセル データをキャンバス メモリに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-600">The driver level drawing function actually writes pixel data into the canvas memory.</span></span>

<span data-ttu-id="0f5ac-601">GUIX は、1、2、4、8、16、24、32 ビット/ピクセル (bpp) を含む、さまざまな色深度のためのストックまたは汎用のディスプレイ ドライバー描画関数を提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-601">GUIX provides stock or generic display driver drawing functions for various color depths, including 1, 2, 4, 8, 16, 24, and 32 bits per pixel (bpp).</span></span> <span data-ttu-id="0f5ac-602">場合によっては、既定のソフトウェアによる描画の実装が、2D 描画アクセラレータを提供するハードウェア ターゲット向けのハードウェア アクセラレータによる実装に置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-602">In some cases, the default software drawing implementation is replaced by hardware-accelerated implementations for those hardware targets that provide a 2D drawing accelerator.</span></span>

### <a name="color-depth"></a><span data-ttu-id="0f5ac-603">色の解像度</span><span class="sxs-lookup"><span data-stu-id="0f5ac-603">Color Depth</span></span> 

<span data-ttu-id="0f5ac-604">GUIX では、最大 32 bpp の色深度のほか、モノクロとグレースケールをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-604">GUIX supports color depths up to 32-bpp as well as monochrome and grayscale.</span></span> <span data-ttu-id="0f5ac-605">色深度のサポートの種類は主に、基になる物理ディスプレイの機能によって決定され、キャンバスの描画領域に必要なメモリの量にも影響を与えます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-605">The type of color depth support largely determined by the capabilities of the underlying physical display and also has an impact on how much memory is required for the canvas drawing area.</span></span> <span data-ttu-id="0f5ac-606">色深度のサポートの一覧を、その色深度内でのバリエーションの簡単な説明と共に次に示します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-606">The following is a list of color depth support along with a brief description of the variations within that color depth.</span></span>

| <span data-ttu-id="0f5ac-607">色&nbsp;形式</span><span class="sxs-lookup"><span data-stu-id="0f5ac-607">Color&nbsp;Format</span></span>       | <span data-ttu-id="0f5ac-608">説明</span><span class="sxs-lookup"><span data-stu-id="0f5ac-608">Description</span></span>                                                                                                   |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="0f5ac-609">1 ビット モノクロ</span><span class="sxs-lookup"><span data-stu-id="0f5ac-609">1-bit monochrome</span></span>   | <span data-ttu-id="0f5ac-610">1 ビット/ピクセルの圧縮形式。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-610">1-bit per pixel packed format.</span></span>                                                                                                   |
| <span data-ttu-id="0f5ac-611">2 ビット グレースケール</span><span class="sxs-lookup"><span data-stu-id="0f5ac-611">2-bit grayscale</span></span>    | <span data-ttu-id="0f5ac-612">4 つのグレー レベル、圧縮された 4 ピクセル/バイト。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-612">4 gray levels, packed four pixels per byte.</span></span>                                                                                      |
| <span data-ttu-id="0f5ac-613">4 ビット グレースケール</span><span class="sxs-lookup"><span data-stu-id="0f5ac-613">4-bit grayscale</span></span>    | <span data-ttu-id="0f5ac-614">16 のグレー レベル、圧縮された 2 ピクセル/バイト。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-614">16 gray levels, packed two pixels per byte.</span></span>                                                                                      |
| <span data-ttu-id="0f5ac-615">4 ビット カラー</span><span class="sxs-lookup"><span data-stu-id="0f5ac-615">4-bit color</span></span>        | <span data-ttu-id="0f5ac-616">VGA 形式の平面メモリ構成。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-616">A VGA format planar memory organization.</span></span>                                                                                         |
| <span data-ttu-id="0f5ac-617">8 ビット グレースケール</span><span class="sxs-lookup"><span data-stu-id="0f5ac-617">8-bit grayscale</span></span>    | <span data-ttu-id="0f5ac-618">256 のグレー レベル</span><span class="sxs-lookup"><span data-stu-id="0f5ac-618">256 gray levels</span></span>                                                                                                                  |
| <span data-ttu-id="0f5ac-619">8 ビット パレット モード</span><span class="sxs-lookup"><span data-stu-id="0f5ac-619">8-bit palette mode</span></span> | <span data-ttu-id="0f5ac-620">パレット インデックスとして使用される 1 バイト/ピクセル</span><span class="sxs-lookup"><span data-stu-id="0f5ac-620">1 byte per pixel used as palette index</span></span>                                                                                           |
| <span data-ttu-id="0f5ac-621">8 ビット r:g:b モード</span><span class="sxs-lookup"><span data-stu-id="0f5ac-621">8-bit r:g:b mode</span></span>   | <span data-ttu-id="0f5ac-622">使用頻度の低い 2:3:2 r:g:b 形式。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-622">A less commonly used 2:3:2 r:g:b format.</span></span>                                                                                         |
| <span data-ttu-id="0f5ac-623">16 ビット</span><span class="sxs-lookup"><span data-stu-id="0f5ac-623">16-bit</span></span>             | <span data-ttu-id="0f5ac-624">各ピクセルに 2 バイトが必要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-624">Each pixel requires two bytes.</span></span> <span data-ttu-id="0f5ac-625">r:g:b または b:g:r のバイト順にできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-625">Can be r:g:b or b:g:r byte order.</span></span> <span data-ttu-id="0f5ac-626">通常は 5:6:5 構造ですが、5:5:5 構造または 4:4:4:4 a:r:g:b 構造にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-626">Normally 5:6:5 structure, but can also be 5:5:5 structure or 4:4:4:4 a:r:g:b structure.</span></span> |
| <span data-ttu-id="0f5ac-627">24 ビット</span><span class="sxs-lookup"><span data-stu-id="0f5ac-627">24-bit</span></span>             | <span data-ttu-id="0f5ac-628">各ピクセルに 3 (圧縮形式) または 4 (非圧縮形式) バイトが必要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-628">Each pixel requires 3 (packed format) or 4 (unpacked format) bytes.</span></span> <span data-ttu-id="0f5ac-629">ハードウェアの必要に応じて、r:g:b または b:g:r のバイト順にできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-629">Can be in r:g:b or b:g:r byte order as required by hardware.</span></span> |
| <span data-ttu-id="0f5ac-630">32 ビット</span><span class="sxs-lookup"><span data-stu-id="0f5ac-630">32-bit</span></span>             | <span data-ttu-id="0f5ac-631">各ピクセルにアルファ チャネルを含む 4 バイトが必要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-631">Each pixel requires 4 bytes with an alpha channel.</span></span> <span data-ttu-id="0f5ac-632">a:r:g:b または b:g:r: のバイト順にでき、ハードウェアによって決定されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-632">Can be a:r:g:b or b:g:r:a byte order and determined by hardware.</span></span>              |

### <a name="mouse-support"></a><span data-ttu-id="0f5ac-633">マウスのサポート</span><span class="sxs-lookup"><span data-stu-id="0f5ac-633">Mouse Support</span></span> 

<span data-ttu-id="0f5ac-634">GUIX では、任意の希望するキャンバスへのマウス カーソルの描画をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-634">GUIX supports drawing a mouse cursor on any desired canvas.</span></span> <span data-ttu-id="0f5ac-635">マウス カーソルはソフトウェアで描画できます。または、ハードウェア カーソル オーバーレイでサポートされる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-635">The mouse cursor can be drawing in software or might be supported by hardware cursor overlay.</span></span> <span data-ttu-id="0f5ac-636">どちらにしても、マウス カーソルのサポートに関してアプリケーションに提供される API は、ソフトウェアまたはハードウェアのどちらのマウス カーソル描画を使用していても同じです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-636">In either case, the API provided to the application related to mouse cursor support is the same whether using software or hardware mouse cursor drawing.</span></span>

<span data-ttu-id="0f5ac-637">GUIX でのマウスのサポートは、GUIX ライブラリを構築する前に gx_user.h ヘッダー ファイルで `#define GX_MOUSE_SUPPORT` が定義されている場合にのみ有効になります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-637">GUIX mouse support is only enabled if the `#define GX_MOUSE_SUPPORT` is defined in the gx_user.h header file before building the GUIX library.</span></span>

<span data-ttu-id="0f5ac-638">アプリケーションでは、***gx_canvas_mouse_define*** API 関数を使用して、マウス カーソルとホットスポットを定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-638">The application must define the mouse cursor and hotspot using the ***gx_canvas_mouse_define*** API function.</span></span> <span data-ttu-id="0f5ac-639">この API では、カーソル イメージが描画されるキャンバスへのポインターと、マウス カーソル イメージとそのイメージの左上隅を基準としたマウス イメージのホットスポットを定義する **GX_MOUSE_CURSOR_INFO** 構造体へのポインターを受け付けます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-639">This API accepts a pointer to the canvas on which the cursor image should be drawn, and a pointer to a **GX_MOUSE_CURSOR_INFO** structure, which defines the mouse cursor image and hotspot of the mouse image relative the image top-left corner.</span></span>

## <a name="guix-display-component"></a><span data-ttu-id="0f5ac-640">GUIX ディスプレイ コンポーネント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-640">GUIX Display Component</span></span> 

<span data-ttu-id="0f5ac-641">ディスプレイ コンポーネントは、内部に 1 つ以上のキャンバス、ウィジェット、ウィンドウを含むすべてのディスプレイ オブジェクトの処理を管理するため、GUIX の基本コンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-641">The display component is fundamental in GUIX, since it manages the processing of all display objects, which in themselves contain one or more canvases, widgets, and windows.</span></span> <span data-ttu-id="0f5ac-642">ディスプレイ コンポーネントはまた、一連の関数ポインター経由で各ディスプレイに関連付けられている基になるハードウェア画面ドライバーも操作します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-642">The display component also interacts with the underlying hardware screen driver associated with each display through a series of function pointers.</span></span>

### <a name="display-creation"></a><span data-ttu-id="0f5ac-643">ディスプレイの作成</span><span class="sxs-lookup"><span data-stu-id="0f5ac-643">Display Creation</span></span> 

<span data-ttu-id="0f5ac-644">ディスプレイ オブジェクトは、初期化中に作成することも、アプリケーション スレッドの実行中の任意の時点で作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-644">A display object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="0f5ac-645">通常、アプリケーションでは、各物理画面を管理するために 1 つのディスプレイ オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-645">Typically an application creates one display object to manage each physical screen.</span></span> <span data-ttu-id="0f5ac-646">使用可能なアプリケーションと物理ディスプレイを定義するために GUIX Studio を使用したことがある場合は、gx_studio_display_configure API 関数を使用して、各ディスプレイを作成および初期化します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-646">If you have used GUIX Studio to define your application and the physical displays available, you will use the gx_studio_display_configure API function to create and initialize each of your displays.</span></span>

### <a name="display-control-block"></a><span data-ttu-id="0f5ac-647">ディスプレイ コントロール ブロック</span><span class="sxs-lookup"><span data-stu-id="0f5ac-647">Display Control Block</span></span> 

<span data-ttu-id="0f5ac-648">各ディスプレイ オブジェクトの特性は、そのコントロール ブロック ***GX_DISPLAY** _ 内にあり、_*_gx_api.h_\*\* で定義されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-648">The characteristics of each display object are found in its control block ***GX_DISPLAY** _ and are defined in _*_gx_api.h_\*\*.</span></span> <span data-ttu-id="0f5ac-649">ディスプレイ オブジェクトに必要なメモリはアプリケーションによって提供され、メモリ内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-649">The memory required for a display object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="0f5ac-650">ただし、ディスプレイ コントロール ブロックは、すべての関数のスコープ外に定義することによってグローバル構造体にすることが最も一般的です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-650">However, it is most common to make the display control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="resource-management"></a><span data-ttu-id="0f5ac-651">リソース管理</span><span class="sxs-lookup"><span data-stu-id="0f5ac-651">Resource Management</span></span> 

<span data-ttu-id="0f5ac-652">リソースは、アプリケーションで必要な UI コンポーネントですが、アプリケーション コードではありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-652">Resources are UI components that are needed by the application, but they are not application code.</span></span> <span data-ttu-id="0f5ac-653">リソースはアプリケーション データであり、通常は静的に定義されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-653">Resources are application data and are usually statically defined.</span></span> <span data-ttu-id="0f5ac-654">リソースの種類には、ピクセルマップ、フォント、色、文字列が含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-654">Resource types include pixelmaps, fonts, colors, and strings.</span></span> <span data-ttu-id="0f5ac-655">これらのリソースは、通常はどのアプリケーション ソフトウェアも変更することなく、いつでも変更できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-655">These resources can be changed at any time, usually without changing any application software.</span></span> <span data-ttu-id="0f5ac-656">アプリケーション ソフトウェアを変更するには通常、そのソフトウェアの関連する再テストと検証が必要になるため、リソースの格納やリソースへの参照をアプリケーション ソフトウェアから分離された状態に維持することにより、UI の外観をアプリケーション コードの変更なしで変更できるようにすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-656">It is important to keep the storage of and references to resources separated from the application software to allow changing UI appearance without changing application code since changes to the application software usually require the associated re-testing and verification of that software.</span></span>

<span data-ttu-id="0f5ac-657">GUIX の ***display*** モジュールは、ディスプレイの色深度および形式に依存しているすべてのリソースのリソース管理機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-657">The GUIX ***display*** module provides resource management facilities for all resources that are dependent on the color depth and format of the display.</span></span> <span data-ttu-id="0f5ac-658">これらの機能には、アクティブなピクセルマップ テーブル、アクティブなフォント テーブル、アクティブなカラー テーブルの管理が含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-658">These facilities include maintaining the active pixelmap table, active font table, and active color table.</span></span> <span data-ttu-id="0f5ac-659">文字列リソースは通常、色深度および形式に基づいて変更する必要がないため、文字列テーブル リソースは GUIX システム モジュールによって管理されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-659">The string table resource is maintained by the GUIX system module, since string resources do not normally need to be changed based on color depth and format.</span></span>

<span data-ttu-id="0f5ac-660">アプリケーション ソフトウェアでは、対応するリソース テーブルへのインデックスであるリソース ID でリソースを参照します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-660">The application software references resources by their resource Id, which is an index into the corresponding resource table.</span></span> <span data-ttu-id="0f5ac-661">これにより、そのテーブルを変更できるようになります。たとえば、製品が "日中モード" から "夜間モード" に変わるとカラー テーブルが変更される可能性がありますが、カラー ID 値は同じままになります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-661">This allows the table to be changed, for example the color table might be changed when a product changes from “day mode” to “night mode”, but the color ID values to remain the same.</span></span>

<span data-ttu-id="0f5ac-662">アプリケーション リソースは、GUIX Studio アプリケーションによってリソース ファイル (または一連のリソース ファイル) に書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-662">Your application resources are written to a resource file (or set of resource files) by the GUIX Studio application.</span></span> <span data-ttu-id="0f5ac-663">新しい GUIX Studio プロジェクトを作成すると、既定の色、ピクセルマップ、フォントが自動的に提供されますが、これらの既定値は、アプリケーションの外観を定義するときに簡単に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-663">Default colors, pixelmaps, and fonts are provided automatically when you create a new GUIX Studio project, but these defaults are easily replaced as you define the look and feel of your application.</span></span>

<span data-ttu-id="0f5ac-664">色、フォント、ピクセルマップのリソース ID は、アクティブなディスプレイ コンポーネントが認識されるまで実際の色、フォント、またはピクセルマップの値に解決できない点に注意することが重要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-664">It is important to note that Resource IDs for colors, fonts, and pixelmaps cannot be resolved to their actual color, font, or pixelmap values until the active Display component is known.</span></span> <span data-ttu-id="0f5ac-665">GUIX のアーキテクチャでは複数のアクティブなディスプレイをサポートしているため、リソース ID をリソース値に解決できるのは、ウィジェットとそれに関連付けられたリソース ID を特定のディスプレイに解決できる場合だけです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-665">Since the GUIX architecture supports multiple active displays, Resource IDs can only be resolved to resource values when a widget and its associated Resource ID can be resolved to a specific display.</span></span> <span data-ttu-id="0f5ac-666">この性質は動的バインドと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-666">This property is known as dynamic binding.</span></span> <span data-ttu-id="0f5ac-667">テキストの色などのプロパティのリソース ID (リソース ID **GX_COLOR_ID_TEXT** など) は、あるディスプレイで使用されるときは白の 16 ビット R:G:B 値に解決される可能性がありますが、別のディスプレイで使用されるときは同じカラー ID がモノクロの黒のカラー値に解決される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-667">The Resource ID for a property such as a text color, for example the resource ID **GX_COLOR_ID_TEXT,** might resolve to a 16-bit R:G:B value for white when used on one display, but the same color ID might resolve to a monochrome black color value when used on another display.</span></span>

<span data-ttu-id="0f5ac-668">実際には、このリソース ID のリソース値への動的バインドは、アプリケーション ソフトウェアと GUIX 内部コンポーネントではほとんどの場合、アクティブな描画コンテキスト内でのみリソース ID をリソース値に解決することを示しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-668">In practice this dynamic binding of Resources IDs to resource values means that application software and GUIX internal components should most often only resolve Resource IDs to resource values within an active drawing context.</span></span> <span data-ttu-id="0f5ac-669">アクティブな描画コンテキストは、現在アクティブなディスプレイを指定するため、GUIX で各リソース ID を特定のリソース値に解決できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-669">An active drawing context specifies the currently active display, which allows GUIX to resolve each Resource ID to a specific resource value.</span></span> <span data-ttu-id="0f5ac-670">アプリケーション ソフトウェアで、描画コンテキストの外部にある特定のリソース値を検索する必要がある場合は、これを表示されるウィジェットに対しても実行できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-670">If the application software is required to find a specific resource value outside of a drawing context, this can also be done for visible widgets.</span></span> <span data-ttu-id="0f5ac-671">表示されるウィジェットは、同様にそのウィジェットのアクティブなキャンバスとディスプレイを解決するために使用できるルート ウィンドウにリンクされています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-671">Visible widgets are linked to a root window which can also be used to resolve the active canvas and display for that widget.</span></span>

<span data-ttu-id="0f5ac-672">ウィジェットが作成されたが、まだ表示されていない (つまり、ルート ウィンドウまたはその他の表示される親にリンクされていていない) 場合は、そのウィジェットに関連付けられているどのリソース ID も、特定のディスプレイに割り当てられたリソース テーブルへのインデックスを直接作成する以外の方法で特定のリソース値に解決することはできません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-672">If a widget has been created but not yet displayed (i.e., has not been linked to any root window or other visible parent), any resource IDs associated with that widget cannot be resolved to a specific resource value other than by directly indexing into the resource table assigned to a specific display.</span></span> <span data-ttu-id="0f5ac-673">特定のリソース テーブルへのこの直接のアクセスはアプリケーション ソフトウェアで安全に実行できますが、内部の GUIX ライブラリ ソフトウェアで実行されることはありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-673">This direct access to a specific resource table can safely be done by the application software, but is never done in the internal GUIX library software.</span></span>

### <a name="widget-defaults"></a><span data-ttu-id="0f5ac-674">ウィジェットの既定値</span><span class="sxs-lookup"><span data-stu-id="0f5ac-674">Widget Defaults</span></span> 

<span data-ttu-id="0f5ac-675">GUIX ディスプレイ コンポーネントはまた、さまざまなウィジェット属性の既定の定義も提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-675">The GUIX display component also provides default definitions for various widget attributes.</span></span> <span data-ttu-id="0f5ac-676">アプリケーションによって特に指定されない限り、ウィジェットまたはウィンドウは、これらのシステム属性を使用して作成されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-676">Unless otherwise specified by the application, widgets/windows are created with these system attributes.</span></span> <span data-ttu-id="0f5ac-677">これらのシステム属性は主に、システム リソース テーブル内に保持されているフォント、色、ビットマップで構成されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-677">These system attributes are mainly composed of fonts, colors, and bitmaps maintained in the system resource tables.</span></span> <span data-ttu-id="0f5ac-678">既定のスクロール バーの外観の追加の属性もまた、GUIX ディスプレイ コンポーネントによって管理されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-678">Additional attributes for default scrollbar appearance are also maintained by the GUIX display component.</span></span>

<span data-ttu-id="0f5ac-679">既定の色設定は、各ディスプレイに割り当てられたカラー テーブルと、事前に定義された既定のカラー ID によって定義されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-679">The default color settings are defined by the color table assigned to each display and the pre-defined default color IDs.</span></span> <span data-ttu-id="0f5ac-680">これらの既定のカラー ID には、次のものが含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-680">These default color ids include the following.</span></span>

| <span data-ttu-id="0f5ac-681">カラー ID</span><span class="sxs-lookup"><span data-stu-id="0f5ac-681">Color ID</span></span> | <span data-ttu-id="0f5ac-682">説明</span><span class="sxs-lookup"><span data-stu-id="0f5ac-682">Description</span></span> |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="0f5ac-683">GX_COLOR_ID_CANVAS</span><span class="sxs-lookup"><span data-stu-id="0f5ac-683">GX_COLOR_ID_CANVAS</span></span> | <span data-ttu-id="0f5ac-684">既定のキャンバス (つまり、ディスプレイの背景) の色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-684">Default canvas (i.e. display background) color</span></span> |
| <span data-ttu-id="0f5ac-685">GX_COLOR_ID_WIDGET_FILL</span><span class="sxs-lookup"><span data-stu-id="0f5ac-685">GX_COLOR_ID_WIDGET_FILL</span></span> | <span data-ttu-id="0f5ac-686">既定のウィジェットの塗りつぶしの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-686">Default widget fill color</span></span> |
| <span data-ttu-id="0f5ac-687">GX_COLOR_ID_WINDOW_FILL</span><span class="sxs-lookup"><span data-stu-id="0f5ac-687">GX_COLOR_ID_WINDOW_FILL</span></span> | <span data-ttu-id="0f5ac-688">既定のウィンドウの塗りつぶしの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-688">Default window fill color</span></span> |
| <span data-ttu-id="0f5ac-689">GX_COLOR_ID_DISABLED_FILL</span><span class="sxs-lookup"><span data-stu-id="0f5ac-689">GX_COLOR_ID_DISABLED_FILL</span></span> | <span data-ttu-id="0f5ac-690">既定の無効になっているウィジェットの塗りつぶしの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-690">Default disabled widget fill color</span></span> |
| <span data-ttu-id="0f5ac-691">GX_COLOR_ID_DEFAULT_BORDER</span><span class="sxs-lookup"><span data-stu-id="0f5ac-691">GX_COLOR_ID_DEFAULT_BORDER</span></span> | <span data-ttu-id="0f5ac-692">既定のウィジェットの境界線の色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-692">Default widget border color</span></span> |
| <span data-ttu-id="0f5ac-693">GX_COLOR_ID_WINDOW_BORDER</span><span class="sxs-lookup"><span data-stu-id="0f5ac-693">GX_COLOR_ID_WINDOW_BORDER</span></span> | <span data-ttu-id="0f5ac-694">既定のウィンドウの境界線の色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-694">Default window border color</span></span> |
| <span data-ttu-id="0f5ac-695">GX_COLOR_ID_TEXT</span><span class="sxs-lookup"><span data-stu-id="0f5ac-695">GX_COLOR_ID_TEXT</span></span> | <span data-ttu-id="0f5ac-696">既定のテキストの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-696">Default text color</span></span> |
| <span data-ttu-id="0f5ac-697">GX_COLOR_ID_SELECTED_TEXT</span><span class="sxs-lookup"><span data-stu-id="0f5ac-697">GX_COLOR_ID_SELECTED_TEXT</span></span> | <span data-ttu-id="0f5ac-698">既定の選択されているテキストの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-698">Default selected text color</span></span> |
| <span data-ttu-id="0f5ac-699">GX_COLOR_ID_DISABLED_TEXT</span><span class="sxs-lookup"><span data-stu-id="0f5ac-699">GX_COLOR_ID_DISABLED_TEXT</span></span> | <span data-ttu-id="0f5ac-700">既定の無効になっているテキストの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-700">Default disabled text color</span></span> |
| <span data-ttu-id="0f5ac-701">GX_COLOR_ID_SELECTED_TEXT_FILL</span><span class="sxs-lookup"><span data-stu-id="0f5ac-701">GX_COLOR_ID_SELECTED_TEXT_FILL</span></span> | <span data-ttu-id="0f5ac-702">既定の選択されているテキストの塗りつぶしの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-702">Default selected text fill color</span></span> |
| <span data-ttu-id="0f5ac-703">GX_COLOR_ID_READONLY_TEXT</span><span class="sxs-lookup"><span data-stu-id="0f5ac-703">GX_COLOR_ID_READONLY_TEXT</span></span> | <span data-ttu-id="0f5ac-704">既定の読み取り専用テキストの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-704">Default readonly text color</span></span> |
| <span data-ttu-id="0f5ac-705">GX_COLOR_ID_READONLY_FILL</span><span class="sxs-lookup"><span data-stu-id="0f5ac-705">GX_COLOR_ID_READONLY_FILL</span></span> | <span data-ttu-id="0f5ac-706">既定の読み取り専用テキストの塗りつぶしの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-706">Default readonly text fill color</span></span> |
| <span data-ttu-id="0f5ac-707">GX_COLOR_ID_SCROLL_FILL</span><span class="sxs-lookup"><span data-stu-id="0f5ac-707">GX_COLOR_ID_SCROLL_FILL</span></span> |    <span data-ttu-id="0f5ac-708">スクロール バーの塗りつぶしの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-708">Scrollbar fill color</span></span> |
| <span data-ttu-id="0f5ac-709">GX_COLOR_ID_SCROLL_BUTTON</span><span class="sxs-lookup"><span data-stu-id="0f5ac-709">GX_COLOR_ID_SCROLL_BUTTON</span></span> | <span data-ttu-id="0f5ac-710">スクロール バー ボタンの塗りつぶしの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-710">Scrollbar button fill color</span></span> |
| <span data-ttu-id="0f5ac-711">GX_COLOR_ID_SHADOW</span><span class="sxs-lookup"><span data-stu-id="0f5ac-711">GX_COLOR_ID_SHADOW</span></span> | <span data-ttu-id="0f5ac-712">既定の影の色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-712">Default shadow color</span></span> |
| <span data-ttu-id="0f5ac-713">GX_COLOR_ID_SHINE</span><span class="sxs-lookup"><span data-stu-id="0f5ac-713">GX_COLOR_ID_SHINE</span></span> | <span data-ttu-id="0f5ac-714">既定の強調表示の色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-714">Default highlight color</span></span> |
| <span data-ttu-id="0f5ac-715">GX_COLOR_ID_BUTTON_BORDER</span><span class="sxs-lookup"><span data-stu-id="0f5ac-715">GX_COLOR_ID_BUTTON_BORDER</span></span> | <span data-ttu-id="0f5ac-716">ボタン ウィジェットの境界線の色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-716">Button widget border color</span></span> |
| <span data-ttu-id="0f5ac-717">GX_COLOR_ID_BUTTON_UPPER</span><span class="sxs-lookup"><span data-stu-id="0f5ac-717">GX_COLOR_ID_BUTTON_UPPER</span></span> | <span data-ttu-id="0f5ac-718">ボタン ウィジェットの上部の塗りつぶしの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-718">Button widget upper fill color</span></span> |
| <span data-ttu-id="0f5ac-719">GX_COLOR_ID_BUTTON_LOWER</span><span class="sxs-lookup"><span data-stu-id="0f5ac-719">GX_COLOR_ID_BUTTON_LOWER</span></span> | <span data-ttu-id="0f5ac-720">ボタン ウィジェットの下部の塗りつぶしの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-720">Button widget lower fill color</span></span> |
| <span data-ttu-id="0f5ac-721">GX_COLOR_ID_BUTTON_TEXT</span><span class="sxs-lookup"><span data-stu-id="0f5ac-721">GX_COLOR_ID_BUTTON_TEXT</span></span> | <span data-ttu-id="0f5ac-722">ボタン ウィジェットのテキストの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-722">Button widget text color</span></span> |
| <span data-ttu-id="0f5ac-723">GX_COLOR_ID_TEXT_INPUT_TEXT</span><span class="sxs-lookup"><span data-stu-id="0f5ac-723">GX_COLOR_ID_TEXT_INPUT_TEXT</span></span> | <span data-ttu-id="0f5ac-724">テキスト入力ウィジェットのテキストの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-724">Text input widget text color</span></span> |
| <span data-ttu-id="0f5ac-725">GX_COLOR_ID_TEXT_INPUT_FILL</span><span class="sxs-lookup"><span data-stu-id="0f5ac-725">GX_COLOR_ID_TEXT_INPUT_FILL</span></span> | <span data-ttu-id="0f5ac-726">テキスト入力の塗りつぶしの色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-726">Text input fill color</span></span> |
| <span data-ttu-id="0f5ac-727">GX_COLOR_ID_SLIDER_TICK</span><span class="sxs-lookup"><span data-stu-id="0f5ac-727">GX_COLOR_ID_SLIDER_TICK</span></span> | <span data-ttu-id="0f5ac-728">スライダーの目盛を描画するために使用される色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-728">Color used to draw slider tick marks.</span></span> |
| <span data-ttu-id="0f5ac-729">GX_COLOR_ID_SLIDER_GROOVE_BOTTOM</span><span class="sxs-lookup"><span data-stu-id="0f5ac-729">GX_COLOR_ID_SLIDER_GROOVE_BOTTOM</span></span> | <span data-ttu-id="0f5ac-730">スライダーの溝を描画するために使用される色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-730">Color used to draw slider groove</span></span> |
| <span data-ttu-id="0f5ac-731">GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE</span><span class="sxs-lookup"><span data-stu-id="0f5ac-731">GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE</span></span> | <span data-ttu-id="0f5ac-732">針の輪郭を描画するために使用される色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-732">Color used to draw needle outline</span></span> |
| <span data-ttu-id="0f5ac-733">GX_COLOR_ID_SLIDER_NEEDLE_FILL</span><span class="sxs-lookup"><span data-stu-id="0f5ac-733">GX_COLOR_ID_SLIDER_NEEDLE_FILL</span></span> | <span data-ttu-id="0f5ac-734">スライダーの針を塗りつぶすために使用される色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-734">Color used to fill slider needle</span></span> |
| <span data-ttu-id="0f5ac-735">GX_COLOR_ID_SLIDER_NEEDLE_LINE1</span><span class="sxs-lookup"><span data-stu-id="0f5ac-735">GX_COLOR_ID_SLIDER_NEEDLE_LINE1</span></span> | <span data-ttu-id="0f5ac-736">針の強調表示を描画するために使用される色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-736">Color used to draw needle highlight</span></span> |
| <span data-ttu-id="0f5ac-737">GX_COLOR_ID_SLIDER_NEEDLE_LINE2</span><span class="sxs-lookup"><span data-stu-id="0f5ac-737">GX_COLOR_ID_SLIDER_NEEDLE_LINE2</span></span> | <span data-ttu-id="0f5ac-738">針の影を描画するために使用される色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-738">Color used to draw needle shadow</span></span> |

<span data-ttu-id="0f5ac-739">これらのカラー ID 値は、各ディスプレイに割り当てられたカラー テーブルの定義に従って、特定のカラー値にマップされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-739">These color ID values are mapped to a specific color value as defined by the color table assigned to each display.</span></span> <span data-ttu-id="0f5ac-740">これらの既定値は、***gx_display_color_table_set*** API 関数を呼び出すことによって、1 つのディスプレイのグループとして変更できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-740">These defaults can be changed as a group for one display by calling the ***gx_display_color_table_set*** API function.</span></span> <span data-ttu-id="0f5ac-741">GUIX Studio を使用している場合は、アプリケーションが ***gx_studio_display_configure*** 関数を呼び出すと、ディスプレイ カラー テーブルが自動的に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-741">If you are using GUIX Studio, the display color table is automatically initialized when your application calls the ***gx_studio_display_configure*** function.</span></span>

<span data-ttu-id="0f5ac-742">GUIX ディスプレイ コンポーネントではまた、既定のフォント テーブルも保持します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-742">The GUIX display component also maintains a default font table.</span></span> <span data-ttu-id="0f5ac-743">既定のフォント テーブルでは、アプリケーションによって特に指定されない限り、ウィジェットの種類ごとに使用されるフォントを定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-743">The default font table defines the font used by each widget type unless specifically specified by the application.</span></span> <span data-ttu-id="0f5ac-744">事前に定義されたディスプレイ フォント テーブル ID には、次の値が含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-744">The pre-defined display font table IDs include the following values.</span></span>

| <span data-ttu-id="0f5ac-745">フォント&nbsp;ID</span><span class="sxs-lookup"><span data-stu-id="0f5ac-745">Font&nbsp;ID</span></span> | <span data-ttu-id="0f5ac-746">説明</span><span class="sxs-lookup"><span data-stu-id="0f5ac-746">Description</span></span> |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="0f5ac-747">GX_FONT_ID_DEFAULT</span><span class="sxs-lookup"><span data-stu-id="0f5ac-747">GX_FONT_ID_DEFAULT</span></span> | <span data-ttu-id="0f5ac-748">特定のフォントが定義されていないときに使用される既定のフォント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-748">Default font used when no specific font is defined</span></span> |
| <span data-ttu-id="0f5ac-749">GX_FONT_ID_BUTTON</span><span class="sxs-lookup"><span data-stu-id="0f5ac-749">GX_FONT_ID_BUTTON</span></span> | <span data-ttu-id="0f5ac-750">ボタン上のすべてのテキストに使用される既定のフォント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-750">Default font used for all text on buttons</span></span> |
| <span data-ttu-id="0f5ac-751">GX_FONT_ID_TEXT_INPUT</span><span class="sxs-lookup"><span data-stu-id="0f5ac-751">GX_FONT_ID_TEXT_INPUT</span></span> | <span data-ttu-id="0f5ac-752">テキスト編集フィールドに使用される既定のフォント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-752">Default font used for text edit fields</span></span> |

<span data-ttu-id="0f5ac-753">テキストの種類のウィジェットによって使用されるフォント ID は、テキスト関連のウィジェットの種類ごとに提供されている **gx_<widget_type>_font_set** API を使用して再割り当てすることができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-753">The font ID used by any text type widget can be re-assigned by using the **gx_<widget_type>_font_set** API provided for each text-related widget type.</span></span> <span data-ttu-id="0f5ac-754">フォント テーブル全体は、**gx_display_font_table_set** API 関数を呼び出して再割り当てすることができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-754">The entire font table can be re-assigned by calling the **gx_display_font_table_set** API function.</span></span>

### <a name="scrollbar-appearance"></a><span data-ttu-id="0f5ac-755">スクロール バーの外観</span><span class="sxs-lookup"><span data-stu-id="0f5ac-755">Scrollbar Appearance</span></span> 

<span data-ttu-id="0f5ac-756">GUIX ディスプレイではまた、そのディスプレイの既定のスクロール バーの外観設定も保持します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-756">GUIX Display also maintains default scrollbar appearance settings for that display.</span></span> <span data-ttu-id="0f5ac-757">これらの設定は、以下に定義されている **GX_SCROLLBAR_APPEARANCE** 構造体によって定義されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-757">These settings are defined by the **GX_SCROLLBAR_APPEARANCE** structure which is defined below.</span></span> <span data-ttu-id="0f5ac-758">GUIX ディスプレイでは、垂直スクロール バー用の 1 つのスクロール バー外観構造体と、水平スクロール バー用の 2 番目の構造体を保持します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-758">GUIX Display maintains one scrollbar appearance structure for vertical scrollbars and a second structure for horizontal scroll bars.</span></span> <span data-ttu-id="0f5ac-759">アプリケーションでは、**GX_SCROLLBAR_APPEARANCE** 構造体を初期化し、API 関数 ***gx_display_scroll_appearance_set*** を呼び出すことによって、任意のディスプレイの既定のスクロール バーの外観を変更できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-759">The application can modify the default scrollbar appearance for any display by initializing a **GX_SCROLLBAR_APPEARANCE** structure and invoking the API function ***gx_display_scroll_appearance_set***.</span></span>

```c
typedef struct GX_SCROLLBAR_APPEARANCE_STRUCT
{
    GX_VALUE       gx_scroll_width;
    GX_VALUE       gx_scroll_thumb_width;
    GX_VALUE       gx_scroll_thumb_travel_min;
    GX_VALUE       gx_scroll_thumb_travel_max;
    GX_UBYTE       gx_scroll_thumb_border_style;
    GX_RESOURCE_ID gx_scroll_fill_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_pixelmap;
    GX_RESOURCE_ID gx_scroll_up_pixelmap;
    GX_RESOURCE_ID gx_scroll_down_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_color;
    GX_RESOURCE_ID gx_scroll_thumb_border_color;
    GX_RESOURCE_ID gx_scroll_button_color;
} GX_SCROLLBAR_APPEARANCE;
```
| <span data-ttu-id="0f5ac-760">GX_SCROLLBAR_APPEARANCE 構造体のメンバー</span><span class="sxs-lookup"><span data-stu-id="0f5ac-760">GX_SCROLLBAR_APPEARANCE Structure Member</span></span> | <span data-ttu-id="0f5ac-761">説明</span><span class="sxs-lookup"><span data-stu-id="0f5ac-761">Description</span></span> |
| --- | --- |
| <span data-ttu-id="0f5ac-762">gx_scroll_width</span><span class="sxs-lookup"><span data-stu-id="0f5ac-762">gx_scroll_width</span></span> | <span data-ttu-id="0f5ac-763">垂直スクロール バーの幅または水平スクロール バーの高さ (ピクセル単位)。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-763">Width of a vertical scrollbar or height of a horizontal scrollbar, in pixels.</span></span> |
| <span data-ttu-id="0f5ac-764">gx_scroll_thumb_width</span><span class="sxs-lookup"><span data-stu-id="0f5ac-764">gx_scroll_thumb_width</span></span> | <span data-ttu-id="0f5ac-765">エレベーター ボタンと終了ボタンの幅 (ピクセル単位)。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-765">Width of the elevator and end buttons, in pixels.</span></span> |
| <span data-ttu-id="0f5ac-766">gx_scroll_thumb_travel_max</span><span class="sxs-lookup"><span data-stu-id="0f5ac-766">gx_scroll_thumb_travel_max</span></span> | <span data-ttu-id="0f5ac-767">スクロール バーの端から親指ボタンの最大移動ポイントまでのオフセット。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-767">Offset from the end of scroll bar to maximum thumb button travel point.</span></span> |
| <span data-ttu-id="0f5ac-768">gx_scroll_fill_pixelmap</span><span class="sxs-lookup"><span data-stu-id="0f5ac-768">gx_scroll_fill_pixelmap</span></span> | <span data-ttu-id="0f5ac-769">スクロールの背景を塗りつぶすために使用されるピクセルマップ。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-769">Pixelmap used to fill scroll background.</span></span> |
| <span data-ttu-id="0f5ac-770">gx_scroll_thumb_pixelmap</span><span class="sxs-lookup"><span data-stu-id="0f5ac-770">gx_scroll_thumb_pixelmap</span></span> | <span data-ttu-id="0f5ac-771">スクロールの親指ボタンを描画するために使用されるピクセルマップ。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-771">Pixelmap used to draw scroll thumb button.</span></span> |
| <span data-ttu-id="0f5ac-772">gx_scroll_up_pixelmap</span><span class="sxs-lookup"><span data-stu-id="0f5ac-772">gx_scroll_up_pixelmap</span></span> | <span data-ttu-id="0f5ac-773">上にスクロール ボタンを描画するために使用されるピクセルマップ。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-773">Pixelmap used to draw scroll up button.</span></span> |
| <span data-ttu-id="0f5ac-774">gx_scroll_down_pixelmap</span><span class="sxs-lookup"><span data-stu-id="0f5ac-774">gx_scroll_down_pixelmap</span></span> | <span data-ttu-id="0f5ac-775">下にスクロール ボタンを描画するために使用されるピクセルマップ。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-775">Pixelmap used to draw scroll down button.</span></span> |
| <span data-ttu-id="0f5ac-776">gx_scroll_fill_color</span><span class="sxs-lookup"><span data-stu-id="0f5ac-776">gx_scroll_fill_color</span></span> | <span data-ttu-id="0f5ac-777">スクロール バーの背景を塗りつぶすために使用される色のカラー ID。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-777">Color ID of color used to fill scrollbar background.</span></span> |
| <span data-ttu-id="0f5ac-778">gx_scroll_button_color</span><span class="sxs-lookup"><span data-stu-id="0f5ac-778">gx_scroll_button_color</span></span> | <span data-ttu-id="0f5ac-779">スクロール バーの親指ボタンを塗りつぶすために使用される色のカラー ID。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-779">Color ID of color used to fill scrollbar thumb button.</span></span> |

<span data-ttu-id="0f5ac-780">フォント、色、スタイルのこれらの既定の設定に加えて、アプリケーションではウィジェットの種類ごとに提供されている API を使用して、必要に応じてケースバイケースで任意のパラメーターを指定できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-780">In addition to these default settings for fonts, color, and styles, the application may specify any of the parameters on a case by case basis as desired using API provided by each widget type.</span></span>

### <a name="skinning-and-themes"></a><span data-ttu-id="0f5ac-781">スキニングとテーマ</span><span class="sxs-lookup"><span data-stu-id="0f5ac-781">Skinning and Themes</span></span>

<span data-ttu-id="0f5ac-782">スキニングを使用すると、GUIX ウィジェットおよびウィンドウで、その基本外観を簡単に変更できます。つまり、1 か所の "スキン" を変更すると、関連付けられているすべてのウィジェットおよびウィンドウの基本外観が変更されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-782">Skinning allows GUIX widgets and windows to easily change their base appearance, i.e., changing the “skin” in one place will change the base appearance of all associated widgets and windows.</span></span>

<span data-ttu-id="0f5ac-783">GUIX アプリケーションを再スキニングするには、GUIX ディスプレイ リソース テーブルに新しい色、フォント、またはピクセルマップ テーブルを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-783">Re-skinning your GUIX application requires that you supply a new color, font and or pixelmap table to the GUIX Display resource tables.</span></span> <span data-ttu-id="0f5ac-784">すべての GUIX ウィジェットが自身の色、ビットマップ、またはフォントをリソース ID で参照しているため、新しいリソース テーブルを指定すると、すべての GUIX ウィジェットが、目的のディスプレイに自身を描画したときに自動的に新しい色やピクセルマップを使用し始めます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-784">Since all GUIX widgets refer to their color, bitmap, or font by resource ID, providing a new resource table automatically causes all GUIX widgets to begin using your new colors and pixelmaps when they draw themselves to the desired display.</span></span>

<span data-ttu-id="0f5ac-785">魅力的な外観を提供するために連携して機能するように設計された新しい一連のフォント、色、ピクセルマップは "*テーマ*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-785">A new set of fonts, colors, and pixelmaps that are designed to work together to provide an attractive appearance is called a *theme*.</span></span> <span data-ttu-id="0f5ac-786">テーマでは、一連のリソース テーブルと、各リソース テーブルのサイズを定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-786">A theme defines a set of resource tables and the size of each resource table.</span></span> <span data-ttu-id="0f5ac-787">GUIX Studio アプリケーションを使用して、任意のディスプレイ用の任意の数のテーマを定義できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-787">Any number of themes can be defined for any display using the GUIX Studio application.</span></span> <span data-ttu-id="0f5ac-788">作成されたディスプレイに初期のテーマをインストールする、GUIX Studio で生成された関数 ***gx_studio_display_configure*** に開始テーマ インデックスを渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-788">You must pass the starting theme index to the GUIX Studio generated function ***gx_studio_display_configure***, which installs the initial theme into the created display.</span></span> <span data-ttu-id="0f5ac-789">任意のディスプレイのアクティブなテーマは、関数 ***gx_display_theme_install*** を呼び出すことによって、いつでも変更できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-789">The active theme for any display can be changed at any time by calling the function ***gx_display_theme_install***.</span></span>

### <a name="root-window"></a><span data-ttu-id="0f5ac-790">ルート ウィンドウ</span><span class="sxs-lookup"><span data-stu-id="0f5ac-790">Root Window</span></span>

<span data-ttu-id="0f5ac-791">アプリケーションによって作成された表示されるキャンバスごとに、アプリケーションでは、そのキャンバス用の 1 つのルート ウィンドウも作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-791">For each visible canvas created by an application, the application must also create one Root Window for that canvas.</span></span> <span data-ttu-id="0f5ac-792">この特殊なウィンドウは基本的に、最上位のすべてのアプリケーション ウィンドウおよびウィジェットのコンテナーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-792">This special window basically acts as a container for all the top-level application windows and widgets.</span></span> <span data-ttu-id="0f5ac-793">ルート ウィンドウでは、キャンバスの背景を描画します。ルート ウィンドウは **GX_WINDOW** クラスから派生しているため、ルート ウィンドウにも壁紙がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-793">The root window draws the canvas background, and since the root window is derived from the **GX_WINDOW** class the root window can also have wallpaper.</span></span> <span data-ttu-id="0f5ac-794">ディスプレイまたはキャンバスの背景色を変更するには、単純に、そのキャンバスにアタッチされているルート ウィンドウの塗りつぶしの色を変更します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-794">To change the background color of your display or canvas, you simply change the fill color of the root window attached to that canvas.</span></span>

<span data-ttu-id="0f5ac-795">GUIX Studio で生成された ***gx_studio_display_configure*** という名前の関数を使用してディスプレイを構成する場合は、この初期化関数の一部として、各ディスプレイのキャンバスとルート ウィンドウが自動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-795">If you use the GUIX Studio generated function named ***gx_studio_display_configure*** to configure your displays, then the canvas and root window for each display are created for you as part of this initialization function.</span></span>

### <a name="anti-aliasing"></a><span data-ttu-id="0f5ac-796">アンチエイリアシング</span><span class="sxs-lookup"><span data-stu-id="0f5ac-796">Anti-Aliasing</span></span> 

<span data-ttu-id="0f5ac-797">アンチエイリアシングは、直線、曲線、フォントを滑らかにするために使用される GUIX のオプション機能です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-797">Anti-Aliasing is an optional feature in GUIX that is used to smooth lines, curves, and fonts.</span></span> <span data-ttu-id="0f5ac-798">アンチエイリアシングは、16 bpp 以上の色深度を利用したディスプレイ ドライバーで動作している場合にのみサポートされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-798">Anti-aliasing is only supported when running with a display driver utilizing 16-bpp or higher color depth.</span></span>

<span data-ttu-id="0f5ac-799">アンチエイリアスされた線描画は、アクティブなブラシで **GX_BRUSH_ALIAS** フラッシュを設定することによって有効になります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-799">Anti-aliased line drawing is enabled by setting the **GX_BRUSH_ALIAS** flash in the active brush.</span></span> <span data-ttu-id="0f5ac-800">これは、直接描画された線だけでなく、多角形または円の境界として描画された線にも適用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-800">This applies to lines drawn directly as well as to lines drawn as the border of a polygon or circle.</span></span>

<span data-ttu-id="0f5ac-801">アンチエイリアスされたテキスト描画は、GUIX スタジオ アプリケーションによって生成されるアンチエイリアスされたフォントを使用することによって有効になります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-801">Anti-aliased text drawing is enabled by using an anti-aliased font which is produced by the GUIX studio application.</span></span> <span data-ttu-id="0f5ac-802">フォントを作成する場合は、アンチエイリアスされたフォントとバイナリ フォントのどちらを生成するかを指定します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-802">You specify whether a font should be generated as antialiased or binary when you create the font.</span></span>
<span data-ttu-id="0f5ac-803">GUIX のアンチエイリアスされたフォントでは、ピクセルごとに 16 レベルの透明度を利用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-803">Anti-aliased fonts in GUIX utilize 16 levels of transparency for each pixel.</span></span>

### <a name="clipping"></a><span data-ttu-id="0f5ac-804">クリッピング</span><span class="sxs-lookup"><span data-stu-id="0f5ac-804">Clipping</span></span> 

<span data-ttu-id="0f5ac-805">クリッピングは、GUIX ディスプレイ コンポーネントによって内部的に、またウィンドウおよびウィジェット レイヤーでは GUIX ウィジェットによって管理される親子アーキテクチャによってサポートされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-805">Clipping is supported internally by the GUIX display component, and at the window and widget layers by the parent-child architecture maintained by GUIX widgets.</span></span> <span data-ttu-id="0f5ac-806">どのウィンドウまたはウィジェットもそのウィジェットの領域の外部に描画することを許可されず、さらにウィジェットは、そのウィジェットの親の領域の外部に描画することを許可されません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-806">No window or widget is ever allowed to draw outside of that widget’s area, and a widget is never allowed to draw outside of the area of that widget’s parent.</span></span>

<span data-ttu-id="0f5ac-807">これにより、ウィジェットがキャンバス メモリの外部にあるピクセル座標に描画することも防止されます。これは、メモリ破損やシステム障害につながる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-807">This also prevents widgets from drawing at pixel coordinates that lay outside of the canvas memory which likely lead to memory corruption or a system failure.</span></span> <span data-ttu-id="0f5ac-808">ウィジェットは、そのウィジェットの領域やウィジェットの親領域の外部に、またはキャンバスの範囲を超えて描画することを許可されません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-808">Widgets are not allowed to draw outside of the widget’s area, the widget’s parent area, or beyond the canvas extent.</span></span>

<span data-ttu-id="0f5ac-809">さらに、ウィジェットは、以前にダーティとマークされている領域にしか描画できません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-809">In addition, widgets can only draw to areas that have previously been marked as dirty.</span></span> <span data-ttu-id="0f5ac-810">これにより、たとえばウィンドウの隅だけが表示されているときに、ウィンドウ全体が描画されることが防止されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-810">This prevents an entire window being drawn, for example, when only a corner of the window has been revealed.</span></span> <span data-ttu-id="0f5ac-811">ウィンドウの実際に更新する必要がある部分だけがダーティとマークされるため、ウィンドウ描画関数では、そのダーティ領域内のピクセルだけを実際に更新します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-811">Only the portion of the window that actually needs to be refreshed is marked as dirty, and so the window drawing function only truly refreshes pixels in the dirty area.</span></span>

<span data-ttu-id="0f5ac-812">GUIX ディスプレイ コンポーネントでは、ドライバー レベルの描画関数を呼び出す前に、これらのクリッピング アルゴリズムを適用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-812">The GUIX dispaly component enforces these clipping algorithms before invoking the driver level drawing functions.</span></span>

### <a name="views"></a><span data-ttu-id="0f5ac-813">ビュー</span><span class="sxs-lookup"><span data-stu-id="0f5ac-813">Views</span></span> 

<span data-ttu-id="0f5ac-814">GUIX では常に、各ルート ウィンドウと、そのルート ウィンドウの各子ウィンドウの一連のビューを保持します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-814">GUIX always maintains a set of views for each root window and each child window of the root window.</span></span> <span data-ttu-id="0f5ac-815">ビューは、ウィンドウの位置や Z オーダーが変更されるに従って変化する、動的で、かつ実行時に決定されるクリッピング領域です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-815">Views are a dynamic, run-time determined clipping area that changes as window position and Z-order are modified.</span></span>
<span data-ttu-id="0f5ac-816">GUIX では、前景のウィンドウまたはウィジェットの上に背景のウィンドウまたはウィジェットが描画されないようにするためにビューを使用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-816">GUIX uses views to prevent a window or widget in the background from drawing on top of a window or widget in the foreground.</span></span> <span data-ttu-id="0f5ac-817">ビューでは Z オーダーの規範が適用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-817">Views enforce Z-order discipline.</span></span> <span data-ttu-id="0f5ac-818">さらに、ビューは、背景のウィンドウがキャンバスの表示不可能などの領域にも描画されないようにするという点で効率のために重要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-818">In addition, views are important for efficiency in that they prevent a window in the background from drawing to any area of the canvas that cannot be seen.</span></span> <span data-ttu-id="0f5ac-819">あるウィンドウが別のウィンドウに完全に覆われている場合、その覆われているウィンドウは、キャンバスに描画することをまったく許可されません (たとえ、それを試みていた場合でも)。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-819">If a window is completely covered by another window, the covered window will not be allowed to draw to the canvas at all, even if it is attempting to do so.</span></span>

### <a name="display-driver-interface"></a><span data-ttu-id="0f5ac-820">Display driver interface (ディスプレイ ドライバー インターフェイス)</span><span class="sxs-lookup"><span data-stu-id="0f5ac-820">Display Driver Interface</span></span> 

<span data-ttu-id="0f5ac-821">GUIX ディスプレイ ドライバーは、基になる物理画面へのすべての操作を担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-821">GUIX display drivers are responsible for all interaction with the underlying physical screen.</span></span> <span data-ttu-id="0f5ac-822">これらのディスプレイ ドライバーには、初期化、描画、フレーム バッファーの表示の 3 つの基本的な機能があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-822">The display drivers have three basic functions: initialization, drawing, and frame buffer display.</span></span>
<span data-ttu-id="0f5ac-823">初期化は、物理ディスプレイ ハードウェアの準備、物理ディスプレイ ハードウェアのプロパティの GUIX への通知、使用される特定の描画関数の GUIX への通知を担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-823">Initialization is responsible for preparing the physical display hardware, informing GUIX of the properties of the physical display hardware, and for informing GUIX which specific drawing functions should be used.</span></span> <span data-ttu-id="0f5ac-824">メイン ディスプレイ ドライバーの初期化は、GUIX ***gx_display_create*** 関数から呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-824">The main display driver initialization is called from the GUIX ***gx_display_create*** function.</span></span> <span data-ttu-id="0f5ac-825">さらに、GUIX スレッドでも、そのスレッド コンテキストからセカンダリ ディスプレイ ドライバーの初期化を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-825">In addition, the GUIX thread will also call a secondary display driver initialization from the thread context.</span></span> <span data-ttu-id="0f5ac-826">このセカンダリ ディスプレイ ドライバーは、ドライバーの初期化中に RTOS サービスが必要になる場合 (デバイスの割り込みや、初期化プロセス内のステップ間の遅延のための ***tx_thread_sleep*** 要求など) にのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-826">This secondary display driver is only needed if the driver requires RTOS services during its initialization, e.g., device interrupts or ***tx_thread_sleep*** requests for delay between steps in the initialization process.</span></span>

<span data-ttu-id="0f5ac-827">初期化が完了すると、ディスプレイ ドライバーは、物理ディスプレイ ハードウェアで実行できるすべての直接の描画を担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-827">Once initialization is complete, the display driver is responsible for any direct drawing that can be done in the physical display hardware.</span></span>
<span data-ttu-id="0f5ac-828">最後に、ディスプレイ ドライバーはフレーム バッファーの表示を担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-828">Finally, the display driver is responsible for displaying the frame buffer.</span></span>

## <a name="guix-widget-component"></a><span data-ttu-id="0f5ac-829">GUIX ウィジェット コンポーネント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-829">GUIX Widget Component</span></span>

<span data-ttu-id="0f5ac-830">GUIX ウィジェットは、表示されるグラフィック要素です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-830">A GUIX widget is a visible graphical element.</span></span> <span data-ttu-id="0f5ac-831">タイマーや数値演算ユーティリティ関数など、表示されない GUIX コンポーネントも存在します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-831">There are GUIX components which are not visible, such as timers and math utility functions.</span></span>
<span data-ttu-id="0f5ac-832">ただし、表示されるコンポーネントはすべて、基本的な GUIX ウィジェット コンポーネントから派生しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-832">However all visible components are derived from the basic GUIX widget component.</span></span> <span data-ttu-id="0f5ac-833">GUIX ウィジェットは、GUIX ディスプレイの主要な構成要素です。その他のグラフィック要素はすべて、基本ウィジェット機能から派生しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-833">A GUIX widget is the primary building block of the GUIX display – all other graphic elements are derived from the base widget functionality.</span></span>

<span data-ttu-id="0f5ac-834">GUIX ウィジェットは、継承が完全にサポートされた、オブジェクト指向の方法で実装されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-834">GUIX widgets are implemented in an object oriented manner with full support of inheritance.</span></span> <span data-ttu-id="0f5ac-835">これは、ANSI C を使用して実現されます。これにより、メモリや処理の要件が可能な限り最小限になります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-835">This is accomplished using ANSI C, which results in the smallest possible memory and processing requirements.</span></span> <span data-ttu-id="0f5ac-836">ある特定のウィジェット (**GX_BUTTON** など) が別のウィジェット (基本 **GX_WIDGET** など) "*から派生している*" と話す場合、それは、**GX_BUTTON** 制御構造体に **GX_WIDGET** のすべてのメンバー変数と関数ポインターが含まれ、さらに **GX_BUTTON** に固有のいくつかの変数が追加されていることを示します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-836">When we speak of one particular widget, such as **GX_BUTTON**, being *derived from* another widget, such as the base **GX_WIDGET**, what we mean is that the **GX_BUTTON** control structure contains all of the member variables and function pointers of **GX_WIDGET**, with some additional variables that are specific to **GX_BUTTON**.</span></span> <span data-ttu-id="0f5ac-837">GUIX では、より複雑なウィジェットが常に、その前のより単純なウィジェットに基づくように、このようにウィジェットのレイヤーを構築しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-837">GUIX builds up layers of widgets in this fashion, so that more complex widgets are always based on a simpler widget before them.</span></span> <span data-ttu-id="0f5ac-838">この派生の階層モデルにより、ウィジェット パラメーターを変更するために使用される API の学習がより簡単になります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-838">This hierarchical model of derivation makes it easier to learn the APIs used to modify widget parameters.</span></span> <span data-ttu-id="0f5ac-839">ボタンの色を変更する場合は、ウィジェットの色を変更するために使用するのと同じ API (つまり、***gx_widget_fill_color_set***) を使用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-839">If you want to modify the color of a button, you use the same API you use to modify the color of a widget, namely ***gx_widget_fill_color_set***.</span></span>

<span data-ttu-id="0f5ac-840">表示されるウィジェットの構成は、子ウィジェットをその親にリンクするツリー構造リストを使用して、親 - 子という形で管理されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-840">The organization of visible widgets is maintained in a parent-child manner using tree structured lists linking child widgets to their parents.</span></span> <span data-ttu-id="0f5ac-841">子は、描画できるビューや描画対象のキャンバスなどの特性をその親から継承します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-841">The children inherit characteristics from their parents such as the views into which they can draw and the canvas on which they draw.</span></span>
<span data-ttu-id="0f5ac-842">子ウィジェットはそれ自身の子ウィジェットを持つことができます。その子ウィジェットも、さまざまな特性を親から継承します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-842">Child widgets may have their own child widgets, again inheriting various characteristics from the parent.</span></span> <span data-ttu-id="0f5ac-843">どのウィジェットの特性も、各種の GUIX API 呼び出しを使用して明示的に再定義できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-843">The characteristics of any widget may be explicitly redefined via various GUIX API calls.</span></span>

### <a name="widget-creation"></a><span data-ttu-id="0f5ac-844">ウィジェットの作成</span><span class="sxs-lookup"><span data-stu-id="0f5ac-844">Widget Creation</span></span> 

<span data-ttu-id="0f5ac-845">ウィジェット オブジェクトは、初期化中に作成することも、アプリケーション スレッドの実行中の任意の時点で作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-845">A widget object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="0f5ac-846">アプリケーションで作成できるウィジェット オブジェクトの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-846">There is no limit on the number of widget objects that can be created by an application.</span></span> <span data-ttu-id="0f5ac-847">また、ウィジェットが持つことができる子の数にも (ターゲット ハードウェアのメモリ制限内で) 制限はありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-847">There is also no limit on the number of children any widget may have, within the memory limits of your target hardware.</span></span>

<span data-ttu-id="0f5ac-848">ウィジェットの種類ごとに、独自の作成関数 (***gx_button_create** _ や _*_gx_prompt_create_\*\* など) があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-848">Each widget type has its own create function, such as ***gx_button_create** _ or _*_gx_prompt_create_\*\*.</span></span> <span data-ttu-id="0f5ac-849">これらの関数への最初の 3 つのパラメーター、つまり、ウィジェット制御構造体へのポインター、ウィジェット名への文字列ポインター、ウィジェットの親へのポインターは常に同じです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-849">The first three parameters to these functions are always the same, namely a pointer to the widget control structure, a string pointer to the widget name, and a pointer to the widget’s parent.</span></span> <span data-ttu-id="0f5ac-850">各作成関数には、その特定のウィジェットの種類の要件に応じて、任意の数の追加パラメーターがある場合があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-850">Each create function may have any number of additional parameters depending on the requirements of that particular widget type.</span></span>

### <a name="widget-control-block"></a><span data-ttu-id="0f5ac-851">ウィジェット コントロール ブロック</span><span class="sxs-lookup"><span data-stu-id="0f5ac-851">Widget Control Block</span></span> 

<span data-ttu-id="0f5ac-852">各ウィジェット オブジェクトの特性は、そのコントロール ブロック **GX_WIDGET** 内にあり、**_gx_api.h_** で定義されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-852">The characteristics of each widget object are found in its control block **GX_WIDGET** and are defined in **_gx_api.h_**.</span></span> <span data-ttu-id="0f5ac-853">ウィジェット オブジェクトに必要なメモリはアプリケーションによって提供され、メモリ内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-853">The memory required for a widget object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="0f5ac-854">ただし、ウィジェット オブジェクト コントロール ブロックは、すべての関数のスコープ外に定義することによってグローバル構造体にすることが最も一般的です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-854">However, it is most common to make the widget object control block a global structure by defining it outside the scope of any function.</span></span> <span data-ttu-id="0f5ac-855">GUIX Studio を使用している場合、ウィジェット コントロール ブロックは、Studio で生成された仕様ファイル内で静的に割り当てるか、またはアプリケーションで動的に割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-855">If you are using GUIX Studio, your widget control blocks can be statically allocated within your Studio generated specifications file, or they can be dynamically allocated by your application.</span></span>

### <a name="dynamic-widget-control-block-allocation-and-de-allocation"></a><span data-ttu-id="0f5ac-856">ウィジェット コントロール ブロックの動的な割り当ておよび割り当て解除</span><span class="sxs-lookup"><span data-stu-id="0f5ac-856">Dynamic Widget Control Block Allocation and De-allocation</span></span> 

<span data-ttu-id="0f5ac-857">コントロール ブロックの動的な割り当てを使用している場合は、ウィジェット コントロール ブロックに必要なメモリの割り当てと解放のために GUIX で使用する 2 つの関数を定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-857">If you are using dynamic control block allocation, you will need to define two functions that GUIX will use to allocate and free the memory required for your widget control blocks.</span></span> <span data-ttu-id="0f5ac-858">メモリ管理のための関数は、***gx_system_memory_allocator_set*** API 関数を使用して GUIX システム コンポーネントに渡されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-858">Your functions for memory management are passed to the GUIX system component via the ***gx_system_memory_allocator_set*** API function.</span></span> <span data-ttu-id="0f5ac-859">この関数を使用すると、GUIX に次の 2 つの関数ポインターを渡すことができます。1 つ目はメモリ割り当て関数へのポインター、2 つ目はメモリ解放関数へのポインターです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-859">This function allows you to pass two function pointers into GUIX: the first is a pointer to a memory allocation function, and the second is a pointer to a memory free function.</span></span> <span data-ttu-id="0f5ac-860">ほとんどの場合、これらの関数は ThreadX バイト プールを使用して実装しますが、GUIX の設計を使用すると、希望する任意の方法で動的メモリ管理を実装できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-860">Most often, you will implement these functions using ThreadX byte pools, but the design of GUIX allows you to implement dynamic memory management in whatever way you prefer.</span></span>

<span data-ttu-id="0f5ac-861">ウィジェットの動的な割り当ては、ほとんどの場合、Studio のウィジェットのプロパティ フィールドで [動的割り当て] オプションが選択されているときに、Studio で生成されたアプリケーション仕様ファイル内で使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-861">Dynamic widget allocation is most often employed within your Studio generated application specifications file, when you select the “dynamically allocated” option in the Studio widget properties field.</span></span> <span data-ttu-id="0f5ac-862">ただし、コントロール ブロックの動的な割り当てはアプリケーション内でも使用できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-862">However, you can also use dynamic control block allocation within your application.</span></span> <span data-ttu-id="0f5ac-863">アプリケーション内でコントロール ブロックの動的な割り当てを使用する場合は、\***gx_widget_allocate** _ API 関数を呼び出して、ウィジェット コントロール ブロックを割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-863">If you use dynamic control block allocation within your application, you should invoke the \***gx_widget_allocate** _ API function to allocate the widget control block.</span></span> <span data-ttu-id="0f5ac-864">次に、ウィジェットを作成するときに、ウィジェット作成関数に必ず _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED*\* スタイル フラグを (その他のすべての必要なスタイル フラグと共に) 渡すようにしてください。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-864">Next, when you create the widget, make certain you pass the _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED*\* style flag (along with any other needed style flags) to the widget create function.</span></span> <span data-ttu-id="0f5ac-865">このフラグは、そのウィジェットをウィジェットの状態フィールドで [動的割り当て] とマークするために使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-865">This flag is used to mark the widget as being dynamically allocated in the widget status field.</span></span> <span data-ttu-id="0f5ac-866">このウィジェットが後で **_gx_widget_delete_** を使用して削除された場合、GUIX ではこの状態フィールドをチェックし、メモリ割り当て解除関数を自動的に呼び出してメモリ リークが発生しないようにします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-866">When and if the widget is later deleted using **_gx_widget_delete_**, GUIX will check this status field and automatically call your memory de-allocator function to insure there are no memory leaks.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0f5ac-867">動的に割り当てられたコントロール ブロックを使用して作成されるウィジェットは、メモリ損失を防ぐために **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** スタイル フラグを使用して作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-867">A widget created using a dynamically allocated control block must be created with the **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** style flag to prevent memory loss.</span></span>

### <a name="types"></a><span data-ttu-id="0f5ac-868">種類</span><span class="sxs-lookup"><span data-stu-id="0f5ac-868">Types</span></span>

<span data-ttu-id="0f5ac-869">GUIX には、完全に機能する、豊富な一連の組み込みウィジェットが用意されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-869">GUIX provides a rich, fully functional set of built-in widgets.</span></span> <span data-ttu-id="0f5ac-870">先に説明したように、特殊なウィジェットはすべて、基本ウィジェットから派生しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-870">As mentioned previously, all specialized widgets are derived from the base widget.</span></span> <span data-ttu-id="0f5ac-871">GUIX の組み込みウィジェットの一覧を次に示します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-871">Following is a list of the built-in widgets in GUIX:</span></span>

<span data-ttu-id="0f5ac-872">**GX_TYPE_WIDGET**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-872">**GX_TYPE_WIDGET**</span></span>

<span data-ttu-id="0f5ac-873">**GX_TYPE_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-873">**GX_TYPE_BUTTON**</span></span>

<span data-ttu-id="0f5ac-874">**GX_TYPE_TEXT_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-874">**GX_TYPE_TEXT_BUTTON**</span></span>

<span data-ttu-id="0f5ac-875">**GX_TYPE_MULTI_LINE_TEXT_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-875">**GX_TYPE_MULTI_LINE_TEXT_BUTTON**</span></span>

<span data-ttu-id="0f5ac-876">**GX_TYPE_RADIO_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-876">**GX_TYPE_RADIO_BUTTON**</span></span>

<span data-ttu-id="0f5ac-877">**GX_TYPE_CHECKBOX**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-877">**GX_TYPE_CHECKBOX**</span></span>

<span data-ttu-id="0f5ac-878">**GX_TYPE_PIXELMAP_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-878">**GX_TYPE_PIXELMAP_BUTTON**</span></span>

<span data-ttu-id="0f5ac-879">**GX_TYPE_ICON_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-879">**GX_TYPE_ICON_BUTTON**</span></span>

<span data-ttu-id="0f5ac-880">**GX_TYPE_ICON**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-880">**GX_TYPE_ICON**</span></span>

<span data-ttu-id="0f5ac-881">**GX_TYPE_SPRITE**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-881">**GX_TYPE_SPRITE**</span></span>

<span data-ttu-id="0f5ac-882">**GX_TYPE_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-882">**GX_TYPE_SLIDER**</span></span>

<span data-ttu-id="0f5ac-883">**GX_TYPE_PIXELMAP_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-883">**GX_TYPE_PIXELMAP_SLIDER**</span></span>

<span data-ttu-id="0f5ac-884">**GX_TYPE_VERTICAL_SCROLL**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-884">**GX_TYPE_VERTICAL_SCROLL**</span></span>

<span data-ttu-id="0f5ac-885">**GX_TYPE_HORIZONTAL_SCROLL**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-885">**GX_TYPE_HORIZONTAL_SCROLL**</span></span>

<span data-ttu-id="0f5ac-886">**GX_TYPE_PROGRESS_BAR**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-886">**GX_TYPE_PROGRESS_BAR**</span></span>

<span data-ttu-id="0f5ac-887">**GX_TYPE_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-887">**GX_TYPE_PROMPT**</span></span>

<span data-ttu-id="0f5ac-888">**GX_TYPE_NUMERIC_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-888">**GX_TYPE_NUMERIC_PROMPT**</span></span>

<span data-ttu-id="0f5ac-889">**GX_TYPE_PIXELMAP_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-889">**GX_TYPE_PIXELMAP_PROMPT**</span></span>

<span data-ttu-id="0f5ac-890">**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-890">**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**</span></span>

<span data-ttu-id="0f5ac-891">**GX_TYPE_SINGLE_LINE_TEXT_INPUT**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-891">**GX_TYPE_SINGLE_LINE_TEXT_INPUT**</span></span>

<span data-ttu-id="0f5ac-892">**GX_TYPE_MULTI_LINE_TEXT_VIEW**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-892">**GX_TYPE_MULTI_LINE_TEXT_VIEW**</span></span>

<span data-ttu-id="0f5ac-893">**GX_TYPE_MULTI_LINE_TEXT_INPUT**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-893">**GX_TYPE_MULTI_LINE_TEXT_INPUT**</span></span>

<span data-ttu-id="0f5ac-894">**GX_TYPE_WINDOW**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-894">**GX_TYPE_WINDOW**</span></span>

<span data-ttu-id="0f5ac-895">**GX_TYPE_ROOT_WINDOW**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-895">**GX_TYPE_ROOT_WINDOW**</span></span>

<span data-ttu-id="0f5ac-896">**GX_TYPE_VERTICAL_LIST**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-896">**GX_TYPE_VERTICAL_LIST**</span></span>

<span data-ttu-id="0f5ac-897">**GX_TYPE_HORIZONTAL_LIST**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-897">**GX_TYPE_HORIZONTAL_LIST**</span></span>

<span data-ttu-id="0f5ac-898">**GX_TYPE_POPUP_LIST**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-898">**GX_TYPE_POPUP_LIST**</span></span>

<span data-ttu-id="0f5ac-899">**GX_TYPE_DROP_LIST**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-899">**GX_TYPE_DROP_LIST**</span></span>

<span data-ttu-id="0f5ac-900">**GX_TYPE_LINE_CHART**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-900">**GX_TYPE_LINE_CHART**</span></span>

<span data-ttu-id="0f5ac-901">**GX_TYPE_DIALOG**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-901">**GX_TYPE_DIALOG**</span></span>

<span data-ttu-id="0f5ac-902">**GX_TYPE_KEYBOARD**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-902">**GX_TYPE_KEYBOARD**</span></span>

<span data-ttu-id="0f5ac-903">**GX_TYPE_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-903">**GX_TYPE_SCROLL_WHEEL**</span></span>

<span data-ttu-id="0f5ac-904">**GX_TYPE_TEXT_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-904">**GX_TYPE_TEXT_SCROLL_WHEEL**</span></span>

<span data-ttu-id="0f5ac-905">**GX_TYPE_STRING_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-905">**GX_TYPE_STRING_SCROLL_WHEEL**</span></span>

<span data-ttu-id="0f5ac-906">**GX_TYPE_NUMERIC_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-906">**GX_TYPE_NUMERIC_SCROLL_WHEEL**</span></span>

<span data-ttu-id="0f5ac-907">**GX_TYPE_CIRCULAR_GAUGE**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-907">**GX_TYPE_CIRCULAR_GAUGE**</span></span>

<span data-ttu-id="0f5ac-908">**GX_TYPE_RADIAL_PROGRESS_BAR**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-908">**GX_TYPE_RADIAL_PROGRESS_BAR**</span></span>

<span data-ttu-id="0f5ac-909">**GX_TYPE_RADIAL_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-909">**GX_TYPE_RADIAL_SLIDER**</span></span>

<span data-ttu-id="0f5ac-910">**GX_TYPE_MENU_LIST**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-910">**GX_TYPE_MENU_LIST**</span></span>

<span data-ttu-id="0f5ac-911">**GX_TYPE_MENU**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-911">**GX_TYPE_MENU**</span></span>

<span data-ttu-id="0f5ac-912">**GX_TYPE_ACCORDION_MENU**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-912">**GX_TYPE_ACCORDION_MENU**</span></span>

<span data-ttu-id="0f5ac-913">**GX_TYPE_TREE_VIEW**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-913">**GX_TYPE_TREE_VIEW**</span></span>


### <a name="styles"></a><span data-ttu-id="0f5ac-914">スタイル</span><span class="sxs-lookup"><span data-stu-id="0f5ac-914">Styles</span></span>

<span data-ttu-id="0f5ac-915">ウィジェット スタイルは、境界線プロパティ (浮き出し、くぼんだ、細い、太い、境界線なし) や、前に一覧表示した特定のウィジェットの種類のプロパティなどの要素で構成されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-915">Widget styles consist of things like border properties (raised, recessed, thin, thick, or no boarder at all) as well as properties for specific widget types, as listed previously.</span></span> <span data-ttu-id="0f5ac-916">ウィジェット スタイル フラグは、任意のウィジェットの外観を変更するための最も簡単な方法です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-916">The widget style flags offer the simplest method for modifying the appearance of any widget.</span></span>
<span data-ttu-id="0f5ac-917">初期のウィジェット スタイルは常に、そのウィジェットの種類に固有の作成関数に渡されるパラメーターです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-917">The initial widget style is always a parameter passed to the widget type specific create function.</span></span>

### <a name="colors"></a><span data-ttu-id="0f5ac-918">色</span><span class="sxs-lookup"><span data-stu-id="0f5ac-918">Colors</span></span> 

<span data-ttu-id="0f5ac-919">ウィジェットでは、システム カラー テーブルで定義されている色を使用して自身を描画します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-919">Widgets draw themselves using colors defined in the system color table.</span></span>
<span data-ttu-id="0f5ac-920">カラー ID は、キャンバスの背景、既定のウィジェットの塗りつぶしの色、ボタンの塗りつぶしの色、テキスト ウィジェットの塗りつぶしの色、ウィンドウの塗りつぶしの色、その他のいくつかの既定のカラー値に対して定義されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-920">Color IDs are defined for canvas background, default widget fill color, button fill color, text widget fill color, window fill color, and several other default color values.</span></span> <span data-ttu-id="0f5ac-921">さらに、**GX_WINDOW** オブジェクトでは、ウィンドウ クライアントが塗りつぶされたときのビットマップまたは壁紙の表示をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-921">In addition, **GX_WINDOW** objects support displaying a bitmap or wallpaper as the window client is filled.</span></span>

<span data-ttu-id="0f5ac-922">既定の配色を変更するための最も簡単な方法は、GUIX Studio を使用して、要件を満たす配色を作成または定義することです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-922">The simplest method of changing the default color scheme is to use GUIX Studio and create or define a color scheme that meets your requirements.</span></span>
<span data-ttu-id="0f5ac-923">また、GX_COLOR 値の配列を作成し、gx_system_color_table_set API 関数を呼び出すことによって、配色を手動で定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-923">You can also define your color scheme manually by creating an array of GX_COLOR values and invoking the gx_system_color_table_set API function.</span></span>

### <a name="event-notification"></a><span data-ttu-id="0f5ac-924">イベント通知</span><span class="sxs-lookup"><span data-stu-id="0f5ac-924">Event Notification</span></span> 

<span data-ttu-id="0f5ac-925">GUIX イベントは、特定のアクションを実行するために 1 つ以上のウィジェットに対して行われる要求、またはウィジェットにユーザー入力や内部のシステム状態変更を通知するための通知です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-925">GUIX events are requests made to one or more widgets to perform a particular action and notifications to notify widgets of user input and internal system status changes.</span></span> <span data-ttu-id="0f5ac-926">たとえば、ウィジェットがフォーカスを取得すると、**GX_EVENT_FOCUS_GAINED** が ***gx_system_event_send*** API サービス経由でそのウィジェットに送信されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-926">For example, when a widget gains focus, the **GX_EVENT_FOCUS_GAINED** is sent to the widget via the ***gx_system_event_send*** API service.</span></span>

<span data-ttu-id="0f5ac-927">イベントは GUIX イベント キュー経由で渡され、各イベントは **GX_EVENT** データ構造体のインスタンスです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-927">Events are passed through the GUIX event queue, and each event is an instance of the **GX_EVENT** data structure.</span></span> <span data-ttu-id="0f5ac-928">**GX_EVENT** データ構造体は ***gx_api.h*** で定義されますが、この構造体の最も重要なフィールドは、**gx_event_type**、**gx_event_sender**、**gx_event_target**、**gx_event_payload** です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-928">The **GX_EVENT** data structure is defined in ***gx_api.h***, however the most important fields of the structure are the **gx_event_type**, **gx_event_sender**, **gx_event_target**, and **gx_event_payload**.</span></span>

<span data-ttu-id="0f5ac-929">**gx_event_type** フィールドは、特定のイベント クラスを識別するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-929">The **gx_event_type** field is used to identify the particular event class.</span></span> <span data-ttu-id="0f5ac-930">イベントの種類は、これが、たとえば **GX_EVENT_PEN_DOWN** イベントまたは **GX_EVENT_TIMER** イベントのどちらであるかを示します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-930">The event type indicates if this is, for example, a **GX_EVENT_PEN_DOWN** event or a **GX_EVENT_TIMER** event.</span></span> <span data-ttu-id="0f5ac-931">**gx_event_payload** は、さまざまなデータ フィールドの和集合であり、すべてがどのイベントの種類でも有効であるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-931">The **gx_event_payload** is a union of various data fields, and they are not all valid for every event type.</span></span>
<span data-ttu-id="0f5ac-932">まず、イベントの種類のフィールドを使用してから、その他のイベント データ フィールドを調べます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-932">You use the event type field first, before examining the other event data fields.</span></span>

<span data-ttu-id="0f5ac-933">イベントが子ウィジェットの通知である場合、**gx_event_sender** フィールドには、そのイベントを生成したウィジェットの ID が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-933">The **gx_event_sender** field contains the ID of the widget that generated the event if the event is a child-widget notification.</span></span>

<span data-ttu-id="0f5ac-934">**gx_event_target** フィールドを使用すると、ユーザー定義イベントを特定のウィンドウまたはウィジェットにルーティングできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-934">The **gx_event_target** field can be used to route user-defined events to a particular window or widget.</span></span> <span data-ttu-id="0f5ac-935">イベントを特定のウィンドウに送信する場合は、そのウィンドウに (明確に識別できる) 一意の ID 値を割り当て、イベントを構築するときにそのウィンドウの ID 値を **gx_event_target** フィールドに設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-935">If you want to send an event to a particular window, you should give the window a unique Id value (so that it can be positively identified), and when building the event place the window Id value in the **gx_event_target** field.</span></span> <span data-ttu-id="0f5ac-936">ターゲットの ID がわからないか、または単に入力フォーカスを持つウィジェットにイベントをルーティングするだけの場合は、**gx_event_target** フィールドを確実に 0 に設定してください。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-936">If you don’t know the target Id or if you just want the event to be routed to the widget that has input focus, make sure to set the **gx_event_target** field to 0.</span></span>

<span data-ttu-id="0f5ac-937">最後に、**gx_event_payload** フィールドは、さまざまなデータの種類の和集合です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-937">Finally, the **gx_event_payload** field is a union of various data types.</span></span> <span data-ttu-id="0f5ac-938">**GX_EVENT_PEN_DOWN** および **GX_EVENT_PEN_UP** イベントの場合、**gx_event_pointdata** フィールドには、ペン位置の x、y ピクセル座標が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-938">For **GX_EVENT_PEN_DOWN** and **GX_EVENT_PEN_UP** events, the **gx_event_pointdata** field contains the x,y pixel coordinate the pen position.</span></span> <span data-ttu-id="0f5ac-939">タイマー イベントの場合、**gx_event_timer_id** フィールドには、有効期限が切れたタイマーの ID が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-939">For timer events, the **gx_event_timer_id** field contains the ID of the expired timer.</span></span> <span data-ttu-id="0f5ac-940">その他のペイロード データ フィールドは、他のイベントの種類に利用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-940">Other payload data fields are utilized for other event types.</span></span> <span data-ttu-id="0f5ac-941">事前に定義されたイベントの種類とそのペイロード フィールドの完全な一覧は、「[付録 E - GUIX イベントの説明](appendix-e.md)」で定義されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-941">The complete list of pre-defined event types and their payload fields is defined in [Appendix E - GUIX Event Descriptions](appendix-e.md).</span></span>

<span data-ttu-id="0f5ac-942">アプリケーションではまた、定数 **GX_FIRST_APP_EVENT** の後に数値で始めて、独自のカスタム イベントを追加することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-942">The application can also add its own custom events, starting numerically after the constant **GX_FIRST_APP_EVENT**.</span></span> <span data-ttu-id="0f5ac-943">この定数の後のすべてのイベント番号が、そのアプリケーションの使用のために予約されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-943">All event numbers after this constant are reserved for the application’s use.</span></span> <span data-ttu-id="0f5ac-944">当然ながら、このアプリケーションのウィジェット イベント ハンドラーには、このようなアプリケーション イベントの処理が含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-944">Of course, the application’s widget event handler must have processing for such application events.</span></span>

### <a name="event-processing"></a><span data-ttu-id="0f5ac-945">イベント処理</span><span class="sxs-lookup"><span data-stu-id="0f5ac-945">Event Processing</span></span> 

<span data-ttu-id="0f5ac-946">すべてのウィジェットには、***gx_<widget-type>_event_process*** という名前の既定のウィジェット イベント処理関数があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-946">There is a default widget event processing function for each and every widget, named ***gx_<widget-type>_event_process***.</span></span> <span data-ttu-id="0f5ac-947">ほとんどの場合、アプリケーションは、特定のどのウィジェットのイベント処理にも関与する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-947">In most cases, the application won’t need to worry about the event handling of any given widget.</span></span> <span data-ttu-id="0f5ac-948">ただし、アプリケーションにカスタム イベント処理または補足的なイベント処理が必要な状況では、アプリケーションが GUIX API ***gx_widget_event_process_set*** を使用して、既定の処理関数を独自の処理関数でオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-948">However, in situations where the application requires custom or supplemental event processing, the application may override the default processing function with its own via the GUIX API ***gx_widget_event_process_set***.</span></span> <span data-ttu-id="0f5ac-949">この関数では、既定のイベント処理関数を API で指定されているイベント処理関数でオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-949">This function overrides the default event processing function with the event function processing function specified in the API.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0f5ac-950">アプリケーション イベント処理関数では、既定の ***gx_widget_event_process*** の処理を直接呼び出すだけで、既定の処理を利用できます (つまり、処理を複製する必要はありません)。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-950">Application event processing functions can take advantage (i.e., not duplicate the processing) of the default processing by simply calling the default ***gx_widget_event_process*** processing directly.</span></span>

<span data-ttu-id="0f5ac-951">イベント処理は、内部の GUIX システム スレッドのコンテキストから排他的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-951">Event processing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="0f5ac-952">この方法では、イベント処理を実行するためのスタックの要件が GUIX スレッドにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-952">In this way, the stack requirements to process the event handling only applies to the GUIX thread.</span></span>

### <a name="implementing-custom-event-processing-example"></a><span data-ttu-id="0f5ac-953">カスタム イベント処理の実装 (例)</span><span class="sxs-lookup"><span data-stu-id="0f5ac-953">Implementing Custom Event Processing (example)</span></span> 

<span data-ttu-id="0f5ac-954">GUIX システムの任意のウィジェットまたはウィンドウに対して独自のイベント処理関数を提供できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-954">You can provide your own event processing function for any widget or window in the GUIX system.</span></span> <span data-ttu-id="0f5ac-955">独自のカスタムのウィジェットの種類を作成している場合は通常、そのウィジェット作成関数でカスタム イベント ハンドラーをインストールします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-955">If you are creating your own custom widget type, you will normally install your custom event handler in the widget creation function.</span></span> <span data-ttu-id="0f5ac-956">既存のウィジェットまたはウィンドウの操作を拡張または変更しているだけである場合は、そのウィジェットまたはウィンドウが作成された後に gx_widget_event_process_set API 関数を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-956">If you are just extending or modifying the operation of an existing widget or window, you can call the gx_widget_event_process_set API function after the widget or window has been created.</span></span> <span data-ttu-id="0f5ac-957">子コントロールによって生成されたイベントを処理するために、最上位レベルのウィンドウ (画面とも呼ばれます) には、ほぼ常に独自のイベント処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-957">You will almost always provide your own event handling for your top-level windows (also called Screens) in order to process events generated by your child controls.</span></span> <span data-ttu-id="0f5ac-958">画面の子コントロールによって生成されたイベントの処理は、GUIX アプリケーションに機能を追加するための主な方法です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-958">Processing event generated by the child controls of a screen is the main way you add functionality to your GUIX application.</span></span>

<span data-ttu-id="0f5ac-959">例として、"main_menu" という名前の最上位レベルの画面を定義するとします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-959">As an example, suppose you define a top-level screen named “main_menu”.</span></span>
<span data-ttu-id="0f5ac-960">この画面は、GUIX Studio を使用して定義することも、アプリケーション コードで作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-960">This screen might be defined using GUIX Studio, or you might create this screen in your application code.</span></span> <span data-ttu-id="0f5ac-961">GUIX Studio 内でこの画面を定義する場合は、その画面に対する Studio のプロパティ フィールドにイベント ハンドラーの名前を入力するだけで、Studio で生成された仕様コードによってそのイベント ハンドラーが自動的にインストールされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-961">If you define the screen within GUIX Studio, you simply type the name of your event handler in the Studio properties field for that screen, and the Studio generated specifications code will automatically install your event handler.</span></span> <span data-ttu-id="0f5ac-962">この場合は、カスタム イベント ハンドラー ***main_menu_event_handler*** を呼び出しますが、それは次のようにコーディングされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-962">In this case, we will call the custom event handler ***main_menu_event_handler*** and it should be coded like this:</span></span>

```C
int main_menu_item; /* example: variable to keep track of selected item */

UINT main_menu_event_handler(GX_WINDOW *main_screen, GX_EVENT *event_ptr)
{
    UINT status = GX_SUCCESS;

    switch(event_ptr->gx_event_type)
    {
    /* this is an example for catching events from a child button */
    case GX_SIGNAL(IDB_CHILD_BUTTON, GX_EVENT_CLICKED):
        /* insert your button handler code here */
        break;

    case GX_EVENT_SHOW:
        /* add functionality to the show event handler */
        /* first, do default processing */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */

        /* now add my own processing */
        main_menu_item = 0;
        break;

    default:
        /* pass all other events to base processing function */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */
        break;
    }
    return status;
}
```

<span data-ttu-id="0f5ac-963">上記の例では、**GX_EVENT_SHOW** (ウィジェットに状態変更を通知するために内部的に生成されたイベント) などのシステム イベントの場合、通常の処理が確実に実行されるようにするには、アプリケーションでこれらのイベントを基本ウィジェット イベント処理関数に渡す必要がある点に注意することが重要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-963">In the example above, it is important to notice that for system events like **GX_EVENT_SHOW** (events generated internally to notify a widget of a status change), the application must pass those events to the base widget event processing function to insure that the normal processing occurs.</span></span> <span data-ttu-id="0f5ac-964">アプリケーションでは、その後、必要に応じて追加のロジックを追加できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-964">The application can then add additional logic as desired.</span></span> <span data-ttu-id="0f5ac-965">また、アプリケーションによって処理されないすべてのイベント (上記の既定のケース) も基本イベント処理関数に渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-965">All events that are not handled by the application (the default case above) should also be passed to the base event processing function.</span></span> <span data-ttu-id="0f5ac-966">この例は **GX_WINDOW** に基づいた最上位レベルの画面のものであったため、既定のイベント処理関数は gx_window_event_process です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-966">Since this example was for a top-level screen based on **GX_WINDOW**, the default event processing function is gx_window_event_process.</span></span>

### <a name="drawing-function"></a><span data-ttu-id="0f5ac-967">描画関数</span><span class="sxs-lookup"><span data-stu-id="0f5ac-967">Drawing Function</span></span> 

<span data-ttu-id="0f5ac-968">ウィジェットの描画はすべて、イベント処理とは別に実行されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-968">All widget drawing is performed separately from the event handling.</span></span> <span data-ttu-id="0f5ac-969">描画は通常、CPU サイクルの点から見てコストが高いため、この方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-969">This is more efficient because drawing is usually expensive in terms of CPU cycles.</span></span> <span data-ttu-id="0f5ac-970">遅延描画アルゴリズムの実装によって、未処理のイベントとそれに関連付けられた表示の変更をすべて完了してから描画を実行することが可能になります。これにより、描画の浪費が解消されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-970">By implementing a deferred drawing algorithm, all of the outstanding events and associated display changes can be completed before any drawing is done, thus eliminating wasted drawing.</span></span> <span data-ttu-id="0f5ac-971">イベント処理と同様に、ほとんどのウィジェットには、***gx_<widget-type>_draw*** という名前の既定のウィジェット描画関数があります。ここで、xxx はウィジェットの種類です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-971">Similar to event processing, there is a default widget drawing function for most widgets, named ***gx_<widget-type>_draw***, where xxx is the widget type.</span></span> <span data-ttu-id="0f5ac-972">ほとんどの場合、アプリケーションは、特定のどのウィジェットの描画関数にも関与する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-972">In most cases, the application won’t need to worry about the drawing function of any given widget.</span></span> <span data-ttu-id="0f5ac-973">ただし、アプリケーションにカスタム描画または補足的な描画が必要な状況では、アプリケーションが GUIX API ***gx_widget_draw_set*** を使用して、既定の描画関数を独自の描画関数でオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-973">However, in situations where the application requires custom or supplemental drawing, the application may override the default drawing function with its own via the GUIX API ***gx_widget_draw_set***.</span></span> <span data-ttu-id="0f5ac-974">この関数を使用すると、アプリケーションでは、任意のウィジェットに対して独自のカスタマイズされた描画関数を提供できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-974">This function allows the application to provide its own customized drawing function for any widget.</span></span> <span data-ttu-id="0f5ac-975">これにより、アプリケーションはさらに、新しいウィジェットの種類の全体を定義できるようになります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-975">This further allows the application to define entire new widget types.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0f5ac-976">アプリケーション描画関数では、オーバーライドされた描画関数から直接呼び出すだけで、既定の描画を利用できます (つまり、コードを複製する必要はありません)。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-976">Application drawing functions can take advantage (i.e., not duplicate the coding) of the default drawing by simply calling it directly from the overridden drawing function.</span></span>

<span data-ttu-id="0f5ac-977">ウィジェット描画は、内部の GUIX システム スレッドのコンテキストから排他的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-977">Widget drawing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="0f5ac-978">この方法では、描画を実行するためのタイミングとスタックの要件が GUIX スレッドにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-978">In this way, the timing and stack requirements to perform the drawing only apply to the GUIX thread.</span></span>

### <a name="implementing-custom-drawing-example"></a><span data-ttu-id="0f5ac-979">カスタム描画の実装 (例)</span><span class="sxs-lookup"><span data-stu-id="0f5ac-979">Implementing Custom Drawing (example)</span></span> 

<span data-ttu-id="0f5ac-980">どのウィジェットの描画関数も、GX_WIDGET コントロール ブロックのメンバーである間接関数ポインターを通して参照されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-980">The drawing function for any widget is referenced through an indirect function pointer which is a member of the GX_WIDGET control block.</span></span> <span data-ttu-id="0f5ac-981">GUIX Studio を使用してウィジェットを定義する場合は、ウィジェットのプロパティの [描画関数] パラメーターに関数の名前を入力するだけで、独自の関数ポインターをインストールできます。そのウィジェットが作成されると、Studio によって関数ポインターが自動的にインストールされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-981">If you use GUIX Studio to define your widget, you can install your own function pointer simply by typing the name of your function in the “Drawing Function” parameter of the widget properties, and Studio will install your function pointer for you when the widget is created.</span></span> <span data-ttu-id="0f5ac-982">アプリケーション コードでウィジェットを作成する場合は、そのウィジェットが作成された後に、***gx_widget_draw_set*** API 関数を使用してカスタム描画関数をインストールする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-982">If you create the widget in your application code, you must use the ***gx_widget_draw_set*** API function to install your custom drawing function after the widget has been created.</span></span>

<span data-ttu-id="0f5ac-983">この例では、ボタンの外観をカスタマイズする場合を想定してみましょう。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-983">For this example, let’s assume that you want to customize the appearance of a button.</span></span> <span data-ttu-id="0f5ac-984">このボタンは **GX_TEXT_BUTTON** と非常に似ていますが、ボタンが押されているときはボタンの中央右側の部分に小さな緑色の "LED_ON" ビットマップを、ボタンが押されていないときは小さな "LED_OFF" ビットマップを描画する処理を追加します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-984">The button will look very much like a **GX_TEXT_BUTTON**, but we will add drawing a small green “LED_ON” bitmap in the middle-right portion of the button when the button is pressed, and small “LED_OFF” bitmap when the button is not pressed.</span></span> <span data-ttu-id="0f5ac-985">ここで作成しようとしているのは次の図のようなボタンです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-985">We want to create a button that looks like the illustrations below.</span></span>

!["オン" の場合の緑色のボタンのスクリーンショット。](./media/guix/image4.jpg) <span data-ttu-id="0f5ac-987">カスタム ボタン "オン"</span><span class="sxs-lookup"><span data-stu-id="0f5ac-987">custom button “on”</span></span>

!["オフ" の場合の赤色のボタンのスクリーンショット。](./media/guix/image5.jpg) <span data-ttu-id="0f5ac-989">カスタム ボタン "オフ"</span><span class="sxs-lookup"><span data-stu-id="0f5ac-989">custom button “off”</span></span>

<span data-ttu-id="0f5ac-990">この場合は、次のようなボタン描画関数を記述します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-990">In this case, we would write a button drawing function that looks something like the following.</span></span>

```C
UINT my_button_draw(GX_TEXT_BUTTON *button)
{
    GX_PIXELMAP *map;
    ULONG button_style;
    INT xpos;
    INT ypos;

    /* first, do the normal text button drawing */
    gx_text_button_draw(button);

    /* now add our extra pixelmap */

    gx_widget_style_get(button, &button_style);

    if (button_style & GX_STYLE_BUTTON_PUSHED)
    {
        /* use the ON pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_ON, &map);
    }
    else
    {
        /* use the OFF pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_OFF, &map);
    }
    if (map)
    {
        /* draw it 20 pixels in from right edge */
        xpos = button->gx_widget_size.gx_rectangle_right;
        xpos -= map->gx_pixelmap_width + 20;

        /* and draw 10 pixels from the top edge */
        ypos = button->gx_widget_size.gx_rectangle_top + 10;

        /* draw the extra pixelmap on top of the button */
        gx_canvas_pixelmap_draw(xpos, ypos, map);
    }
}
```

## <a name="guix-drawing-context-component"></a><span data-ttu-id="0f5ac-991">GUIX 描画コンテキスト コンポーネント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-991">GUIX Drawing Context Component</span></span> 

<span data-ttu-id="0f5ac-992">描画コンテキストは、GUIX によって各キャンバス更新操作が実行されるとき、実行時に動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-992">The drawing context is created dynamically, at runtime, as GUIX performs each canvas refresh operation.</span></span> <span data-ttu-id="0f5ac-993">描画コンテキストによって、キャンバス、画面ドライバー、現在の描画操作を実行するために使用されるブラシが結び付けられます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-993">The drawing context ties together the canvas, screen driver, and brush being used to perform the current drawing operations.</span></span>

<span data-ttu-id="0f5ac-994">描画コンテキストは、**GX_DRAW_CONTEXT** 構造体によって定義されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-994">The drawing context is defined by the **GX_DRAW_CONTEXT** structure.</span></span>
<span data-ttu-id="0f5ac-995">この構造体には、現在の描画操作のクリッピングとビューを定義する変数、現在のキャンバスを定義する変数、使用されている現在の画面ドライバーを定義する変数が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-995">This structure contains variables that define the clipping and view of the current drawing operation, define the current canvas, and define the current screen driver in use.</span></span> <span data-ttu-id="0f5ac-996">また、**GX_DRAW_CONTEXT** 構造体には、描画に使用されるブラシも保持されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-996">The **GX_DRAW_CONTEXT** structure also holds the brush being used for drawing.</span></span> <span data-ttu-id="0f5ac-997">描画コンテキスト ブラシは、カスタム描画関数で直接操作するメンバーです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-997">The draw context brush is the member that you will work directly with in your custom drawing functions.</span></span> <span data-ttu-id="0f5ac-998">ブラシ構造体は、次のコードに示すように定義されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-998">The brush structure is defined as shown in the code below.</span></span>

```C
typedef struct GX_BRUSH_STRUCT
{
    GX_PIXELMAP *gx_brush_pixelmap;
    GX_FONT     *gx_brush_font;
    ULONG        gx_brush_line_pattern;
    ULONG        gx_brush_pattern_mask;
    GX_COLOR     gx_brush_fill_color;  
    GX_COLOR     gx_brush_line_color;  
    UINT         gx_brush_style;
    GX_VALUE     gx_brush_width;
    UCHAR        gx_brush_alpha;  
} GX_BRUSH;
```

<span data-ttu-id="0f5ac-999">**gx_brush_pixelmap** フィールドでは、四角形と多角形の塗りつぶしに使用するピクセルマップを定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-999">The **gx_brush_pixelmap** field defines a pixelmap to use for rectangle and polygon fills.</span></span> <span data-ttu-id="0f5ac-1000">このメンバーは、**gx_brush_style** に **GX_BRUSH_PIXELMAP** スタイルが含まれていない限り使用されません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1000">This member is not used unless the **gx_brush_style** is includes the **GX_BRUSH_PIXELMAP** style.</span></span>

<span data-ttu-id="0f5ac-1001">**gx_brush_font** メンバーでは、テキスト描画に使用されるフォントを定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1001">The **gx_brush_font** member defines the font used for text drawing.</span></span>
<span data-ttu-id="0f5ac-1002">**gx_brush_line_pattern** メンバーでは、破線に使用されるパターンを定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1002">The **gx_brush_line_pattern** member defines the pattern used for dashed lines.</span></span>
<span data-ttu-id="0f5ac-1003">**gx_brush_style** メンバーは、ブラシ属性を完全に定義するために OR で結合できる一連のスタイル フラグです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1003">The **gx_brush_style** member is a set of style flags that can be OR’d together to fully define the brush attributes.</span></span> <span data-ttu-id="0f5ac-1004">使用可能なブラシ スタイル フラグには、次のものが含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1004">The available brush style flags include the following.</span></span>

<span data-ttu-id="0f5ac-1005">**GX_BRUSH_OUTLINE**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1005">**GX_BRUSH_OUTLINE**</span></span>  
<span data-ttu-id="0f5ac-1006">**GX_BRUSH_SOLID_FILL**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1006">**GX_BRUSH_SOLID_FILL**</span></span>  
<span data-ttu-id="0f5ac-1007">**GX_BRUSH_PIXELMAP_FILL**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1007">**GX_BRUSH_PIXELMAP_FILL**</span></span>  
<span data-ttu-id="0f5ac-1008">**GX_BRUSH_ALIAS**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1008">**GX_BRUSH_ALIAS**</span></span>  
<span data-ttu-id="0f5ac-1009">**GX_BRUSH_UNDERLINE**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1009">**GX_BRUSH_UNDERLINE**</span></span>  
<span data-ttu-id="0f5ac-1010">**GX_BRUSH_ROUND**</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1010">**GX_BRUSH_ROUND**</span></span>

<span data-ttu-id="0f5ac-1011">**gx_brush_width** メンバーでは、線描画での線の幅、または輪郭のある図形の描画での輪郭の幅を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1011">The **gx_brush_width** member defines the line with for line drawing, or the outline width for outlined shape drawing.</span></span>

<span data-ttu-id="0f5ac-1012">**gx_brush_line_color** メンバーでは、線描画とテキスト描画での前景色を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1012">The **gx_brush_line_color** member defines the foreground color for line drawing and for text drawing.</span></span>

<span data-ttu-id="0f5ac-1013">**gx_brush_fill_color** メンバーでは、図形の塗りつぶしに使用される単色塗りつぶしの色を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1013">The **gx_brush_fill_color** member defines the solid fill color used for shape filling.</span></span> <span data-ttu-id="0f5ac-1014">GUIX コンテキスト コンポーネントは、アクティブなコンテキスト内の現在のブラシを非常に簡単に変更できるように設計された一連の API を提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1014">The GUIX context component provides a set of APIs designed to make it very easy to modify the current brush within the active context.</span></span> <span data-ttu-id="0f5ac-1015">これらの API には、**gx_context_brush_define**、**gx_context_line_color_set**、**gx_context_fill_color_set**、**gx_context_font_set**、その他多数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1015">These APIs include **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set**, and many others.</span></span>

<span data-ttu-id="0f5ac-1016">親オブジェクトの描画コンテキストは、そのオブジェクトの子によって継承されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1016">The draw context of a parent object is inherited by the objects children.</span></span> <span data-ttu-id="0f5ac-1017">実際には、子オブジェクトの描画関数が呼び出されたときに、そのオブジェクトによって親描画コンテキストの複製が継承されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1017">Actually, a clone of the parent drawing context is inherited by the child objects when their drawing functions are invoked.</span></span> <span data-ttu-id="0f5ac-1018">子は、親の描画に影響を与えることなくそのコンテキストを変更できますが、必要に応じて、ブラシの色やスタイルなどの情報を親から継承することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1018">The child can modify the context without affecting the parent drawing, but it can also inherit information from the parent such as brush color and style if desired.</span></span>

## <a name="guix-window-component"></a><span data-ttu-id="0f5ac-1019">GUIX ウィンドウ コンポーネント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1019">GUIX Window Component</span></span> 

<span data-ttu-id="0f5ac-1020">ウィンドウ コンポーネントは、GUIX でのすべてのウィンドウ処理を担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1020">The window component is responsible for all window processing in GUIX.</span></span> <span data-ttu-id="0f5ac-1021">GUIX ウィンドウは基本的に、1 つ以上の子ウィジェットを含むことができる個別のディスプレイ領域です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1021">A GUIX window is fundamentally a distinct display area that may contain one or more child widgets.</span></span> <span data-ttu-id="0f5ac-1022">GUIX では、ウィンドウは実際には、基本ウィジェット オブジェクトの特殊な形式にすぎません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1022">In GUIX, the window is actually just a special form of the fundamental widget object.</span></span>

<span data-ttu-id="0f5ac-1023">GUIX ウィンドウは、継承が完全にサポートされた、オブジェクト指向の方法で実装されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1023">GUIX windows are implemented in an object oriented manner with full support of inheritance.</span></span> <span data-ttu-id="0f5ac-1024">これは、ANSI C を使用して実現されます。これにより、メモリや処理の要件が可能な限り最小限になります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1024">This is accomplished using ANSI C, which results in the smallest possible memory and processing requirements.</span></span>

<span data-ttu-id="0f5ac-1025">GUIX ウィンドウは、主に水平および垂直スクロールのサポートを追加することによって、GUIX ウィジェットの機能を拡張します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1025">GUIX windows extend the functionality of the GUIX widget primarily by adding support for horizontal and vertical scrolling.</span></span> <span data-ttu-id="0f5ac-1026">GUIX ウィンドウ オブジェクトでは、スクロール バーを自動的に作成して表示し、スクロール バーの入力に応答できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1026">GUIX window objects can automatically create and display scroll bars and respond to scroll bar input.</span></span> <span data-ttu-id="0f5ac-1027">また、移動可能なウィンドウには、ペン入力イベントに基づいてウィンドウを移動またはドラッグできるようにするためのイベント処理も組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1027">Movable windows also have built in event handling to allow the window to be moved or dragged based on pen input events.</span></span>
<span data-ttu-id="0f5ac-1028">最後に、GUIX ウィンドウでは入力フォーカスを受け取ると、そのウィンドウをウィンドウ Z オーダーの前面に移動することによって応答します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1028">Finally, GUIX window responds to receiving input focus by moving the window to the front of the window Z-order.</span></span>

<span data-ttu-id="0f5ac-1029">GUIX ウィンドウでは、"*クライアント領域*" の概念を保持しています。これは、ウィンドウの境界線やスクロール バーなどのクライアント以外のオブジェクトが使用可能な領域から削除された後のウィンドウの内側の部分です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1029">GUIX window maintains the concept of *client area*, which is the inner portion of the window once the window borders and non-client objects such as scrollbars are removed from the available area.</span></span> <span data-ttu-id="0f5ac-1030">クライアント領域の子ウィジェットがウィンドウ クライアント領域にクリップされるのに対して、スクロール バーなどのクライアント以外の子はクライアント領域の外部に描画することを許可されますが、引き続きそのウィンドウの外側のディメンションにはクリップされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1030">Client area child widgets are clipped to the window client area, while non-client children such as scroll bars are allowed to draw outside of the client area, but are still clipped to the window outer dimensions.</span></span>

<span data-ttu-id="0f5ac-1031">ウィンドウは、親 - 子という形で管理されます。ここで、子は特性をその親から継承します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1031">Windows are maintained in a parent-child manner, where the children inherit characteristics from their parent.</span></span> <span data-ttu-id="0f5ac-1032">子ウィンドウはそれ自身の子ウィンドウを持つことができます。その子ウィンドウも、さまざまな特性を親から継承します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1032">Children windows may have their own child windows, again inheriting various characteristics from the parent.</span></span> <span data-ttu-id="0f5ac-1033">どのウィンドウの特性も、各種の GUIX API 呼び出しを使用して明示的に再定義できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1033">The characteristics of any window may be explicitly redefined via various GUIX API calls.</span></span>

### <a name="window-creation"></a><span data-ttu-id="0f5ac-1034">ウィンドウの作成</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1034">Window Creation</span></span> 

<span data-ttu-id="0f5ac-1035">ウィンドウ オブジェクトは、初期化中に作成することも、アプリケーション スレッドの実行中の任意の時点で作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1035">A window object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="0f5ac-1036">アプリケーションで作成できるウィンドウ オブジェクトの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1036">There is no limit on the number of window objects that can be created by an application.</span></span> <span data-ttu-id="0f5ac-1037">また、ウィンドウが持つことができる子の数にも制限はありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1037">There is also no limit on the number of children any window may have.</span></span>

### <a name="window-control-block"></a><span data-ttu-id="0f5ac-1038">ウィンドウ コントロール ブロック</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1038">Window Control Block</span></span> 

<span data-ttu-id="0f5ac-1039">各ウィンドウ オブジェクトの特性は、そのコントロール ブロック **GX_WINDOW** 内にあり、**_gx_api.h_** で定義されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1039">The characteristics of each window object are found in its control block **GX_WINDOW** and are defined in **_gx_api.h_**.</span></span> <span data-ttu-id="0f5ac-1040">ウィンドウ オブジェクトに必要なメモリはアプリケーションによって提供され、メモリ内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1040">The memory required for a window object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="0f5ac-1041">ただし、ウィンドウ オブジェクト コントロール ブロックは、すべての関数のスコープ外に定義することによってグローバル構造体にすることが最も一般的です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1041">However, it is most common to make the window object control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="root-window"></a><span data-ttu-id="0f5ac-1042">ルート ウィンドウ</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1042">Root Window</span></span> 

<span data-ttu-id="0f5ac-1043">GUIX では、ルート ウィンドウと呼ばれるものがキャンバスごとに必要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1043">GUIX requires what is called a root window for each canvas.</span></span> <span data-ttu-id="0f5ac-1044">ルート ウィンドウは境界線がなく、それがアタッチされているキャンバスと同じディメンションを持っています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1044">The root window is borderless and has the same dimensions as the canvas to which it is attached.</span></span> <span data-ttu-id="0f5ac-1045">これは主に、すべての第 1 レベルのウィジェットおよびウィンドウのコンテナーとして使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1045">It is used primarily as a container for all first-level widgets and windows.</span></span> <span data-ttu-id="0f5ac-1046">ルート ウィンドウは通常、画面とキャンバスの作成のすぐ後に、API 関数 ***gx_window_root_create*** を使用してアプリケーションによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1046">The root window is typically created by the application via the API function ***gx_window_root_create***, shortly after the creation of the screen and canvas.</span></span> <span data-ttu-id="0f5ac-1047">Studio で生成された関数 gx_studio_display_configure を使用する場合は、ルート ウィンドウのアドレスを、この関数への最後のパラメーターとして渡された場所に返すことができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1047">If you use the Studio generated function gx_studio_display_configure, the address of the root window can be returned in the location passed as the last parameter to this function.</span></span>

<span data-ttu-id="0f5ac-1048">ルート ウィンドウは既定では移動不可能になっており、最も単純なケースでは、ルート ウィンドウはキャンバスのサイズになります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1048">A root window defaults to being un-moveable, and in the simplest case the root window is the size of the canvas.</span></span> <span data-ttu-id="0f5ac-1049">ルート ウィンドウでは、実質的にディスプレイの背景を描画するため、ディスプレイの背景色を変更したり、背景壁紙を表示したりするには、ルート ウィンドウに色または壁紙を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1049">The root window in effect draws the display background, so to change the display background color or to display background wallpaper you would assign a color or wallpaper to the root window.</span></span>

<span data-ttu-id="0f5ac-1050">ルート ウィンドウが移動可能な場合は、子ウィンドウの場合のようにキャンバス上の位置を変更するのではなく、キャンバス自体を移動することによってルート ウィンドウを移動します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1050">If a root window is moveable, it moves not by changing its position on the canvas as a child window would do, but by moving the canvas itself.</span></span>
<span data-ttu-id="0f5ac-1051">この機能により、GUIX ルート ウィンドウでは、ハードウェア オフセット レジスタを備えた複数のフレーム バッファーをサポートするハードウェアを利用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1051">This feature allows the GUIX root window to leverage hardware that supports multiple frame buffers with hardware offset registers.</span></span>

### <a name="background"></a><span data-ttu-id="0f5ac-1052">バックグラウンド</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1052">Background</span></span> 

<span data-ttu-id="0f5ac-1053">ウィンドウの背景は、単色またはビットマップ イメージのどちらかです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1053">Window backgrounds are either solid colors or bitmap images.</span></span> <span data-ttu-id="0f5ac-1054">システム レベルでは、一連の初期ウィンドウの既定値を提供する既定のウィンドウの背景があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1054">There is a default window background at the system level which provides the default for the initial set of windows.</span></span> <span data-ttu-id="0f5ac-1055">当然ながら、ウィンドウの背景はすべて、GUIX API を使用して変更できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1055">Of course, any window background can be changed via the GUIX API.</span></span>

<span data-ttu-id="0f5ac-1056">ウィンドウの単色の背景を変更するには、***gx_widget_fill_color_set*** API を使用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1056">To change the solid color background of a window, use the ***gx_widget_fill_color_set*** API.</span></span> <span data-ttu-id="0f5ac-1057">ウィンドウに背景壁紙を割り当てるには、***gx_window_wallpaper_set*** API を使用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1057">To assign a background wallpaper to a window, use the ***gx_window_wallpaper_set*** API.</span></span>

### <a name="scrolling"></a><span data-ttu-id="0f5ac-1058">スクロール</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1058">Scrolling</span></span> 

<span data-ttu-id="0f5ac-1059">GUIX では、ウィンドウの子を表示するために必要な領域がそのウィンドウの現在のサイズ (水平または垂直、あるいはその両方) を超えた場合、標準のウィンドウ スクロールをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1059">GUIX supports standard window scrolling when area required to display the window children exceeds the current size of the window – horizontally and/or vertically.</span></span> <span data-ttu-id="0f5ac-1060">スクロールを有効にするには、アプリケーションで目的のスクロール バーを作成し、それをウィンドウにアタッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1060">To enable scrolling, the application must create the desired scroll bars and attach them to the window.</span></span>

<span data-ttu-id="0f5ac-1061">GUIX ウィンドウ コンポーネントは、ウィンドウ クライアント領域のサイズとすべての子ウィジェットの範囲に基づいた既定のスクロール実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1061">The GUIX window component provides a default scrolling implementation based on the size of the window client area and the extent of the all child widgets.</span></span> <span data-ttu-id="0f5ac-1062">また、アプリケーションで特定のウィンドウの ***gx_window_scroll_info_get*** 関数をオーバーライドすることによって、独自のスクロール実装と解釈を提供することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1062">Applications can also provide their own scrolling implementation and interpretation by overriding the ***gx_window_scroll_info_get*** function for a particular window.</span></span>

### <a name="event-notification"></a><span data-ttu-id="0f5ac-1063">イベント通知</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1063">Event Notification</span></span> 

<span data-ttu-id="0f5ac-1064">既定のウィンドウ イベント処理関数は、主にスクロールおよびサイズ変更イベントの処理で GX_WIDGET のイベント処理とは異なります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1064">The default window event processing function differs from the GX_WIDGET event processing primarily in the handling of scrolling and sizing events.</span></span> <span data-ttu-id="0f5ac-1065">GX_WINDOW には、スクロールおよびサイズ変更イベントの既定のハンドラーが用意されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1065">GX_WINDOW provided defalt handlers for scrolling and sizing events.</span></span>

<span data-ttu-id="0f5ac-1066">アプリケーションではまた、定数 **GX_FIRST_APP_EVENT** の後に数値で始めて、独自のカスタム イベントを追加することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1066">The application can also add its own custom events, starting numerically after the constant **GX_FIRST_APP_EVENT**.</span></span> <span data-ttu-id="0f5ac-1067">この定数の後のすべてのイベント番号が、そのアプリケーションの使用のために予約されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1067">All event numbers after this constant are reserved for the application’s use.</span></span> <span data-ttu-id="0f5ac-1068">当然ながら、このアプリケーションのウィンドウ イベント ハンドラーには、このようなアプリケーション イベントの処理が含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1068">Of course, the application’s window event handler must have processing for such application events.</span></span>

### <a name="event-processing"></a><span data-ttu-id="0f5ac-1069">イベント処理</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1069">Event Processing</span></span> 

<span data-ttu-id="0f5ac-1070">その他のすべてのウィジェットの種類と同様に、すべてのウィンドウには、***gx_window_event_process*** という名前の既定のウィンドウ イベント処理関数があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1070">Just like all other widget types, there is a default window event processing function for every window, named ***gx_window_event_process***.</span></span> <span data-ttu-id="0f5ac-1071">このイベント処理関数は通常、ユーザーが作成したウィンドウの独自のイベント ハンドラーでオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1071">You will usually override this event handling function with your own event handler in the windows that you create.</span></span> <span data-ttu-id="0f5ac-1072">この方法で、イベントに応答したり、ウィンドウの子コントロールによって生成されたイベントに基づいてアクションを実行したりします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1072">This is how you will respond to events and take action based on events generated by the window child controls.</span></span>

<span data-ttu-id="0f5ac-1073">そのイベント ハンドラーをオーバーライドする場合は、イベント ハンドラーに追加している任意のアクションに加えて既定のイベント処理を実行できるようにするために、忘れずに GUIX システム イベントの基本 ***gx_window_event_process*** 関数を呼び出すことが重要です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1073">It is important to remember to invoke the base ***gx_window_event_process*** function for GUIX system events if you override that event handler, to allow the default event handling to occur in addition to whatever action you are adding to the event handler.</span></span> <span data-ttu-id="0f5ac-1074">たとえば、**GX_EVENT_SHOW** イベントのカスタム ハンドラーを提供しても、このイベントを ***gx_window_event_process*** に渡さないと、そのウィンドウは表示されません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1074">For example if you provide a custom handler for the **GX_EVENT_SHOW** event, and do not pass this event to ***gx_window_event_process***, your window will never become visible.</span></span>
<span data-ttu-id="0f5ac-1075">ウィンドウのカスタム イベント ハンドラーを提供するには、***gx_widget_event_process_set*** 関数を使用して、そのイベント ハンドラーのアドレスを定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1075">To provide a custom event handler for a window, use the ***gx_widget_event_process_set*** function to define the address of your event handler.</span></span> <span data-ttu-id="0f5ac-1076">この関数では、既定のイベント処理関数を API で指定されているイベント処理関数でオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1076">This function overrides the default event processing function with the event function processing function specified in the API.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0f5ac-1077">アプリケーション イベント処理関数では、既定の ***gx_window_event_process*** を直接呼び出すだけで、既定の処理を利用できます (つまり、処理を複製する必要はありません)。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1077">Application event processing functions can take advantage (i.e., not duplicate the processing) of the default processing by simply calling the default ***gx_window_event_process*** directly.</span></span>

<span data-ttu-id="0f5ac-1078">イベント処理は、内部の GUIX システム スレッドのコンテキストから排他的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1078">Event processing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="0f5ac-1079">この方法では、イベント処理を実行するためのスタックの要件が GUIX スレッドにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1079">In this way, the stack requirements to process the event handling only applies to the GUIX thread.</span></span>

## <a name="guix-image-reader-component"></a><span data-ttu-id="0f5ac-1080">GUIX イメージ リーダー コンポーネント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1080">GUIX Image Reader Component</span></span> 

<span data-ttu-id="0f5ac-1081">イメージ リーダー コンポーネントは、未加工の圧縮されたイメージを GUIX ピクセルマップ形式に展開するためのユーティリティと API 関数を提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1081">The image reader component provides utilities and API functions to decompress raw compressed images to GUIX pixelmap format.</span></span> <span data-ttu-id="0f5ac-1082">JPEG および PNG 形式の未加工のイメージ データがサポートされ、将来のリリースのために追加の形式が予約されています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1082">JPEG and PNG format raw image data are supported, with additional formats reserved for future releases.</span></span>

<span data-ttu-id="0f5ac-1083">大部分の GUIX アプリケーションには GUIX イメージ リーダー コンポーネントが必要ないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1083">Note that for the vast majority of GUIX applications, the GUIX Image Reader component is not required.</span></span> <span data-ttu-id="0f5ac-1084">ほとんどのアプリケーションは、JPEG および PNG 形式のグラフィックス資産を GUIX と互換性のある **GX_PIXELMAP** リソースに変換するために GUIX Studio アプリケーションに依存しています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1084">Most applications rely on the GUIX Studio application to convert JPEG and PNG format graphics assets into GUIX compatible **GX_PIXELMAP** resources.</span></span> <span data-ttu-id="0f5ac-1085">GUIX イメージ リーダー コンポーネントは、未加工のグラフィックス資産が実行時にしか認識されない場合、またはシステム ストレージの制約のためにリソースを **GX_PIXELMAP** 形式で格納できない場合に利用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1085">The GUIX image reader component is utilized when the raw graphics assets are known only at runtime, or when the system storage constraints prevent storing resources in **GX_PIXELMAP** format.</span></span> <span data-ttu-id="0f5ac-1086">JPEG および PNG 形式のイメージ データは一般に **GX_PIXELMAP** 形式よりコンパクトですが、これらのイメージの種類の展開および色空間の変換の動的な実行に関連した非常に大きなランタイム オーバーヘッドが発生します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1086">JPEG and PNG format image data is generally more compact than **GX_PIXELMAP** format, however there is considerable runtime overhead associated with performing decompression and color space conversion of these image types dynamically.</span></span>

<span data-ttu-id="0f5ac-1087">未加工の形式の JPEG または PNG イメージが gx_canvas_pixelmap_draw API 関数に渡された場合、GUIX では、その JPEG または PNG データを動的に展開して描画します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1087">If raw format JPEG or PNG images are passed to the gx_canvas_pixelmap_draw API function, GUIX dynamically decompresses and draws the JPEG or PNG data.</span></span> <span data-ttu-id="0f5ac-1088">これがランタイム描画速度に重大な悪影響を与えることに注意してください。ハードウェアで支援された JPEG または PNG の展開をサポートするハードウェア ターゲットを使用していない限り、RAW 形式のイメージ データを gx_canvas_pixelmap_draw 関数に渡すことはお勧めできません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1088">Note that this will have a significant negative impact on runtime drawing speed, and passing RAW format image data to the gx_canvas_pixelmap_draw function is not recommended unless you are using a hardware target that supports hardware assisted JPEG or PNG decompression.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0f5ac-1089">未加工の JPEG または PNG 形式のイメージを gx_canvas_pixelmap_draw API に渡すと、ほとんどのターゲット ハードウェアで重大なランタイム オーバーヘッドが発生します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1089">Passing raw JPEG or PNG formatted images to the gx_canvas_pixelmap_draw API incurs significant runtime overhead for most target hardware.</span></span>

<span data-ttu-id="0f5ac-1090">別の方法として、イメージ リーダー コンポーネントを使用して、未加工の JPEG および PNG データを実行時に GX_PIXELMAP 形式に変換することもできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1090">As an alternative, raw JPEG and PNG data may be converted to GX_PIXELMAP format at runtime using the Image Reader component.</span></span>
<span data-ttu-id="0f5ac-1091">この方法で生成されたピクセルマップは、Studio によって生成され、リソース ファイル内に含まれているピクセルマップと同様に使用したり、描画したりできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1091">Pixelmaps produced in this way can be used and drawn just like pixelmaps produced by Studio and contained within your resource file.</span></span> <span data-ttu-id="0f5ac-1092">これにより、アプリケーションでは、イメージの展開、ディザリング、色空間の変換などをイメージが描画されるたびに実行するのではなく、これらの操作を (通常はプログラムの起動中に) 1 回実行するだけで済むようになります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1092">This allows your application to perform the image decompression, dithering, and color space conversion one time (usually during program startup) rather than performing these operations each time the image is drawn.</span></span>

<span data-ttu-id="0f5ac-1093">イメージ リーダー コンポーネント関数には、次のものが含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1093">The Image Reader component functions include:</span></span>

<span data-ttu-id="0f5ac-1094">***gx_image_reader_create***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1094">***gx_image_reader_create***</span></span>  
<span data-ttu-id="0f5ac-1095">***gx_image_reader_palette_set***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1095">***gx_image_reader_palette_set***</span></span>  
<span data-ttu-id="0f5ac-1096">***gx_image_reader_start***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1096">***gx_image_reader_start***</span></span>

## <a name="guix-animation-component"></a><span data-ttu-id="0f5ac-1097">GUIX アニメーション コンポーネント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1097">GUIX Animation Component</span></span> 

<span data-ttu-id="0f5ac-1098">GUIX アニメーション コンポーネントは、画面とウィジェットの切り替えを自動化するために使用される一連の関数およびサービスです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1098">The GUIX Animation component is a set of functions and services used to automate screen and widget transition automations.</span></span> <span data-ttu-id="0f5ac-1099">GUIX アニメーション コンポーネントでは、任意のウィジェットの種類のフェード イン、フェード アウト、移動、またはスライドの種類のアニメーションをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1099">The GUIX Animation component supports fading in, fading out, and movement or slide type animations of any widget type.</span></span>

<span data-ttu-id="0f5ac-1100">フェードの種類のアニメーションは、フェードするウィジェットの内部アルファ値を変化させるか (**GX_BRUSH_ALPHA_SUPPORT** が有効になっている場合)、またはウィジェットのいずれかのコレクションを別のメモリ キャンバスに描画する (これにより、背景とブレンドされます) ことによってサポートできます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1100">Fade type animations can be supported either by varying the fading widget(s) internal alpha value (if **GX_BRUSH_ALPHA_SUPPORT** is enabled), or by drawing any collection of widgets to a separate memory canvas when is then blended with the background.</span></span> <span data-ttu-id="0f5ac-1101">複数のハードウェア グラフィックス レイヤーをサポートするハードウェア ターゲットの場合、スムーズなフェード効果のサポートは、このキャンバス ブレンドのアプローチを使用することによって最適に実現されます。多くの場合、コア CPU 帯域幅はほとんど必要ありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1101">For hardware targets that support multiple hardware graphics layers, support for smooth fading effects is best accomplished using this canvas blending approach, often with very little core CPU bandwidth required.</span></span> <span data-ttu-id="0f5ac-1102">複数のグラフィックス レイヤーをサポートしていないハードウェア ターゲットの場合は、16 bpp 以上の色深度で動作しているとき、GUIX ブラシのアルファ値を使用したブレンドがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1102">For hardware targets that do not support multiple graphics layers, blending using the GUIX brush alpha value is supported when running at 16 bpp and higher color depths.</span></span>

<span data-ttu-id="0f5ac-1103">アニメーションで別の描画キャンバスを使用する必要がある場合、GUIX アニメーション コンポーネントは、この目的のために API サービス gx_animation_canvas_define を提供します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1103">If an animation should use a separate drawing canvas, the GUIX Animation component provides the API service gx_animation_canvas_define for this purpose.</span></span> <span data-ttu-id="0f5ac-1104">他のアニメーションの種類では別のキャンバスは必要ありませんが、使用可能になっている場合は利用します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1104">Other animation types do not require a separate canvas, but they will utilize it if it is available.</span></span> <span data-ttu-id="0f5ac-1105">これにより、複数のハードウェア サーフェスに対する基になるハードウェア サポートの考えられる最高の使用が可能になります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1105">This makes the best possible use of any underlying hardware support for multiple hardware surfaces.</span></span>

<span data-ttu-id="0f5ac-1106">アニメーションを制御する変数は、2 つのコントロール ブロックによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1106">The variables controlling an animation are defined by two control blocks.</span></span> <span data-ttu-id="0f5ac-1107">1 つ目は、アニメーション コントローラーを定義する **GX_ANIMATION** コントロール ブロックです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1107">First, the **GX_ANIMATION** control block which defines the animation controller.</span></span> <span data-ttu-id="0f5ac-1108">アニメーション コントローラーは、ユーザーが定義したアニメーション シーケンスを実行する駆動エンジンです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1108">The animation controller is the driving engine that executes the animation sequence you define.</span></span> <span data-ttu-id="0f5ac-1109">1 つのアニメーション コントローラーを何回も再利用して、多くの異なるアニメーション シーケンスを実行できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1109">A single animation controller can be re-used many times to run many different animation sequences.</span></span> <span data-ttu-id="0f5ac-1110">複数のアニメーション シーケンスを同時に実行する必要がある場合は、複数の **GX_ANIMATION** アニメーション コントローラーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1110">If you need to run multiple animation sequences simultaneously, you can create multiple **GX_ANIMATION** animation controllers.</span></span>

<span data-ttu-id="0f5ac-1111">GUIX システム コンポーネントは、**GX_ANIMATION** 制御構造体の再利用可能なブロックを提供できます。これは、アプリケーションでアニメーションが必要になったときに要求することができ、アニメーション シーケンスが完了すると自動的にシステム プールに返されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1111">The GUIX system component can provide a re-usable block of **GX_ANIMATION** control structures, which can be requested by the application when and animation is needed and are automatically returned to the system pool when the animation sequence is completed.</span></span> <span data-ttu-id="0f5ac-1112">これにより、アプリケーションは、実装される可能性があるアニメーションごとに **GX_ANIMATION** 構造体を静的に定義する処理から解放されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1112">This frees the application from statically defining a **GX_ANIMATION** structure for every animation that might be implemented.</span></span> <span data-ttu-id="0f5ac-1113">この **GX_ANIMATION** 構造体のプールのサイズは、定数 **GX_ANIMATION_POOL_SIZE** によって定義されます。この既定値は 6 です。つまり、既定では、システム プールから 6 つの同時アニメーションを割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1113">The size of this pool of **GX_ANIMATION** structures is defined by the constant **GX_ANIMATION_POOL_SIZE**, which defaults to 6, meaning that by default 6 simultaneous animations can be allocated from the system pool.</span></span> <span data-ttu-id="0f5ac-1114">この定数は当然、それを超える数の同時アニメーションが必要になった場合は gx_user.h ヘッダー ファイルで再定義できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1114">This constant can of course be re-defined in the gx_user.h header file is more simultaneous animations are required.</span></span> <span data-ttu-id="0f5ac-1115">**GX_ANIMATION_POOL_SIZE** が 0 に設定されている場合は、GUIX システム コンポーネントによってアニメーション プールやそれに関連するサービスは提供されません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1115">If **GX_ANIMATION_POOL_SIZE** is set to zero, then the GUIX system component does not provide an animation pool or related services.</span></span>

<span data-ttu-id="0f5ac-1116">アニメーションを定義するために使用される 2 つ目のコントロール ブロックまたは構造体は、**GX_ANIMATION_INFO** 構造体です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1116">The second control block or structure used to define an animation is the **GX_ANIMATION_INFO** structure.</span></span> <span data-ttu-id="0f5ac-1117">この構造体は、特定の 1 つのアニメーション シーケンスを定義するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1117">This structure is used to define one particular animation sequence.</span></span> <span data-ttu-id="0f5ac-1118">この情報構造体は、gx_animation_start API サービスを使用してアニメーション シーケンスを開始するときにアニメーション コントローラーに渡します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1118">You pass this information structure to your animation controller to initiate an animation sequence using the gx_animation_start API service.</span></span> <span data-ttu-id="0f5ac-1119">**GX_ANIMATION_INFO** 構造体には、次のフィールドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1119">The **GX_ANIMATION_INFO** structure contains the following fields:</span></span>

```C
typedef struct GX_ANIMATION_INFO_STRUCT
{
    GX_WIDGET *gx_animation_target;
    GX_WIDGET *gx_animation_parent;
    GX_WIDGET *gx_animation_screen_list;
    USHORT gx_animation_style;
    USHORT gx_animation_id;
    USHORT gx_animation_start_delay;
    USHORT gx_animation_frame_interval;
    GX_POINT gx_animation_start_position;
    GX_POINT gx_animation_end_position;
    GX_UBYTE gx_animation_start_alpha;
    GX_UBYTE gx_animation_end_alpha;
    GX_UBYTE gx_animation_steps;
} GX_ANIMATION_INFO;
```

<span data-ttu-id="0f5ac-1120">**gx_animation_target** メンバーでは、アニメーション コントローラーで処理するターゲット ウィジェットを定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1120">The **gx_animation_target** member defines the target widget that the animation controller will act upon.</span></span>

<span data-ttu-id="0f5ac-1121">**gx_animation_parent** メンバーでは、アニメーション シーケンスが完了したしたときにターゲット ウィジェットがアタッチされる親ウィジェット (存在する場合) を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1121">The **gx_animation_parent** member defines the parent widget, if any, to which the target widget will be attached when the animation sequence is complete.</span></span> <span data-ttu-id="0f5ac-1122">gx_animation_parent はまた、アニメーションが完了したときに生成される GX_ANIMATION_COMPLETE イベントの受信者でもあります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1122">The gx_animation_parent is also the recipient of the GX_ANIMATION_COMPLETE event that is generated when an animation is completed.</span></span>

<span data-ttu-id="0f5ac-1123">**gx_animation_screen_list** メンバーでは、ペン入力によって開始される画面スライド アニメーションのウィジェットの一覧を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1123">The **gx_animation_screen_list** member defines a widget list for pen-input-driven screen slide animations.</span></span> <span data-ttu-id="0f5ac-1124">このウィジェットの一覧は GX_NULL ポインターで終了する必要があり、一覧内の各ウィジェットの x、y ディメンションは gx_animation_parent と同じである必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1124">The widge list should be terminated with GX_NULL pointer, and each widget in the list should have the same x,y dimensions as the gx_animation_parent.</span></span>

<span data-ttu-id="0f5ac-1125">**gx_animation_style** は、実行されるアニメーションの種類とそれに関連付けられたオプションを定義するビットマスクです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1125">The **gx_animation_style** is a bitmask defining the type of animation to be performed and associated options.</span></span> <span data-ttu-id="0f5ac-1126">アニメーション スタイルのフラグには、次のものが含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1126">The animation style flags include the following.</span></span>

| <span data-ttu-id="0f5ac-1127">アニメーション&nbsp;スタイルのフラグ</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1127">Animation&nbsp;Style&nbsp;Flag</span></span> | <span data-ttu-id="0f5ac-1128">説明</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1128">Description</span></span> |
| --- | --- |
| <span data-ttu-id="0f5ac-1129">GX_ANIMATION_TRANSLATE</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1129">GX_ANIMATION_TRANSLATE</span></span> | <span data-ttu-id="0f5ac-1130">スライドまたはフェードの種類のアニメーションを要求します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1130">Request a slide or fade type animation.</span></span> |
| <span data-ttu-id="0f5ac-1131">GX_ANIMATION_SCREEN_DRAG</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1131">GX_ANIMATION_SCREEN_DRAG</span></span> | <span data-ttu-id="0f5ac-1132">ペン入力によって開始される画面ドラッグ アニメーションを要求します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1132">Request a pen-input driven screen drag animation.</span></span> |

<span data-ttu-id="0f5ac-1133">次のフラグは、**SCREEN_DRAG** の種類のアニメーションと組み合わせて使用できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1133">The following flags can be used in combination with **SCREEN_DRAG** type animations.</span></span>

| <span data-ttu-id="0f5ac-1134">画面ドラッグのフラグ</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1134">Screen&nbsp;Drag&nbsp;Flags</span></span> | <span data-ttu-id="0f5ac-1135">説明</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1135">Description</span></span> |
| --- | --- |
| <span data-ttu-id="0f5ac-1136">GX_ANIMATION_WRAP</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1136">GX_ANIMATION_WRAP</span></span> | <span data-ttu-id="0f5ac-1137">画面の一覧を最後まで行ったら先頭に折り返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1137">The screen list should wrap from end back to start.</span></span> |
| <span data-ttu-id="0f5ac-1138">GX_ANIMATION_HORIZONTAL</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1138">GX_ANIMATION_HORIZONTAL</span></span> | <span data-ttu-id="0f5ac-1139">水平方向に許可される画面ドラッグ。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1139">Screen drag allowed in horizontal direction.</span></span>  |
| <span data-ttu-id="0f5ac-1140">GX_ANIMATION_VERTICAL</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1140">GX_ANIMATION_VERTICAL</span></span> | <span data-ttu-id="0f5ac-1141">垂直方向に許可される画面ドラッグ。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1141">Screen drag allowed in vertical direction.</span></span> |

<span data-ttu-id="0f5ac-1142">次のフラグは、平行移動アニメーションと組み合わせて使用できます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1142">The following flag can be used in combination with translate animations.</span></span>

| <span data-ttu-id="0f5ac-1143">平行移動アニメーションのフラグ</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1143">Translate&nbsp;Animations&nbsp;Flags</span></span> | <span data-ttu-id="0f5ac-1144">説明</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1144">Description</span></span> |
| --- | --- |
| <span data-ttu-id="0f5ac-1145">GX_ANIMATION_DETACH</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1145">GX_ANIMATION_DETACH</span></span> | <span data-ttu-id="0f5ac-1146">アニメーションが完了したら、アニメーション ターゲットをアニメーションの親からデタッチします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1146">Detach the animation target from the animation parent when the animation is completed.</span></span> <span data-ttu-id="0f5ac-1147">このターゲットが動的に割り当てられ、GUIX Studio で生成された自動イベント処理によって作成されている場合、そのターゲットはデタッチされた後に削除されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1147">If the target was dynamically allocated and created by the GUIX Studio generated automated event handling, the target will be deleted after it is detached.</span></span> |
| <span data-ttu-id="0f5ac-1148">GX_ANIMATION_TRANSLATE</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1148">GX_ANIMATION_TRANSLATE</span></span> | <span data-ttu-id="0f5ac-1149">アニメーションの種類は、タイマーによって開始されるアニメーションです。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1149">Animation types are timer driven animations.</span></span> <span data-ttu-id="0f5ac-1150">アプリケーションでターゲット ウィジェットの開始および終了位置と開始および終了アルファ値を定義すると、アニメーション マネージャーでは、アニメーションを実行するための推進力として機能するタイマーを作成します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1150">The application defines the starting and ending position and starting and ending alpha value for the target widget, and the animation manager creates a timer to serve and as the driving force to execute the animation.</span></span>
| <span data-ttu-id="0f5ac-1151">GX_ANIMATION_SCREEN_DRAG</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1151">GX_ANIMATION_SCREEN_DRAG</span></span> | <span data-ttu-id="0f5ac-1152">このアニメーションの種類がペン入力イベントによって開始されるという点で、**TRANSLATE** アニメーションとは異なります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1152">Differs from the **TRANSLATE** animations in that this animation type is driven by pen input events.</span></span> <span data-ttu-id="0f5ac-1153">このアニメーションの種類では、タッチ スクリーン入力を追跡して、ユーザーが入力タッチ スクリーン上でペンまたはスタイラスをドラッグしたらターゲット ウィジェットをスワイプします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1153">This animation type tracks along with the touch screen input to swipe the target widget as the user drags a pen or stylus across the input touch screen.</span></span> <span data-ttu-id="0f5ac-1154">この種類のアニメーションを利用するには、アプリケーションで **_gx_animation_drag_enable_** API を呼び出して、このアニメーションを有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1154">To utilize this type of animation, the application should call the **_gx_animation_drag_enable_** API to enable this animation.</span></span> |

<span data-ttu-id="0f5ac-1155">**gx_animation_id** 値は、**GX_ANIMATION_COMPLETE** イベントの event.gx_event_sender フィールドでアニメーションの親に戻されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1155">The **gx_animation_id** value is passed back to the animation parent in the event.gx_event_sender field of the **GX_ANIMATION_COMPLETE** event.</span></span> <span data-ttu-id="0f5ac-1156">この値は、複数ある可能性がある子アニメーションのどれが完了を報告しているかを特定するために、アニメーションの親によって使用されます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1156">This value is used by the animation parent to determine which of possibly several child animations is reporting completion.</span></span> <span data-ttu-id="0f5ac-1157">この値は 0 である場合があり、ID 値が 0 のアニメーションによって **ANIMATION_COMPLETE** イベントが生成されることはありません。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1157">This value can be 0, and an animation with ID value 0 will not generate an **ANIMATION_COMPLETE** event at all.</span></span>

<span data-ttu-id="0f5ac-1158">**gx_animation_start_delay** 値は、**_gx_animation_start_ *_ が呼び出されてから実際にアニメーションを実行するまで遅延させるタイマー刻みの数を示す GUIX ティック数です。この値を 0 にして、_* _gx_animation_start_** を呼び出した後すぐにアニメーションを開始することができます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1158">The **gx_animation_start_delay** value is a GUIX tick count indicating the number of timer ticks to delay after **_gx_animation_start_*_ is called before actually executing the animation. The value can be 0 to start the animation immediately upon calling _*_gx_animation_start_**.</span></span>

<span data-ttu-id="0f5ac-1159">**gx_animation_frame_interval** フィールドでは、アニメーション シーケンスの各フレーム間で遅延させる GUIX タイマー刻みの数 (基になる OS ティック レートの倍数) を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1159">The **gx_animation_frame_interval** field defines the number of GUIX timer ticks (a multiple of the underlying OS tick rate) to delay between each frame of the animation sequence.</span></span> <span data-ttu-id="0f5ac-1160">最小値は 1 です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1160">The minimum value is 1.</span></span>

<span data-ttu-id="0f5ac-1161">**gx_animation_start_position** では、平行移動アニメーションでのターゲット ウィジェットの左上の開始点を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1161">The **gx_animation_start_position** defines the top-left starting point for the target widget for translation animations.</span></span>

<span data-ttu-id="0f5ac-1162">**gx_animation_end_position** では、平行移動の種類のアニメーションでのターゲット ウィジェットの左上の終了位置を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1162">The **gx_animation_end_position** defines the top-left ending position for the target widget for translation type animations.</span></span>

<span data-ttu-id="0f5ac-1163">**gx_animation_start_alpha** フィールドでは、平行移動の種類のアニメーションでの開始キャンバス アルファ値を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1163">The **gx_animation_start_alpha** field defines the starting canvas alpha value for translation type animations.</span></span>

<span data-ttu-id="0f5ac-1164">**gx_animation_end_alpha** フィールドでは、平行移動の種類のアニメーションでの終了キャンバス アルファ値を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1164">The **gx_animation_end_alpha** field defines the ending canvas alpha value for translation type animations.</span></span>

<span data-ttu-id="0f5ac-1165">**gx_animation_steps** フィールドでは、コントローラーが平行移動アニメーションで実行する必要があるステップまたはフレームの数を定義します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1165">The **gx_animation_steps** field defines how many steps or frames the controller should execute for translation animations.</span></span> <span data-ttu-id="0f5ac-1166">ステップ数を大きくすると、より滑らかなスライドまたはフェードの外観が生成されますが、必要になるシステム帯域幅も大きくなります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1166">A larger number of steps produces a smoother slide and/or fade appearance, but also requires greater system bandwidth.</span></span>

<span data-ttu-id="0f5ac-1167">アプリケーションでアニメーション効果を実装するには、まず ***gx_animation_create*** を呼び出して、アニメーション コントローラーを初期化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1167">To implement animation effects in your application, you must first call ***gx_animation_create*** to initialize your animation controller.</span></span> <span data-ttu-id="0f5ac-1168">アニメーションでセカンダリ キャンバスを使用する場合は、gx_animation_canvas_define を呼び出してこのキャンバスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1168">If your animation will be using a secondary canvas, initialize this canvas by calling gx_animation_canvas_define.</span></span> <span data-ttu-id="0f5ac-1169">次に、**GX_ANIMATION_INFO** 構造体を初期化して、実行されるアニメーションの特定の種類とその他のアニメーション パラメーターを定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1169">Next, you should initialize the **GX_ANIMATION_INFO** structure to define the specific type of animation to be performed and the other animation parameters.</span></span> <span data-ttu-id="0f5ac-1170">最後に、gx_animation_start を呼び出して、アニメーション シーケンスをトリガーします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1170">Finally, call gx_animation_start to trigger the animation sequence.</span></span>

<span data-ttu-id="0f5ac-1171">アニメーション コントローラーは、アニメーション シーケンスを完了すると、親ウィジェットに **GX_ANIMATION_COMPLETE** イベントを送信して、その時点でアニメーション キャンバスのすべての望ましいクリーンアップを実行できるようにします。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1171">When the animation controller completes an animation sequence, it sends an **GX_ANIMATION_COMPLETE** event to the parent widget, allowing the any desired cleanup of the animation canvas to be done at that time.</span></span>

## <a name="guix-utility-component"></a><span data-ttu-id="0f5ac-1172">GUIX ユーティリティ コンポーネント</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1172">GUIX Utility Component</span></span> 

<span data-ttu-id="0f5ac-1173">ユーティリティ コンポーネントは、GUIX のすべての一般的なユーティリティ関数を担当します。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1173">The utility component is responsible for all common utility functions in GUIX.</span></span> <span data-ttu-id="0f5ac-1174">これらは、有効なユーティリティであり、さらにアプリケーションまたは内部の GUIX コード内のどこからでも呼び出すことができる一般的な関数です。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1174">These are common functions that are useful utilities and can be invoked from anywhere in the application or the internal GUIX code.</span></span> <span data-ttu-id="0f5ac-1175">ユーティリティ コンポーネント関数には、次のものが含まれます。</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1175">The utility component functions include the following.</span></span>

<span data-ttu-id="0f5ac-1176">***gx_utility_canvas_to_bmp***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1176">***gx_utility_canvas_to_bmp***</span></span>

<span data-ttu-id="0f5ac-1177">***gx_utility_circle_point_get***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1177">***gx_utility_circle_point_get***</span></span>

<span data-ttu-id="0f5ac-1178">***gx_utility_alphamap_create***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1178">***gx_utility_alphamap_create***</span></span>

<span data-ttu-id="0f5ac-1179">***gx_utility_gradient_create***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1179">***gx_utility_gradient_create***</span></span>

<span data-ttu-id="0f5ac-1180">***gx_utility_gradient_delete***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1180">***gx_utility_gradient_delete***</span></span>

<span data-ttu-id="0f5ac-1181">***gx_utlity_ltoa***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1181">***gx_utlity_ltoa***</span></span>

<span data-ttu-id="0f5ac-1182">***gx_utility_math_acos***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1182">***gx_utility_math_acos***</span></span>

<span data-ttu-id="0f5ac-1183">***gx_utility_math_asin***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1183">***gx_utility_math_asin***</span></span>

<span data-ttu-id="0f5ac-1184">***gx_utility_math_cos***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1184">***gx_utility_math_cos***</span></span>

<span data-ttu-id="0f5ac-1185">***gx_utility_math_sin***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1185">***gx_utility_math_sin***</span></span>

<span data-ttu-id="0f5ac-1186">***gx_utility_math_sqrt***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1186">***gx_utility_math_sqrt***</span></span>

<span data-ttu-id="0f5ac-1187">***gx_utility_pixelmap_resize***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1187">***gx_utility_pixelmap_resize***</span></span>

<span data-ttu-id="0f5ac-1188">***gx_utility_pixelmap_rotate***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1188">***gx_utility_pixelmap_rotate***</span></span>

<span data-ttu-id="0f5ac-1189">***gx_utility_pixelmap_simple_rotate***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1189">***gx_utility_pixelmap_simple_rotate***</span></span>

<span data-ttu-id="0f5ac-1190">***gx_utility_rectangle_center***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1190">***gx_utility_rectangle_center***</span></span>

<span data-ttu-id="0f5ac-1191">***gx_utility_rectangle_center_find***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1191">***gx_utility_rectangle_center_find***</span></span>

<span data-ttu-id="0f5ac-1192">***gx_utility_rectangle_combine***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1192">***gx_utility_rectangle_combine***</span></span>

<span data-ttu-id="0f5ac-1193">***gx_utility_rectangle_compare***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1193">***gx_utility_rectangle_compare***</span></span>

<span data-ttu-id="0f5ac-1194">***gx_utility_rectangle_define***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1194">***gx_utility_rectangle_define***</span></span>

<span data-ttu-id="0f5ac-1195">***gx_utility_rectangle_overlap_detect***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1195">***gx_utility_rectangle_overlap_detect***</span></span>

<span data-ttu-id="0f5ac-1196">***gx_utility_rectangle_point_detect***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1196">***gx_utility_rectangle_point_detect***</span></span>

<span data-ttu-id="0f5ac-1197">***gx_utility_rectangle_resize***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1197">***gx_utility_rectangle_resize***</span></span>

<span data-ttu-id="0f5ac-1198">***gx_utility_rectangle_shift***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1198">***gx_utility_rectangle_shift***</span></span>

<span data-ttu-id="0f5ac-1199">***gx_utility_string_to_alphamap***</span><span class="sxs-lookup"><span data-stu-id="0f5ac-1199">***gx_utility_string_to_alphamap***</span></span>
