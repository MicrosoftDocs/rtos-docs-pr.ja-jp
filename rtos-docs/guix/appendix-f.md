---
title: 付録 F - GUIX RTOS バインド サービス
description: GUIX RTOS バインド サービスの詳細について説明します。
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 7928e1781be03969de25901ebbe728e6554e96befb59c860f4ea53663c28932d
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/07/2021
ms.locfileid: "116784599"
---
# <a name="appendix-f---guix-rtos-binding-services"></a>付録 F - GUIX RTOS バインド サービス

GUIX には、基になる RTOS が提供するスレッドまたはタスク サービス、ミューテックス、イベント キュー、およびタイミング サービスが必要です。 既定では、GUIX は、ThreadX リアルタイム オペレーティング システムを使用してこれらのサービスを提供するように構成されています。 別のオペレーティング システムに GUIX を移植するには、開発者は、プリプロセッサ ディレクティブ GX_DISABLE_THREADX_BINDING を定義し、GUIX ライブラリをリビルドして、ThreadX 依存関係を削除する必要があります。 さらに、開発者は、次のマクロ定義とサポート関数を提供する必要があります。 これらのマクロ定義およびサポート関数の例は、gx_system_rtos_bind.h ファイルと gx_system_rtos_bind.c ファイルにあります。これらのファイルには、一般的な RTOS 統合の例が用意されています。

システム統合マクロ:

**GX_RTOS_BINDING_INITIALIZE**

このマクロは、システムの初期化中に呼び出されます。 このマクロは、RTOS システム サービスまたは RTOS リソースの使用前の準備に必要な任意の関数を呼び出すように定義する必要があります。 これは、GUIX が使用する RTOS リソースを準備するためのバインドの機会です。

**GX_SYSTEM_THREAD_START**

このマクロは、GUIX タスクまたはスレッドを実行し始める必要があるときに呼び出されます。 このマクロは、GUIX スレッドの実行を開始する関数を呼び出すように定義する必要があります。 呼び出された関数には、GUIX スレッドへのエントリ ポイントが渡されます。 呼び出された関数のシグネチャは、次のようにする必要があります

**UINT *function_name*(VOID (thread_entry_point)(VOID));**

この関数は、スレッドが正常に開始された場合は GX_SUCCESS を返し、それ以外の場合は GX_FAILURE を返します。

**GX_EVENT_PUSH**

このマクロは、使用される FIFO イベント キューにイベントをプッシュするために、GUIX によって呼び出されます。 新しい RTOS に移植する場合は、スレッドセーフな方法でこのイベント キューを実装する必要があります。 GX_EVENT 構造体は、このキューにコピーし、このキューからコピーする必要があります。つまり、GX_EVENT ポインターのキューは動作しません。これは、GUIX イベントは、イベント プロデューサーから見ると、自動変数になる可能性があるためです。 このマクロによって呼び出される関数のシグネチャは、次のようにする必要があります。

**UINT *function_name* (GX_EVENT *event_ptr);**

この関数は、イベントがイベント キューにプッシュされた場合は GX_SUCCESS を返し、それ以外の場合は GX_FAILURE を返します。

**GX_EVENT_POP**

このマクロは、GUIX イベント キューから先頭の (一番古い) イベントを削除し、要求された場所にコピーするために呼び出されます。 この関数は、現在イベント キューにイベントがない場合に、必要に応じてイベントをブロックまたは待機できなければなりません。 このマクロによって呼び出される関数のシグネチャは、次のようにする必要があります

UINT function_name(GX_EVENT *put_event, GX_BOOL wait)

wait パラメーター が GX_TRUE の場合、イベントが提供されるまで、関数から制御が戻されません。 wait パラメーターが GX_FALSE の場合は、イベントの有無に関係なく、関数からすぐに制御が戻されます。

キューからイベントが取得された場合、そのイベントは put_event の場所にコピーされ、リターン状態は GX_SUCCESS になります。 それ以外の場合、リターン状態は GX_FAILURE です。

**GX_EVENT_FOLD**

このマクロは、FIFO イベント キューにイベントを折りたたむために、GUIX によって呼び出されます。 イベントの折りたたみとは、同じ種類のイベントが既にキュー内に存在する場合に、新しいイベントのペイロードを含むようにそのエントリが更新されることです。 同じ種類の既存のイベントがキュー内に見つからない場合は、新しいイベントがキューにプッシュされます。 

イベント折りたたみ機能を実装できないバインディングの場合は、単に GX_EVENT_PUSH を呼び出すことができます。

**GX_TIMER_START**

このマクロは、GUIX が定期的なタイマー入力を受け取る必要がある場合に呼び出されます。 このマクロは、低レベル RTOS の定期的なタイマー サービスを開始するサービスを呼び出す必要があります。 RTOS タイマー サービスを簡単に停止および開始できない場合、このサービスを常時実行させておいても構いませんが、効率的ではありません。

低レベル RTOS タイマー サービスが定期的に期限切れになる場合、バインドは GUIX システム関数 _gx_system_timer_expiration (0) を呼び出す必要があります。この関数を定期的に呼び出すことで、高レベル GUIX タイマー ウィジェットのタイマー サービスが動作します。

**GX_TIMER_STOP**

このマクロは、GUIX に定期的なタイマーが不要になった場合 (つまり、アクティブな GUIX タイマーが実行されていない場合) に呼び出されます。 RTOS タイマー サービスを簡単に停止および開始できない場合、このサービスを常時実行させて何も行わないようにこのマクロを定義しても構いませんが、効率的ではありません。

**GX_SYSTEM_MUTEX_LOCK**

このマクロは、重要なコード セクション中、別のタスクが一般的なデータ構造に優先して実行され、そのデータ構造を変更し、破損を引き起こす可能性を防ぐために、GUIX によって呼び出されます。 このマクロは、適切な RTOS リソース ロック サービスを実装する関数を呼び出す必要があります。

GUIX API サービスを GUIX スレッド外で使用しない場合は、何も実行しないようにこのマクロを定義できます。

**GX_SYSTEM_MUTEX_UNLOCK**

このマクロは、重要なコード セクションの最後に呼び出され、基になる適切な RTOS サービスを使用して GUIX リソースのロックを解除します。 GUIX API サービスを GUIX スレッド外で使用しない場合は、何も実行しないようにこのマクロを定義できます。

**GX_SYSTEM_TIME_GET**

このマクロは、現在のシステム時刻を "システム ティック数" で返す関数を呼び出す必要があります。システム ティック数は、通常、システムの起動後に発生した低レベルのタイマー割り込みの数です。 このサービスは、タッチ入力ジェスチャに対するタッチ イベントのペン速度を計算するために使用されます。 このマクロによって呼び出される関数のシグネチャは、次のようにする必要があります。

**ULONG *function_name*(VOID);**

**GX_CURRENT_THREAD**

このマクロは、現在実行中のスレッドを識別するために呼び出されます。 このマクロによって呼び出されるサービスは、void * を返す必要があります。つまり、現在の実行スレッドを識別するために、お使いのオペレーティング システムによって使用されるデータ型を GUIX に返すには、void * にキャストしなければなりません。

一般的な RTOS バインドの完全な例は、登録済み gx_system_rtos_bind.h および gx_system_rtos_bind.c フィールド内に実装されています