---
title: 第 2 章 - Azure RTOS FileX のインストールと使用
description: この章では、Azure RTOS FileX の概要のほか、次のようなインストール条件、手順、および使用法について説明します
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 6703b10d8e0895984bb92d74d5dff809dca1a7f8
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104810325"
---
# <a name="chapter-2---installation-and-use-of-azure-rtos-filex"></a>第 2 章 - Azure RTOS FileX のインストールと使用

この章では、Azure RTOS FileX の概要のほか、インストール条件、手順、および使用法について説明します。 

## <a name="host-considerations"></a>ホストに関する考慮事項

### <a name="computer-type"></a>コンピューターの種類

組み込み開発は、通常、Windows または Linux (Unix) ホスト コンピューター上で行われます。 アプリケーションは、コンパイルされ、リンクされ、ホスト上に配置された後、実行のためにターゲット ハードウェアにダウンロードされます。

### <a name="download-interfaces"></a>ダウンロードのインターフェイス

通常、ターゲットのダウンロードは、開発ツールのデバッガー内から実行されます。 ダウンロード後、デバッガーは、メモリおよびプロセッサ レジスタへのアクセスだけでなく、ターゲットの実行制御 (移動、停止、ブレークポイントなど) を提供します。

### <a name="debugging-tools"></a>デバッグ ツール

開発ツールのデバッガーのほとんどは、JTAG (IEEE 1149.1) やバックグラウンド デバッグ モード (BDM) などのオンチップ デバッグ (OCD) 接続によってターゲット ハードウェアと通信します。 また、デバッガーは、インサーキット エミュレーション (ICE) 接続を使用してターゲット ハードウェアと通信します。 OCD 接続と ICE 接続はどちらも、ターゲットの常駐ソフトウェアへの侵入を最小限に抑える堅牢なソリューションを提供します。

### <a name="required-hard-disk-space"></a>必要なハード ディスク容量

FileX のソース コードは、ASCII 形式で提供され、ホスト コンピューターのハード ディスク上に約 500 KB の領域を必要とします。

## <a name="target-considerations"></a>ターゲットに関する考慮事項

FileX は、ターゲット上に 6 KB から 30 KB の読み取り専用メモリ (ROM) を必要とします。 FileX グローバル データ構造体には、ターゲットのランダム アクセス メモリ (RAM) がさらに 100 バイトに必要になります。 さらに、開いているメディアごとに、1 つのセクター (通常は 512 バイト) のデータを格納するための RAM に加えて、制御ブロック用に 1.5 KB の RAM が必要になります。

日付または時刻のスタンプを正常に機能させるために、FileX は ThreadX のタイマー機能を利用しています。 これを実行するために、FileX の初期化時に FileX 固有のタイマーを作成しています。 また、FileX は、複数のスレッド保護と I/O の中断に ThreadX セマフォを利用しています。

## <a name="product-distribution"></a>製品ディストリビューション

Azure RTOS FileX は、<https://github.com/azure-rtos/filex/> のパブリック ソース コード リポジトリから入手できます。

以下は、リポジトリ内のいくつかの重要なファイルの一覧です。

- ***fx_api.h***: この C ヘッダー ファイルには、システム等価物、データ構造体、およびサービス プロトタイプがすべて含まれています。
- ***fx_port.h***: この C ヘッダー ファイルには、開発ツール固有のデータ定義とデータ構造体がすべて含まれています。
- ***demo_filex.c***: この C ファイルには、小さなデモ アプリケーションが含まれています。
- "***fx.a (または fx.lib)***": これは、FileX C ライブラリのバイナリ バージョンです。 標準パッケージと共に配布されます。

> [!IMPORTANT]
> "*ファイル名はすべて小文字で表記します。この名前付け規則を使用することで、コマンドを Linux (Unix) 開発プラットフォームに簡単に変換できます。* "

## <a name="filex-installation"></a>FileX のインストール

FileX をインストールするには、GitHub リポジトリをローカル コンピューターにクローンします。 自分の PC 上に FileX リポジトリのクローンを作成するための一般的な構文を次に示します。

```c
    git clone https://github.com/azure-rtos/filex
```

GitHub メイン ページ上のダウンロード ボタンを使用して、リポジトリのコピーをダウンロードすることもできます。

また、オンライン リポジトリのフロント ページには、FileX ライブラリを構築する手順も紹介されています。

> [!IMPORTANT]
> アプリケーション ソフトウェアは、FileX ライブラリ ファイル (通常、***fx.a** _ または _*_fx.lib_*_) _と、C インクルード ファイル **fx_api.h** および **fx_port.h** にアクセスする必要があります。 これを行うには、開発ツールの適切なパスを設定するか、これらのファイルをアプリケーション開発領域にコピーします。

## <a name="using-filex"></a>FileX の使用

FileX は簡単に使用できます。 基本的には、コンパイル中にアプリケーション コードに ***fx_api.h** _ をインクルードし、FileX ランタイム ライブラリ _*_fx.a_*_ (または _*_fx.lib_*_) とリンクする必要があります。 当然ながら、ThreadX ファイル、つまり _*_tx_api.h_*_ と _*_tx.a_*_ (または _*_tx.lib_*_)_* も必要になります。

> [!IMPORTANT]
> FileX をスタンドアロン モードで使用する場合 (**FX_STANDALONE_ENABLE** を定義する必要があります)、ThreadX ファイルまたはライブラリは必要ありません。

ThreadX を既に使用していると仮定した場合、FileX アプリケーションを構築するために必要な手順は 4 つあります。

1. ***fx_api.h*** ファイルを、FileX サービスまたはデータ構造体を使用するすべてのアプリケーション ファイルにインクルードします。
1. _ *_tx_application_define_** 関数またはアプリケーション スレッドから ***fx_system_initialize** _ を呼び出して、FileX システムを初期化します。

    > [!IMPORTANT]
    > FileX をスタンドアロン モードで使用している場合は、***fx_system_initialize*** をアプリケーション コードから直接呼び出す必要があります。

1. FileX メディアを設定するために、***fx_media_open*** の呼び出しを 1 つ以上追加します。 この呼び出しは、アプリケーション スレッドのコンテキストから行う必要があります。

    > [!IMPORTANT]
    > "***fx_media_open** 呼び出しを行うには、1 つのセクターのデータを格納するのに十分な RAM が必要であることに注意してください。* "

1. アプリケーション ソースをコンパイルし、FileX および ThreadX のランタイム ライブラリ ***fx.a** _ (または _*_fx.lib_*_) および _*_tx.a_*_ (または _*_tx.lib_**) とリンクします。 結果のイメージはターゲットにダウンロードして、実行できます。

## <a name="troubleshooting"></a>トラブルシューティング

各 FileX ポートには、デモンストレーション アプリケーションが付属しています。 ターゲット ハードウェアまたは特定のデモンストレーション環境のいずれかで最初にデモンストレーション システムを稼働させることを常にお勧めします。

デモンストレーション システムが動作しない場合は、次のことを試して問題を絞り込んでください。

1. デモンストレーションがどの程度を実行されているかを調べます。
1. スタック サイズを増やします (これは、デモンストレーションよりも実際のアプリケーション コードでより重要です)。
1. 32 KB の既定の RAM ディスク サイズ用に十分な RAM があることを確認します。 基本的なシステムは、もっと少ない RAM でも動作しますが、十分なメモリがない場合は、RAM ディスクの使用量が増えるにつれて、問題が表面化します。
1. 最近の変更を一時的にバイパスして、問題が解消または変化するかどうかを確認します。 このような情報は、Microsoft サポート エンジニアにとって有益です。 「カスタマー サポート センター」に記載されている手順に従って、トラブルシューティング手順で収集した情報を送信します。

## <a name="configuration-options"></a>構成オプション

FileX を使用して FileX ライブラリとアプリケーションを構築する場合、構成オプションがいくつかあります。 以下のオプションは、アプリケーション ソース内、コマンド ライン上、または ***fx_user.h*** インクルード ファイル内で定義できます。

> [!IMPORTANT]
> "***fx_user.h** 内で定義されているオプションが適用されるのは、アプリケーションと ThreadX ライブラリを構築する際に **_FX_INCLUDE_USER_DEFINE_FILE_*_ が定義されている場合のみです。_"FileX をスタンドアロン モードで使用する場合 (** FX_STANDALONE_ENABLE** を定義する必要があります)、ThreadX ファイルまたはライブラリは必要ありません。

次の一覧では、各構成オプションについて詳しく説明しています。

|定義|意味|
|----------    |-----------|
|FX_MAX_LAST_NAME_LEN        |この値は、完全なパス名を含むファイル名の最大長を定義します。 既定では、この値は 256 です。|
|FX_DONT_UPDATE_OPEN_FILES    |定義済み。既に開いているファイルは FileX によって更新されません。|
|FX_MEDIA_DISABLE_SEARCH_CACHE    |定義済み。ファイル検索キャッシュの最適化は無効になっています。|
|FX_MEDIA_DISABLE_SEARCH_CACHE    |定義済み。ファイル検索キャッシュの最適化は無効になっています。|
|FX_DISABLE_DIRECT_DATA_READ_CACHE_FILL |定義済み。キャッシュの直接読み取りセクター更新は無効になっています。|
|FX_MEDIA_STATISTICS_DISABLE |定義済み。メディア統計の収集は無効になっています。|
|FX_SINGLE_OPEN_LEGACY |定義済み。同じファイルに対する従来の単一オープン ロジックは有効になっています。|
|FX_RENAME_PATH_INHERIT    |定義済み。名前の変更時にパス情報が継承されます。|
|FX_DISABLE_ERROR_CHECKING    |基本的な FileX エラー チェック API を削除します。これにより、パフォーマンスが向上し (最大 30%)、コード サイズが小さくなります。|
|FX_MAX_LONG_NAME_LEN    |FileX のファイル名の最大サイズを指定します。 既定値は 256 ですが、これはコマンドライン定義でオーバーライドできます。 有効な値の範囲は 13 から 256 です。|
|FX_MAX_SECTOR_CACHE|FileX でキャッシュできる論理セクターの最大数を指定します。 キャッシュできる実際のセクター数は、この定数と、fx_media_open で指定されたメモリ容量に収まるセクター数のうち、より小さい方になります。 既定値は 256 です。 すべての値は 2 の累乗である必要があります。|
|FX_FAT_MAP_SIZE    |FAT 更新マップで表現できるセクターの数を指定します。 既定値は 256 ですが、これはコマンドライン定義でオーバーライドできます。 値を大きくすると、セカンダリ FAT セクターの不要な更新を低減するのに役立ちます。|
|FX_MAX_FAT_CACHE    |内部 FAT キャッシュ内のエントリの数を指定します。 既定値は 16 ですが、これはコマンドライン定義でオーバーライドできます。 すべての値は 2 の累乗である必要があります。|
|FX_FAULT_TOLERANT    |定義した場合、FileX は、すべてのシステム セクター (ブート、FAT、およびディレクトリ セクター) の書き込み要求を即座にメディアのドライバーに渡します。 これにより、パフォーマンスが低下する可能性がありますが、影響はクラスターの紛失に制限されます。 この機能を有効にしても FileX フォールト トレラント モジュールが自動的に有効にならないことに注意してください。これを有効にするには、次の項目を定義します。|
|FX_FAULT_TOLERANT_DATA    |定義した場合、FileX は、すべてのファイル データ書き込み要求を即座にメディアのドライバーに渡します。 これにより、パフォーマンスが低下する可能性がありますが、ファイル データの紛失に制限されます。 この機能を有効にしても FileX フォールト トレラント モジュールが自動的に有効にならないことに注意してください。これを有効にするには、***FX_ENABLE_FAULT_TOLERANT*** を定義します。|
|FX_NO_LOCAL_PATH|FileX からローカル パス ロジックを削除します。これにより、コード サイズが小さくなります。|
|FX_NO_TIMER|FileX システムの時刻と日付を更新するための ThreadX タイマーの設定をなくします。 これにより、既定の時刻と日付がすべてのファイル操作に適用されます。|
|FX_UPDATE_RATE_IN_SECONDS    |FileX のシステム時刻を調整するレートを指定します。 既定値は 10 で、FileX のシステム時刻が 10 秒ごとに更新されることを指定します。|
|FX_ENABLE_EXFAT| 定義した場合、exFAT ファイル システムを処理するためのロジックが FileX で有効になります。 既定では、このシンボルは定義されません。| 
|FX_UPDATE_RATE_IN_TICKS| 基になる ThreadX タイマーの頻度を除いて、***FX_UPDATE_RATE_IN_SECONDS*** (上記を参照) と同じレートを指定します。 既定値は 1,000 で、ThreadX タイマー レートが 10 ミリ秒、間隔が 10 秒と想定しています。|
|FX_SINGLE_THREAD|FileX ソースから ThreadX 保護ロジックを削除します。 これは、FileX を 1 つのスレッドからのみ使用している場合、または ThreadX なしで FileX を使用している場合に使用してください。|
|FX_DRIVER_USE_64BIT_LBA|定義した場合、I/O ドライバーで使用される 64 ビット セクター アドレスを有効にします。 既定では、このオプションは定義されません。|
|FX_ENABLE_FAULT_TOLERANT| 定義した場合、FileX フォールト トレラント モジュールを有効にします。 フォールト トレラントを有効にすると、シンボル ***FX_FAULT_TOLERANT** _ および _*_FX_FAULT_TOLERANT_DATA_** が自動的に定義されます。 既定では、このオプションは定義されません。|
|FX_FAULT_TOLERANT_BOOT_INDEX|フォールト トレラント ログのクラスターが存在するブート セクターのバイト オフセットを定義します。 既定では、この値は 116 です。 このフィールドでは 4 バイトが使用されます。 FAT 12、16、32、または exFAT 仕様で予約済みとしてマークされているため、バイト 116 から 119 が選択されます。|
|FX_FAULT_TOLERANT_MINIMAL_CLUSTER|このシンボルは非推奨です。 これは、FileX フォールト トレラントで使用されなくなりました。|
|FX_STANDALONE_ENABLE|定義済み。FileX をスタンドアロン モード (Azure RTOS なし) で使用できるようにします。 既定では、このシンボルは定義されません。|

> [!IMPORTANT]
> **FX_STANDALONE_ENABLE** を定義すると、ローカル パス ロジックと ThreadX タイマーの設定が無効になります。

## <a name="filex-version-id"></a>FileX バージョン ID

FileX の現在のバージョンは、実行時にユーザーとアプリケーション ソフトウェアの両方で取得できます。 プログラマーは、**fx_port.h** ファイルを調べることで FileX のバージョンを確認できます。 さらに、このファイルには、対応するポートのバージョン履歴も含まれています。 アプリケーション ソフトウェアは、グローバル文字列 **_ _fx_version_id_** を調べることで FileX バージョンを取得できます。
