---
title: 第 1 章 - Azure RTOS ThreadX SMP の概要
description: この章では、製品の概要と、そのアプリケーションおよび利点について説明します。
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 67bdb9076272fa3671ec9321baec609b291c04b8
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811387"
---
# <a name="chapter-1-introduction-to-azure-rtos-threadx-smp"></a><span data-ttu-id="5925d-103">第 1 章: Azure RTOS ThreadX SMP の概要</span><span class="sxs-lookup"><span data-stu-id="5925d-103">Chapter 1: Introduction to Azure RTOS ThreadX SMP</span></span>

<span data-ttu-id="5925d-104">Azure RTOS ThreadX SMP は、埋め込みアプリケーション専用に設計された高パフォーマンス リアルタイム SMP カーネルです。</span><span class="sxs-lookup"><span data-stu-id="5925d-104">Azure RTOS ThreadX SMP is a high-performance real-time SMP kernel designed specifically for embedded applications.</span></span> <span data-ttu-id="5925d-105">この章では、製品の概要と、そのアプリケーションおよび利点について説明します。</span><span class="sxs-lookup"><span data-stu-id="5925d-105">This chapter contains an introduction to the product and a description of its applications and benefits.</span></span>

## <a name="threadx-smp-unique-features"></a><span data-ttu-id="5925d-106">ThreadX SMP の固有の機能</span><span class="sxs-lookup"><span data-stu-id="5925d-106">ThreadX SMP Unique Features</span></span>

<span data-ttu-id="5925d-107">ThreadX SMP によって、埋め込みアプリケーションに対称型マルチプロセッシング （SMP） テクノロジがもたらされます。</span><span class="sxs-lookup"><span data-stu-id="5925d-107">ThreadX SMP brings Symmetric Multi-Processing (SMP) technology to embedded applications.</span></span> <span data-ttu-id="5925d-108">実行 「準備完了」 状態の ThreadX SMP のアプリケーション スレッド （優先度はさまざま） が、スケジューリング時に、使用可能なプロセッサ コアに動的に割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="5925d-108">ThreadX SMP application threads (of varying priority) that are "READY" to run are dynamically allocated to available processor cores during scheduling.</span></span> <span data-ttu-id="5925d-109">これにより、使用可能なすべてのプロセッサ コアに対してアプリケーション スレッドの実行を自動的に負荷分散するなど、真の SMP 処理が実現します。</span><span class="sxs-lookup"><span data-stu-id="5925d-109">This results in true SMP processing, including automatic load balancing of application thread execution across all available processor cores.</span></span>

<span data-ttu-id="5925d-110">他のリアルタイム カーネルとは異なり、ThreadX SMP は汎用性を重視して設計され、小型マイクロコントローラーをベースとしたアプリケーションから、強力な CISC、RISC、および DSP プロセッサ搭載のアプリケーションに容易にスケーリングできます。</span><span class="sxs-lookup"><span data-stu-id="5925d-110">Unlike other real-time kernels, ThreadX SMP is designed to be versatile—easily scaling among small micro-controller-based applications through those that use powerful CISC, RISC, and DSP processors.</span></span>

<span data-ttu-id="5925d-111">ThreadX SMP は、基になるアーキテクチャに従ってスケーラブルに動作します。</span><span class="sxs-lookup"><span data-stu-id="5925d-111">ThreadX SMP is scalable based on its underlying architecture.</span></span> <span data-ttu-id="5925d-112">ThreadX SMP サービスは C ライブラリとして実装されているため、アプリケーションによって実際に使用されるサービスのみが実行時イメージに取り込まれます。</span><span class="sxs-lookup"><span data-stu-id="5925d-112">Because ThreadX SMP services are implemented as a C library, only those services actually used by the application are brought into the run-time image.</span></span> <span data-ttu-id="5925d-113">したがって、ThreadX SMP の実際のサイズは、アプリケーションによって完全に決まります。</span><span class="sxs-lookup"><span data-stu-id="5925d-113">Hence, the actual size of ThreadX SMP is completely determined by the application.</span></span> <span data-ttu-id="5925d-114">ThreadX SMP の命令イメージのサイズは、ほとんどのアプリケーションで 5 KB から 20 KB の範囲になります。</span><span class="sxs-lookup"><span data-stu-id="5925d-114">For most applications, the instruction image of ThreadX SMP ranges between 5 KBytes and 20 KBytes in size.</span></span>

### <a name="picokernel-architecture"></a><span data-ttu-id="5925d-115">picokernel™ アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="5925d-115">picokernel™ Architecture</span></span> 
<span data-ttu-id="5925d-116">ThreadX SMP サービスは、従来の 「*マイクロカーネル*」 アーキテクチャのようにカーネル関数を重ねていくのではなく、そのコアに直接接続します。</span><span class="sxs-lookup"><span data-stu-id="5925d-116">Instead of layering kernel functions on top of each other like traditional *microkernel* architectures, ThreadX SMP services plug directly into its core.</span></span> <span data-ttu-id="5925d-117">これにより、コンテキスト切り替えとサービス呼び出しのパフォーマンスが最速になります。</span><span class="sxs-lookup"><span data-stu-id="5925d-117">This results in the fastest possible context switching and service call performance.</span></span> <span data-ttu-id="5925d-118">このような非レイヤー設計を *picokernel* アーキテクチャと呼んでいます。</span><span class="sxs-lookup"><span data-stu-id="5925d-118">We call this nonlayering design a *picokernel* architecture.</span></span>

### <a name="ansi-c-source-code"></a><span data-ttu-id="5925d-119">ANSI C ソース コード</span><span class="sxs-lookup"><span data-stu-id="5925d-119">ANSI C Source Code</span></span> 
<span data-ttu-id="5925d-120">ThreadX SMP は主に ANSI C で記述されており、カーネルを基になるターゲット プロセッサに合わせて調整するために、少量のアセンブリ言語が必要です。</span><span class="sxs-lookup"><span data-stu-id="5925d-120">ThreadX SMP is written primarily in ANSI C. A small amount of assembly language is needed to tailor the kernel to the underlying target processor.</span></span> <span data-ttu-id="5925d-121">この設計により、ThreadX SMP を、非常に短い時間で新しいプロセッサ ファミリーに移植できます （通常は数週間かかります）。</span><span class="sxs-lookup"><span data-stu-id="5925d-121">This design makes it possible to port ThreadX SMP to a new processor family in a very short time—usually within weeks!</span></span>

### <a name="advanced-technology"></a><span data-ttu-id="5925d-122">高度なテクノロジ</span><span class="sxs-lookup"><span data-stu-id="5925d-122">Advanced Technology</span></span> 
<span data-ttu-id="5925d-123">次に ThreadX SMP の高度なテクノロジの概要を示します。</span><span class="sxs-lookup"><span data-stu-id="5925d-123">The following are highlights of the ThreadX SMP advanced technology:</span></span>

  - <span data-ttu-id="5925d-124">シンプルな *picokernel* アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="5925d-124">Simple *picokernel* architecture</span></span>
  - <span data-ttu-id="5925d-125">自動負荷分散</span><span class="sxs-lookup"><span data-stu-id="5925d-125">Automatic load balancing</span></span>
  - <span data-ttu-id="5925d-126">スレッドごとのプロセッサの除外</span><span class="sxs-lookup"><span data-stu-id="5925d-126">Per-thread processor exclusion</span></span>
  - <span data-ttu-id="5925d-127">自動スケーリング （占有領域が小さい）</span><span class="sxs-lookup"><span data-stu-id="5925d-127">Automatic scaling (small footprint)</span></span>
  - <span data-ttu-id="5925d-128">決定論的処理</span><span class="sxs-lookup"><span data-stu-id="5925d-128">Deterministic processing</span></span>
  - <span data-ttu-id="5925d-129">高速なリアルタイムのパフォーマンス</span><span class="sxs-lookup"><span data-stu-id="5925d-129">Fast real-time performance</span></span>
  - <span data-ttu-id="5925d-130">プリエンプティブ スケジューリングと協調スケジューリング</span><span class="sxs-lookup"><span data-stu-id="5925d-130">Preemptive and cooperative scheduling</span></span>
  - <span data-ttu-id="5925d-131">柔軟なスレッド優先順位のサポート （32-1024）</span><span class="sxs-lookup"><span data-stu-id="5925d-131">Flexible thread priority support (32-1024)</span></span>
  - <span data-ttu-id="5925d-132">システム オブジェクトの動的生成</span><span class="sxs-lookup"><span data-stu-id="5925d-132">Dynamic system object creation</span></span>
  - <span data-ttu-id="5925d-133">システム オブジェクト数に制限がない</span><span class="sxs-lookup"><span data-stu-id="5925d-133">Unlimited number of system objects</span></span>
  - <span data-ttu-id="5925d-134">最適化された割り込み処理</span><span class="sxs-lookup"><span data-stu-id="5925d-134">Optimized interrupt handling</span></span>
  - <span data-ttu-id="5925d-135">優先しきい値™</span><span class="sxs-lookup"><span data-stu-id="5925d-135">Preemption-threshold™</span></span>
  - <span data-ttu-id="5925d-136">優先度の継承</span><span class="sxs-lookup"><span data-stu-id="5925d-136">Priority inheritance</span></span>
  - <span data-ttu-id="5925d-137">イベントチェーン™</span><span class="sxs-lookup"><span data-stu-id="5925d-137">Event-chaining™</span></span>
  - <span data-ttu-id="5925d-138">高速ソフトウェアタイマー</span><span class="sxs-lookup"><span data-stu-id="5925d-138">Fast software timers</span></span>
  - <span data-ttu-id="5925d-139">実行時メモリの管理</span><span class="sxs-lookup"><span data-stu-id="5925d-139">Run-time memory management</span></span>
  - <span data-ttu-id="5925d-140">実行時パフォーマンスの監視</span><span class="sxs-lookup"><span data-stu-id="5925d-140">Run-time performance monitoring</span></span>
  - <span data-ttu-id="5925d-141">実行時スタック分析</span><span class="sxs-lookup"><span data-stu-id="5925d-141">Run-time stack analysis</span></span>
  - <span data-ttu-id="5925d-142">組み込みシステム トレース</span><span class="sxs-lookup"><span data-stu-id="5925d-142">Built-in system trace</span></span>
  - <span data-ttu-id="5925d-143">大規模なプロセッサのサポート</span><span class="sxs-lookup"><span data-stu-id="5925d-143">Vast processor support</span></span>
  - <span data-ttu-id="5925d-144">大規模な開発ツールのサポート</span><span class="sxs-lookup"><span data-stu-id="5925d-144">Vast development tool support</span></span>
  - <span data-ttu-id="5925d-145">完全なエンディアン ニュートラル</span><span class="sxs-lookup"><span data-stu-id="5925d-145">Completely endian neutral</span></span>

### <a name="not-a-black-box"></a><span data-ttu-id="5925d-146">ブラック ボックスではない</span><span class="sxs-lookup"><span data-stu-id="5925d-146">Not A Black Box</span></span>
<span data-ttu-id="5925d-147">ThreadX SMP のほとんどのディストリビューションに、完全な C ソースコードと、プロセッサ固有のアセンブリ言語が含まれています。</span><span class="sxs-lookup"><span data-stu-id="5925d-147">Most distributions of ThreadX SMP include the complete C source code as well as the processorspecific assembly language.</span></span> <span data-ttu-id="5925d-148">これにより、多くの商用カーネルで発生する 「ブラックボックス」 の問題が解消されます。</span><span class="sxs-lookup"><span data-stu-id="5925d-148">This eliminates the “black-box” problems that occur with many commercial kernels.</span></span> <span data-ttu-id="5925d-149">ThreadX SMP を使用すると、アプリケーション開発者が、カーネルの動作を正確に知ることができます。謎はありません。</span><span class="sxs-lookup"><span data-stu-id="5925d-149">With ThreadX SMP, application developers can see exactly what the kernel is doing—there are no mysteries!</span></span>

<span data-ttu-id="5925d-150">また、ソース コードによって、アプリケーション固有の変更を行うこともできます。</span><span class="sxs-lookup"><span data-stu-id="5925d-150">The source code also allows for application specific modifications.</span></span> <span data-ttu-id="5925d-151">推奨はされていませんが、どうしても必要な場合にカーネルを変更できれば、確かに便利です。</span><span class="sxs-lookup"><span data-stu-id="5925d-151">Although not recommended, it is certainly beneficial to have the ability to modify the kernel if it is absolutely required.</span></span>

<span data-ttu-id="5925d-152">これらの機能は、独自の 「*社内カーネル*」 の操作に慣れている開発者にとっては、特に心強いものです。</span><span class="sxs-lookup"><span data-stu-id="5925d-152">These features are especially comforting to developers accustomed to working with their own *inhouse kernels*.</span></span> <span data-ttu-id="5925d-153">期待されているのは、ソースコードと、カーネルを変更する機能です。</span><span class="sxs-lookup"><span data-stu-id="5925d-153">They expect to have source code and the ability to modify the kernel.</span></span> <span data-ttu-id="5925d-154">ThreadX SMP は、このような開発者のための究極のカーネルです。</span><span class="sxs-lookup"><span data-stu-id="5925d-154">ThreadX SMP is the ultimate kernel for such developers.</span></span>

### <a name="the-rtos-standard"></a><span data-ttu-id="5925d-155">RTOS 標準</span><span class="sxs-lookup"><span data-stu-id="5925d-155">The RTOS Standard</span></span>
<span data-ttu-id="5925d-156">ThreadX SMP は、その汎用性、高パフォーマンス *picokernel* アーキテクチャ、高度なテクノロジ、および実証済みの移植性により、現在 20 億台以上のデバイスに導入されています。</span><span class="sxs-lookup"><span data-stu-id="5925d-156">Because of its versatility, high-performance *picokernel* architecture, advanced technology, and demonstrated portability, ThreadX SMP is deployed in more than two-billion devices today.</span></span> <span data-ttu-id="5925d-157">これにより、事実上、ThreadX SMP は、深く埋め込まれているアプリケーションの RTOS 標準となっています。</span><span class="sxs-lookup"><span data-stu-id="5925d-157">This effectively makes ThreadX SMP the RTOS standard for deeply embedded applications.</span></span>

## <a name="safety-certifications"></a><span data-ttu-id="5925d-158">安全性の認定</span><span class="sxs-lookup"><span data-stu-id="5925d-158">Safety Certifications</span></span>

### <a name="tv-certification"></a><span data-ttu-id="5925d-159">TÜV 認定</span><span class="sxs-lookup"><span data-stu-id="5925d-159">TÜV Certification</span></span>  
<span data-ttu-id="5925d-160">ThreadX SMP は、IEC61508 および IEC-62304 に従って、安全性が重要なシステムで使用できるように SGS-TÜV Saar によって認定されています。</span><span class="sxs-lookup"><span data-stu-id="5925d-160">ThreadX SMP has been certified by SGS-TÜV Saar for use in safety-critical systems, according to IEC61508 and IEC-62304.</span></span> <span data-ttu-id="5925d-161">この認定により、「電気・電子・プログラマブル電子安全関連系の機能安全」 に関する国際電気標準会議 （IEC） 61508 および IEC 62304 の、安全性の最高レベルに対応する安全関連ソフトウェアの開発に、ThreadX SMP を使用できることが承認されます。ThreadX SMP can be used in the development of safety-related software for the highest safety integrity levels of the International Electrotechnical Commission</span><span class="sxs-lookup"><span data-stu-id="5925d-161">The certification confirms that ThreadX SMP can be used in the development of safety-related software for the highest safety integrity levels of the International Electrotechnical Commission (IEC) 61508 and IEC 62304, for the “Functional Safety of electrical, electronic, and programmable electronic safety-related systems.”</span></span> <span data-ttu-id="5925d-162">ドイツの SGS-Group と TÜV Saarland の共同事業を通じて結成された SGS-TÜV Saar は、世界中の安全関連システムのための埋め込みソフトウェアのテスト、監査、検証、認定を行う、世界有数の公認された独立系企業になりました。</span><span class="sxs-lookup"><span data-stu-id="5925d-162">SGS-TÜV Saar, formed through a joint venture of Germany’s SGS-Group and TÜV Saarland, has become the leading accredited, independent company for testing, auditing, verifying, and certifying embedded software for safety-related systems worldwide.</span></span> <span data-ttu-id="5925d-163">工業安全規格の IEC 61508 と、そこから派生したすべての標準 （IEC 62304 を含む） は、電気・電子・プログラマブル電子安全関連の医療デバイス、プロセス制御システム、工業機械、鉄道制御システムの機能安全を保証するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="5925d-163">The industrial safety standard IEC 61508, and all standards that are derived from it, including IEC 62304, are used to assure the functional safety of electrical, electronic, and programmable electronic safety-related medical devices, process control systems, industrial machinery, and railway control systems.</span></span>

<span data-ttu-id="5925d-164">SGS-TÜV Saar は、ISO 26262 標準に従って、ThreadX SMP を、安全性が重要な自動車システムで使用できるものとして認定しました。</span><span class="sxs-lookup"><span data-stu-id="5925d-164">SGS-TÜV Saar has certified ThreadX SMP to be used in safety-critical automotive systems, according to the ISO 26262 standard.</span></span> <span data-ttu-id="5925d-165">さらに、ThreadX SMP は、ISO 26262 認定の最高レベルを表す Automotive Safety Integrity Level （ASIL） D に認定されています。</span><span class="sxs-lookup"><span data-stu-id="5925d-165">Furthermore, ThreadX SMP is certified to Automotive Safety Integrity Level (ASIL) D, which represents the highest level of ISO 26262 certification.</span></span>

<span data-ttu-id="5925d-166">また、SGS-TÜV Saar は、ThreadX SMP を、安全性が重要な鉄道アプリケーションで使用できるものとして認定しており、EN 50128 標準の最高レベル SW-SIL 4 を満たしています。</span><span class="sxs-lookup"><span data-stu-id="5925d-166">In addition, SGS-TÜV Saar has certified ThreadX SMP to be used in safety-critical railway applications, meeting to the EN 50128 standard up to SW-SIL 4.</span></span>

![TÜV 認定](media/image2.png)

<span data-ttu-id="5925d-168">IEC 61508 （最高レベル: SIL 4）</span><span class="sxs-lookup"><span data-stu-id="5925d-168">IEC 61508 up to SIL 4</span></span>  
<span data-ttu-id="5925d-169">IEC 62304 （最高レベル: SW 安全性クラス C）</span><span class="sxs-lookup"><span data-stu-id="5925d-169">IEC 62304 up to SW safety Class C</span></span>  
<span data-ttu-id="5925d-170">ISO 26262 ASIL D</span><span class="sxs-lookup"><span data-stu-id="5925d-170">ISO 26262 ASIL D</span></span>  
<span data-ttu-id="5925d-171">EN 50128 SW-SIL 4</span><span class="sxs-lookup"><span data-stu-id="5925d-171">EN 50128 SW-SIL 4</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="5925d-172">TÜV によって認定されている ThreadX SMP のバージョンに関する詳細情報や、テスト レポート、証明書、および関連ドキュメントの入手については、[azure-rtos-support@microsoft.com](https://azure-rtos-support@microsoft.com) までお問い合わせください。</span><span class="sxs-lookup"><span data-stu-id="5925d-172">Please contact [azure-rtos-support@microsoft.com](https://azure-rtos-support@microsoft.com) for more information on which version(s) of ThreadX SMP have been certified by TÜV or for the availability of test reports, certificates, and associated documentation.</span></span>

### <a name="misra-c-compliant"></a><span data-ttu-id="5925d-173">MISRA C 準拠</span><span class="sxs-lookup"><span data-stu-id="5925d-173">MISRA C Compliant</span></span> 
<span data-ttu-id="5925d-174">MISRA C は、C プログラミング言語を使用した重要なシステム用の一連のプログラミング ガイドラインです。</span><span class="sxs-lookup"><span data-stu-id="5925d-174">MISRA C is a set of programming guidelines for critical systems using the C programming language.</span></span> <span data-ttu-id="5925d-175">元の MISRA C ガイドラインは主に自動車アプリケーションを対象としていましたが、現在 MISRA C は安全性が重要なすべてのアプリケーションに適用できるものとして広く認識されています。</span><span class="sxs-lookup"><span data-stu-id="5925d-175">The original MISRA C guidelines were primarily targeted toward automotive applications; however, MISRA C is now widely recognized as being applicable to any safety critical application.</span></span> <span data-ttu-id="5925d-176">ThreadX SMP は、MISRA-C:2004 と MISRA C:2012 のすべての 「必要」 ルールと 「必須」 ルールに準拠しています。</span><span class="sxs-lookup"><span data-stu-id="5925d-176">ThreadX SMP is compliant with all “required” and “mandatory” rules of MISRA-C:2004 and MISRA C:2012.</span></span> <span data-ttu-id="5925d-177">また、ThreadX SMP は、3 つを除くすべての 「推奨」 ルールにも準拠しています。</span><span class="sxs-lookup"><span data-stu-id="5925d-177">ThreadX SMP is also compliant with all but three “advisory” rules.</span></span> <span data-ttu-id="5925d-178">詳細については、***ThreadX_MISRA_Compliance.pdf*** ドキュメントをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="5925d-178">Refer to the ***ThreadX_MISRA_Compliance.pdf*** document for more details.</span></span>

### <a name="ul-certification"></a><span data-ttu-id="5925d-179">UL 認定</span><span class="sxs-lookup"><span data-stu-id="5925d-179">UL Certification</span></span> 
<span data-ttu-id="5925d-180">ThreadX SMP は、プログラマブル コンポーネント内のソフトウェアに対する UL 60730-1 付属文書 H、CSA E60730-1 付属文書 H、IEC 60730-1 付属文書 H、UL 60335-1 付属文書 R、IEC 60335-1 付属文書 R、UL 1998 の各安全標準に準拠しているものとして UL によって認定されています。</span><span class="sxs-lookup"><span data-stu-id="5925d-180">ThreadX SMP has been certified by UL for compliance with UL 60730-1 Annex H, CSA E607301 Annex H, IEC 60730-1 Annex H, UL 60335-1 Annex R, IEC 60335-1 Annex R, and UL 1998 safety standards for software in programmable components.</span></span> <span data-ttu-id="5925d-181">IEC/UL 60730-1 の付属文書 H には 「ソフトウェアを使用した制御」 に対する要件が、そして IEC 60335-1 標準の付属文書 R には 「プログラマブル電子回路」 に対する要件が記載されています。また、IEC 60730 の 付属文書 R と IEC 60335-1 の 付属文書 R は、洗濯機、乾燥機、冷蔵庫、冷凍庫、オーブンなどのアプライアンスで使用される MCU のハードウェアとソフトウェアの安全性を取り上げています。</span><span class="sxs-lookup"><span data-stu-id="5925d-181">Along with IEC/UL 60730-1, which has requirements for “Controls Using Software” in its Annex H, the IEC 60335-1 standard describes the requirements for “Programmable Electronic Circuits” in its Annex R. IEC 60730 Annex H and IEC 60335-1 Annex R address the safety of MCU hardware and software used in appliances such as washing machines, dishwashers, dryers, refrigerators, freezers, and ovens.</span></span>

![UL 認定](media/image3.png) 

<span data-ttu-id="5925d-183">*UL/IEC 60730、UL/IEC 60335、UL 1998*</span><span class="sxs-lookup"><span data-stu-id="5925d-183">*UL/IEC 60730, UL/IEC 60335, UL 1998*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5925d-184">TÜV によって認定されている ThreadX SMP のバージョンに関する詳細情報や、テスト レポート、証明書、および関連ドキュメントの入手については、[azure-rtos-support@microsoft.com](https://azure-rtos-support@microsoft.com) までお問い合わせください。</span><span class="sxs-lookup"><span data-stu-id="5925d-184">Please contact [azure-rtos-support@microsoft.com](https://azure-rtos-support@microsoft.com) for more information on which version(s) of ThreadX SMP have been certified by TÜV or for the availability of test reports, certificates, and associated documentation.</span></span>

### <a name="certification-pack"></a><span data-ttu-id="5925d-185">認定パック</span><span class="sxs-lookup"><span data-stu-id="5925d-185">Certification Pack</span></span>

<span data-ttu-id="5925d-186">ThreadX SMP Certification Pack™ は、すぐに使える 100% 完全な業界固有のスタンドアロン パッケージで、安全性が重要な航空、医療、産業システムに求められる最高レベルの信頼性と重要度レベルに対して、ThreadX SMP ベースの製品を認定または適切に提出するのに必要なすべての ThreadX SMP の証拠を提供します。</span><span class="sxs-lookup"><span data-stu-id="5925d-186">The ThreadX SMP Certification Pack™ is a 100% complete, turnkey, industry-specific, stand-alone package that provides all of the ThreadX SMP evidence needed to certify or successfully submit the ThreadX SMP-based product to the highest reliability and criticality levels required for safety-critical Aviation, Medical, and Industrial systems.</span></span> <span data-ttu-id="5925d-187">サポートされている認定には、DO-178B、ED-12B、DO-278、FDA510（k）、IEC-62304、IEC-60601、ISO-14971、UL-1998、IEC-61508、CENELEC EN50128、BS50128、および 49CFR236 があります。</span><span class="sxs-lookup"><span data-stu-id="5925d-187">Certifications supported include DO-178B, ED-12B, DO-278, FDA510(k), IEC-62304, IEC-60601, ISO- 14971, UL-1998, IEC-61508, CENELEC EN50128, BS50128, and 49CFR236.</span></span> <span data-ttu-id="5925d-188">認定パックの詳細については、sales@expresslogic.com にお問い合わせください。</span><span class="sxs-lookup"><span data-stu-id="5925d-188">Please contact sales@expresslogic.com for more information on Certification Pack.</span></span>

## <a name="embedded-applications"></a><span data-ttu-id="5925d-189">埋め込みアプリケーション</span><span class="sxs-lookup"><span data-stu-id="5925d-189">Embedded Applications</span></span>

<span data-ttu-id="5925d-190">埋め込みアプリケーションは、ワイヤレス通信デバイス、自動車エンジン、レーザー プリンター、医療機器などの製品内に埋め込まれたマイクロプロセッサ上で実行されます。また、そのソフトウェアとハードウェアに専用の用途があることも、埋め込みアプリケーションの特徴の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="5925d-190">Embedded applications execute on microprocessors buried within products such as wireless communication devices, automobile engines, laser printers, medical devices, etc. Another distinction of embedded applications is that their software and hardware have a dedicated purpose.</span></span>

### <a name="real-time-software"></a><span data-ttu-id="5925d-191">リアルタイム ソフトウェア</span><span class="sxs-lookup"><span data-stu-id="5925d-191">Real-time Software</span></span> 
<span data-ttu-id="5925d-192">アプリケーション ソフトウェアに時間的な制約が課される場合、そのソフトウェアは 「*リアルタイム*」 ソフトウェアと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="5925d-192">When time constraints are imposed on the application software, it is called the *real-time* software.</span></span> <span data-ttu-id="5925d-193">基本的には、正確な時間内に処理を実行する必要があるソフトウェアが、「*リアルタイム*」 ソフトウェアと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="5925d-193">Basically, software that must perform its processing within an exact period of time is called *real-time* software.</span></span> <span data-ttu-id="5925d-194">埋め込みアプリケーションは外部イベントとのやり取りが不可欠であるため、ほとんどの場合、リアルタイムです。</span><span class="sxs-lookup"><span data-stu-id="5925d-194">Embedded applications are almost always real-time because of their inherent interaction with external events.</span></span>

### <a name="multitasking"></a><span data-ttu-id="5925d-195">マルチタスキング</span><span class="sxs-lookup"><span data-stu-id="5925d-195">Multitasking</span></span>  
<span data-ttu-id="5925d-196">前述のように、埋め込みアプリケーションには専用の用途があります。</span><span class="sxs-lookup"><span data-stu-id="5925d-196">As mentioned, embedded applications have a dedicated purpose.</span></span> <span data-ttu-id="5925d-197">この目的を達成するために、ソフトウェアはさまざまな 「*タスク*」 を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5925d-197">To fulfill this purpose, the software must perform a variety of *tasks*.</span></span> <span data-ttu-id="5925d-198">タスクは、特定の職務を実行する、アプリケーションの半独立した部分です。</span><span class="sxs-lookup"><span data-stu-id="5925d-198">A task is a semi-independent portion of the application that carries out a specific duty.</span></span> <span data-ttu-id="5925d-199">また、タスクによっては、他のタスクよりも重要になってくる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="5925d-199">It is also the case that some tasks are more important than others.</span></span> <span data-ttu-id="5925d-200">埋め込みアプリケーションの大きな課題の 1 つが、さまざまなアプリケーション タスク間でプロセッサを割り振ることです。</span><span class="sxs-lookup"><span data-stu-id="5925d-200">One of the major difficulties in an embedded application is the allocation of the processor between the various application tasks.</span></span> <span data-ttu-id="5925d-201">競合するタスク間で処理を割り振ることが、ThreadX SMP の主な目的です。</span><span class="sxs-lookup"><span data-stu-id="5925d-201">This allocation of processing between competing tasks is the primary purpose of ThreadX SMP.</span></span>

### <a name="tasks-vs-threads"></a><span data-ttu-id="5925d-202">タスクとスレッド</span><span class="sxs-lookup"><span data-stu-id="5925d-202">Tasks vs. Threads</span></span> 
<span data-ttu-id="5925d-203">タスクについては、もう 1 つ特徴があります。</span><span class="sxs-lookup"><span data-stu-id="5925d-203">Another distinction about tasks must be made.</span></span> <span data-ttu-id="5925d-204">タスクという用語は、さまざまな意味で使われます。</span><span class="sxs-lookup"><span data-stu-id="5925d-204">The term task is used in a variety of ways.</span></span> <span data-ttu-id="5925d-205">あるときは、個別に読み込み可能なプログラムを意味します。</span><span class="sxs-lookup"><span data-stu-id="5925d-205">It sometimes means a separately loadable program.</span></span> <span data-ttu-id="5925d-206">内部プログラム セグメントを指すこともあります。</span><span class="sxs-lookup"><span data-stu-id="5925d-206">In other instances, it may refer to an internal program segment.</span></span>

<span data-ttu-id="5925d-207">最近のオペレーティング システムの話をする場合、このタスクという用語は、ほぼ 「*プロセス*」 と 「*スレッド* 」 という 2 つの用語に置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="5925d-207">In contemporary operating system discussion, there are two terms that more or less replace the use of task: *process* and *thread*.</span></span> <span data-ttu-id="5925d-208">「*プロセス*」 は、独自のアドレス空間を持つ完全に独立したプログラムで、「*スレッド*」 は、プロセス内で実行される半独立したプログラム セグメントです。</span><span class="sxs-lookup"><span data-stu-id="5925d-208">A *process* is a completely independent program that has its own address space, while a *thread* is a semi-independent program segment that executes within a process.</span></span> <span data-ttu-id="5925d-209">スレッドは同じプロセス アドレス空間を共有します。</span><span class="sxs-lookup"><span data-stu-id="5925d-209">Threads share the same process address space.</span></span> <span data-ttu-id="5925d-210">スレッド管理に伴うオーバーヘッドは最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="5925d-210">The overhead associated with thread management is minimal.</span></span>

<span data-ttu-id="5925d-211">埋め込みアプリケーションのほとんどが、本格的なプロセス指向のオペレーティング システムに伴うオーバーヘッド （メモリとパフォーマンスの両方） を許容できません。</span><span class="sxs-lookup"><span data-stu-id="5925d-211">Most embedded applications cannot afford the overhead (both memory and performance) associated with a full-blown process-oriented operating system.</span></span> <span data-ttu-id="5925d-212">また、小規模なマイクロプロセッサには、真のプロセス指向オペレーティング システムをサポートするハードウェア アーキテクチャがありません。</span><span class="sxs-lookup"><span data-stu-id="5925d-212">In addition, smaller microprocessors don’t have the hardware architecture to support a true process-oriented operating system.</span></span> <span data-ttu-id="5925d-213">このような理由から、ThreadX SMP が実装しているスレッド モデルは、リアルタイムの埋め込みアプリケーションのほとんどに対して非常に効率的かつ実用的です。</span><span class="sxs-lookup"><span data-stu-id="5925d-213">For these reasons, ThreadX SMP implements a thread model, which is both extremely efficient and practical for most real-time embedded applications.</span></span>

<span data-ttu-id="5925d-214">混乱を避けるため、「*タスク*」 という用語は、ThreadX SMP では使用されていません。</span><span class="sxs-lookup"><span data-stu-id="5925d-214">To avoid confusion, ThreadX SMP does not use the term *task*.</span></span> <span data-ttu-id="5925d-215">代わりに、よりわかりやすい最近の名称である 「*スレッド*」 が使用されます。</span><span class="sxs-lookup"><span data-stu-id="5925d-215">Instead, the more descriptive and contemporary name *thread* is used.</span></span>

## <a name="threadx-smp-benefits"></a><span data-ttu-id="5925d-216">ThreadX SMP の利点</span><span class="sxs-lookup"><span data-stu-id="5925d-216">ThreadX SMP Benefits</span></span>

<span data-ttu-id="5925d-217">ThreadX SMP を使用すると、埋め込みアプリケーションに多くのメリットがもたらされます。</span><span class="sxs-lookup"><span data-stu-id="5925d-217">Using ThreadX SMP provides many benefits to embedded applications.</span></span> <span data-ttu-id="5925d-218">もちろん、一番のメリットは、埋め込みアプリケーションのスレッドへの処理時間の割り当て方法です。</span><span class="sxs-lookup"><span data-stu-id="5925d-218">Of course, the primary benefit rests in how embedded application threads are allocated processing time.</span></span>

### <a name="automatic-load-balancing"></a><span data-ttu-id="5925d-219">自動負荷分散</span><span class="sxs-lookup"><span data-stu-id="5925d-219">Automatic Load Balancing</span></span>  
<span data-ttu-id="5925d-220">ThreadX SMP は、自動負荷分散 （使用可能なコア間でのスレッドの実行） が可能であるため、マルチコア プロセッサの利用が可能な限り容易になります。</span><span class="sxs-lookup"><span data-stu-id="5925d-220">ThreadX SMP provides automatic load balancing (thread execution across available cores), which makes utilizing multicore processors as easy as possible.</span></span> 

### <a name="improved-responsiveness"></a><span data-ttu-id="5925d-221">応答性の向上</span><span class="sxs-lookup"><span data-stu-id="5925d-221">Improved Responsiveness</span></span>  
<span data-ttu-id="5925d-222">ThreadX SMP のようなリアルタイム カーネルが登場する前は、埋め込みアプリケーションのほとんどが、通常は C の *main* 関数内から、単純な制御ループを使用して処理時間を割り当てていました。</span><span class="sxs-lookup"><span data-stu-id="5925d-222">Prior to real-time kernels like ThreadX SMP, most embedded applications allocated processing time with a simple control loop, usually from within the C *main* function.</span></span> <span data-ttu-id="5925d-223">この方法は、非常に小さなアプリケーションや単純なアプリケーション内では今でも使用されています。</span><span class="sxs-lookup"><span data-stu-id="5925d-223">This approach is still used in very small or simple applications.</span></span> <span data-ttu-id="5925d-224">しかし、大きなアプリケーションまたは複雑なアプリケーションの場合、これは実用的ではありません。イベントへの応答時間が、制御ループを 1 回通過するのに要する最悪のケースの処理時間の関数になるからです。</span><span class="sxs-lookup"><span data-stu-id="5925d-224">However, in large or complex applications, it is not practical because the response time to any event is a function of the worstcase processing time of one pass through the control loop.</span></span>

<span data-ttu-id="5925d-225">さらに悪いことに、制御ループが変わるたびに、アプリケーションのタイミング特性が変化します。</span><span class="sxs-lookup"><span data-stu-id="5925d-225">Making matters worse, the timing characteristics of the application change whenever modifications are made to the control loop.</span></span> <span data-ttu-id="5925d-226">これにより、アプリケーションが本質的に不安定になり、保守と改良が困難になります。</span><span class="sxs-lookup"><span data-stu-id="5925d-226">This makes the application inherently unstable and difficult to maintain and improve on.</span></span>

<span data-ttu-id="5925d-227">ThreadX SMP が重要な外部イベントに対して提供する応答時間は、高速かつ決定論的です。</span><span class="sxs-lookup"><span data-stu-id="5925d-227">ThreadX SMP provides fast and deterministic response times to important external events.</span></span> <span data-ttu-id="5925d-228">ThreadX SMP は、優先順位に基づくプリエンプティブなスケジューリング アルゴリズムによってこれを実現するため、優先度の高いスレッドが、実行中の優先度の低いスレッドを横取りできます。</span><span class="sxs-lookup"><span data-stu-id="5925d-228">ThreadX SMP accomplishes this through its preemptive, priority-based scheduling algorithm, which allows a higher-priority thread to preempt an executing lower-priority thread.</span></span> <span data-ttu-id="5925d-229">結果として、最悪のケースでの応答時間は、コンテキスト切り替えの実行に必要な時間に近くなります。</span><span class="sxs-lookup"><span data-stu-id="5925d-229">As a result, the worst-case response time approaches the time required to perform a context switch.</span></span> <span data-ttu-id="5925d-230">これは決定論的であるだけでなく、非常に高速でもあります。</span><span class="sxs-lookup"><span data-stu-id="5925d-230">This is not only deterministic, but it is also extremely fast.</span></span>

### <a name="software-maintenance"></a><span data-ttu-id="5925d-231">ソフトウェアのメンテナンス</span><span class="sxs-lookup"><span data-stu-id="5925d-231">Software Maintenance</span></span>  
<span data-ttu-id="5925d-232">ThreadX SMP カーネルを使用すると、アプリケーション開発者がアプリケーション スレッドの特定の要件に専念できます。その際、そのアプリケーションの他の領域のタイミングが変わることを心配する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="5925d-232">The ThreadX SMP kernel enables application developers to concentrate on specific requirements of their application threads without having to worry about changing the timing of other areas of the application.</span></span> <span data-ttu-id="5925d-233">また、この機能によって、ThreadX SMP を利用するアプリケーションの修復や拡張がはるかに簡単になります。</span><span class="sxs-lookup"><span data-stu-id="5925d-233">This feature also makes it much easier to repair or enhance an application that utilizes ThreadX SMP.</span></span>

### <a name="increased-throughput"></a><span data-ttu-id="5925d-234">スループットの向上</span><span class="sxs-lookup"><span data-stu-id="5925d-234">Increased Throughput</span></span>  
<span data-ttu-id="5925d-235">制御ループの応答時間に関する問題は、ポーリングを追加することで回避できることがあります。</span><span class="sxs-lookup"><span data-stu-id="5925d-235">A possible work-around to the control loop response time problem is to add more polling.</span></span> <span data-ttu-id="5925d-236">これにより応答性は向上しますが、やはり最悪のケースの応答時間が一定になることは保証されず、アプリケーションの将来の変更を強化するものではありません。</span><span class="sxs-lookup"><span data-stu-id="5925d-236">This improves the responsiveness, but it still doesn’t guarantee a constant worst-case response time and does nothing to enhance future modification of the application.</span></span> <span data-ttu-id="5925d-237">また、追加のポーリングが原因で、プロセッサが実行する不要な処理が増えてしまいます。</span><span class="sxs-lookup"><span data-stu-id="5925d-237">Also, the processor is now performing even more unnecessary processing because of the extra polling.</span></span> <span data-ttu-id="5925d-238">このような不要な処理すべてが、システムの全体的なスループット低下につながります。</span><span class="sxs-lookup"><span data-stu-id="5925d-238">All of this unnecessary processing reduces the overall throughput of the system.</span></span>

<span data-ttu-id="5925d-239">オーバーヘッドに関する興味深い点は、開発者の多くが、ThreadX SMP のようなマルチスレッド環境はオーバーヘッドを増やし、システム全体のスループットに悪影響を及ぼすと考えていることです。</span><span class="sxs-lookup"><span data-stu-id="5925d-239">An interesting point regarding overhead is that many developers assume that multithreaded environments like ThreadX SMP increase overhead and have a negative impact on total system throughput.</span></span> <span data-ttu-id="5925d-240">しかし、マルチスレッド化により、制御ループ環境で発生する冗長なポーリングすべてが排除され、実際にオーバーヘッドを軽減できる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="5925d-240">But in some cases, multithreading actually reduces overhead by eliminating all of the redundant polling that occurs in control loop environments.</span></span> <span data-ttu-id="5925d-241">マルチスレッド カーネルに関連するオーバーヘッドは、通常、コンテキスト切り替えに必要な時間の関数です。</span><span class="sxs-lookup"><span data-stu-id="5925d-241">The overhead associated with multithreaded kernels is typically a function of the time required for context switching.</span></span> <span data-ttu-id="5925d-242">コンテキスト切り替え時間がポーリング プロセスよりも短い場合、ThreadX SMP は、オーバーヘッドを減らし、スループットを向上させる可能性のあるソリューションを提供します。</span><span class="sxs-lookup"><span data-stu-id="5925d-242">If the context switch time is less than the polling process, ThreadX SMP provides a solution with the potential of less overhead and more throughput.</span></span> <span data-ttu-id="5925d-243">このため、ある程度の複雑さやサイズを持つアプリケーションに ThreadX SMP を選択するのは自然なことです。</span><span class="sxs-lookup"><span data-stu-id="5925d-243">This makes ThreadX SMP an obvious choice for applications that have any degree of complexity or size.</span></span>

### <a name="processor-isolation"></a><span data-ttu-id="5925d-244">プロセッサの分離</span><span class="sxs-lookup"><span data-stu-id="5925d-244">Processor Isolation</span></span>  
<span data-ttu-id="5925d-245">ThreadX SMP は、アプリケーションと基になるプロセッサの間に、プロセッサに依存しない堅牢なインターフェイスを提供します。</span><span class="sxs-lookup"><span data-stu-id="5925d-245">ThreadX SMP provides a robust processorindependent interface between the application and the underlying processor.</span></span> <span data-ttu-id="5925d-246">これにより、開発者はアプリケーションに専念することができます。ハードウェアの詳細の学習に膨大な時間をかける必要はありません。</span><span class="sxs-lookup"><span data-stu-id="5925d-246">This allows developers to concentrate on the application rather than spending a significant amount of time learning hardware details.</span></span> 

### <a name="dividing-the-application"></a><span data-ttu-id="5925d-247">アプリケーションの分割</span><span class="sxs-lookup"><span data-stu-id="5925d-247">Dividing the Application</span></span>  
<span data-ttu-id="5925d-248">制御ループをベースにしたアプリケーションの場合は、各開発者が、アプリケーション全体の実行時の動作と要件を熟知している必要があります。</span><span class="sxs-lookup"><span data-stu-id="5925d-248">In control loop-based applications, each developer must have an intimate knowledge of the entire application’s run-time behavior and requirements.</span></span> <span data-ttu-id="5925d-249">これは、プロセッサの割り当てロジックがアプリケーション全体に分散しているためです。</span><span class="sxs-lookup"><span data-stu-id="5925d-249">This is because the processor allocation logic is dispersed throughout the entire application.</span></span> <span data-ttu-id="5925d-250">アプリケーションのサイズや複雑さが増すほど、すべての開発者が、アプリケーション全体の正確な処理要件を覚えることは不可能になります。</span><span class="sxs-lookup"><span data-stu-id="5925d-250">As an application increases in size or complexity, it becomes impossible for all developers to remember the precise processing requirements of the entire application.</span></span>

<span data-ttu-id="5925d-251">ThreadX SMP は、プロセッサの割り当てに関する悩みから各開発者を解放し、埋め込みアプリケーションの特定の部分に集中できるようにします。</span><span class="sxs-lookup"><span data-stu-id="5925d-251">ThreadX SMP frees each developer from the worries associated with processor allocation and allows them to concentrate on their specific piece of the embedded application.</span></span> <span data-ttu-id="5925d-252">さらに、ThreadX SMP により、アプリケーションは、明確に定義されたスレッドに強制的に分割されます。</span><span class="sxs-lookup"><span data-stu-id="5925d-252">In addition, ThreadX SMP forces the application to be divided into clearly defined threads.</span></span> <span data-ttu-id="5925d-253">このようにアプリケーションをスレッドに分割すれば、開発が格段に簡単になります。</span><span class="sxs-lookup"><span data-stu-id="5925d-253">By itself, this division of the application into threads makes development much simpler.</span></span>

### <a name="ease-of-use"></a><span data-ttu-id="5925d-254">使いやすさ</span><span class="sxs-lookup"><span data-stu-id="5925d-254">Ease of Use</span></span>  
<span data-ttu-id="5925d-255">ThreadX SMP は、アプリケーション開発者を念頭に置いて設計されています。</span><span class="sxs-lookup"><span data-stu-id="5925d-255">ThreadX SMP is designed with the application developer in mind.</span></span> <span data-ttu-id="5925d-256">ThreadX SMP のアーキテクチャとサービス呼び出しインターフェイスは、簡単に理解できるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="5925d-256">The ThreadX SMP architecture and service call interface are designed to be easily understood.</span></span> <span data-ttu-id="5925d-257">その結果、ThreadX SMP の開発者は、その高度な機能をすぐに使うことができます。</span><span class="sxs-lookup"><span data-stu-id="5925d-257">As a result, ThreadX SMP developers can quickly use its advanced features.</span></span>  

### <a name="improve-time-to-market"></a><span data-ttu-id="5925d-258">市場投入までの時間の短縮</span><span class="sxs-lookup"><span data-stu-id="5925d-258">Improve Time-to-market</span></span>  
<span data-ttu-id="5925d-259">ThreadX SMP のすべての利点が、ソフトウェア開発プロセスを加速します。</span><span class="sxs-lookup"><span data-stu-id="5925d-259">All of the benefits of ThreadX SMP accelerate the software development process.</span></span> <span data-ttu-id="5925d-260">ThreadX SMP は、プロセッサに関するほとんどの問題と、最も一般的な安全性の認定に対応しているため、これに伴う作業を開発スケジュールから取り除くことができます。</span><span class="sxs-lookup"><span data-stu-id="5925d-260">ThreadX SMP takes care of most processor issues and the most common safety certifications, thereby removing this effort from the development schedule.</span></span> <span data-ttu-id="5925d-261">その結果、市場投入までの時間が短縮されます。</span><span class="sxs-lookup"><span data-stu-id="5925d-261">All of this results in a faster time to market!</span></span>  

### <a name="protecting-the-software-investment"></a><span data-ttu-id="5925d-262">ソフトウェア投資の保護</span><span class="sxs-lookup"><span data-stu-id="5925d-262">Protecting the Software Investment</span></span>  
<span data-ttu-id="5925d-263">ThreadX SMP は、そのアーキテクチャのおかげで、新しいプロセッサや開発ツール環境に簡単に移植できます。</span><span class="sxs-lookup"><span data-stu-id="5925d-263">Because of its architecture, ThreadX SMP is easily ported to new processor and/or development tool environments.</span></span> <span data-ttu-id="5925d-264">このことと、ThreadX SMP が、基になるプロセッサの詳細からアプリケーションを切り離しているという事実が相まって、ThreadX SMP アプリケーションも移植性が高くなっています。</span><span class="sxs-lookup"><span data-stu-id="5925d-264">This, coupled with the fact that ThreadX SMP insulates applications from details of the underlying processors, makes ThreadX SMP applications highly portable.</span></span> <span data-ttu-id="5925d-265">その結果、アプリケーションの移行パスが保証され、当初の開発投資が保護されます。</span><span class="sxs-lookup"><span data-stu-id="5925d-265">As a result, the application’s migration path is guaranteed, and the original development investment is protected.</span></span>