---
title: 第 3 章 - Azure RTOS ThreadX SMP の機能コンポーネント
description: この章では、機能の観点から見た高パフォーマンスの Azure RTOS ThreadX SMP カーネルについて説明します。
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 6a72acb111aa986f4621e8747568ce3ce3e5e080
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104812275"
---
# <a name="chapter-3---functional-components-of-azure-rtos-threadx-smp"></a><span data-ttu-id="293a5-103">第 3 章 - Azure RTOS ThreadX SMP の機能コンポーネント</span><span class="sxs-lookup"><span data-stu-id="293a5-103">Chapter 3 - Functional Components of Azure RTOS ThreadX SMP</span></span>

<span data-ttu-id="293a5-104">この章では、機能の観点から見た高パフォーマンスの Azure RTOS ThreadX SMP カーネルについて説明します。</span><span class="sxs-lookup"><span data-stu-id="293a5-104">This chapter contains a description of the highperformance Azure RTOS ThreadX SMP kernel from a functional perspective.</span></span> <span data-ttu-id="293a5-105">個々の機能コンポーネントについて、わかりやすく説明します。</span><span class="sxs-lookup"><span data-stu-id="293a5-105">Each functional component is presented in an easy-to-understand manner.</span></span>

## <a name="execution-overview"></a><span data-ttu-id="293a5-106">実行の概要</span><span class="sxs-lookup"><span data-stu-id="293a5-106">Execution Overview</span></span>

<span data-ttu-id="293a5-107">ThreadX SMP アプリケーション内のプログラム実行には、初期化、スレッド実行、割り込みサービス ルーチン (ISR)、アプリケーション タイマーの 4 種類があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-107">There are four types of program execution within a ThreadX SMP application: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers.</span></span>

<span data-ttu-id="293a5-108">45 ページの 図 1 では、さまざまな種類のプログラム実行を示しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-108">Figure 1 on page 45 shows each different type of program execution.</span></span> <span data-ttu-id="293a5-109">これらの各種類の詳細については、この章の後続のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="293a5-109">More detailed information about each of these types is found in subsequent sections of this chapter.</span></span>

### <a name="initialization"></a><span data-ttu-id="293a5-110">初期化</span><span class="sxs-lookup"><span data-stu-id="293a5-110">Initialization</span></span>
<span data-ttu-id="293a5-111">名前が示すように、これは ThreadX SMP アプリケーションでのプログラム実行の最初の種類です。</span><span class="sxs-lookup"><span data-stu-id="293a5-111">As the name implies, this is the first type of program execution in a ThreadX SMP application.</span></span> <span data-ttu-id="293a5-112">初期化には、プロセッサのリセットから、"*スレッド スケジューリング ループ*" のエントリ ポイントまでの間のすべてのプログラム実行が含まれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-112">Initialization includes all program execution between processor reset and the entry point of the *thread scheduling loop.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-113">初期化は、リセット後の既定の実行中コアであるコア 0 によって実行または開始されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-113">Initialization is performed by or initiated by core 0, which is the default running core after reset.</span></span>

### <a name="thread-execution"></a><span data-ttu-id="293a5-114">スレッド実行</span><span class="sxs-lookup"><span data-stu-id="293a5-114">Thread Execution</span></span>
<span data-ttu-id="293a5-115">初期化が完了した後、ThreadX SMP を実行している各コアは、そのスレッド スケジューリング ループに入ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-115">After initialization is complete, each core running ThreadX SMP enters its thread scheduling loop.</span></span> <span data-ttu-id="293a5-116">スケジューリング ループでは、そのコアで実行準備の完了しているアプリケーション スレッドが検索されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-116">The scheduling loop looks for an application thread ready for execution on that core.</span></span> <span data-ttu-id="293a5-117">準備の完了したスレッドが見つかると、ThreadX SMP はそれに制御を移します。</span><span class="sxs-lookup"><span data-stu-id="293a5-117">When a ready thread is found, ThreadX SMP transfers control to it.</span></span> <span data-ttu-id="293a5-118">スレッドが完了すると (または、それより優先度の高い別のスレッドが準備完了になると)、実行はスレッド スケジューリング ループに戻り、次に優先度の高い、各コアで準備の完了したスレッドが検索されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-118">After the thread is finished (or another higher-priority thread becomes ready), execution transfers back to the thread scheduling loop to find the next highest priority ready thread on each core.</span></span>

<span data-ttu-id="293a5-119">スレッドの実行とスケジューリングを継続的に行うこのプロセスは、ThreadX SMP アプリケーションで最も一般的な種類のプログラム実行です。</span><span class="sxs-lookup"><span data-stu-id="293a5-119">This process of continually executing and scheduling threads is the most common type of program execution in ThreadX SMP applications.</span></span>

![スレッド実行](media/image4.png)

<span data-ttu-id="293a5-121">**図 1. プログラムの実行の種類**</span><span class="sxs-lookup"><span data-stu-id="293a5-121">**FIGURE 1. Types of Program Execution**</span></span>

### <a name="interrupt-service-routines-isr"></a><span data-ttu-id="293a5-122">割り込みサービス ルーチン (ISR)</span><span class="sxs-lookup"><span data-stu-id="293a5-122">Interrupt Service Routines (ISR)</span></span>
<span data-ttu-id="293a5-123">割り込みは、リアルタイム システムの基礎となります。</span><span class="sxs-lookup"><span data-stu-id="293a5-123">Interrupts are the cornerstone of real-time systems.</span></span> <span data-ttu-id="293a5-124">割り込みがなければ、外部の変化に迅速に対応することが非常に困難になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-124">Without interrupts it would be extremely difficult to respond to changes in the external world in a timely manner.</span></span> <span data-ttu-id="293a5-125">割り込みが検出されると、プロセッサでは、現在のプログラムの実行に関する重要な情報を保存し (通常はスタックに)、その後、定義済みのプログラム領域に制御を移します。</span><span class="sxs-lookup"><span data-stu-id="293a5-125">On detection of an interrupt, the processor saves key information about the current program execution (usually on the stack), then transfers control to a predefined program area.</span></span> <span data-ttu-id="293a5-126">この定義済みのプログラム領域は、一般に割り込みサービス ルーチンと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-126">This predefined program area is commonly called an Interrupt Service Routine.</span></span>

<span data-ttu-id="293a5-127">ほとんどの場合、割り込みはスレッドの実行中に (またはスレッド スケジューリング ループ内で) 発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-127">In most cases, interrupts occur during thread execution (or in the thread scheduling loop).</span></span> <span data-ttu-id="293a5-128">ただし、割り込みは、実行中の ISR またはアプリケーション タイマーの内部で発生する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-128">However, interrupts may also occur inside of an executing ISR or an Application Timer.</span></span>

<span data-ttu-id="293a5-129">すべてのコアで割り込みを処理できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-129">All cores are allowed to process interrupts.</span></span> <span data-ttu-id="293a5-130">コアへの割り込みのマッピングは、アプリケーションによって直接制御されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-130">The mapping of interrupts to cores is under the direct control of the application.</span></span> <span data-ttu-id="293a5-131">ThreadX SMP のタイマー割り込みは、既定で処理のためにコア 0 に割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="293a5-131">The ThreadX SMP timer interrupt is by default assigned to core 0 for processing.</span></span> <span data-ttu-id="293a5-132">この割り当ての実装については、*tx_timer_interrupt.S* のコードを参照してください。</span><span class="sxs-lookup"><span data-stu-id="293a5-132">Please see the code in *tx_timer_interrupt.S* for implementation of this assignment.</span></span>

### <a name="application-timers"></a><span data-ttu-id="293a5-133">アプリケーション タイマー</span><span class="sxs-lookup"><span data-stu-id="293a5-133">Application Timers</span></span>
<span data-ttu-id="293a5-134">アプリケーション タイマーは ISR に似ていますが、ハードウェア実装 (通常は単一の周期的ハードウェア割り込みが使用されます) はアプリケーションから見えません。</span><span class="sxs-lookup"><span data-stu-id="293a5-134">Application Timers are similar to ISRs, except the hardware implementation (usually a single periodic hardware interrupt is used) is hidden from the application.</span></span> <span data-ttu-id="293a5-135">このようなタイマーは、タイムアウト、周期割り込み、またはウォッチドッグ サービスを実行するためにアプリケーションによって使用されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-135">Such timers are used by applications to perform time-outs, periodics, and/or watchdog services.</span></span> <span data-ttu-id="293a5-136">ISR と同様に、アプリケーション タイマーもスレッドの実行に割り込むことがよくあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-136">Just like ISRs, Application Timers most often interrupt thread execution.</span></span> <span data-ttu-id="293a5-137">ただし、ISR とは異なり、アプリケーション タイマーどうしで割り込むことはできません。</span><span class="sxs-lookup"><span data-stu-id="293a5-137">Unlike ISRs, however, Application Timers cannot interrupt each other.</span></span>

> [!NOTE]
> <span data-ttu-id="293a5-138">スレッドと同様に、アプリケーション タイマーは任意のコアで実行から除外できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-138">That like threads, application timers can be excluded from execution on any core.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="293a5-139">メモリ使用量</span><span class="sxs-lookup"><span data-stu-id="293a5-139">Memory Usage</span></span>

<span data-ttu-id="293a5-140">ThreadX SMP は、アプリケーション プログラムと共存しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-140">ThreadX SMP resides along with the application program.</span></span> <span data-ttu-id="293a5-141">その結果、ThreadX SMP の静的メモリ (つまり固定メモリ) の使用量は、開発ツール (コンパイラ、リンカー、ロケーターなど) によって決定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-141">As a result, the static memory (or fixed memory) usage of ThreadX SMP is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="293a5-142">動的メモリ (つまり実行時メモリ) の使用量は、アプリケーションによって直接制御されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-142">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

> [!NOTE]
> <span data-ttu-id="293a5-143">ThreadX SMP によってアクセスされるすべてのメモリは、キャッシュ コヒーレントである必要があり、ThreadX SMP を実行しているすべてのコアからアクセス可能である必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-143">All the memory accessed by ThreadX SMP must be cache coherent and accessible from all cores executing ThreadX SMP.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="293a5-144">静的メモリの使用量</span><span class="sxs-lookup"><span data-stu-id="293a5-144">Static Memory Usage</span></span>
<span data-ttu-id="293a5-145">ほとんどの開発ツールでは、アプリケーション プログラム イメージを "*命令*"、"*定数*"、"*初期化されたデータ*"、"*初期化されていないデータ*"、"*システム スタック*" の 5 つの基本的な領域に分割します。</span><span class="sxs-lookup"><span data-stu-id="293a5-145">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and *system stack*.</span></span> <span data-ttu-id="293a5-146">47 ページの図 2 は、これらのメモリ領域の例を示しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-146">Figure 2 on page 47 shows an example of these memory areas.</span></span>

![静的メモリの使用量](media/image5.png)

<span data-ttu-id="293a5-148">**図 2. メモリ領域の例**</span><span class="sxs-lookup"><span data-stu-id="293a5-148">**FIGURE 2. Memory Area Example**</span></span>

<span data-ttu-id="293a5-149">これは例にすぎないことを理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-149">It is important to understand that this is only an example.</span></span> <span data-ttu-id="293a5-150">実際の静的メモリのレイアウトは、プロセッサ、開発ツール、基になるハードウェアに固有のものです。</span><span class="sxs-lookup"><span data-stu-id="293a5-150">The actual static memory layout is specific to the processor, development tools, and the underlying hardware.</span></span>

<span data-ttu-id="293a5-151">命令領域には、そのプログラムのすべてのプロセッサ命令が含まれています。</span><span class="sxs-lookup"><span data-stu-id="293a5-151">The instruction area contains all of the program’s processor instructions.</span></span> <span data-ttu-id="293a5-152">この領域は、一般に最も大きく、多くの場合 ROM 内にあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-152">This area is typically the largest and is often located in ROM.</span></span>

<span data-ttu-id="293a5-153">定数領域には、プログラム内で定義または参照される文字列も含め、さまざまなコンパイル済み定数が含まれています。</span><span class="sxs-lookup"><span data-stu-id="293a5-153">The constant area contains various compiled constants, including strings defined or referenced within the program.</span></span> <span data-ttu-id="293a5-154">さらに、この領域には、初期化されたデータ領域の "初期のコピー" も含まれています。</span><span class="sxs-lookup"><span data-stu-id="293a5-154">In addition, this area contains the “initial copy” of the initialized data area.</span></span> <span data-ttu-id="293a5-155">コンパイラの初期化プロセス中に、定数領域のこの部分は、RAM 内の初期化されたデータ領域を設定するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-155">During the compiler’s initialization process, this portion of the constant area is used to set up the initialized data area in RAM.</span></span> <span data-ttu-id="293a5-156">定数領域は、通常は命令領域の後にあり、多くの場合は ROM 内にあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-156">The constant area usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="293a5-157">初期化されたデータ領域と初期化されていないデータ領域には、グローバル変数と静的変数がすべて含まれています。</span><span class="sxs-lookup"><span data-stu-id="293a5-157">The initialized data and uninitialized data areas contain all of the global and static variables.</span></span> <span data-ttu-id="293a5-158">これらの領域は常に RAM 内に配置されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-158">These areas are always located in RAM.</span></span>

<span data-ttu-id="293a5-159">システム スタックは、通常、初期化されたデータ領域と初期化されていないデータ領域の直後に配置されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-159">The system stack is generally set up immediately following the initialized and uninitialized data areas.</span></span> <span data-ttu-id="293a5-160">システム スタックは、コンパイラによって初期化中に使用され、次に ThreadX SMP によって初期化中に使用され、その後 ISR 処理で使用されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-160">The system stack is used by the compiler during initialization, then by ThreadX SMP during initialization and, subsequently, in ISR processing.</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="293a5-161">動的メモリの使用量</span><span class="sxs-lookup"><span data-stu-id="293a5-161">Dynamic Memory Usage</span></span>
<span data-ttu-id="293a5-162">先に説明したように、動的メモリの使用量は、アプリケーションによって直接制御されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-162">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="293a5-163">スタック、キュー、メモリ プールに関連付けられている制御ブロックとメモリ領域は、ターゲットのメモリ領域内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-163">Control blocks and memory areas associated with stacks, queues, and memory pools can be placed anywhere in the target’s memory space.</span></span> <span data-ttu-id="293a5-164">これにより、さまざまな種類の物理メモリを簡単に利用できるようになるため、これは重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-164">This is an important feature because it facilitates easy utilization of different types of physical memory.</span></span>

<span data-ttu-id="293a5-165">たとえば、ターゲットのハードウェア環境に、高速なメモリと低速なメモリの両方が存在するとします。</span><span class="sxs-lookup"><span data-stu-id="293a5-165">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="293a5-166">優先度の高いスレッドのためにアプリケーションで追加のパフォーマンスを必要とする場合は、その制御ブロック (TX_THREAD) とスタックを高速メモリ領域に配置できます。これにより、パフォーマンスが大幅に向上する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-166">If the application needs extra performance for a high-priority thread, its control block (TX_THREAD) and stack can be placed in the fast memory area, which may greatly enhance its performance.</span></span>

## <a name="initialization"></a><span data-ttu-id="293a5-167">初期化</span><span class="sxs-lookup"><span data-stu-id="293a5-167">Initialization</span></span> 
<span data-ttu-id="293a5-168">初期化プロセスを理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-168">Understanding the initialization process is important.</span></span> <span data-ttu-id="293a5-169">初期のハードウェア環境がここで設定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-169">The initial hardware environment is set up here.</span></span> <span data-ttu-id="293a5-170">さらに、ここでアプリケーションに初期のパーソナリティが付与されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-170">In addition, this is where the application is given its initial personality.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-171">ThreadX SMP では、可能な限り、完全な開発ツールの初期化プロセスの利用を試みます。</span><span class="sxs-lookup"><span data-stu-id="293a5-171">ThreadX SMP attempts to utilize (whenever possible) the complete development tool’s initialization process.</span></span> <span data-ttu-id="293a5-172">これにより、将来的に、開発ツールの新しいバージョンへのアップグレードが容易になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-172">This makes it easier to upgrade to new versions of the development tools in the future.</span></span>

### <a name="system-reset-vector"></a><span data-ttu-id="293a5-173">システム リセット ベクター</span><span class="sxs-lookup"><span data-stu-id="293a5-173">System Reset Vector</span></span> 
<span data-ttu-id="293a5-174">すべてのマイクロプロセッサにリセット ロジックがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-174">All microprocessors have reset logic.</span></span> <span data-ttu-id="293a5-175">リセット (ハードウェアまたはソフトウェア) が発生すると、アプリケーションのエントリ ポイントのアドレスが特定のメモリ位置から取得されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-175">When a reset occurs (either hardware or software), the address of the application’s entry point is retrieved from a specific memory location.</span></span> <span data-ttu-id="293a5-176">エントリ ポイントが取得されると、プロセッサはその位置に制御を移します。</span><span class="sxs-lookup"><span data-stu-id="293a5-176">After the entry point is retrieved, the processor transfers control to that location.</span></span> 

<span data-ttu-id="293a5-177">アプリケーションのエントリ ポイントは、多くの場合、ネイティブ アセンブリ言語で記述されており、通常は開発ツールによって (少なくともテンプレート形式で) 提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-177">The application entry point is quite often written in the native assembly language and is usually supplied by the development tools (at least in template form).</span></span> <span data-ttu-id="293a5-178">場合によっては、特別なバージョンのエントリ プログラムが ThreadX SMP によって提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-178">In some cases, a special version of the entry program is supplied with ThreadX SMP.</span></span> 

### <a name="development-tool-initialization"></a><span data-ttu-id="293a5-179">開発ツールの初期化</span><span class="sxs-lookup"><span data-stu-id="293a5-179">Development Tool Initialization</span></span>
<span data-ttu-id="293a5-180">低レベルの初期化が完了すると、開発ツールの高レベルの初期化に制御が移ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-180">After the low-level initialization is complete, control transfers to the development tool’s high-level initialization.</span></span> <span data-ttu-id="293a5-181">通常はここで、初期化されたグローバルおよび静的 C 変数の設定が行われます。</span><span class="sxs-lookup"><span data-stu-id="293a5-181">This is usually the place where initialized global and static C variables are set up.</span></span> <span data-ttu-id="293a5-182">それらの初期値は定数領域から取得されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="293a5-182">Remember their initial values are retrieved from the constant area.</span></span> <span data-ttu-id="293a5-183">厳密な初期化処理は開発ツールに固有です。</span><span class="sxs-lookup"><span data-stu-id="293a5-183">Exact initialization processing is development tool specific.</span></span>

### <a name="main-function"></a><span data-ttu-id="293a5-184">main 関数</span><span class="sxs-lookup"><span data-stu-id="293a5-184">main Function</span></span> 
<span data-ttu-id="293a5-185">開発ツールの初期化が完了すると、ユーザー指定の *main* 関数に制御が移ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-185">When the development tool initialization is complete, control transfers to the user-supplied *main* function.</span></span> <span data-ttu-id="293a5-186">この時点で、次に行われる処理はアプリケーションによって制御されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-186">At this point, the application controls what happens next.</span></span> <span data-ttu-id="293a5-187">ほとんどのアプリケーションでは、main 関数は単に *tx_kernel_enter* を呼び出します。これは ThreadX SMP へのエントリです。</span><span class="sxs-lookup"><span data-stu-id="293a5-187">For most applications, the main function simply calls *tx_kernel_enter*, which is the entry into ThreadX SMP.</span></span> <span data-ttu-id="293a5-188">ただし、ThreadX SMP に入る前に、アプリケーションで事前処理 (通常はハードウェアの初期化のため) を実行できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-188">However, applications can perform preliminary processing (usually for hardware initialization) prior to entering ThreadX SMP.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-189">tx_kernel_enter の呼び出しは戻らないため、その後に処理を配置しないでください。</span><span class="sxs-lookup"><span data-stu-id="293a5-189">The call to tx_kernel_enter does not return, so do not place any processing after it!</span></span>

### <a name="tx_kernel_enter"></a><span data-ttu-id="293a5-190">tx_kernel_enter</span><span class="sxs-lookup"><span data-stu-id="293a5-190">tx_kernel_enter</span></span> 
<span data-ttu-id="293a5-191">このエントリ関数は、さまざまな内部 ThreadX SMP データ構造の初期化を調整し、アプリケーションの定義関数 *tx_application_define* を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="293a5-191">The entry function coordinates initialization of various internal ThreadX SMP data structures and then calls the application’s definition function *tx_application_define*.</span></span>

<span data-ttu-id="293a5-192">*tx_application_define* が戻ると、スレッド スケジューリング ループに制御が移ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-192">When *tx_application_define* returns, control is transferred to the thread scheduling loop.</span></span> <span data-ttu-id="293a5-193">これは初期化が終了したことを示します。</span><span class="sxs-lookup"><span data-stu-id="293a5-193">This marks the end of initialization!</span></span>

### <a name="application-definition-function"></a><span data-ttu-id="293a5-194">アプリケーション定義関数</span><span class="sxs-lookup"><span data-stu-id="293a5-194">Application Definition Function</span></span>
<span data-ttu-id="293a5-195">*tx_application_define* 関数では、初期のアプリケーション スレッド、キュー、セマフォ、ミューテックス、イベント フラグ、メモリ プール、タイマーがすべて定義されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-195">The *tx_application_define* function defines all of the initial application threads, queues, semaphores, mutexes, event flags, memory pools, and timers.</span></span> <span data-ttu-id="293a5-196">また、アプリケーションの通常の動作中に、スレッドからシステム リソースの作成と削除を行うこともできます。</span><span class="sxs-lookup"><span data-stu-id="293a5-196">It is also possible to create and delete system resources from threads during the normal operation of the application.</span></span> <span data-ttu-id="293a5-197">ただし、初期のアプリケーション リソースはすべてここで定義されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-197">However, all initial application resources are defined here.</span></span>

<span data-ttu-id="293a5-198">*tx_application_define* 関数には 1 つの入力パラメーターがあり、これについては触れておく価値があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-198">The *tx_application_define* function has a single input parameter and it is certainly worth mentioning.</span></span> <span data-ttu-id="293a5-199">"*最初に使用可能な*" RAM アドレスが、この関数の唯一の入力パラメーターです。</span><span class="sxs-lookup"><span data-stu-id="293a5-199">The *first-available* RAM address is the sole input parameter to this function.</span></span> <span data-ttu-id="293a5-200">これは通常、スレッドのスタック、キュー、メモリ プールの初期実行時メモリ割り当ての開始点として使用されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-200">It is typically used as a starting point for initial run-time memory allocations of thread stacks, queues, and memory pools.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-201">初期化が完了した後は、実行中のスレッドだけがシステム リソース (他のスレッドも含まれます) の作成と削除を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="293a5-201">After initialization is complete, only an executing thread can create and delete system resources—including other threads.</span></span> <span data-ttu-id="293a5-202">そのため、初期化中に、少なくとも 1 つのスレッドが作成される必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-202">Therefore, at least one thread must be created during initialization.</span></span>

### <a name="interrupts"></a><span data-ttu-id="293a5-203">割り込み</span><span class="sxs-lookup"><span data-stu-id="293a5-203">Interrupts</span></span> 
<span data-ttu-id="293a5-204">初期化プロセス全体を通して、割り込みは無効のままになります。</span><span class="sxs-lookup"><span data-stu-id="293a5-204">Interrupts are left disabled during the entire initialization process.</span></span> <span data-ttu-id="293a5-205">アプリケーションで何らかの方法によって割り込みを有効にすると、予期しない動作が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-205">If the application somehow enables interrupts, unpredictable behavior may occur.</span></span> <span data-ttu-id="293a5-206">52 ページの図 3 は、システム リセットからアプリケーション固有の初期化までの初期化プロセス全体を示しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-206">Figure 3 on page 52 shows the entire initialization process, from system reset through application-specific initialization.</span></span>

## <a name="thread-execution"></a><span data-ttu-id="293a5-207">スレッド実行</span><span class="sxs-lookup"><span data-stu-id="293a5-207">Thread Execution</span></span>

<span data-ttu-id="293a5-208">アプリケーション スレッドのスケジューリングと実行は、ThreadX SMP の最も重要なアクティビティです。</span><span class="sxs-lookup"><span data-stu-id="293a5-208">Scheduling and executing application threads is the most important activity of ThreadX SMP.</span></span> <span data-ttu-id="293a5-209">スレッドは通常、特定の目的を持つ半独立のプログラム セグメントとして定義されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-209">A thread is typically defined as a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="293a5-210">すべてのスレッドの処理を組み合わせることによって、アプリケーションができあがります。</span><span class="sxs-lookup"><span data-stu-id="293a5-210">The combined processing of all threads makes an application.</span></span>

<span data-ttu-id="293a5-211">スレッドは、初期化中またはスレッド実行中に *tx_thread_create* の呼び出しによって動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-211">Threads are created dynamically by calling *tx_thread_create* during initialization or during thread execution.</span></span> <span data-ttu-id="293a5-212">スレッドは、"*準備完了*" または "*中断*" 状態のいずれかで作成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-212">Threads are created in either a *ready* or *suspended* state.</span></span>

![SMP 初期化プロセス](media/image6.png)

<span data-ttu-id="293a5-214">**図 3. SMP 初期化プロセス**</span><span class="sxs-lookup"><span data-stu-id="293a5-214">**FIGURE 3. SMP Initialization Process**</span></span>

### <a name="thread-execution-states"></a><span data-ttu-id="293a5-215">スレッド実行状態</span><span class="sxs-lookup"><span data-stu-id="293a5-215">Thread Execution States</span></span>  
<span data-ttu-id="293a5-216">スレッドのさまざまな処理状態を理解することは、マルチスレッド環境全体を理解するための重要な要素です。</span><span class="sxs-lookup"><span data-stu-id="293a5-216">Understanding the different processing states of threads is a key ingredient to understanding the entire multithreaded environment.</span></span> <span data-ttu-id="293a5-217">ThreadX SMP では、スレッドの状態には "*準備完了*"、"*中断*"、"*実行中*"、"*終了*"、"*完了*" の 5 つがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-217">In ThreadX SMP, there are five distinct thread states: *ready*, *suspended*, *executing*, *terminated*, and *completed*.</span></span> <span data-ttu-id="293a5-218">図 4 は、ThreadX SMP のスレッド状態遷移図を示しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-218">Figure 4 shows the thread state transition diagram for ThreadX SMP.</span></span>

![スレッド実行状態](media/image7.png)

<span data-ttu-id="293a5-220">**図 4. スレッドの状態遷移**</span><span class="sxs-lookup"><span data-stu-id="293a5-220">**FIGURE 4. Thread State Transition**</span></span>

<span data-ttu-id="293a5-221">スレッドは、実行準備が整ったときに "*準備完了*" 状態になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-221">A thread is in a *ready* state when it is ready for execution.</span></span> <span data-ttu-id="293a5-222">準備の完了したスレッドは、準備完了状態にある最も優先度の高いスレッドになるまで実行されません。</span><span class="sxs-lookup"><span data-stu-id="293a5-222">A ready thread is not executed until it is the highest priority thread in ready state.</span></span> <span data-ttu-id="293a5-223">これが発生すると、ThreadX SMP でスレッドが実行され、その状態が "*実行中*" に変更されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-223">When this happens, ThreadX SMP executes the thread, which then changes its state to *executing*.</span></span>

<span data-ttu-id="293a5-224">より優先度の高いスレッドの準備が整うと、実行中のスレッドは "*準備完了*" 状態に戻ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-224">If a higher-priority thread becomes ready, the executing thread reverts back to a *ready* state.</span></span> <span data-ttu-id="293a5-225">その後、新しく準備の整った優先度の高いスレッドが実行され、その論理状態が "*実行中*" に変わります。</span><span class="sxs-lookup"><span data-stu-id="293a5-225">The newly ready high-priority thread is then executed, which changes its logical state to *executing*.</span></span> <span data-ttu-id="293a5-226">スレッドのプリエンプションが発生するたびに、"*準備完了*" 状態と "*実行中*" 状態の間の遷移が発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-226">This transition between *ready* and *executing* states occurs every time thread preemption occurs.</span></span>

<span data-ttu-id="293a5-227">どの時点でも、1 つのスレッドのみが "*実行中*" 状態になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-227">At any given moment, only one thread is in an *executing* state.</span></span> <span data-ttu-id="293a5-228">これは、"*実行中*" 状態のスレッドが、基になるプロセッサを制御できるためです。</span><span class="sxs-lookup"><span data-stu-id="293a5-228">This is because a thread in the *executing* state has control of the underlying processor.</span></span>

<span data-ttu-id="293a5-229">"*中断*" 状態のスレッドは、実行の対象になりません。</span><span class="sxs-lookup"><span data-stu-id="293a5-229">Threads in a *suspended* state are not eligible for execution.</span></span> <span data-ttu-id="293a5-230">"*中断*" 状態になる理由として、時間、キュー メッセージ、セマフォ、ミューテックス、イベント フラグ、メモリによる中断や、基本的なスレッドの中断があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-230">Reasons for being in a *suspended* state include suspension for time, queue messages, semaphores, mutexes, event flags, memory, and basic thread suspension.</span></span> <span data-ttu-id="293a5-231">中断の原因が解消されると、スレッドは "*準備完了*" 状態に戻ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-231">After the cause for suspension is removed, the thread is placed back in a *ready* state.</span></span>

<span data-ttu-id="293a5-232">"*完了*" 状態のスレッドは、処理を完了し、そのエントリ関数から戻ったスレッドです。</span><span class="sxs-lookup"><span data-stu-id="293a5-232">A thread in a *completed* state is a thread that has completed its processing and returned from its entry function.</span></span> <span data-ttu-id="293a5-233">エントリ関数は、スレッドの作成時に指定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-233">The entry function is specified during thread creation.</span></span> <span data-ttu-id="293a5-234">"*完了*" 状態のスレッドを再度実行することはできません。</span><span class="sxs-lookup"><span data-stu-id="293a5-234">A thread in a *completed* state cannot execute again.</span></span>

<span data-ttu-id="293a5-235">スレッドが "*終了*" 状態になるのは、別のスレッドまたはスレッド自体が *tx_thread_terminate* サービスを呼び出したためです。</span><span class="sxs-lookup"><span data-stu-id="293a5-235">A thread is in a *terminated* state because another thread or the thread itself called the *tx_thread_terminate* service.</span></span> <span data-ttu-id="293a5-236">"*終了*" 状態のスレッドを再度実行することはできません。</span><span class="sxs-lookup"><span data-stu-id="293a5-236">A thread in a *terminated* state cannot execute again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-237">完了または終了したスレッドを再度開始する必要がある場合、アプリケーションでは最初にスレッドを削除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-237">If re-starting a completed or terminated thread is desired, the application must first delete the thread.</span></span> <span data-ttu-id="293a5-238">その後、再作成して再度開始することができます。</span><span class="sxs-lookup"><span data-stu-id="293a5-238">It can then be re-created and re-started.</span></span>

### <a name="thread-entryexit-notification"></a><span data-ttu-id="293a5-239">スレッド開始/終了通知</span><span class="sxs-lookup"><span data-stu-id="293a5-239">Thread Entry/Exit Notification</span></span>  
<span data-ttu-id="293a5-240">アプリケーションによっては、特定のスレッドが最初に開始したとき、完了したとき、または終了したときに通知を受け取ると役立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-240">Some applications may find it advantageous to be notified when a specific thread is entered for the first time, when it completes, or is terminated.</span></span> <span data-ttu-id="293a5-241">ThreadX SMP では、*tx_thread_entry_exit_notify* サービスによってこの機能が提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-241">ThreadX SMP provides this ability through the *tx_thread_entry_exit_notify* service.</span></span> <span data-ttu-id="293a5-242">このサービスによって、特定のスレッドに対するアプリケーション通知関数が登録されます。この関数は、スレッドが実行を開始するたび、完了するたび、または終了されるたびに ThreadX SMP によって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-242">This service registers an application notification function for a specific thread, which is called by ThreadX SMP whenever the thread starts running, completes, or is terminated.</span></span> <span data-ttu-id="293a5-243">アプリケーション通知関数では、呼び出された後、アプリケーション固有の処理を実行できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-243">After being invoked, the application notification function can perform the applicationspecific processing.</span></span> <span data-ttu-id="293a5-244">これには通常、ThreadX SMP 同期プリミティブを介して別のアプリケーション スレッドにイベントを通知することが含まれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-244">This typically involves informing another application thread of the event via a ThreadX SMP synchronization primitive.</span></span>

### <a name="thread-priorities"></a><span data-ttu-id="293a5-245">スレッドの優先度</span><span class="sxs-lookup"><span data-stu-id="293a5-245">Thread Priorities</span></span>  
<span data-ttu-id="293a5-246">前述のとおり、スレッドは、特定の目的を持つ半独立のプログラム セグメントです。</span><span class="sxs-lookup"><span data-stu-id="293a5-246">As mentioned before, a thread is a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="293a5-247">ただし、すべてのスレッドが等しく作成されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-247">However, all threads are not created equal!</span></span> <span data-ttu-id="293a5-248">一部のスレッドが持つ特定の目的は、他のものよりもはるかに重要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-248">The dedicated purpose of some threads is much more important than others.</span></span> <span data-ttu-id="293a5-249">このようにスレッドの重要度が不均一であることは、埋め込みリアルタイム アプリケーションの特徴です。</span><span class="sxs-lookup"><span data-stu-id="293a5-249">This heterogeneous type of thread importance is a hallmark of embedded realtime applications.</span></span>

<span data-ttu-id="293a5-250">ThreadX SMP では、スレッドが作成されるときに、その "*優先度*" を表す数値を割り当てることによって、スレッドの重要度を決定します。</span><span class="sxs-lookup"><span data-stu-id="293a5-250">ThreadX SMP determines a thread’s importance when the thread is created by assigning a numerical value representing its *priority*.</span></span> <span data-ttu-id="293a5-251">ThreadX SMP の優先度の最大数は、32 ～ 1,024 の範囲で 32 刻みで構成できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-251">The maximum number of ThreadX SMP priorities is configurable from 32 through 1024 in increments of 32.</span></span> <span data-ttu-id="293a5-252">優先度の実際の最大数は、ThreadX SMP ライブラリのコンパイル中に *TX_MAX_PRIORITIES* 定数によって決定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-252">The actual maximum number of priorities is determined by the *TX_MAX_PRIORITIES* constant during compilation of the ThreadX SMP library.</span></span> <span data-ttu-id="293a5-253">優先度の数値を大きくしても、処理のオーバーヘッドが大幅に増加することはありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-253">Having a larger number of priorities does not significantly increase processing overhead.</span></span> <span data-ttu-id="293a5-254">ただし、32 個の優先度レベルのグループごとに、その管理のために 128 バイトの RAM が追加で必要になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-254">However, for each group of 32 priority levels an additional 128 bytes of RAM is required to manage them.</span></span> <span data-ttu-id="293a5-255">たとえば、32 個の優先度レベルでは 128 バイトの RAM、64 個の優先度レベルでは 256 バイトの RAM、96 個の優先度レベルでは 384 バイトの RAM が必要になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-255">For example, 32 priority levels require 128 bytes of RAM, 64 priority levels require 256 bytes of RAM, and 96 priority levels requires 384 bytes of RAM.</span></span>

<span data-ttu-id="293a5-256">既定では、ThreadX SMP には優先度 0 から優先度 31 まで、32 個の優先度レベルがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-256">By default, ThreadX SMP has 32 priority levels, ranging from priority 0 through priority 31.</span></span>

<span data-ttu-id="293a5-257">数値が小さいほど優先度が高くなります。</span><span class="sxs-lookup"><span data-stu-id="293a5-257">Numerically smaller values imply higher priority.</span></span> <span data-ttu-id="293a5-258">したがって、優先度 0 は最も高い優先度を表し、優先度 (*TX_MAX_PRIORITIES*-1) は最も低い優先度を表します。</span><span class="sxs-lookup"><span data-stu-id="293a5-258">Hence, priority 0 represents the highest priority, while priority (*TX_MAX_PRIORITIES*-1) represents the lowest priority.</span></span>

<span data-ttu-id="293a5-259">協調スケジューリングやタイム スライシングを利用して、複数のスレッドに同じ優先度を指定できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-259">Multiple threads can have the same priority relying on cooperative scheduling or time-slicing.</span></span> <span data-ttu-id="293a5-260">また、スレッドの優先度は、実行時に変更できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-260">In addition, thread priorities can be changed during run-time.</span></span>

### <a name="thread-scheduling"></a><span data-ttu-id="293a5-261">スレッドのスケジューリング</span><span class="sxs-lookup"><span data-stu-id="293a5-261">Thread Scheduling</span></span> 
<span data-ttu-id="293a5-262">ThreadX SMP では、優先度に基づいてスレッドをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="293a5-262">ThreadX SMP schedules threads based on their priority.</span></span> <span data-ttu-id="293a5-263">最も優先度の高い準備完了スレッドが最初に実行されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-263">The ready thread with the highest priority is executed first.</span></span> <span data-ttu-id="293a5-264">同じ優先度の準備完了スレッドが複数ある場合は、"*先入れ先出し*" (FIFO) 方式で実行されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-264">If multiple threads of the same priority are ready, they are executed in a *first-in-first-out* (FIFO) manner.</span></span>

<span data-ttu-id="293a5-265">既定では、ThreadX SMP は、最も優先度の高い "n" 個のスレッドを、"n" 個の使用可能なプロセッサでスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="293a5-265">By default, ThreadX SMP schedules the “n” highest priority threads on the “n” available processors.</span></span> <span data-ttu-id="293a5-266">同じ優先度の準備完了スレッドでしか並行処理が必要ない場合は、**TX_THREAD_SMP_EQUAL_PRIORITY** を定義して ThreadX SMP ライブラリをビルドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-266">If concurrent processing is only required on ready threads of the same priority, the ThreadX SMP library must be built with **TX_THREAD_SMP_EQUAL_PRIORITY** defined.</span></span>

> [!NOTE]
> <span data-ttu-id="293a5-267">**TX_THREAD_SMP_ONLY_CORE_0_DEFAULT** を定義して ThreadX SMP ライブラリをビルドすることにより、既定ではコア 0 でのみ実行されるよう、すべてのスレッドを初期設定できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-267">That all threads can be initially defaulted to only run on core 0, by building the ThreadX SMP library with **TX_THREAD_SMP_ONLY_CORE_0_DEFAULT** defined.</span></span>

### <a name="round-robin-scheduling"></a><span data-ttu-id="293a5-268">ラウンドロビン スケジューリング</span><span class="sxs-lookup"><span data-stu-id="293a5-268">Round-robin Scheduling</span></span>  
<span data-ttu-id="293a5-269">ThreadX SMP では、同じ優先度を持つ複数のスレッドの "*ラウンドロビン*" スケジューリングがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="293a5-269">ThreadX SMP supports *round-robin* scheduling of multiple threads having the same priority.</span></span> <span data-ttu-id="293a5-270">これは、*tx_thread_relinquish* の協調呼び出しを通じて実現されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-270">This is accomplished through cooperative calls to *tx_thread_relinquish*.</span></span> <span data-ttu-id="293a5-271">このサービスにより、*tx_thread_relinquish* の呼び出し元が再度実行される前に、同じ優先度の他の準備完了スレッドすべてに実行の機会が与えられます。</span><span class="sxs-lookup"><span data-stu-id="293a5-271">This service gives all other ready threads of the same priority a chance to execute before the *tx_thread_relinquish* caller executes again.</span></span>

### <a name="time-slicing"></a><span data-ttu-id="293a5-272">タイム スライシング</span><span class="sxs-lookup"><span data-stu-id="293a5-272">Time-Slicing</span></span> 
<span data-ttu-id="293a5-273">"*タイム スライシング*" は、ラウンドロビン スケジューリングのもう 1 つの形式です。</span><span class="sxs-lookup"><span data-stu-id="293a5-273">*Time-slicing* is another form of round-robin scheduling.</span></span> <span data-ttu-id="293a5-274">タイム スライスは、スレッドがプロセッサを明け渡さずに実行できるタイマー ティック (タイマー割り込み) の最大数を指定します。</span><span class="sxs-lookup"><span data-stu-id="293a5-274">A time-slice specifies the maximum number of timer ticks (timer interrupts) that a thread can execute without giving up the processor.</span></span> <span data-ttu-id="293a5-275">ThreadX SMP では、タイム スライシングはスレッド単位で使用できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-275">In ThreadX SMP, time-slicing is available on a perthread basis.</span></span> <span data-ttu-id="293a5-276">スレッドのタイム スライスは作成時に割り当てられ、実行時に変更できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-276">The thread’s time-slice is assigned during creation and can be modified during run-time.</span></span> <span data-ttu-id="293a5-277">タイム スライスの有効期限が切れると、タイム スライスされたスレッドが再度実行される前に、同じ優先度レベルの他の準備完了スレッドすべてに実行の機会が与えられます。</span><span class="sxs-lookup"><span data-stu-id="293a5-277">When a time-slice expires, all other ready threads of the same priority level are given a chance to execute before the time-sliced thread executes again.</span></span>

<span data-ttu-id="293a5-278">スレッドが中断した後、放棄した後、プリエンプションの原因となる ThreadX SMP サービス呼び出しを行った後、またはそれ自体がタイム スライスされた後は、スレッドに新しいスレッド タイム スライスが与えられます。</span><span class="sxs-lookup"><span data-stu-id="293a5-278">A fresh thread time-slice is given to a thread after it suspends, relinquishes, makes a ThreadX SMP service call that causes preemption, or is itself timesliced.</span></span>

<span data-ttu-id="293a5-279">タイム スライスされたスレッドがプリエンプトされた場合は、そのタイム スライスの残りの部分が、同じ優先度の他の準備完了スレッドよりも前に再開されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-279">When a time-sliced thread is preempted, it will resume before other ready threads of equal priority for the remainder of its time-slice.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-280">タイム スライシングを使用すると、わずかなシステム オーバーヘッドが発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-280">Using time-slicing results in a slight amount of system overhead.</span></span> <span data-ttu-id="293a5-281">タイム スライシングは、複数のスレッドが同じ優先度を共有している場合にしか役立たないため、一意の優先度を持つスレッドにはタイム スライスを割り当てないでください。</span><span class="sxs-lookup"><span data-stu-id="293a5-281">Because time-slicing is only useful in cases in which multiple threads share the same priority, threads having a unique priority should not be assigned a time-slice.</span></span>

### <a name="preemption"></a><span data-ttu-id="293a5-282">優先</span><span class="sxs-lookup"><span data-stu-id="293a5-282">Preemption</span></span> 
<span data-ttu-id="293a5-283">プリエンプションは、より優先度の高いスレッドを優先して、実行中のスレッドに一時的に割り込むプロセスです。</span><span class="sxs-lookup"><span data-stu-id="293a5-283">Preemption is the process of temporarily interrupting an executing thread in favor of a higher-priority thread.</span></span> <span data-ttu-id="293a5-284">このプロセスは、実行中のスレッドからは認識できません。</span><span class="sxs-lookup"><span data-stu-id="293a5-284">This process is invisible to the executing thread.</span></span> <span data-ttu-id="293a5-285">優先度の高いスレッドが終了すると、プリエンプションが発生した正確な場所に制御が戻ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-285">When the higher-priority thread is finished, control is transferred back to the exact place where the preemption took place.</span></span>

<span data-ttu-id="293a5-286">重要なアプリケーション イベントへの迅速な対応が容易になるため、これはリアルタイム システムでは非常に重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-286">This is a very important feature in real-time systems because it facilitates fast response to important application events.</span></span> <span data-ttu-id="293a5-287">非常に重要な機能ですが、プリエンプションは、飢餓状態、過剰なオーバーヘッド、優先度の逆転など、さまざまな問題の原因になることもあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-287">Although a very important feature, preemption can also be a source of a variety of problems, including starvation, excessive overhead, and priority inversion.</span></span>

### <a name="preemption-threshold"></a><span data-ttu-id="293a5-288">プリエンプションしきい値™</span><span class="sxs-lookup"><span data-stu-id="293a5-288">Preemption-Threshold™</span></span> 
<span data-ttu-id="293a5-289">プリエンプションに固有の問題の一部を緩和するために、ThreadX SMP には、"*プリエンプションしきい値*" と呼ばれるユニークで高度な機能が用意されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-289">To ease some of the inherent problems of preemption, ThreadX SMP provides a unique and advanced feature called *preemption-threshold*.</span></span>

<span data-ttu-id="293a5-290">プリエンプションしきい値を使用すると、スレッドでプリエンプションを無効にするための優先度の "*上限*" を指定できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-290">A preemption-threshold allows a thread to specify a priority *ceiling* for disabling preemption.</span></span> <span data-ttu-id="293a5-291">上限より高い優先度を持つスレッドは引き続きプリエンプトできますが、上限より低いスレッドはプリエンプトできません。</span><span class="sxs-lookup"><span data-stu-id="293a5-291">Threads that have higher priorities than the ceiling are still allowed to preempt, while those less than the ceiling are not allowed to preempt.</span></span>

<span data-ttu-id="293a5-292">たとえば、優先度 20 のスレッドが、15 ～ 20 の優先度を持つスレッドのグループとのみやり取りするとします。</span><span class="sxs-lookup"><span data-stu-id="293a5-292">For example, suppose a thread of priority 20 only interacts with a group of threads that have priorities between 15 and 20.</span></span> <span data-ttu-id="293a5-293">この優先度 20 のスレッドでは、そのクリティカル セクションの処理中、プリエンプションしきい値を 15 に設定することで、やり取りするすべてのスレッドからのプリエンプションを防止できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-293">During its critical sections, the thread of priority 20 can set its preemption-threshold to 15, thereby preventing preemption from all of the threads that it interacts with.</span></span> <span data-ttu-id="293a5-294">これにより、非常に重要なスレッド (優先度 0 から 14 まで) では、クリティカル セクションの処理中でもこのスレッドをプリエンプトでき、応答性が大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="293a5-294">This still permits really important threads (priorities between 0 and 14) to preempt this thread during its critical section processing, which results in much more responsive processing.</span></span>

<span data-ttu-id="293a5-295">もちろん、スレッドでプリエンプションしきい値を 0 に設定して、すべてのプリエンプションを無効にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="293a5-295">Of course, it is still possible for a thread to disable all preemption by setting its preemption-threshold to 0.</span></span> <span data-ttu-id="293a5-296">また、プリエンプションしきい値は実行時に変更できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-296">In addition, preemption-threshold can be changed during run-time.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-297">プリエンプションしきい値を使用すると、指定されたスレッドのタイム スライシングが無効になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-297">Using preemption-threshold disables time-slicing for the specified thread.</span></span>

### <a name="priority-inheritance"></a><span data-ttu-id="293a5-298">優先度の継承</span><span class="sxs-lookup"><span data-stu-id="293a5-298">Priority Inheritance</span></span> 
<span data-ttu-id="293a5-299">ThreadX SMP では、この章の後半で説明するミューテックス サービス内で、オプションの優先度の継承もサポートしています。</span><span class="sxs-lookup"><span data-stu-id="293a5-299">ThreadX SMP also supports optional priority inheritance within its mutex services described later in this chapter.</span></span> <span data-ttu-id="293a5-300">優先度の継承を使用すると、優先度の低いスレッドによって所有されているミューテックスを待機している優先度の高いスレッドがあるとき、その優先度を優先度の低いスレッドで一時的に受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="293a5-300">Priority inheritance allows a lower priority thread to temporarily assume the priority of a high priority thread that is waiting for a mutex owned by the lower priority thread.</span></span> <span data-ttu-id="293a5-301">この機能により、アプリケーションでは、中間スレッド優先度のプリエンプションを排除することで、不確定な優先度の逆転を回避できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-301">This capability helps the application to avoid nondeterministic priority inversion by eliminating preemption of intermediate thread priorities.</span></span> <span data-ttu-id="293a5-302">もちろん、"*プリエンプションしきい値*" を使用して同様の結果を得ることもできます。</span><span class="sxs-lookup"><span data-stu-id="293a5-302">Of course, *preemption-threshold* may be used to achieve a similar result.</span></span>

### <a name="thread-creation"></a><span data-ttu-id="293a5-303">スレッドの作成</span><span class="sxs-lookup"><span data-stu-id="293a5-303">Thread Creation</span></span> 
<span data-ttu-id="293a5-304">アプリケーション スレッドは、初期化中、または他のアプリケーション スレッドの実行中に作成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-304">Application threads are created during initialization or during the execution of other application threads.</span></span> <span data-ttu-id="293a5-305">アプリケーションで作成できるスレッドの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-305">There is no limit on the number of threads that can be created by an application.</span></span>

### <a name="thread-control-block-tx_thread"></a><span data-ttu-id="293a5-306">スレッド制御ブロック TX_THREAD</span><span class="sxs-lookup"><span data-stu-id="293a5-306">Thread Control Block TX_THREAD</span></span> 
<span data-ttu-id="293a5-307">各スレッドの特性は、その制御ブロックに含まれています。</span><span class="sxs-lookup"><span data-stu-id="293a5-307">The characteristics of each thread are contained in its control block.</span></span> <span data-ttu-id="293a5-308">この構造体は ***tx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-308">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="293a5-309">スレッドの制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="293a5-309">A thread’s control block can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

<span data-ttu-id="293a5-310">動的に割り当てられたすべてのメモリと同様に、他の領域に制御ブロックを配置するにはもう少し注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-310">Locating the control block in other areas requires a bit more care, just like all dynamically allocated memory.</span></span> <span data-ttu-id="293a5-311">制御ブロックが C 関数内に割り当てられている場合、それに関連付けられているメモリは、呼び出し元スレッドのスタックの一部になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-311">If a control block is allocated within a C function, the memory associated with it is part of the calling thread’s stack.</span></span> <span data-ttu-id="293a5-312">一般に、制御ブロックにローカル ストレージを使用することは避けてください。これは、関数から制御が返された後、そのローカル変数スタック領域が、別のスレッドで制御ブロックのためにそれを使用しているかどうかに関係なくすべて解放されるためです。</span><span class="sxs-lookup"><span data-stu-id="293a5-312">In general, avoid using local storage for control blocks because after the function returns, all of its local variable stack space is released—regardless of whether another thread is using it for a control block!</span></span>

<span data-ttu-id="293a5-313">ほとんどの場合、アプリケーションでスレッドの制御ブロックの内容は認識されていません。</span><span class="sxs-lookup"><span data-stu-id="293a5-313">In most cases, the application is oblivious to the contents of the thread’s control block.</span></span> <span data-ttu-id="293a5-314">ただし、状況により、特にデバッグ中には、特定のメンバーを確認することが役に立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-314">However, there are some situations, especially during debug, in which looking at certain members is useful.</span></span> <span data-ttu-id="293a5-315">有用な制御ブロック メンバーの一部を次に示します。</span><span class="sxs-lookup"><span data-stu-id="293a5-315">The following are some of the more useful control block members:</span></span>

- <span data-ttu-id="293a5-316">**tx_thread_run_count** には、スレッドがスケジュールされた回数のカウンターが格納されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-316">**tx_thread_run_count** contains a counter of the number of many times the thread has been scheduled.</span></span> <span data-ttu-id="293a5-317">カウンターが増加している場合は、スレッドがスケジュールされ、実行されていることを示しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-317">An increasing counter indicates the thread is being scheduled and executed.</span></span>

- <span data-ttu-id="293a5-318">**tx_thread_state** には、関連付けられているスレッドの状態が格納されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-318">**tx_thread_state** contains the state of the associated thread.</span></span> <span data-ttu-id="293a5-319">スレッドの取り得る状態を次に示します。</span><span class="sxs-lookup"><span data-stu-id="293a5-319">The following lists the possible thread states:</span></span>

    - <span data-ttu-id="293a5-320">TX_READY(0x00)</span><span class="sxs-lookup"><span data-stu-id="293a5-320">TX_READY(0x00)</span></span>
    - <span data-ttu-id="293a5-321">TX_COMPLETED(0x01)</span><span class="sxs-lookup"><span data-stu-id="293a5-321">TX_COMPLETED(0x01)</span></span>
    - <span data-ttu-id="293a5-322">TX_TERMINATED(0x02)</span><span class="sxs-lookup"><span data-stu-id="293a5-322">TX_TERMINATED(0x02)</span></span>
    - <span data-ttu-id="293a5-323">TX_SUSPENDED(0x03)</span><span class="sxs-lookup"><span data-stu-id="293a5-323">TX_SUSPENDED(0x03)</span></span>
    - <span data-ttu-id="293a5-324">TX_SLEEP(0x04)</span><span class="sxs-lookup"><span data-stu-id="293a5-324">TX_SLEEP(0x04)</span></span>
    - <span data-ttu-id="293a5-325">TX_QUEUE_SUSP(0x05)</span><span class="sxs-lookup"><span data-stu-id="293a5-325">TX_QUEUE_SUSP(0x05)</span></span>
    - <span data-ttu-id="293a5-326">TX_SEMAPHORE_SUSP(0x06)</span><span class="sxs-lookup"><span data-stu-id="293a5-326">TX_SEMAPHORE_SUSP(0x06)</span></span>
    - <span data-ttu-id="293a5-327">TX_EVENT_FLAG (0x07)</span><span class="sxs-lookup"><span data-stu-id="293a5-327">TX_EVENT_FLAG (0x07)</span></span>
    - <span data-ttu-id="293a5-328">TX_BLOCK_MEMORY(0x08)</span><span class="sxs-lookup"><span data-stu-id="293a5-328">TX_BLOCK_MEMORY(0x08)</span></span>
    - <span data-ttu-id="293a5-329">TX_BYTE_MEMORY (0x09)</span><span class="sxs-lookup"><span data-stu-id="293a5-329">TX_BYTE_MEMORY (0x09)</span></span>
    - <span data-ttu-id="293a5-330">TX_MUTEX_SUSP(0x0D)</span><span class="sxs-lookup"><span data-stu-id="293a5-330">TX_MUTEX_SUSP(0x0D)</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-331">もちろん、スレッドの制御ブロックには、スタック ポインター、タイム スライス値、優先度など、他にも多くの興味深いフィールドがあります。制御ブロック メンバーを確認することはお勧めしますが、変更は厳密に禁止されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-331">Of course there are many other interesting fields in the thread control block, including the stack pointer, time-slice value, priorities, etc. Users are welcome to review control block members, but modifications are strictly prohibited!</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-332">このセクションで前述した "実行中" 状態に相当するものはありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-332">There is no equate for the “executing” state mentioned earlier in this section.</span></span> <span data-ttu-id="293a5-333">どの時点でも、実行中のスレッドは 1 つだけなので、これは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-333">It is not necessary because there is only one executing thread at a given time.</span></span> <span data-ttu-id="293a5-334">実行中のスレッドの状態も ***TX_READY*** です。</span><span class="sxs-lookup"><span data-stu-id="293a5-334">The state of an executing thread is also ***TX_READY***.</span></span>

### <a name="currently-executing-thread"></a><span data-ttu-id="293a5-335">現在実行中のスレッド</span><span class="sxs-lookup"><span data-stu-id="293a5-335">Currently Executing Thread</span></span> 
<span data-ttu-id="293a5-336">前述のとおり、どの時点でも、実行中のスレッドは 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="293a5-336">As mentioned before, there is only one thread executing at any given time.</span></span> <span data-ttu-id="293a5-337">どのスレッドが要求を行っているかに応じて、実行中のスレッドを識別する方法はいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-337">There are several ways to identify the executing thread, depending on which thread is making the request.</span></span>

<span data-ttu-id="293a5-338">プログラム セグメントでは、***tx_thread_identify*** を呼び出すことによって、実行中のスレッドの制御ブロック アドレスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-338">A program segment can get the control block address of the executing thread by calling ***tx_thread_identify***.</span></span> <span data-ttu-id="293a5-339">これは、複数のスレッドから実行されるアプリケーション コードの共有部分で役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-339">This is useful in shared portions of application code that are executed from multiple threads.</span></span>

<span data-ttu-id="293a5-340">デバッグ セッションでは、ユーザーは内部 ThreadX SMP ポインター配列 ***_tx_thread_current_ptr[core]*** を調べることができます。</span><span class="sxs-lookup"><span data-stu-id="293a5-340">In debug sessions, users can examine the internal ThreadX SMP pointer array ***_tx_thread_current_ptr[core]***.</span></span> <span data-ttu-id="293a5-341">これには、現在実行中のスレッドの制御ブロック アドレスが格納されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-341">It contains the control block address of the currently executing thread.</span></span> <span data-ttu-id="293a5-342">このポインターが NULL の場合、実行中のアプリケーション スレッドはありません。つまり、スレッドが準備完了になるまで、ThreadX SMP はスケジューリング ループ内で待機しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-342">If this pointer is NULL, no application thread is executing; i.e., ThreadX SMP is waiting in its scheduling loop for a thread to become ready.</span></span>

### <a name="thread-stack-area"></a><span data-ttu-id="293a5-343">スレッド スタック領域</span><span class="sxs-lookup"><span data-stu-id="293a5-343">Thread Stack Area</span></span> 
<span data-ttu-id="293a5-344">各スレッドには、最後の実行とコンパイラでの使用のコンテキストを保存するために、それぞれ専用のスタックが必要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-344">Each thread must have its own stack for saving the context of its last execution and compiler use.</span></span> <span data-ttu-id="293a5-345">ほとんどの C コンパイラでは、関数呼び出しを行うためと、一時的にローカル変数を割り当てるために、スタックを使用します。</span><span class="sxs-lookup"><span data-stu-id="293a5-345">Most C compilers use the stack for making function calls and for temporarily allocating local variables.</span></span> <span data-ttu-id="293a5-346">61 ページの 図 5 は、一般的なスレッド スタックを示しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-346">Figure 5 on page 61 shows a typical thread’s stack.</span></span>

![スレッド スタック領域](media/image8.png)

<span data-ttu-id="293a5-348">**図 5. 一般的なスレッド スタック**</span><span class="sxs-lookup"><span data-stu-id="293a5-348">**FIGURE 5. Typical Thread Stack**</span></span>

<span data-ttu-id="293a5-349">スレッド スタックがメモリ内のどこに配置されるかは、アプリケーションしだいです。</span><span class="sxs-lookup"><span data-stu-id="293a5-349">Where a thread stack is located in memory is up to the application.</span></span> <span data-ttu-id="293a5-350">スタック領域は、スレッドの作成時に指定され、ターゲットのアドレス空間内の任意の場所に配置できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-350">The stack area is specified during thread creation and can be located anywhere in the target’s address space.</span></span> <span data-ttu-id="293a5-351">アプリケーションでスタックを高速 RAM に配置することによって、重要なスレッドのパフォーマンスを向上させることができるため、これは重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-351">This is an important feature because it allows applications to improve performance of important threads by placing their stack in high-speed RAM.</span></span>

<span data-ttu-id="293a5-352">スタックの大きさをどの程度にするべきかは、スレッドに関して最も多く寄せられる質問の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="293a5-352">How big a stack should be is one of the most frequently asked questions about threads.</span></span> <span data-ttu-id="293a5-353">スレッドのスタック領域には、最悪の場合の関数呼び出しの入れ子、ローカル変数割り当て、および最後の実行コンテキストの保存に対応できる十分な大きさが必要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-353">A thread’s stack area must be large enough to accommodate worst-case function call nesting, local variable allocation, and saving its last execution context.</span></span>

<span data-ttu-id="293a5-354">最小スタック サイズ **TX_MINIMUM_STACK** は、ThreadX SMP によって定義されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-354">The minimum stack size, **TX_MINIMUM_STACK**, is defined by ThreadX SMP.</span></span> <span data-ttu-id="293a5-355">このサイズのスタックでは、スレッドのコンテキストの保存と、最小量の関数呼び出しおよびローカル変数割り当てがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="293a5-355">A stack of this size supports saving a thread’s context and minimum amount of function calls and local variable allocation.</span></span>

<span data-ttu-id="293a5-356">ただし、ほとんどのスレッドにとって最小スタック サイズは小さすぎるため、ユーザーは関数呼び出しの入れ子とローカル変数割り当てを調べることによって、最悪の場合のサイズ要件を確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-356">For most threads, however, the minimum stack size is too small, and the user must ascertain the worstcase size requirement by examining function-call nesting and local variable allocation.</span></span> <span data-ttu-id="293a5-357">もちろん、大きなスタック領域から始めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="293a5-357">Of course, it is always better to start with a larger stack area.</span></span>

<span data-ttu-id="293a5-358">アプリケーションのデバッグ後、メモリが不足している場合は、スレッド スタックのサイズを調整できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-358">After the application is debugged, it is possible to tune the thread stack sizes if memory is scarce.</span></span> <span data-ttu-id="293a5-359">お勧めの方法は、スレッドを作成する前に、(0xEFEF) のような簡単に識別できるデータ パターンをすべてのスタック領域に事前設定することです。</span><span class="sxs-lookup"><span data-stu-id="293a5-359">A favorite trick is to preset all stack areas with an easily identifiable data pattern like (0xEFEF) prior to creating the threads.</span></span> <span data-ttu-id="293a5-360">アプリケーションの性能が完全に確認された後、スタック領域を調べて、実際に使用されたスタックの量を調べることができます。これは、データ パターンがそのまま残っているスタック領域を見つけることによって行われます。</span><span class="sxs-lookup"><span data-stu-id="293a5-360">After the application has been thoroughly put through its paces, the stack areas can be examined to see how much stack was actually used by finding the area of the stack where the data pattern is still intact.</span></span> <span data-ttu-id="293a5-361">図 6 は、0xEFEF に事前設定されていたスタックの、完全なスレッド実行後の状態を示しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-361">Figure 6 shows a stack preset to 0xEFEF after thorough thread execution.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-362">ThreadX SMP では、既定で、各スレッド スタックのすべてのバイトが値 0xEF で初期化されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-362">By default, ThreadX SMP initializes every byte of each thread stack with a value of 0xEF.</span></span>

### <a name="memory-pitfalls"></a><span data-ttu-id="293a5-363">メモリの落とし穴</span><span class="sxs-lookup"><span data-stu-id="293a5-363">Memory Pitfalls</span></span> 
<span data-ttu-id="293a5-364">スレッドのスタック要件は大きくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-364">The stack requirements for threads can be large.</span></span> <span data-ttu-id="293a5-365">そのため、妥当な数のスレッドを持つようにアプリケーションを設計することが重要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-365">Therefore, it is important to design the application to have a reasonable number of threads.</span></span> <span data-ttu-id="293a5-366">さらに、スレッド内でスタックが過剰に使用されないように注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-366">Furthermore, some care must be taken to avoid excessive stack usage within threads.</span></span> <span data-ttu-id="293a5-367">再帰アルゴリズムと大規模なローカル データ構造は避けてください。</span><span class="sxs-lookup"><span data-stu-id="293a5-367">Recursive algorithms and large local data structures should be avoided.</span></span>

<span data-ttu-id="293a5-368">ほとんどの場合、オーバーフローしたスタックが原因で、スタック領域に隣接する (通常はその前にある)</span><span class="sxs-lookup"><span data-stu-id="293a5-368">In most cases, an overflowed stack causes thread execution to corrupt memory adjacent (usually</span></span> 

![メモリの落とし穴](media/image9.png)

<span data-ttu-id="293a5-370">**図 6. 0xEFEF にプリセットされたスタック**</span><span class="sxs-lookup"><span data-stu-id="293a5-370">**FIGURE 6. Stack Preset to 0xEFEF**</span></span>

<span data-ttu-id="293a5-371">メモリがスレッドの実行によって破損します。</span><span class="sxs-lookup"><span data-stu-id="293a5-371">before) its stack area.</span></span> <span data-ttu-id="293a5-372">結果は予測不可能ですが、ほとんどの場合、プログラム カウンターに不自然な変更が発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-372">The results are unpredictable, but most often result in an un-natural change in the program counter.</span></span> <span data-ttu-id="293a5-373">これは、"雑草へのジャンプ" と呼ばれることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-373">This is often called “jumping into the weeds.”</span></span> <span data-ttu-id="293a5-374">もちろん、これを防ぐには、すべてのスレッド スタックが十分に大きいことを確認するのが唯一の方法です。</span><span class="sxs-lookup"><span data-stu-id="293a5-374">Of course, the only way to prevent this is to ensure all thread stacks are large enough.</span></span>

### <a name="optional-run-time-stack-checking"></a><span data-ttu-id="293a5-375">オプションの実行時スタック チェック</span><span class="sxs-lookup"><span data-stu-id="293a5-375">Optional Run-time Stack Checking</span></span>  
<span data-ttu-id="293a5-376">ThreadX SMP では、実行時に各スレッドのスタックが破損していないかどうかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-376">ThreadX SMP provides the ability to check each thread's stack for corruption during run-time.</span></span> <span data-ttu-id="293a5-377">ThreadX SMP では、既定で、作成時にスレッド スタックのすべてのバイトが 0xEF データ パターンで埋められます。</span><span class="sxs-lookup"><span data-stu-id="293a5-377">By default, ThreadX SMP fills every byte of thread stacks with a 0xEF data pattern during creation.</span></span> <span data-ttu-id="293a5-378">アプリケーションで \***TX_ENABLE_STACK_CHECKING** _ を定義して ThreadX SMP ライブラリをビルドした場合、ThreadX SMP では、スレッドが中断または再開されるたびに、各スレッドのスタックが破損していないかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="293a5-378">If the application builds the ThreadX SMP library with \***TX_ENABLE_STACK_CHECKING** _ defined, ThreadX SMP will examine each thread's stack for corruption as it is suspended or resumed.</span></span> <span data-ttu-id="293a5-379">スタックの破損が検出された場合、ThreadX では、_tx_thread_stack_error_notify\* の呼び出しで指定されたとおりにアプリケーションのスタック エラー処理ルーチンを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="293a5-379">If stack corruption is detected, ThreadX SMP will call the application's stack error handling routine as specified by the call to _tx_thread_stack_error_notify\*.</span></span> <span data-ttu-id="293a5-380">または、スタック エラー ハンドラーが指定されていない場合、ThreadX SMP では内部の *_tx_thread_stack_error_handler* ルーチンを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="293a5-380">Otherwise, if no stack error handler was specified, ThreadX SMP will call the internal *_tx_thread_stack_error_handler* routine.</span></span>

### <a name="reentrancy"></a><span data-ttu-id="293a5-381">再入</span><span class="sxs-lookup"><span data-stu-id="293a5-381">Reentrancy</span></span> 
<span data-ttu-id="293a5-382">マルチスレッドの本当の長所の 1 つは、同じ C 関数を複数のスレッドから呼び出せることです。</span><span class="sxs-lookup"><span data-stu-id="293a5-382">One of the real beauties of multithreading is that the same C function can be called from multiple threads.</span></span> <span data-ttu-id="293a5-383">これによって大きな力がもたらされ、コード空間の削減にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-383">This provides great power and also helps reduce code space.</span></span> <span data-ttu-id="293a5-384">ただし、複数のスレッドから呼び出される C 関数は "*再入可能*" である必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-384">However, it does require that C functions called from multiple threads are *reentrant*.</span></span>

<span data-ttu-id="293a5-385">基本的に、再入可能関数では、呼び出し元の戻り先アドレスを現在のスタックに格納します。あらかじめ設定したグローバル変数や静的 C 変数には依存しません。</span><span class="sxs-lookup"><span data-stu-id="293a5-385">Basically, a reentrant function stores the caller’s return address on the current stack and does not rely on global or static C variables that it previously set up.</span></span> <span data-ttu-id="293a5-386">ほとんどのコンパイラでは、戻り先アドレスがスタックに配置されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-386">Most compilers place the return address on the stack.</span></span> <span data-ttu-id="293a5-387">そのため、アプリケーション開発者は、"*グローバル変数*" と "*静的変数*" の使用についてのみ注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-387">Hence, application developers must only worry about the use of *globals* and *statics*.</span></span>

<span data-ttu-id="293a5-388">再入不可能な関数の例として、標準 C ライブラリの文字列トークン関数 "strtok" があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-388">An example of a non-reentrant function is the string token function “strtok” found in the standard C library.</span></span> <span data-ttu-id="293a5-389">この関数は、後続の呼び出しで前の文字列ポインターを "記憶" しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-389">This function remembers the previous string pointer on subsequent calls.</span></span> <span data-ttu-id="293a5-390">これは、静的な文字列ポインターを使用して行われます。</span><span class="sxs-lookup"><span data-stu-id="293a5-390">It does this with a static string pointer.</span></span> <span data-ttu-id="293a5-391">この関数が複数のスレッドから呼び出された場合、無効なポインターが返される可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="293a5-391">If this function is called from multiple threads, it would most likely return an invalid pointer.</span></span>

### <a name="thread-priority-pitfalls"></a><span data-ttu-id="293a5-392">スレッド優先度の落とし穴</span><span class="sxs-lookup"><span data-stu-id="293a5-392">Thread Priority Pitfalls</span></span> 
<span data-ttu-id="293a5-393">スレッドの優先度の選択は、マルチスレッドの最も重要な側面の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="293a5-393">Selecting thread priorities is one of the most important aspects of multithreading.</span></span> <span data-ttu-id="293a5-394">実行時に何が必要かを判断するのではなく、スレッドの重要度の思い込みに基づいて優先度を割り当てたくなることがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-394">It is sometimes very tempting to assign priorities based on a perceived notion of thread importance rather than determining what is exactly required during run-time.</span></span> <span data-ttu-id="293a5-395">スレッドの優先度を取り違えると、他のスレッドが飢餓状態になったり、優先度の逆転が発生したり、処理帯域幅が減少したり、アプリケーションの実行時の動作がわかりにくくなったりする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-395">Misuse of thread priorities can starve other threads, create priority inversion, reduce processing bandwidth, and make the application’s run-time behavior difficult to understand.</span></span>

<span data-ttu-id="293a5-396">前述のとおり、ThreadX SMP では、優先度に基づくプリエンプティブ スケジューリング アルゴリズムが提供されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-396">As mentioned before, ThreadX SMP provides a priority-based, preemptive scheduling algorithm.</span></span> <span data-ttu-id="293a5-397">優先度の低いスレッドは、より優先度が高く、実行準備の整ったスレッドが存在しなくなるまで実行されません。</span><span class="sxs-lookup"><span data-stu-id="293a5-397">Lower priority threads do not execute until there are no higher priority threads ready for execution.</span></span> <span data-ttu-id="293a5-398">優先度の高いスレッドが常に準備完了状態である場合、優先度の低いスレッドが実行されることはありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-398">If a higher priority thread is always ready, the lower priority threads never execute.</span></span> <span data-ttu-id="293a5-399">この状態は、"*スレッドの飢餓状態*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-399">This condition is called *thread starvation*.</span></span>

<span data-ttu-id="293a5-400">スレッドの飢餓状態に関する問題のほとんどは、デバッグの早い段階で検出されます。また、優先度の高いスレッドが継続的に実行されないようにすることで解決できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-400">Most thread starvation problems are detected early in debug and can be solved by ensuring that higher priority threads don’t execute continuously.</span></span> <span data-ttu-id="293a5-401">または、実行する機会が得られるまで、飢餓状態のスレッドの優先度を徐々に上げるロジックをアプリケーションに追加することができます。</span><span class="sxs-lookup"><span data-stu-id="293a5-401">Alternatively, logic can be added to the application that gradually raises the priority of starved threads until they get a chance to execute.</span></span>

<span data-ttu-id="293a5-402">スレッドの優先度に関連するもう 1 つの落とし穴は "*優先度の逆転*" です。</span><span class="sxs-lookup"><span data-stu-id="293a5-402">Another pitfall associated with thread priorities is *priority inversion*.</span></span> <span data-ttu-id="293a5-403">必要なリソースが優先度の低いスレッドによって保持されているために、優先度の高いスレッドが中断されると、優先度の逆転が発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-403">Priority inversion takes place when a higher priority thread is suspended because a lower priority thread has a needed resource.</span></span> <span data-ttu-id="293a5-404">もちろん、場合によっては、優先度の異なる 2 つのスレッドで共通のリソースを共有する必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-404">Of course, in some instances it is necessary for two threads of different priority to share a common resource.</span></span> <span data-ttu-id="293a5-405">これらのスレッドだけがアクティブである場合、優先度の逆転時間は、優先度の低いスレッドがリソースを保持している時間に限られます。</span><span class="sxs-lookup"><span data-stu-id="293a5-405">If these threads are the only ones active, the priority inversion time is bounded by the time the lower priority thread holds the resource.</span></span> <span data-ttu-id="293a5-406">この状態は確定的かつ正常です。</span><span class="sxs-lookup"><span data-stu-id="293a5-406">This condition is both deterministic and quite normal.</span></span> <span data-ttu-id="293a5-407">ただし、この優先度の逆転状態で、中間優先度のスレッドがアクティブになった場合、優先度の逆転時間は確定的ではなくなり、アプリケーション エラーが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-407">However, if threads of intermediate priority become active during this priority inversion condition, the priority inversion time is no longer deterministic and could cause an application failure.</span></span>

<span data-ttu-id="293a5-408">ThreadX SMP での不確定な優先度逆転を防止するには、主に 3 つの方法があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-408">There are principally three distinct methods of preventing nondeterministic priority inversion in ThreadX SMP.</span></span> <span data-ttu-id="293a5-409">まず、アプリケーションの優先度の選択と実行時の動作を、優先度の逆転問題を防ぐように設計できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-409">First, the application priority selections and run-time behavior can be designed in a manner that prevents the priority inversion problem.</span></span> <span data-ttu-id="293a5-410">次に、優先度の低いスレッドでは、"*プリエンプションしきい値*" を使用して、中間スレッドからのプリエンプションをブロックしながら、優先度の高いスレッドとリソースを共有できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-410">Second, lower priority threads can utilize *preemption-threshold* to block preemption from intermediate threads while they share resources with higher priority threads.</span></span> <span data-ttu-id="293a5-411">最後に、ThreadX SMP ミューテックス オブジェクトを使用してシステム リソースを保護しているスレッドでは、オプションのミューテックス "*優先度継承*" を利用して、不確定な優先度逆転を排除できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-411">Finally, threads using ThreadX SMP mutex objects to protect system resources may utilize the optional mutex *priority inheritance* to eliminate nondeterministic priority inversion.</span></span>

### <a name="priority-overhead"></a><span data-ttu-id="293a5-412">優先度のオーバーヘッド</span><span class="sxs-lookup"><span data-stu-id="293a5-412">Priority Overhead</span></span> 
<span data-ttu-id="293a5-413">マルチスレッドのオーバーヘッドを減らすための方法として、最も見落とされがちなものの 1 つは、コンテキスト切り替えの数を減らすことです。</span><span class="sxs-lookup"><span data-stu-id="293a5-413">One of the most overlooked ways to reduce overhead in multithreading is to reduce the number of context switches.</span></span> <span data-ttu-id="293a5-414">前述のとおり、優先度の高いスレッドの実行が実行中のスレッドよりも優先される場合、コンテキスト切り替えが発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-414">As previously mentioned, a context switch occurs when execution of a higher priority thread is favored over that of the executing thread.</span></span> <span data-ttu-id="293a5-415">より優先度の高いスレッドが準備完了状態になるのは、割り込みなどの外部イベントによる場合と、実行中のスレッドによって行われたサービス呼び出しによる場合の両方があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-415">It is worthwhile to mention that higher priority threads can become ready as a result of both external events (like interrupts) and from service calls made by the executing thread.</span></span>

<span data-ttu-id="293a5-416">スレッドの優先度がコンテキスト切り替えのオーバーヘッドに与える影響を示すために、*thread_1*、*thread_2*、および *thread_3* という名前のスレッドを持つ 3 つのスレッド環境があると仮定します。</span><span class="sxs-lookup"><span data-stu-id="293a5-416">To illustrate the effects thread priorities have on context switch overhead, assume a three thread environment with threads named *thread_1*, *thread_2*, and *thread_3*.</span></span> <span data-ttu-id="293a5-417">さらに、すべてのスレッドが、メッセージを待機して中断状態にあるとします。</span><span class="sxs-lookup"><span data-stu-id="293a5-417">Assume further that all of the threads are in a state of suspension waiting for a message.</span></span> <span data-ttu-id="293a5-418">thread_1 は、メッセージを受信すると、すぐに thread_2 に転送します。</span><span class="sxs-lookup"><span data-stu-id="293a5-418">When thread_1 receives a message, it immediately forwards it to thread_2.</span></span> <span data-ttu-id="293a5-419">thread_2 はその後、メッセージを thread_3 に転送します。</span><span class="sxs-lookup"><span data-stu-id="293a5-419">Thread_2 then forwards the message to thread_3.</span></span> <span data-ttu-id="293a5-420">thread_3 は、メッセージを破棄するだけです。</span><span class="sxs-lookup"><span data-stu-id="293a5-420">Thread_3 just discards the message.</span></span> <span data-ttu-id="293a5-421">各スレッドは、メッセージを処理した後、戻って別のメッセージを待機します。</span><span class="sxs-lookup"><span data-stu-id="293a5-421">After each thread processes its message, it goes back and waits for another message.</span></span>

<span data-ttu-id="293a5-422">これら 3 つのスレッドを実行するために必要な処理は、それらの優先度によって大きく変わります。</span><span class="sxs-lookup"><span data-stu-id="293a5-422">The processing required to execute these three threads varies greatly depending on their priorities.</span></span> <span data-ttu-id="293a5-423">すべてのスレッドの優先度が同じである場合は、各スレッドの実行前に 1 回のコンテキスト切り替えが発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-423">If all of the threads have the same priority, a single context switch occurs before the execution of each thread.</span></span> <span data-ttu-id="293a5-424">コンテキスト切り替えは、各スレッドが空のメッセージ キューで中断したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-424">The context switch occurs when each thread suspends on an empty message queue.</span></span>

<span data-ttu-id="293a5-425">ただし、thread_2 の優先度が thread_1 よりも高く、thread_3 の優先度が thread_2 よりも高い場合、コンテキスト切り替えの数は 2 倍になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-425">However, if thread_2 is higher priority than thread_1 and thread_3 is higher priority than thread_2, the number of context switches doubles.</span></span> <span data-ttu-id="293a5-426">これは、優先度の高いスレッドの準備が整ったことが検出されると、*tx_queue_send* サービスの内部でもう 1 回コンテキスト切り替えが発生するためです。</span><span class="sxs-lookup"><span data-stu-id="293a5-426">This is because another context switch occurs inside of the *tx_queue_send* service when it detects that a higher priority thread is now ready.</span></span>

<span data-ttu-id="293a5-427">ThreadX SMP のプリエンプションしきい値のメカニズムを使用すると、このような余分なコンテキスト切り替えを回避でき、前述した優先度の選択も引き続き可能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-427">The ThreadX SMP preemption-threshold mechanism can avoid these extra context switches and still allow the previously mentioned priority selections.</span></span> <span data-ttu-id="293a5-428">スケジューリング時に複数のスレッド優先度が許可されると同時に、スレッド実行時にそれらの間で発生する不要なコンテキスト切り替えの一部を回避できるため、これは重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-428">This is an important feature because it allows several thread priorities during scheduling, while at the same time eliminating some of the unwanted context switching between them during thread execution.</span></span>

### <a name="run-time-thread-performance-information"></a><span data-ttu-id="293a5-429">実行時のスレッド パフォーマンス情報</span><span class="sxs-lookup"><span data-stu-id="293a5-429">Run-time Thread Performance Information</span></span> 
<span data-ttu-id="293a5-430">ThreadX SMP では、実行時のスレッド パフォーマンス情報がオプションで提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-430">ThreadX SMP provides optional run-time thread performance information.</span></span> <span data-ttu-id="293a5-431">ThreadX SMP ライブラリとアプリケーションが ***TX_THREAD_ENABLE_PERFORMANCE_INFO*** を定義してビルドされている場合、ThreadX SMP では次の情報が蓄積されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-431">If the ThreadX SMP library and application is built with ***TX_THREAD_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information:</span></span>

<span data-ttu-id="293a5-432">システム全体の合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-432">Total number for the overall system:</span></span>

- <span data-ttu-id="293a5-433">スレッドの再開</span><span class="sxs-lookup"><span data-stu-id="293a5-433">thread resumptions</span></span>
- <span data-ttu-id="293a5-434">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="293a5-434">thread suspensions</span></span>
- <span data-ttu-id="293a5-435">サービス呼び出しのプリエンプション</span><span class="sxs-lookup"><span data-stu-id="293a5-435">service call preemptions</span></span>
- <span data-ttu-id="293a5-436">割り込みのプリエンプション</span><span class="sxs-lookup"><span data-stu-id="293a5-436">interrupt preemptions</span></span>
- <span data-ttu-id="293a5-437">優先度逆転</span><span class="sxs-lookup"><span data-stu-id="293a5-437">priority inversions</span></span>
- <span data-ttu-id="293a5-438">タイムスライス</span><span class="sxs-lookup"><span data-stu-id="293a5-438">time-slices</span></span>
- <span data-ttu-id="293a5-439">放棄</span><span class="sxs-lookup"><span data-stu-id="293a5-439">relinquishes</span></span>
- <span data-ttu-id="293a5-440">スレッド タイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-440">thread timeouts</span></span>
- <span data-ttu-id="293a5-441">中断の中止</span><span class="sxs-lookup"><span data-stu-id="293a5-441">suspension aborts</span></span>
- <span data-ttu-id="293a5-442">アイドル システム リターン</span><span class="sxs-lookup"><span data-stu-id="293a5-442">idle system returns</span></span>
- <span data-ttu-id="293a5-443">非アイドル システム リターン</span><span class="sxs-lookup"><span data-stu-id="293a5-443">non-idle system returns</span></span>

<span data-ttu-id="293a5-444">スレッドごとの合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-444">Total number for each thread:</span></span>

- <span data-ttu-id="293a5-445">再開</span><span class="sxs-lookup"><span data-stu-id="293a5-445">resumptions</span></span>
- <span data-ttu-id="293a5-446">中断</span><span class="sxs-lookup"><span data-stu-id="293a5-446">suspensions</span></span>
- <span data-ttu-id="293a5-447">サービス呼び出しのプリエンプション</span><span class="sxs-lookup"><span data-stu-id="293a5-447">service call preemptions</span></span>
- <span data-ttu-id="293a5-448">割り込みのプリエンプション</span><span class="sxs-lookup"><span data-stu-id="293a5-448">interrupt preemptions</span></span>
- <span data-ttu-id="293a5-449">優先度逆転</span><span class="sxs-lookup"><span data-stu-id="293a5-449">priority inversions</span></span>
- <span data-ttu-id="293a5-450">タイムスライス</span><span class="sxs-lookup"><span data-stu-id="293a5-450">time-slices</span></span>
- <span data-ttu-id="293a5-451">スレッド放棄</span><span class="sxs-lookup"><span data-stu-id="293a5-451">thread relinquishes</span></span>
- <span data-ttu-id="293a5-452">スレッド タイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-452">thread timeouts</span></span>
- <span data-ttu-id="293a5-453">中断の中止</span><span class="sxs-lookup"><span data-stu-id="293a5-453">suspension aborts</span></span>

<span data-ttu-id="293a5-454">この情報は、実行時にサービス *tx_thread_performance_info_get* および *tx_thread_performance_system_info_get* を通じて取得できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-454">This information is available at run-time through the services *tx_thread_performance_info_get* and *tx_thread_performance_system_info_get*.</span></span> <span data-ttu-id="293a5-455">スレッド パフォーマンス情報は、アプリケーションが正しく動作しているかどうかを判断するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-455">Thread performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="293a5-456">アプリケーションの最適化にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-456">It is also useful in optimizing the application.</span></span> <span data-ttu-id="293a5-457">たとえば、サービス呼び出しのプリエンプションが比較的多い場合は、スレッドの優先度やプリエンプションしきい値が低すぎることを示唆している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-457">For example, a relatively high number of service call preemptions might suggest the thread’s priority and/or preemption-threshold is too low.</span></span> <span data-ttu-id="293a5-458">さらに、アイドル システム リターンが比較的少ない場合は、優先度の低いスレッドが十分に中断していないことを示唆している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-458">Furthermore, a relatively low number of idle system returns might suggest that lower priority threads are not suspending enough.</span></span>

### <a name="debugging-pitfalls"></a><span data-ttu-id="293a5-459">デバッグの落とし穴</span><span class="sxs-lookup"><span data-stu-id="293a5-459">Debugging Pitfalls</span></span> 
<span data-ttu-id="293a5-460">マルチスレッド アプリケーションでは、複数のスレッドから同じプログラム コードが実行される可能性があるため、デバッグが少し難しくなります。</span><span class="sxs-lookup"><span data-stu-id="293a5-460">Debugging multithreaded applications is a little more difficult because the same program code can be executed from multiple threads.</span></span> <span data-ttu-id="293a5-461">このような場合、ブレークポイントだけでは不十分な場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-461">In such cases, a break-point alone may not be enough.</span></span> <span data-ttu-id="293a5-462">デバッガーで条件付きブレークポイントを使用して現在のスレッド ポインター配列 ***_tx_thread_current_ptr[core]*** を表示し、呼び出し元スレッドがデバッグ対象のスレッドであるかどうかを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-462">The debugger must also view the current thread pointer array ***_tx_thread_current_ptr[core]*** using a conditional breakpoint to see if the calling thread is the one to debug.</span></span>

<span data-ttu-id="293a5-463">この多くは、さまざまな開発ツールのベンダーが提供するマルチスレッド サポート パッケージで処理されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-463">Much of this is being handled in multithreading support packages offered through various development tool vendors.</span></span> <span data-ttu-id="293a5-464">シンプルな設計のため、ThreadX SMP をさまざまな開発ツールと統合するのは比較的簡単です。</span><span class="sxs-lookup"><span data-stu-id="293a5-464">Because of its simple design, integrating ThreadX SMP with different development tools is relatively easy.</span></span>

<span data-ttu-id="293a5-465">スタック サイズは、常にマルチスレッドの重要なデバッグ トピックです。</span><span class="sxs-lookup"><span data-stu-id="293a5-465">Stack size is always an important debug topic in multithreading.</span></span> <span data-ttu-id="293a5-466">原因不明の動作が見られた場合、通常はまず、すべてのスレッドのスタック サイズ (特に最後に実行するスレッドのスタックサイズ) を増やすことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="293a5-466">Whenever unexplained behavior is observed, it is usually a good first guess to increase stack sizes for all threads—especially the stack size of the last thread to execute!</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-467">TX_ENABLE_STACK_CHECKING を定義して ThreadX SMP ライブラリをビルドすることもお勧めします。</span><span class="sxs-lookup"><span data-stu-id="293a5-467">It is also a good idea to build the ThreadX SMP library with TX_ENABLE_STACK_CHECKING defined.</span></span> <span data-ttu-id="293a5-468">これにより、処理のできるだけ早い段階でスタックの破損の問題を特定できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-468">This will help isolate stack corruption problems as early in the processing as possible!</span></span>

## <a name="message-queues"></a><span data-ttu-id="293a5-469">メッセージ キュー</span><span class="sxs-lookup"><span data-stu-id="293a5-469">Message Queues</span></span>

<span data-ttu-id="293a5-470">メッセージ キューは、ThreadX SMP でのスレッド間通信の主要な手段です。</span><span class="sxs-lookup"><span data-stu-id="293a5-470">Message queues are the primary means of interthread communication in ThreadX SMP.</span></span> <span data-ttu-id="293a5-471">メッセージ キューには 1 つ以上のメッセージを格納できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-471">One or more messages can reside in a message queue.</span></span> <span data-ttu-id="293a5-472">1 つのメッセージを保持するメッセージ キューは、通常、"*メールボックス*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-472">A message queue that holds a single message is commonly called a *mailbox*.</span></span>

<span data-ttu-id="293a5-473">メッセージは *tx_queue_send* によってキューにコピーされ、*tx_queue_receive* によってキューからコピーされます。</span><span class="sxs-lookup"><span data-stu-id="293a5-473">Messages are copied to a queue by *tx_queue_send* and are copied from a queue by *tx_queue_receive*.</span></span> <span data-ttu-id="293a5-474">唯一の例外は、スレッドが空のキューでメッセージを待機して中断されている場合です。</span><span class="sxs-lookup"><span data-stu-id="293a5-474">The only exception to this is when a thread is suspended while waiting for a message on an empty queue.</span></span> <span data-ttu-id="293a5-475">この場合、キューに送信された次のメッセージは、スレッドの送信先領域に直接配置されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-475">In this case, the next message sent to the queue is placed directly into the thread’s destination area.</span></span>

<span data-ttu-id="293a5-476">各メッセージ キューはパブリック リソースです。</span><span class="sxs-lookup"><span data-stu-id="293a5-476">Each message queue is a public resource.</span></span> <span data-ttu-id="293a5-477">ThreadX SMP では、メッセージ キューの使用方法に関する制約はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-477">ThreadX SMP places no constraints on how message queues are used.</span></span>

### <a name="creating-message-queues"></a><span data-ttu-id="293a5-478">メッセージ キューの作成</span><span class="sxs-lookup"><span data-stu-id="293a5-478">Creating Message Queues</span></span> 
<span data-ttu-id="293a5-479">メッセージ キューは、初期化中または実行時にアプリケーション スレッドによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-479">Message queues are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="293a5-480">アプリケーションでのメッセージ キューの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-480">There is no limit on the number of message queues in an application.</span></span> 

### <a name="message-size"></a><span data-ttu-id="293a5-481">メッセージ サイズ</span><span class="sxs-lookup"><span data-stu-id="293a5-481">Message Size</span></span> 
<span data-ttu-id="293a5-482">各メッセージ キューでは、いくつかの固定サイズのメッセージがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="293a5-482">Each message queue supports a number of fixedsized messages.</span></span> <span data-ttu-id="293a5-483">使用可能なメッセージ サイズは、32 ビット ワードで 1 ～ 16 (両端を含む) です。</span><span class="sxs-lookup"><span data-stu-id="293a5-483">The available message sizes are 1 through 16 32-bit words inclusive.</span></span> <span data-ttu-id="293a5-484">メッセージ サイズは、キューの作成時に指定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-484">The message size is specified when the queue is created.</span></span> 

<span data-ttu-id="293a5-485">16 ワードを超えるアプリケーション メッセージは、ポインターによって渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-485">Application messages greater than 16 words must be passed by pointer.</span></span> <span data-ttu-id="293a5-486">これを実現するには、メッセージ サイズを 1 ワード (ポインターを保持するために十分) としてキューを作成し、メッセージ全体ではなくメッセージ ポインターを送受信します。</span><span class="sxs-lookup"><span data-stu-id="293a5-486">This is accomplished by creating a queue with a message size of 1 word (enough to hold a pointer) and then sending and receiving message pointers instead of the entire message.</span></span>

### <a name="message-queue-capacity"></a><span data-ttu-id="293a5-487">メッセージ キューの容量</span><span class="sxs-lookup"><span data-stu-id="293a5-487">Message Queue Capacity</span></span> 
<span data-ttu-id="293a5-488">キューに保持できるメッセージの数は、そのメッセージ サイズと、作成時に指定されたメモリ領域のサイズの関数です。</span><span class="sxs-lookup"><span data-stu-id="293a5-488">The number of messages a queue can hold is a function of its message size and the size of the memory area supplied during creation.</span></span> <span data-ttu-id="293a5-489">キューの合計メッセージ容量は、指定されたメモリ領域の合計バイト数を、各メッセージのバイト数で割ることによって計算されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-489">The total message capacity of the queue is calculated by dividing the number of bytes in each message into the total number of bytes in the supplied memory area.</span></span>

<span data-ttu-id="293a5-490">たとえば、32 ビット ワードで 1 (4 バイト) のメッセージ サイズをサポートするメッセージ キューが 100 バイトのメモリ領域で作成されている場合、その容量は 25 メッセージになります。</span><span class="sxs-lookup"><span data-stu-id="293a5-490">For example, if a message queue that supports a message size of 1 32-bit word (4 bytes) is created with a 100-byte memory area, its capacity is 25 messages.</span></span>

### <a name="queue-memory-area"></a><span data-ttu-id="293a5-491">キューのメモリ領域</span><span class="sxs-lookup"><span data-stu-id="293a5-491">Queue Memory Area</span></span> 
<span data-ttu-id="293a5-492">前述のように、メッセージをバッファー処理するためのメモリ領域は、キューの作成時に指定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-492">As mentioned before, the memory area for buffering messages is specified during queue creation.</span></span> <span data-ttu-id="293a5-493">ThreadX SMP の他のメモリ領域と同様に、ターゲットのアドレス空間内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-493">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span>

<span data-ttu-id="293a5-494">かなりの柔軟性がアプリケーションに提供されるため、これは重要な特徴です。</span><span class="sxs-lookup"><span data-stu-id="293a5-494">This is an important feature because it gives the application considerable flexibility.</span></span> <span data-ttu-id="293a5-495">たとえば、アプリケーションでは、重要なキューのメモリ領域を高速 RAM に配置することによって、パフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="293a5-495">For example, an application might locate the memory area of an important queue in high-speed RAM to improve performance.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="293a5-496">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="293a5-496">Thread Suspension</span></span>  
<span data-ttu-id="293a5-497">アプリケーション スレッドは、キューに対してメッセージを送受信しようとして中断することがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-497">Application threads can suspend while attempting to send or receive a message from a queue.</span></span> <span data-ttu-id="293a5-498">通常、スレッドの中断には、空のキューからのメッセージの待機が伴います。</span><span class="sxs-lookup"><span data-stu-id="293a5-498">Typically, thread suspension involves waiting for a message from an empty queue.</span></span> <span data-ttu-id="293a5-499">ただし、満杯になっているキューにメッセージを送信しようとしてスレッドが中断する可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-499">However, it is also possible for a thread to suspend trying to send a message to a full queue.</span></span> 

<span data-ttu-id="293a5-500">中断の条件が解決されると、要求されたサービスが実行され、待機中のスレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-500">After the condition for suspension is resolved, the service requested is completed and the waiting thread is resumed.</span></span> <span data-ttu-id="293a5-501">同じキューで複数のスレッドが中断された場合、それらは中断された順序で再開されます (FIFO)。</span><span class="sxs-lookup"><span data-stu-id="293a5-501">If multiple threads are suspended on the same queue, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="293a5-502">ただし、スレッドの中断を解除するキュー サービスよりも前にアプリケーションで ***tx_queue_prioritize*** を呼び出す場合は、優先度による再開も可能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-502">However, priority resumption is also possible if the application calls ***tx_queue_prioritize*** prior to the queue service that lifts thread suspension.</span></span> <span data-ttu-id="293a5-503">キューの優先度付けサービスでは、最も優先度の高いスレッドが中断リストの先頭に配置され、他の中断されたスレッドはすべて、同じ FIFO 順序のまま残ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-503">The queue prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

<span data-ttu-id="293a5-504">すべてのキューの中断でタイムアウトを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="293a5-504">Time-outs are also available for all queue suspensions.</span></span> <span data-ttu-id="293a5-505">基本的に、タイムアウトは、スレッドが中断されたままになるタイマー ティックの最大数を指定します。</span><span class="sxs-lookup"><span data-stu-id="293a5-505">Basically, a time-out specifies the maximum number of timer ticks the thread will stay suspended.</span></span> <span data-ttu-id="293a5-506">タイムアウトが発生すると、スレッドが再開され、サービスから該当するエラー コードが返されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-506">If a time-out occurs, the thread is resumed and the service returns with the appropriate error code.</span></span>

### <a name="queue-send-notification"></a><span data-ttu-id="293a5-507">キューの送信通知</span><span class="sxs-lookup"><span data-stu-id="293a5-507">Queue Send Notification</span></span>  
<span data-ttu-id="293a5-508">アプリケーションによっては、キューにメッセージが配置されるたびに通知を受け取ると役立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-508">Some applications may find it advantageous to be notified whenever a message is placed on a queue.</span></span> <span data-ttu-id="293a5-509">ThreadX SMP では、*tx_queue_send_notify* サービスを介してこの機能が提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-509">ThreadX SMP provides this ability through the *tx_queue_send_notify* service.</span></span> <span data-ttu-id="293a5-510">このサービスは、指定されたアプリケーション通知関数を指定されたキューに登録します。</span><span class="sxs-lookup"><span data-stu-id="293a5-510">This service registers the supplied application notification function with the specified queue.</span></span> <span data-ttu-id="293a5-511">その後、メッセージがキューに送信されるたびに、このアプリケーション通知関数が ThreadX SMP によって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-511">ThreadX SMP will subsequently invoke this application notification function whenever a message is sent to the queue.</span></span> <span data-ttu-id="293a5-512">アプリケーション通知関数内の正確な処理は、アプリケーションによって決定されます。ただし、通常は、新しいメッセージを処理するための適切なスレッドを再開することから成ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-512">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new message.</span></span>

### <a name="queue-event-chaining"></a><span data-ttu-id="293a5-513">キュー イベントチェーン™</span><span class="sxs-lookup"><span data-stu-id="293a5-513">Queue Event-chaining™</span></span>  
<span data-ttu-id="293a5-514">ThreadX SMP の通知機能を試用して、さまざまな同期イベントを連結できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-514">The notification capabilities in ThreadX SMP can be used to chain various synchronization events together.</span></span> <span data-ttu-id="293a5-515">これは通常、1 つのスレッドで複数の同期イベントを処理する必要がある場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-515">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="293a5-516">たとえば、1 つのスレッドで 5 つの異なるキューからのメッセージを処理する必要があり、メッセージがない場合には中断する必要もあるとします。</span><span class="sxs-lookup"><span data-stu-id="293a5-516">For example, suppose a single thread is responsible for processing messages from five different queues and must also suspend when no messages are available.</span></span> <span data-ttu-id="293a5-517">これは、各キューにアプリケーション通知関数を登録し、追加のカウント セマフォを導入することによって簡単に実現できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-517">This is easily accomplished by registering an application notification function for each queue and introducing an additional counting semaphore.</span></span> <span data-ttu-id="293a5-518">具体的には、アプリケーション通知関数は、呼び出されるたびに *tx_semaphore_put* を実行します (セマフォのカウントは 5 つのキューすべてのメッセージの合計数を表します)。</span><span class="sxs-lookup"><span data-stu-id="293a5-518">Specifically, the application notification function performs a *tx_semaphore_put* whenever it is called (the semaphore count represents the total number of messages in all five queues).</span></span> <span data-ttu-id="293a5-519">処理中のスレッドは、*tx_semaphore_get* サービスを介してこのセマフォで中断します。</span><span class="sxs-lookup"><span data-stu-id="293a5-519">The processing thread suspends on this semaphore via the *tx_semaphore_get* service.</span></span> <span data-ttu-id="293a5-520">セマフォが使用可能になると (この場合は、メッセージが利用可能になったとき)、処理中のスレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-520">When the semaphore is available (in this case, when a message is available!), the processing thread is resumed.</span></span> <span data-ttu-id="293a5-521">次に、各キューにメッセージがあるか問い合わせ、見つかったメッセージを処理し、もう一度 *tx_semaphore_get* を実行して次のメッセージを待機します。</span><span class="sxs-lookup"><span data-stu-id="293a5-521">It then interrogates each queue for a message, processes the found message, and performs another *tx_semaphore_get* to wait for the next message.</span></span> <span data-ttu-id="293a5-522">イベントチェーンを使用せずにこれを実現することは非常に困難であり、多くのスレッドや追加のアプリケーション コードが必要になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-522">Accomplishing this without event-chaining is quite difficult and likely would require more threads and/or additional application code.</span></span>

<span data-ttu-id="293a5-523">一般的には、*イベント連結* によってスレッド、オーバーヘッド、RAM 要件が減少します。</span><span class="sxs-lookup"><span data-stu-id="293a5-523">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="293a5-524">より複雑なシステムの同期要件を処理するための、柔軟性が高いメカニズムも提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-524">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-queue-performance-information"></a><span data-ttu-id="293a5-525">実行時のキュー パフォーマンス情報</span><span class="sxs-lookup"><span data-stu-id="293a5-525">Run-time Queue Performance Information</span></span>  
<span data-ttu-id="293a5-526">ThreadX SMP では、実行時のキュー パフォーマンス情報がオプションで提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-526">ThreadX SMP provides optional run-time queue performance information.</span></span> <span data-ttu-id="293a5-527">ThreadX SMP ライブラリとアプリケーションが ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** を定義してビルドされている場合、ThreadX SMP では次の情報が蓄積されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-527">If the ThreadX SMP library and application is built with ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information:</span></span>

<span data-ttu-id="293a5-528">システム全体の合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-528">Total number for the overall system:</span></span>

- <span data-ttu-id="293a5-529">送信されたメッセージ</span><span class="sxs-lookup"><span data-stu-id="293a5-529">messages sent</span></span>
- <span data-ttu-id="293a5-530">受信したメッセージ</span><span class="sxs-lookup"><span data-stu-id="293a5-530">messages received</span></span>
- <span data-ttu-id="293a5-531">キューの空の中断</span><span class="sxs-lookup"><span data-stu-id="293a5-531">queue empty suspensions</span></span>
- <span data-ttu-id="293a5-532">キューの満杯の中断</span><span class="sxs-lookup"><span data-stu-id="293a5-532">queue full suspensions</span></span>
- <span data-ttu-id="293a5-533">キュー満杯エラー リターン (中断未指定)</span><span class="sxs-lookup"><span data-stu-id="293a5-533">queue full error returns (suspension not speci-fied)</span></span>
- <span data-ttu-id="293a5-534">キュー タイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-534">queue timeouts</span></span>

<span data-ttu-id="293a5-535">キューごとの合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-535">Total number for each queue:</span></span>

- <span data-ttu-id="293a5-536">送信されたメッセージ</span><span class="sxs-lookup"><span data-stu-id="293a5-536">messages sent</span></span>
- <span data-ttu-id="293a5-537">受信したメッセージ</span><span class="sxs-lookup"><span data-stu-id="293a5-537">messages received</span></span>
- <span data-ttu-id="293a5-538">キューの空の中断</span><span class="sxs-lookup"><span data-stu-id="293a5-538">queue empty suspensions</span></span>
- <span data-ttu-id="293a5-539">キューの満杯の中断</span><span class="sxs-lookup"><span data-stu-id="293a5-539">queue full suspensions</span></span>
- <span data-ttu-id="293a5-540">キュー満杯エラー リターン (中断未指定)</span><span class="sxs-lookup"><span data-stu-id="293a5-540">queue full error returns (suspension not speci-fied)</span></span>
- <span data-ttu-id="293a5-541">キュー タイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-541">queue timeouts</span></span>

<span data-ttu-id="293a5-542">この情報は、実行時にサービス *tx_queue_performance_info_get* および *tx_queue_performance_system_info_get* を通じて取得できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-542">This information is available at run-time through the services *tx_queue_performance_info_get* and *tx_queue_performance_system_info_get*.</span></span> <span data-ttu-id="293a5-543">キュー パフォーマンス情報は、アプリケーションが正しく動作しているかどうかを判断するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-543">Queue performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="293a5-544">アプリケーションの最適化にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-544">It is also useful in optimizing the application.</span></span> <span data-ttu-id="293a5-545">たとえば、"キューの満杯の中断" の数が比較的多い場合は、キューのサイズを大きくすることが有益となる可能性を示唆しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-545">For example, a relatively high number of “queue full suspensions” suggests an increase in the queue size might be beneficial.</span></span>

### <a name="queue-control-block-tx_queue"></a><span data-ttu-id="293a5-546">キュー制御ブロック TX_QUEUE</span><span class="sxs-lookup"><span data-stu-id="293a5-546">Queue Control Block TX_QUEUE</span></span> 
<span data-ttu-id="293a5-547">各メッセージ キューの特性は、その制御ブロックにあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-547">The characteristics of each message queue are found in its control block.</span></span> <span data-ttu-id="293a5-548">これには、キュー内のメッセージの数などの興味深い情報が格納されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-548">It contains interesting information such as the number of messages in the queue.</span></span> <span data-ttu-id="293a5-549">この構造体は ***tx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-549">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="293a5-550">メッセージ キュー制御ブロックは、メモリ内の任意の場所に配置することもできますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="293a5-550">Message queue control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="message-destination-pitfall"></a><span data-ttu-id="293a5-551">メッセージ送信先の落とし穴</span><span class="sxs-lookup"><span data-stu-id="293a5-551">Message Destination Pitfall</span></span>  
<span data-ttu-id="293a5-552">前述のとおり、メッセージはキュー領域とアプリケーション データ領域の間でコピーされます。</span><span class="sxs-lookup"><span data-stu-id="293a5-552">As mentioned previously, messages are copied between the queue area and application data areas.</span></span> <span data-ttu-id="293a5-553">受信したメッセージの送信先がメッセージ全体を保持するのに十分な大きさであることを確認することが重要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-553">It is important to ensure the destination for a received message is large enough to hold the entire message.</span></span> <span data-ttu-id="293a5-554">そうでない場合は、メッセージの送信先に続くメモリが破損する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-554">If not, the memory following the message destination will likely be corrupted.</span></span> 

> [!WARNING]
> <span data-ttu-id="293a5-555">これは、小さすぎるメッセージ送信先がスタック上にある場合には特に致命的です。関数の戻り先アドレスの破壊ほどひどいことはありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-555">This is especially lethal when a too-small message destination is on the stack—nothing like corrupting the return address of a function!</span></span>

## <a name="counting-semaphores"></a><span data-ttu-id="293a5-556">カウント セマフォ</span><span class="sxs-lookup"><span data-stu-id="293a5-556">Counting Semaphores</span></span>

<span data-ttu-id="293a5-557">ThreadX SMP には、0 ～ 4,294,967,295 の値を範囲とする 32 ビットのカウント セマフォが用意されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-557">ThreadX SMP provides 32-bit counting semaphores that range in value between 0 and 4,294,967,295.</span></span> <span data-ttu-id="293a5-558">カウント セマフォには 2 つの操作 *tx_semaphore_get* および *tx_semaphore_put* があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-558">There are two operations for counting semaphores: *tx_semaphore_get* and *tx_semaphore_put*.</span></span> <span data-ttu-id="293a5-559">get 操作によってセマフォは 1 減ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-559">The get operation decreases the semaphore by one.</span></span> <span data-ttu-id="293a5-560">セマフォが 0 の場合、get 操作は成功しません。</span><span class="sxs-lookup"><span data-stu-id="293a5-560">If the semaphore is 0, the get operation is not successful.</span></span> <span data-ttu-id="293a5-561">get 操作の逆が put 操作です。</span><span class="sxs-lookup"><span data-stu-id="293a5-561">The inverse of the get operation is the put operation.</span></span> <span data-ttu-id="293a5-562">これによってセマフォは 1 増えます。</span><span class="sxs-lookup"><span data-stu-id="293a5-562">It increases the semaphore by one.</span></span>

<span data-ttu-id="293a5-563">各カウント セマフォはパブリック リソースです。</span><span class="sxs-lookup"><span data-stu-id="293a5-563">Each counting semaphore is a public resource.</span></span> <span data-ttu-id="293a5-564">ThreadX SMP では、カウント セマフォの使用方法に関する制約はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-564">ThreadX SMP places no constraints on how counting semaphores are used.</span></span>

<span data-ttu-id="293a5-565">通常、カウント セマフォは "*相互排他*" のために使用されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-565">Counting semaphores are typically used for *mutual exclusion*.</span></span> <span data-ttu-id="293a5-566">ただし、カウント セマフォは、イベント通知の方法としても使用できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-566">However, counting semaphores can also be used as a method for event notification.</span></span>

### <a name="mutual-exclusion"></a><span data-ttu-id="293a5-567">相互排他</span><span class="sxs-lookup"><span data-stu-id="293a5-567">Mutual Exclusion</span></span> 
<span data-ttu-id="293a5-568">相互排他は、特定のアプリケーション領域 ("*クリティカル セクション*" や "*アプリケーション リソース*" とも呼ばれます) へのスレッドのアクセスを制御することに関連します。</span><span class="sxs-lookup"><span data-stu-id="293a5-568">Mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="293a5-569">相互排他のために使用する場合、セマフォの "現在のカウント" は、アクセスが許可されるスレッドの合計数を表します。</span><span class="sxs-lookup"><span data-stu-id="293a5-569">When used for mutual exclusion, the “current count” of a semaphore represents the total number of threads that are allowed access.</span></span> <span data-ttu-id="293a5-570">ほとんどの場合、相互排他のために使用されるカウント セマフォには初期値 1 が割り当てられます。これは、関連付けられたリソースに一度にアクセスできるスレッドは 1 つだけであることを意味します。</span><span class="sxs-lookup"><span data-stu-id="293a5-570">In most cases, counting semaphores used for mutual exclusion will have an initial value of 1, meaning that only one thread can access the associated resource at a time.</span></span> <span data-ttu-id="293a5-571">0 または 1 の値のみを取るカウント セマフォは、一般に "*バイナリ セマフォ*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-571">Counting semaphores that only have values of 0 or 1 are commonly called *binary semaphores*.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-572">バイナリ セマフォが使用されている場合、ユーザーは、同じスレッドが既に所有しているセマフォに対して get 操作を実行できないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-572">If a binary semaphore is being used, the user must prevent the same thread from performing a get operation on a semaphore it already owns.</span></span> <span data-ttu-id="293a5-573">2 番目の get は失敗し、呼び出し元スレッドが無期限に中断され、リソースが恒久的に利用不可になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-573">A second get would be unsuccessful and could cause indefinite suspension of the calling thread and permanent unavailability of the resource.</span></span>

### <a name="event-notification"></a><span data-ttu-id="293a5-574">イベント通知</span><span class="sxs-lookup"><span data-stu-id="293a5-574">Event Notification</span></span> 
<span data-ttu-id="293a5-575">また、プロデューサー/コンシューマー形式でカウント セマフォをイベント通知として使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="293a5-575">It is also possible to use counting semaphores as event notification, in a producer-consumer fashion.</span></span> <span data-ttu-id="293a5-576">何かが使用可能になるたびにプロデューサーはカウント セマフォを増やし、コンシューマーはセマフォの取得を試みます。</span><span class="sxs-lookup"><span data-stu-id="293a5-576">The consumer attempts to get the counting semaphore while the producer increases the semaphore whenever something is available.</span></span> <span data-ttu-id="293a5-577">通常、このようなセマフォの初期値は 0 であり、プロデューサーからコンシューマーに何かを提供できるようになるまでは増加しません。</span><span class="sxs-lookup"><span data-stu-id="293a5-577">Such semaphores usually have an initial value of 0 and will not increase until the producer has something ready for the consumer.</span></span> <span data-ttu-id="293a5-578">イベント通知に使用されるセマフォでは、*tx_semaphore_ceiling_put* サービス呼び出しを使用することにもメリットがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-578">Semaphores used for event notification may also benefit from use of the *tx_semaphore_ceiling_put* service call.</span></span> <span data-ttu-id="293a5-579">このサービスにより、セマフォのカウントが呼び出しで指定された値を超えないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="293a5-579">This service ensures that the semaphore count never exceeds the value supplied in the call.</span></span>

### <a name="creating-counting-semaphores"></a><span data-ttu-id="293a5-580">カウント セマフォの作成</span><span class="sxs-lookup"><span data-stu-id="293a5-580">Creating Counting Semaphores</span></span> 
<span data-ttu-id="293a5-581">カウント セマフォは、初期化中または実行時にアプリケーション スレッドによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-581">Counting semaphores are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="293a5-582">セマフォの初期カウントは、作成時に指定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-582">The initial count of the semaphore is specified during creation.</span></span> <span data-ttu-id="293a5-583">アプリケーションでのカウント セマフォの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-583">There is no limit on the number of counting semaphores in an application.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="293a5-584">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="293a5-584">Thread Suspension</span></span>  
<span data-ttu-id="293a5-585">アプリケーション スレッドは、現在のカウントが 0 のセマフォで get 操作を実行しようとして中断することがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-585">Application threads can suspend while attempting to perform a get operation on a semaphore with a current count of 0.</span></span> 

<span data-ttu-id="293a5-586">put 操作が実行されると、中断されたスレッドの get 操作が実行され、スレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-586">After a put operation is performed, the suspended thread’s get operation is performed and the thread is resumed.</span></span> <span data-ttu-id="293a5-587">同じカウント セマフォで複数のスレッドが中断された場合、それらは中断されたのと同じ順序で再開されます (FIFO)。</span><span class="sxs-lookup"><span data-stu-id="293a5-587">If multiple threads are suspended on the same counting semaphore, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="293a5-588">ただし、アプリケーションでは、スレッドの中断を解除するセマフォ put 呼び出しの前に ***tx_semaphore_prioritize*** を呼び出すと、優先度による再開も可能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-588">However, priority resumption is also possible if the application calls ***tx_semaphore_prioritize*** prior to the semaphore put call that lifts thread suspension.</span></span> <span data-ttu-id="293a5-589">セマフォの優先度付けサービスでは、最も優先度の高いスレッドが中断リストの先頭に配置され、他の中断されたスレッドはすべて、同じ FIFO 順序のまま残ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-589">The semaphore prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="semaphore-put-notification"></a><span data-ttu-id="293a5-590">セマフォ put 通知</span><span class="sxs-lookup"><span data-stu-id="293a5-590">Semaphore Put Notification</span></span> 
<span data-ttu-id="293a5-591">アプリケーションによっては、セマフォが put されるたびに通知を受け取ると役立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-591">Some applications may find it advantageous to be notified whenever a semaphore is put.</span></span> <span data-ttu-id="293a5-592">ThreadX SMP では、*tx_semaphore_put_notify* サービスを介してこの機能が提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-592">ThreadX SMP provides this ability through the *tx_semaphore_put_notify* service.</span></span> <span data-ttu-id="293a5-593">このサービスは、指定されたアプリケーション通知関数を指定されたセマフォに登録します。</span><span class="sxs-lookup"><span data-stu-id="293a5-593">This service registers the supplied application notification function with the specified semaphore.</span></span> <span data-ttu-id="293a5-594">その後、セマフォが put されるたびに、このアプリケーション通知関数が ThreadX SMP によって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-594">ThreadX SMP will subsequently invoke this application notification function whenever the semaphore is put.</span></span> <span data-ttu-id="293a5-595">アプリケーション通知関数内の正確な処理は、アプリケーションによって決定されます。ただし、通常は、新しいセマフォ put イベントを処理するための適切なスレッドを再開することから成ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-595">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new semaphore put event.</span></span>

### <a name="semaphore-eventchaining"></a><span data-ttu-id="293a5-596">セマフォ イベントチェーン™</span><span class="sxs-lookup"><span data-stu-id="293a5-596">Semaphore Eventchaining™</span></span> 
<span data-ttu-id="293a5-597">ThreadX SMP の通知機能を試用して、さまざまな同期イベントを連結できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-597">The notification capabilities in ThreadX SMP can be used to chain various synchronization events together.</span></span> <span data-ttu-id="293a5-598">これは通常、1 つのスレッドで複数の同期イベントを処理する必要がある場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-598">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="293a5-599">たとえば、キュー メッセージ、イベント フラグ、セマフォに対して個別のスレッドを中断する代わりに、アプリケーションではオブジェクトごとに通知ルーチンを登録できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-599">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="293a5-600">呼び出されると、アプリケーション通知ルーチンでは次に、1 つのスレッドを再開できます。これにより、各オブジェクトを問い合わせて新しいイベントを検索および処理できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-600">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="293a5-601">一般的には、*イベント連結* によってスレッド、オーバーヘッド、RAM 要件が減少します。</span><span class="sxs-lookup"><span data-stu-id="293a5-601">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="293a5-602">より複雑なシステムの同期要件を処理するための、柔軟性が高いメカニズムも提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-602">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-semaphore-performance-information"></a><span data-ttu-id="293a5-603">実行時のセマフォ パフォーマンス情報</span><span class="sxs-lookup"><span data-stu-id="293a5-603">Run-time Semaphore Performance Information</span></span> 
<span data-ttu-id="293a5-604">ThreadX SMP では、実行時のセマフォ パフォーマンス情報がオプションで提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-604">ThreadX SMP provides optional run-time semaphore performance information.</span></span> <span data-ttu-id="293a5-605">ThreadX SMP ライブラリとアプリケーションが ***TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO*** を定義してビルドされている場合、ThreadX SMP では次の情報が蓄積されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-605">If the ThreadX SMP library and application is built with ***TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span> 

<span data-ttu-id="293a5-606">システム全体の合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-606">Total number for the overall system:</span></span>

- <span data-ttu-id="293a5-607">セマフォ put</span><span class="sxs-lookup"><span data-stu-id="293a5-607">semaphore puts</span></span>
- <span data-ttu-id="293a5-608">セマフォ get</span><span class="sxs-lookup"><span data-stu-id="293a5-608">semaphore gets</span></span>
- <span data-ttu-id="293a5-609">セマフォ get の中断</span><span class="sxs-lookup"><span data-stu-id="293a5-609">semaphore get suspensions</span></span>
- <span data-ttu-id="293a5-610">セマフォ get タイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-610">semaphore get timeouts</span></span>

<span data-ttu-id="293a5-611">セマフォごとの合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-611">Total number for each semaphore:</span></span>

- <span data-ttu-id="293a5-612">セマフォ put</span><span class="sxs-lookup"><span data-stu-id="293a5-612">semaphore puts</span></span>
- <span data-ttu-id="293a5-613">セマフォ get</span><span class="sxs-lookup"><span data-stu-id="293a5-613">semaphore gets</span></span>
- <span data-ttu-id="293a5-614">セマフォ get の中断</span><span class="sxs-lookup"><span data-stu-id="293a5-614">semaphore get suspensions</span></span>
- <span data-ttu-id="293a5-615">セマフォ get タイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-615">semaphore get timeouts</span></span>

<span data-ttu-id="293a5-616">この情報は、実行時にサービス *tx_semaphore_performance_info_get* および *tx_semaphore_performance_system_info_get* を通じて取得できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-616">This information is available at run-time through the services *tx_semaphore_performance_info_get* and *tx_semaphore_performance_system_info_get*.</span></span> <span data-ttu-id="293a5-617">セマフォ パフォーマンス情報は、アプリケーションが正しく動作しているかどうかを判断するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-617">Semaphore performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="293a5-618">アプリケーションの最適化にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-618">It is also useful in optimizing the application.</span></span> <span data-ttu-id="293a5-619">たとえば、"セマフォ get タイムアウト" が比較的多い場合は、他のスレッドによってリソースが長時間保持されていることを示唆している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-619">For example, a relatively high number of “semaphore get timeouts” might suggest that other threads are holding resources too long.</span></span>

### <a name="semaphore-control-block-tx_semaphore"></a><span data-ttu-id="293a5-620">セマフォ制御ブロック TX_SEMAPHORE</span><span class="sxs-lookup"><span data-stu-id="293a5-620">Semaphore Control Block TX_SEMAPHORE</span></span> 
<span data-ttu-id="293a5-621">各カウント セマフォの特性は、その制御ブロックにあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-621">The characteristics of each counting semaphore are found in its control block.</span></span> <span data-ttu-id="293a5-622">これには、セマフォの現在のカウントなどの情報が格納されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-622">It contains information such as the current semaphore count.</span></span> <span data-ttu-id="293a5-623">この構造体は ***tx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-623">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="293a5-624">セマフォ制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="293a5-624">Semaphore control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="deadly-embrace"></a><span data-ttu-id="293a5-625">破壊的な支配</span><span class="sxs-lookup"><span data-stu-id="293a5-625">Deadly Embrace</span></span> 
<span data-ttu-id="293a5-626">相互排他のために使用されるセマフォに関連する落とし穴のうち、最も興味深く危険なものの 1 つは、"*破壊的な支配*" です。</span><span class="sxs-lookup"><span data-stu-id="293a5-626">One of the most interesting and dangerous pitfalls associated with semaphores used for mutual exclusion is the *deadly embrace*.</span></span> <span data-ttu-id="293a5-627">破壊的な支配、つまり "*デッドロック*" とは、2 つ以上のスレッドが、既に互いに所有されているセマフォを get しようとして、無期限に中断される状態です。</span><span class="sxs-lookup"><span data-stu-id="293a5-627">A deadly embrace, or *deadlock*, is a condition in which two or more threads are suspended indefinitely while attempting to get semaphores already owned by each other.</span></span>

<span data-ttu-id="293a5-628">この状態は、2 つのスレッドと 2 つのセマフォの例で示すとよくわかります。</span><span class="sxs-lookup"><span data-stu-id="293a5-628">This condition is best illustrated by a two thread, two semaphore example.</span></span> <span data-ttu-id="293a5-629">1 つ目のスレッドが 1 つ目のセマフォを所有し、2 つ目のスレッドが 2 つ目のセマフォを所有しているとします。</span><span class="sxs-lookup"><span data-stu-id="293a5-629">Suppose the first thread owns the first semaphore and the second thread owns the second semaphore.</span></span> <span data-ttu-id="293a5-630">1 つ目のスレッドが 2 つ目のセマフォを get しようとしたときに、同時に 2 つ目のスレッドが 1 つ目のセマフォを get しようとすると、両方のスレッドがデッドロック状態になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-630">If the first thread attempts to get the second semaphore and at the same time the second thread attempts to get the first semaphore, both threads enter a deadlock condition.</span></span> <span data-ttu-id="293a5-631">さらに、これらのスレッドが無期限に中断されたままになると、関連付けられているリソースも無期限にロックアウトされます。</span><span class="sxs-lookup"><span data-stu-id="293a5-631">In addition, if these threads stay suspended forever, their associated resources are locked-out forever as well.</span></span> <span data-ttu-id="293a5-632">78 ページの図 7 は、この例を示しています。</span><span class="sxs-lookup"><span data-stu-id="293a5-632">Figure 7 on page 78 illustrates this example.</span></span>

![破壊的な支配](media/image10.png)

<span data-ttu-id="293a5-634">**図 7. 中断したスレッドの例**</span><span class="sxs-lookup"><span data-stu-id="293a5-634">**FIGURE 7. Example of Suspended Threads**</span></span>

<span data-ttu-id="293a5-635">リアルタイム システムでは、スレッドによるセマフォ獲得の方法に特定の制限を設けることによって、破壊的な支配を回避できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-635">For real-time systems, deadly embraces can be prevented by placing certain restrictions on how threads obtain semaphores.</span></span> <span data-ttu-id="293a5-636">スレッドで所有できるセマフォは一度に 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="293a5-636">Threads can only have one semaphore at a time.</span></span> <span data-ttu-id="293a5-637">または、スレッドで複数のセマフォを所有できるのは、それらを同じ順序で収集する場合です。</span><span class="sxs-lookup"><span data-stu-id="293a5-637">Alternatively, threads can own multiple semaphores if they gather them in the same order.</span></span> <span data-ttu-id="293a5-638">前の例では、1 つ目と 2 つ目のスレッドで、1 つ目と 2 つ目のセマフォを順に取得する場合、破壊的な支配は回避されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-638">In the previous example, if the first and second thread obtain the first and second semaphore in order, the deadly embrace is prevented.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-639">get 操作に関連付けられた中断タイムアウトを使用して、破壊的な支配から回復することもできます。</span><span class="sxs-lookup"><span data-stu-id="293a5-639">It is also possible to use the suspension time-out associated with the get operation to recover from a deadly embrace.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="293a5-640">優先度の逆転</span><span class="sxs-lookup"><span data-stu-id="293a5-640">Priority Inversion</span></span> 
<span data-ttu-id="293a5-641">相互排他セマフォに関連するもう 1 つの落とし穴は、優先度の逆転です。</span><span class="sxs-lookup"><span data-stu-id="293a5-641">Another pitfall associated with mutual exclusion semaphores is priority inversion.</span></span> <span data-ttu-id="293a5-642">このトピックについては、64 ページの「スレッド優先度の落とし穴」で詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="293a5-642">This topic is discussed more fully in “Thread Priority Pitfalls” on page 64.</span></span>

<span data-ttu-id="293a5-643">基本的な問題は、優先度の高いスレッドが必要とするセマフォが、優先度の低いスレッドに所有されている状況によって生じます。</span><span class="sxs-lookup"><span data-stu-id="293a5-643">The basic problem results from a situation in which a lower-priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="293a5-644">このこと自体は正常です。</span><span class="sxs-lookup"><span data-stu-id="293a5-644">This in itself is normal.</span></span> <span data-ttu-id="293a5-645">ただし、互いの間に優先度があるスレッドでは、優先度の逆転が際限なく続く場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-645">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="293a5-646">これには、スレッドの優先度を慎重に選択すること、プリエンプションしきい値を使用すること、および、リソースを所有しているスレッドの優先度を優先度の高いスレッドのものまで一時的に上げることで対処できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-646">This can be handled through careful selection of thread priorities, using preemption-threshold, and temporarily raising the priority of the thread that owns the resource to that of the high priority thread.</span></span>

## <a name="mutexes"></a><span data-ttu-id="293a5-647">ミューテックス</span><span class="sxs-lookup"><span data-stu-id="293a5-647">Mutexes</span></span>

<span data-ttu-id="293a5-648">セマフォに加えて、ThreadX SMP ではミューテックス オブジェクトも提供されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-648">In addition to semaphores, ThreadX SMP also provides a mutex object.</span></span> <span data-ttu-id="293a5-649">ミューテックスは基本的にはバイナリ セマフォです。したがって、一度に 1 つのスレッドのみがミューテックスを所有できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-649">A mutex is basically a binary semaphore, which means that only one thread can own a mutex at a time.</span></span> <span data-ttu-id="293a5-650">また、同じスレッドが、所有しているミューテックスに対してミューテックス get 操作を複数回、正常に実行することができます。正確には、4,294,967,295 回です。</span><span class="sxs-lookup"><span data-stu-id="293a5-650">In addition, the same thread may perform a successful mutex get operation on an owned mutex multiple times, 4,294,967,295 to be exact.</span></span> <span data-ttu-id="293a5-651">ミューテックス オブジェクトには 2 つの操作 ***tx_mutex_get** _ および _*_tx_mutex_put_\*\* があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-651">There are two operations on the mutex object: ***tx_mutex_get** _ and _*_tx_mutex_put_\*\*.</span></span> <span data-ttu-id="293a5-652">get 操作は、他のスレッドによって所有されていないミューテックスを獲得し、put 操作は、以前に獲得したミューテックスを解放します。</span><span class="sxs-lookup"><span data-stu-id="293a5-652">The get operation obtains a mutex not owned by another thread, while the put operation releases a previously obtained mutex.</span></span> <span data-ttu-id="293a5-653">スレッドでミューテックスを解放するには、put 操作の回数が前の get 操作の回数と同じである必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-653">For a thread to release a mutex, the number of put operations must equal the number of prior get operations.</span></span>

<span data-ttu-id="293a5-654">各ミューテックスはパブリック リソースです。</span><span class="sxs-lookup"><span data-stu-id="293a5-654">Each mutex is a public resource.</span></span> <span data-ttu-id="293a5-655">ThreadX SMP では、ミューテックスの使用方法に関する制約はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-655">ThreadX SMP places no constraints on how mutexes are used.</span></span>

<span data-ttu-id="293a5-656">ThreadX のミューテックスは "*相互排他*" のためだけに使用されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-656">ThreadX mutexes are used solely for *mutual exclusion*.</span></span> <span data-ttu-id="293a5-657">カウント セマフォとは異なり、ミューテックスはイベント通知の方法としては使用されません。</span><span class="sxs-lookup"><span data-stu-id="293a5-657">Unlike counting semaphores, mutexes have no use as a method for event notification.</span></span>

### <a name="mutex-mutual-exclusion"></a><span data-ttu-id="293a5-658">ミューテックス相互排他</span><span class="sxs-lookup"><span data-stu-id="293a5-658">Mutex Mutual Exclusion</span></span> 
<span data-ttu-id="293a5-659">カウント セマフォのセクションの説明と同様に、相互排他は、特定のアプリケーション領域 ("*クリティカル セクション*" や "*アプリケーション リソース*" とも呼ばれます) へのスレッドのアクセスを制御することに関連します。</span><span class="sxs-lookup"><span data-stu-id="293a5-659">Similar to the discussion in the counting semaphore section, mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="293a5-660">使用可能な場合、ThreadX SMP のミューテックスの所有権カウントは 0 になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-660">When available, a ThreadX SMP mutex will have an ownership count of 0.</span></span> <span data-ttu-id="293a5-661">ミューテックスがスレッドによって獲得された後は、ミューテックスに対して get 操作が正常に実行されるたびに所有権カウントが 1 回インクリメントされ、put 操作が正常に実行されるたびにデクリメントされます。</span><span class="sxs-lookup"><span data-stu-id="293a5-661">After the mutex is obtained by a thread, the ownership count is incremented once for every successful get operation performed on the mutex and decremented for every successful put operation.</span></span>

### <a name="creating-mutexes"></a><span data-ttu-id="293a5-662">ミューテックスの作成</span><span class="sxs-lookup"><span data-stu-id="293a5-662">Creating Mutexes</span></span> 
<span data-ttu-id="293a5-663">ThreadX SMP のミューテックスは、初期化中または実行時にアプリケーション スレッドによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-663">ThreadX SMP mutexes are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="293a5-664">ミューテックスの初期状態は常に "使用可能" です。</span><span class="sxs-lookup"><span data-stu-id="293a5-664">The initial condition of a mutex is always “available.”</span></span> <span data-ttu-id="293a5-665">また、"*優先度の継承*" を選択してミューテックスを作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="293a5-665">A mutex may also be created with *priority inheritance* selected.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="293a5-666">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="293a5-666">Thread Suspension</span></span> 
<span data-ttu-id="293a5-667">アプリケーション スレッドは、別のスレッドによって既に所有されているミューテックスに対して get 操作を実行しようとして中断することがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-667">Application threads can suspend while attempting to perform a get operation on a mutex already owned by another thread.</span></span>

<span data-ttu-id="293a5-668">所有側スレッドによって同じ数の put 操作が実行されると、中断されたスレッドの get 操作が実行され、ミューテックスの所有権が与えられ、スレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-668">After the same number of put operations are performed by the owning thread, the suspended thread’s get operation is performed, giving it ownership of the mutex, and the thread is resumed.</span></span> <span data-ttu-id="293a5-669">同じミューテックスで複数のスレッドが中断された場合、それらは中断されたのと同じ順序で再開されます (FIFO)。</span><span class="sxs-lookup"><span data-stu-id="293a5-669">If multiple threads are suspended on the same mutex, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="293a5-670">ただし、作成時にミューテックスの優先度の継承を選択した場合は、優先度による再開が自動的に行われます。</span><span class="sxs-lookup"><span data-stu-id="293a5-670">However, priority resumption is done automatically if the mutex priority inheritance was selected during creation.</span></span> <span data-ttu-id="293a5-671">アプリケーションで、スレッドの中断を解除するミューテックス put 呼び出しの前に ***tx_mutex_prioritize*** を呼び出すと、優先度による再開も可能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-671">Priority resumption is also possible if the application calls ***tx_mutex_prioritize*** prior to the mutex put call that lifts thread suspension.</span></span> <span data-ttu-id="293a5-672">ミューテックスの優先度付けサービスでは、最も優先度の高いスレッドが中断リストの先頭に配置され、他の中断されたスレッドはすべて、同じ FIFO 順序のまま残ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-672">The mutex prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-mutex-performance-information"></a><span data-ttu-id="293a5-673">実行時ミューテックスのパフォーマンス情報</span><span class="sxs-lookup"><span data-stu-id="293a5-673">Run-time Mutex Performance Information</span></span> 
<span data-ttu-id="293a5-674">ThreadX SMP では、実行時のミューテックス パフォーマンス情報がオプションで提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-674">ThreadX SMP provides optional run-time mutex performance information.</span></span> <span data-ttu-id="293a5-675">ThreadX SMP ライブラリとアプリケーションが ***TX_MUTEX_ENABLE_PERFORMANCE_INFO*** を定義してビルドされている場合、ThreadX SMP では次の情報が蓄積されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-675">If the ThreadX SMP library and application is built with ***TX_MUTEX_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="293a5-676">システム全体の合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-676">Total number for the overall system:</span></span>

- <span data-ttu-id="293a5-677">ミューテックス put</span><span class="sxs-lookup"><span data-stu-id="293a5-677">mutex puts</span></span>
- <span data-ttu-id="293a5-678">ミューテックス get</span><span class="sxs-lookup"><span data-stu-id="293a5-678">mutex gets</span></span>
- <span data-ttu-id="293a5-679">ミューテックス get の中断</span><span class="sxs-lookup"><span data-stu-id="293a5-679">mutex get suspensions</span></span>
- <span data-ttu-id="293a5-680">ミューテックス get タイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-680">mutex get timeouts</span></span>
- <span data-ttu-id="293a5-681">ミューテックス優先度逆転</span><span class="sxs-lookup"><span data-stu-id="293a5-681">mutex priority inversions</span></span>
- <span data-ttu-id="293a5-682">ミューテックス優先度継承</span><span class="sxs-lookup"><span data-stu-id="293a5-682">mutex priority inheritances</span></span>

<span data-ttu-id="293a5-683">ミューテックスごとの合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-683">Total number for each mutex:</span></span>

- <span data-ttu-id="293a5-684">ミューテックス put</span><span class="sxs-lookup"><span data-stu-id="293a5-684">mutex puts</span></span>
- <span data-ttu-id="293a5-685">ミューテックス get</span><span class="sxs-lookup"><span data-stu-id="293a5-685">mutex gets</span></span>
- <span data-ttu-id="293a5-686">ミューテックス get の中断</span><span class="sxs-lookup"><span data-stu-id="293a5-686">mutex get suspensions</span></span>
- <span data-ttu-id="293a5-687">ミューテックス get タイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-687">mutex get timeouts</span></span>
- <span data-ttu-id="293a5-688">ミューテックス優先度逆転</span><span class="sxs-lookup"><span data-stu-id="293a5-688">mutex priority inversions</span></span>
- <span data-ttu-id="293a5-689">ミューテックス優先度継承</span><span class="sxs-lookup"><span data-stu-id="293a5-689">mutex priority inheritances</span></span>

<span data-ttu-id="293a5-690">この情報は、実行時にサービス *tx_mutex_performance_info_get* および *tx_mutex_performance_system_info_get* を通じて取得できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-690">This information is available at run-time through the services *tx_mutex_performance_info_get* and *tx_mutex_performance_system_info_get*.</span></span> <span data-ttu-id="293a5-691">ミューテックス パフォーマンス情報は、アプリケーションが正しく動作しているかどうかを判断するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-691">Mutex performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="293a5-692">アプリケーションの最適化にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-692">It is also useful in optimizing the application.</span></span> <span data-ttu-id="293a5-693">たとえば、"ミューテックス get タイムアウト" が比較的多い場合は、他のスレッドによってリソースが長時間保持されていることを示唆している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-693">For example, a relatively high number of “mutex get timeouts” might suggest that other threads are holding resources too long.</span></span>

### <a name="mutex-control-block-tx_mutex"></a><span data-ttu-id="293a5-694">ミューテックス制御ブロック TX_MUTEX</span><span class="sxs-lookup"><span data-stu-id="293a5-694">Mutex Control Block TX_MUTEX</span></span> 
<span data-ttu-id="293a5-695">各ミューテックスの特性は、その制御ブロックにあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-695">The characteristics of each mutex are found in its control block.</span></span> <span data-ttu-id="293a5-696">これには、ミューテックスを所有しているスレッドのポインターと共に、ミューテックスの現在の所有権カウントなどの情報が含まれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-696">It contains information such as the current mutex ownership count along with the pointer of the thread that owns the mutex.</span></span> <span data-ttu-id="293a5-697">この構造体は ***tx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-697">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="293a5-698">ミューテックス制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="293a5-698">Mutex control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="293a5-699">破壊的な支配</span><span class="sxs-lookup"><span data-stu-id="293a5-699">Deadly Embrace</span></span>  
<span data-ttu-id="293a5-700">ミューテックスの所有権に関連する落とし穴のうち、最も興味深く危険なものの 1 つは、"*破壊的な支配*" です。</span><span class="sxs-lookup"><span data-stu-id="293a5-700">One of the most interesting and dangerous pitfalls associated with mutex ownership is the *deadly embrace*.</span></span> <span data-ttu-id="293a5-701">破壊的な支配、つまり "*デッドロック*" とは、2 つ以上のスレッドが、他のスレッドによって既に所有されているミューテックスを get しようとして、無期限に中断される状態です。</span><span class="sxs-lookup"><span data-stu-id="293a5-701">A deadly embrace, or *deadlock*, is a condition where two or more threads are suspended indefinitely while attempting to get a mutex already owned by the other threads.</span></span> <span data-ttu-id="293a5-702">77 ページにある "*破壊的な支配*" とその対処方法に関する説明は、ミューテックス オブジェクトに対しても完全に有効です。</span><span class="sxs-lookup"><span data-stu-id="293a5-702">The discussion of *deadly embrace* and its remedies found on page 77 is completely valid for the mutex object as well.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="293a5-703">優先度の逆転</span><span class="sxs-lookup"><span data-stu-id="293a5-703">Priority Inversion</span></span> 
<span data-ttu-id="293a5-704">前述のとおり、相互排他に関連する大きな落とし穴は、優先度の逆転です。</span><span class="sxs-lookup"><span data-stu-id="293a5-704">As mentioned previously, a major pitfall associated with mutual exclusion is priority inversion.</span></span> <span data-ttu-id="293a5-705">このトピックについては、64 ページの「スレッド優先度の落とし穴」で詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="293a5-705">This topic is discussed more fully in “Thread Priority Pitfalls” on page 64.</span></span> 

<span data-ttu-id="293a5-706">基本的な問題は、優先度の高いスレッドが必要とするセマフォが、優先度の低いスレッドに所有されている状況によって生じます。</span><span class="sxs-lookup"><span data-stu-id="293a5-706">The basic problem results from a situation in which a lower priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="293a5-707">このこと自体は正常です。</span><span class="sxs-lookup"><span data-stu-id="293a5-707">This in itself is normal.</span></span> <span data-ttu-id="293a5-708">ただし、互いの間に優先度があるスレッドでは、優先度の逆転が際限なく続く場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-708">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="293a5-709">前述のセマフォとは異なり、ThreadX SMP のミューテックス オブジェクトにはオプションの "*優先順位継承*" があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-709">Unlike semaphores discussed previously, the ThreadX SMP mutex object has optional *priority inheritance*.</span></span> <span data-ttu-id="293a5-710">優先度継承の背後にある基本的な考え方は、優先度の低いスレッドによって所有されているミューテックスを必要としている優先度の高いスレッドがあるとき、その優先度まで優先度の低いスレッドを一時的に引き上げることです。</span><span class="sxs-lookup"><span data-stu-id="293a5-710">The basic idea behind priority inheritance is that a lower priority thread has its priority raised temporarily to the priority of a high priority thread that wants the same mutex owned by the lower priority thread.</span></span> <span data-ttu-id="293a5-711">優先度の低いスレッドがミューテックスを解放すると、その優先度は元に戻り、優先度の高いスレッドにミューテックスの所有権が与えられます。</span><span class="sxs-lookup"><span data-stu-id="293a5-711">When the lower priority thread releases the mutex, its original priority is then restored and the higher priority thread is given ownership of the mutex.</span></span> <span data-ttu-id="293a5-712">この機能により、優先度の逆転時間は、優先度の低いスレッドがミューテックスを保持している時間に限られるため、不確定な優先度の逆転が排除されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-712">This feature eliminates nondeterministic priority inversion by bounding the amount of inversion to the time the lower priority thread holds the mutex.</span></span> <span data-ttu-id="293a5-713">もちろん、この章の前半で説明した、不確定な優先度の逆転に対処する手法も、ミューテックスでも有効です。</span><span class="sxs-lookup"><span data-stu-id="293a5-713">Of course, the techniques discussed earlier in this chapter to handle nondeterministic priority inversion are also valid with mutexes as well.</span></span>

## <a name="event-flags"></a><span data-ttu-id="293a5-714">イベント フラグ</span><span class="sxs-lookup"><span data-stu-id="293a5-714">Event Flags</span></span>

<span data-ttu-id="293a5-715">イベント フラグは、スレッドの同期のための強力なツールです。</span><span class="sxs-lookup"><span data-stu-id="293a5-715">Event flags provide a powerful tool for thread synchronization.</span></span> <span data-ttu-id="293a5-716">各イベント フラグは、1 つのビットで表されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-716">Each event flag is represented by a single bit.</span></span> <span data-ttu-id="293a5-717">イベント フラグは、32 個ずつのグループに編成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-717">Event flags are arranged in groups of 32.</span></span>

<span data-ttu-id="293a5-718">スレッドでは、グループ内の 32 個のイベント フラグすべてを同時に操作できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-718">Threads can operate on all 32 event flags in a group at the same time.</span></span> <span data-ttu-id="293a5-719">イベントは *tx_event_flags_set* で設定し、*tx_event_flags_get* で取得します。</span><span class="sxs-lookup"><span data-stu-id="293a5-719">Events are set by *tx_event_flags_set* and are retrieved by *tx_event_flags_get*.</span></span>

<span data-ttu-id="293a5-720">イベント フラグの設定は、現在のイベント フラグと新しいイベント フラグとの間で論理 AND/OR 演算を使用して行われます。</span><span class="sxs-lookup"><span data-stu-id="293a5-720">Setting event flags is done with a logical AND/OR operation between the current event flags and the new event flags.</span></span> <span data-ttu-id="293a5-721">論理演算の種類 (AND または OR) は、*tx_event_flags_set* の呼び出しで指定します。</span><span class="sxs-lookup"><span data-stu-id="293a5-721">The type of logical operation (either an AND or OR) is specified in the *tx_event_flags_set* call.</span></span>

<span data-ttu-id="293a5-722">イベント フラグの取得についても、類似の論理オプションがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-722">There are similar logical options for retrieval of event flags.</span></span> <span data-ttu-id="293a5-723">get 要求では、指定したすべてのイベント フラグが必要であることを指定できます (論理 AND)。</span><span class="sxs-lookup"><span data-stu-id="293a5-723">A get request can specify that all specified event flags are required (a logical AND).</span></span> <span data-ttu-id="293a5-724">また、get 要求では、指定したイベント フラグのどれであっても要求を満たすことを指定できます (論理 OR)。</span><span class="sxs-lookup"><span data-stu-id="293a5-724">Alternatively, a get request can specify that any of the specified event flags will satisfy the request (a logical OR).</span></span> <span data-ttu-id="293a5-725">イベント フラグの取得に関連する論理演算の種類は、*tx_event_flags_get* の呼び出しで指定します。</span><span class="sxs-lookup"><span data-stu-id="293a5-725">The type of logical operation associated with event flags retrieval is specified in the *tx_event_flags_get* call.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-726">get 要求を満たすイベント フラグは消費されます。つまり、要求で **TX_OR_CLEAR** または **TX_AND_CLEAR** が指定されている場合は 0 に設定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-726">Event flags that satisfy a get request are consumed, i.e., set to zero, if **TX_OR_CLEAR** or **TX_AND_CLEAR** are specified by the request.</span></span>

<span data-ttu-id="293a5-727">各イベント フラグ グループはパブリック リソースです。</span><span class="sxs-lookup"><span data-stu-id="293a5-727">Each event flags group is a public resource.</span></span> <span data-ttu-id="293a5-728">ThreadX SMP では、イベント フラグ グループの使用方法に関する制約はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-728">ThreadX SMP places no constraints on how event flags groups are used.</span></span>

### <a name="creating-event-flags-groups"></a><span data-ttu-id="293a5-729">イベント フラグ グループの作成</span><span class="sxs-lookup"><span data-stu-id="293a5-729">Creating Event Flags Groups</span></span>
<span data-ttu-id="293a5-730">イベント フラグ グループは、初期化中または実行時にアプリケーション スレッドによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-730">Event flags groups are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="293a5-731">作成時に、グループ内のすべてのイベント フラグが 0 に設定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-731">At the time of their creation, all event flags in the group are set to zero.</span></span> <span data-ttu-id="293a5-732">アプリケーションでのイベント フラグ グループの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-732">There is no limit on the number of event flags groups in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="293a5-733">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="293a5-733">Thread Suspension</span></span> 
<span data-ttu-id="293a5-734">アプリケーション スレッドは、イベント フラグの論理的な組み合わせをグループから取得しようとしている間、中断することがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-734">Application threads can suspend while attempting to get any logical combination of event flags from a group.</span></span> <span data-ttu-id="293a5-735">イベント フラグが設定されると、すべての中断されたスレッドの get 要求が確認されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-735">After an event flag is set, the get requests of all suspended threads are reviewed.</span></span> <span data-ttu-id="293a5-736">これで、必要なイベント フラグを取得できたすべてのスレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-736">All the threads that now have the required event flags are resumed.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-737">イベント フラグ グループで中断されているスレッドはすべて、そのイベント フラグが設定されたときに確認されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-737">All suspended threads on an event flags group are reviewed when its event flags are set.</span></span> <span data-ttu-id="293a5-738">もちろん、これには追加のオーバーヘッドが伴います。</span><span class="sxs-lookup"><span data-stu-id="293a5-738">This, of course, introduces additional overhead.</span></span> <span data-ttu-id="293a5-739">そのため、同じイベント フラグ グループを使用するスレッドの数を、妥当な数に制限することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="293a5-739">Therefore, it is good practice to limit the number of threads using the same event flags group to a reasonable number.</span></span>

### <a name="event-flags-set-notification"></a><span data-ttu-id="293a5-740">イベント フラグ設定通知</span><span class="sxs-lookup"><span data-stu-id="293a5-740">Event Flags Set Notification</span></span> 
<span data-ttu-id="293a5-741">アプリケーションによっては、イベント フラグが設定されるたびに通知を受け取ると役立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-741">Some applications may find it advantageous to be notified whenever an event flag is set.</span></span> <span data-ttu-id="293a5-742">ThreadX SMP では、*tx_event_flags_set_notify* サービスを介してこの機能が提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-742">ThreadX SMP provides this ability through the *tx_event_flags_set_notify* service.</span></span> <span data-ttu-id="293a5-743">このサービスは、指定されたアプリケーション通知関数を指定されたイベント フラグ グループに登録します。</span><span class="sxs-lookup"><span data-stu-id="293a5-743">This service registers the supplied application notification function with the specified event flags group.</span></span> <span data-ttu-id="293a5-744">その後、そのグループのイベント フラグが設定されるたびに、このアプリケーション通知関数が ThreadX SMP によって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-744">ThreadX SMP will subsequently invoke this application notification function whenever an event flag in the group is set.</span></span> <span data-ttu-id="293a5-745">アプリケーション通知関数内の正確な処理は、アプリケーションによって決定されます。ただし、通常は、新しいイベント フラグを処理するための適切なスレッドを再開することから成ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-745">The exact processing within the application notification function is determined by the application, but it typically consists of resuming the appropriate thread for processing the new event flag.</span></span> 

### <a name="event-flags-event-chaining"></a><span data-ttu-id="293a5-746">イベント フラグ イベントチェーン™</span><span class="sxs-lookup"><span data-stu-id="293a5-746">Event Flags Event-chaining™</span></span> 
<span data-ttu-id="293a5-747">ThreadX SMP の通知機能を試用して、さまざまな同期イベントを "連結" できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-747">The notification capabilities in ThreadX SMP can be used to “chain” various synchronization events together.</span></span> <span data-ttu-id="293a5-748">これは通常、1 つのスレッドで複数の同期イベントを処理する必要がある場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-748">This is typically useful when a single thread must process multiple synchronization events.</span></span> 

<span data-ttu-id="293a5-749">たとえば、キュー メッセージ、イベント フラグ、セマフォに対して個別のスレッドを中断する代わりに、アプリケーションではオブジェクトごとに通知ルーチンを登録できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-749">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="293a5-750">呼び出されると、アプリケーション通知ルーチンでは次に、1 つのスレッドを再開できます。これにより、各オブジェクトを問い合わせて新しいイベントを検索および処理できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-750">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span> 

<span data-ttu-id="293a5-751">一般的には、*イベント連結* によってスレッド、オーバーヘッド、RAM 要件が減少します。</span><span class="sxs-lookup"><span data-stu-id="293a5-751">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="293a5-752">より複雑なシステムの同期要件を処理するための、柔軟性が高いメカニズムも提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-752">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span> 

### <a name="run-time-event-flags-performance-information"></a><span data-ttu-id="293a5-753">実行時イベント フラグのパフォーマンス情報</span><span class="sxs-lookup"><span data-stu-id="293a5-753">Run-time Event Flags Performance Information</span></span> 
<span data-ttu-id="293a5-754">ThreadX SMP では、実行時のイベント フラグ パフォーマンス情報がオプションで提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-754">ThreadX SMP provides optional run-time event flags performance information.</span></span> <span data-ttu-id="293a5-755">ThreadX SMP ライブラリとアプリケーションが ***TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO*** を定義してビルドされている場合、ThreadX SMP では次の情報が蓄積されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-755">If the ThreadX SMP library and application is built with ***TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="293a5-756">システム全体の合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-756">Total number for the overall system:</span></span>

- <span data-ttu-id="293a5-757">イベント フラグ set</span><span class="sxs-lookup"><span data-stu-id="293a5-757">event flags sets</span></span>
- <span data-ttu-id="293a5-758">イベント フラグ get</span><span class="sxs-lookup"><span data-stu-id="293a5-758">event flags gets</span></span>
- <span data-ttu-id="293a5-759">イベント フラグ get の中断</span><span class="sxs-lookup"><span data-stu-id="293a5-759">event flags get suspensions</span></span>
- <span data-ttu-id="293a5-760">イベント フラグ get タイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-760">event flags get timeouts</span></span>

<span data-ttu-id="293a5-761">イベント フラグ グループごとの合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-761">Total number for each event flags group:</span></span>

- <span data-ttu-id="293a5-762">イベント フラグ set</span><span class="sxs-lookup"><span data-stu-id="293a5-762">event flags sets</span></span>
- <span data-ttu-id="293a5-763">イベント フラグ get</span><span class="sxs-lookup"><span data-stu-id="293a5-763">event flags gets</span></span>
- <span data-ttu-id="293a5-764">イベント フラグ get の中断</span><span class="sxs-lookup"><span data-stu-id="293a5-764">event flags get suspensions</span></span>
- <span data-ttu-id="293a5-765">イベント フラグ get タイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-765">event flags get timeouts</span></span>

<span data-ttu-id="293a5-766">この情報は、実行時にサービス *tx_event_flags_performance_info_get* および *tx_event_flags_performance_system_info_get* を通じて取得できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-766">This information is available at run-time through the services *tx_event_flags_performance_info_get* and *tx_event_flags_performance_system_info_get*.</span></span> <span data-ttu-id="293a5-767">イベント フラグのパフォーマンス情報は、アプリケーションが正しく動作しているかどうかを判断するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-767">Event Flags performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="293a5-768">アプリケーションの最適化にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-768">It is also useful in optimizing the application.</span></span> <span data-ttu-id="293a5-769">たとえば、*tx_event_flags_get* サービスでのタイムアウトが比較的多い場合は、イベント フラグの中断のタイムアウトが短すぎることを示唆している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-769">For example, a relatively high number of timeouts on the *tx_event_flags_get* service might suggest that the event flags suspension timeout is too short.</span></span>

### <a name="event-flags-group-control-block-tx_event_flags_group"></a><span data-ttu-id="293a5-770">イベント フラグ グループ制御ブロック TX_EVENT_FLAGS_GROUP</span><span class="sxs-lookup"><span data-stu-id="293a5-770">Event Flags Group Control Block TX_EVENT_FLAGS_GROUP</span></span>
<span data-ttu-id="293a5-771">各イベント フラグ グループの特性は、その制御ブロックにあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-771">The characteristics of each event flags group are found in its control block.</span></span> <span data-ttu-id="293a5-772">これには、現在のイベント フラグの設定や、イベントのために中断されたスレッドの数などの情報が格納されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-772">It contains information such as the current event flags settings and the number of threads suspended for events.</span></span> <span data-ttu-id="293a5-773">この構造体は ***tx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-773">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="293a5-774">イベント グループ制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="293a5-774">Event group control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

## <a name="memory-block-pools"></a><span data-ttu-id="293a5-775">メモリ ブロック プール</span><span class="sxs-lookup"><span data-stu-id="293a5-775">Memory Block Pools</span></span>  

<span data-ttu-id="293a5-776">メモリを高速かつ決定論的な方法で割り当てることは、常に、リアルタイム アプリケーションの課題です。</span><span class="sxs-lookup"><span data-stu-id="293a5-776">Allocating memory in a fast and deterministic manner is always a challenge in real-time applications.</span></span> <span data-ttu-id="293a5-777">これを念頭に置いて、ThreadX SMP では、固定サイズのメモリ ブロックの複数のプールを作成および管理する機能が提供されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-777">With this in mind, ThreadX SMP provides the ability to create and manage multiple pools of fixed-size memory blocks.</span></span>

<span data-ttu-id="293a5-778">メモリ ブロック プールは固定サイズのブロックで構成されているため、断片化の問題は発生しません。</span><span class="sxs-lookup"><span data-stu-id="293a5-778">Because memory block pools consist of fixed-size blocks, there are never any fragmentation problems.</span></span> <span data-ttu-id="293a5-779">もちろん、断片化によって本質的に非決定論的な動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-779">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="293a5-780">さらに、固定サイズのメモリ ブロックを割り当てて解放するために必要な時間は、単純なリンク リスト操作と同等です。</span><span class="sxs-lookup"><span data-stu-id="293a5-780">In addition, the time required to allocate and free a fixed-size memory block is comparable to that of simple linked-list manipulation.</span></span> <span data-ttu-id="293a5-781">さらに、使用可能な一覧の先頭でメモリ ブロックの割り当てと割り当て解除が行われます。</span><span class="sxs-lookup"><span data-stu-id="293a5-781">Furthermore, memory block allocation and de-allocation is done at the head of the available list.</span></span> <span data-ttu-id="293a5-782">これにより、リンク リストの処理が最速になり、実際のメモリ ブロックをキャッシュに保持するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-782">This provides the fastest possible linked list processing and might help keep the actual memory block in cache.</span></span>

<span data-ttu-id="293a5-783">固定サイズのメモリ プールの主な欠点は、柔軟性の欠如です。</span><span class="sxs-lookup"><span data-stu-id="293a5-783">Lack of flexibility is the main drawback of fixed-size memory pools.</span></span> <span data-ttu-id="293a5-784">プールのブロック サイズは、最悪ケースのユーザーのメモリ要件に対処できる十分な大きさにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-784">The block size of a pool must be large enough to handle the worst case memory requirements of its users.</span></span> <span data-ttu-id="293a5-785">もちろん、同じプールに対してさまざまなサイズのメモリ要求が行われた場合、メモリが浪費される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-785">Of course, memory may be wasted if many different size memory requests are made to the same pool.</span></span> <span data-ttu-id="293a5-786">解決策としては、サイズの異なるメモリ ブロックを含む複数のメモリ ブロック プールを作成することが考えられます。</span><span class="sxs-lookup"><span data-stu-id="293a5-786">A possible solution is to make several different memory block pools that contain different sized memory blocks.</span></span>

<span data-ttu-id="293a5-787">各メモリ ブロック プールはパブリック リソースです。</span><span class="sxs-lookup"><span data-stu-id="293a5-787">Each memory block pool is a public resource.</span></span> <span data-ttu-id="293a5-788">ThreadX SMP では、プールの使用方法に関する制約はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-788">ThreadX SMP places no constraints on how pools are used.</span></span>

### <a name="creating-memory-block-pools"></a><span data-ttu-id="293a5-789">メモリ ブロック プールの作成</span><span class="sxs-lookup"><span data-stu-id="293a5-789">Creating Memory Block Pools</span></span>  
<span data-ttu-id="293a5-790">メモリ ブロック プールは、初期化中または実行時にアプリケーション スレッドによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-790">Memory block pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="293a5-791">アプリケーションでのメモリ ブロック プールの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-791">There is no limit on the number of memory block pools in an application.</span></span>

### <a name="memory-block-size"></a><span data-ttu-id="293a5-792">メモリ ブロック サイズ</span><span class="sxs-lookup"><span data-stu-id="293a5-792">Memory Block Size</span></span>  
<span data-ttu-id="293a5-793">前述のとおり、メモリ ブロック プールには、いくつかの固定サイズのブロックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="293a5-793">As mentioned earlier, memory block pools contain a number of fixed-size blocks.</span></span> <span data-ttu-id="293a5-794">ブロック サイズは、プールの作成時にバイト単位で指定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-794">The block size, in bytes, is specified during creation of the pool.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-795">ThreadX SMP では、プール内の各メモリ ブロックに少量のオーバーヘッド (C ポインターのサイズ) が追加されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-795">ThreadX SMP adds a small amount of overhead— the size of a C pointer—to each memory block in the pool.</span></span> <span data-ttu-id="293a5-796">さらに、ThreadX SMP では、各メモリ ブロックの先頭を適切なアラインメントに保つために、ブロック サイズのパディングが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-796">In addition, ThreadX SMP might have to pad the block size to keep the beginning of each memory block on proper alignment.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="293a5-797">プールの容量</span><span class="sxs-lookup"><span data-stu-id="293a5-797">Pool Capacity</span></span> 
<span data-ttu-id="293a5-798">プール内のメモリ ブロック数は、ブロック サイズと、作成時に指定されたメモリ領域の合計バイト数の関数です。</span><span class="sxs-lookup"><span data-stu-id="293a5-798">The number of memory blocks in a pool is a function of the block size and the total number of bytes in the memory area supplied during creation.</span></span> <span data-ttu-id="293a5-799">プールの容量は、指定されたメモリ領域の合計バイト数を、ブロック サイズ (パディングとポインターのオーバーヘッド バイトを含む) で割ることによって計算されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-799">The capacity of a pool is calculated by dividing the block size (including padding and the pointer overhead bytes) into the total number of bytes in the supplied memory area.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="293a5-800">プールのメモリ領域</span><span class="sxs-lookup"><span data-stu-id="293a5-800">Pool’s Memory Area</span></span> 
<span data-ttu-id="293a5-801">前述のとおり、ブロック プールのメモリ領域は作成時に指定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-801">As mentioned before, the memory area for the block pool is specified during creation.</span></span> <span data-ttu-id="293a5-802">ThreadX SMP の他のメモリ領域と同様に、ターゲットのアドレス空間内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-802">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span>

<span data-ttu-id="293a5-803">非常に高い柔軟性が提供されるため、これは重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-803">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="293a5-804">たとえば、I/O 用に高速メモリ領域がある通信製品を考えます。</span><span class="sxs-lookup"><span data-stu-id="293a5-804">For example, suppose that a communication product has a highspeed memory area for I/O.</span></span> <span data-ttu-id="293a5-805">このメモリ領域を ThreadX SMP メモリ ブロック プール内に作成することで、この領域を簡単に管理できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-805">This memory area is easily managed by making it into a ThreadX SMP memory block pool.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="293a5-806">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="293a5-806">Thread Suspension</span></span> 
<span data-ttu-id="293a5-807">空のプールからのメモリ ブロックを待機している間に、アプリケーション スレッドが中断する場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-807">Application threads can suspend while waiting for a memory block from an empty pool.</span></span> <span data-ttu-id="293a5-808">ブロックがプールに返されると、中断されているスレッドにこのブロックが割り当てられ、スレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-808">When a block is returned to the pool, the suspended thread is given this block and the thread is resumed.</span></span>

<span data-ttu-id="293a5-809">同じメモリ ブロック プールで複数のスレッドが中断された場合、それらは中断された順序で再開されます (FIFO)。</span><span class="sxs-lookup"><span data-stu-id="293a5-809">If multiple threads are suspended on the same memory block pool, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="293a5-810">ただし、アプリケーションでは、スレッドの中断を解除するブロック解放呼び出しの前に ***tx_block_pool_prioritize*** を呼び出すと、優先度による再開も可能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-810">However, priority resumption is also possible if the application calls ***tx_block_pool_prioritize*** prior to the block release call that lifts thread suspension.</span></span> <span data-ttu-id="293a5-811">ブロック プールの優先度付けサービスでは、最も優先度の高いスレッドが中断リストの先頭に配置され、他の中断されたスレッドはすべて、同じ FIFO 順序のまま残ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-811">The block pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-block-pool-performance-information"></a><span data-ttu-id="293a5-812">実行時ブロック プールのパフォーマンス情報</span><span class="sxs-lookup"><span data-stu-id="293a5-812">Run-time Block Pool Performance Information</span></span>  
<span data-ttu-id="293a5-813">ThreadX SMP では、実行時のブロック プール パフォーマンス情報がオプションで提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-813">ThreadX SMP provides optional run-time block pool performance information.</span></span> <span data-ttu-id="293a5-814">ThreadX SMP ライブラリとアプリケーションが ***TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO*** を定義してビルドされている場合、ThreadX SMP では次の情報が蓄積されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-814">If the ThreadX SMP library and application is built with ***TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="293a5-815">システム全体の合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-815">Total number for the overall system:</span></span>

- <span data-ttu-id="293a5-816">割り当てられたブロック</span><span class="sxs-lookup"><span data-stu-id="293a5-816">blocks allocated</span></span>
- <span data-ttu-id="293a5-817">解放されたブロック</span><span class="sxs-lookup"><span data-stu-id="293a5-817">blocks released</span></span>
- <span data-ttu-id="293a5-818">割り当て中断</span><span class="sxs-lookup"><span data-stu-id="293a5-818">allocation suspensions</span></span>
- <span data-ttu-id="293a5-819">割り当てタイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-819">allocation timeouts</span></span>

<span data-ttu-id="293a5-820">ブロック プールごとの合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-820">Total number for each block pool:</span></span>

- <span data-ttu-id="293a5-821">割り当てられたブロック</span><span class="sxs-lookup"><span data-stu-id="293a5-821">blocks allocated</span></span>
- <span data-ttu-id="293a5-822">解放されたブロック</span><span class="sxs-lookup"><span data-stu-id="293a5-822">blocks released</span></span>
- <span data-ttu-id="293a5-823">割り当て中断</span><span class="sxs-lookup"><span data-stu-id="293a5-823">allocation suspensions</span></span>
- <span data-ttu-id="293a5-824">割り当てタイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-824">allocation timeouts</span></span>

<span data-ttu-id="293a5-825">この情報は、実行時にサービス *tx_block_pool_performance_info_get* および *tx_block_pool_performance_system_info_get* を通じて取得できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-825">This information is available at run-time through the services *tx_block_pool_performance_info_get* and *tx_block_pool_performance_system_info_get*.</span></span> <span data-ttu-id="293a5-826">ブロック プールのパフォーマンス情報は、アプリケーションが正しく動作しているかどうかを判断するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-826">Block pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="293a5-827">アプリケーションの最適化にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-827">It is also useful in optimizing the application.</span></span> <span data-ttu-id="293a5-828">たとえば、"割り当て中断" が比較的多い場合は、ブロック プールが小さすぎることを示唆している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-828">For example, a relatively high number of “allocation suspensions” might suggest that the block pool is too small.</span></span>

### <a name="memory-block-pool-control-block-tx_block_pool"></a><span data-ttu-id="293a5-829">メモリ ブロック プール制御ブロック TX_BLOCK_POOL</span><span class="sxs-lookup"><span data-stu-id="293a5-829">Memory Block Pool Control Block TX_BLOCK_POOL</span></span>  
<span data-ttu-id="293a5-830">各メモリ ブロック プールの特性は、その制御ブロックに含まれています。</span><span class="sxs-lookup"><span data-stu-id="293a5-830">The characteristics of each memory block pool are found in its control block.</span></span> <span data-ttu-id="293a5-831">これには、使用可能なメモリ ブロックの数や、メモリ プールのブロック サイズなどの情報が格納されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-831">It contains information such as the number of memory blocks available and the memory pool block size.</span></span> <span data-ttu-id="293a5-832">この構造体は ***tx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-832">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="293a5-833">プール制御ブロックは、メモリ内の任意の場所に配置することもできますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="293a5-833">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="293a5-834">メモリ ブロックの上書き</span><span class="sxs-lookup"><span data-stu-id="293a5-834">Overwriting Memory Blocks</span></span>  
<span data-ttu-id="293a5-835">割り当てられたメモリ ブロックのユーザーによって、その境界の外部に書き込まれないようにすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-835">It is important to ensure that the user of an allocated memory block does not write outside its boundaries.</span></span> <span data-ttu-id="293a5-836">これが発生すると、隣接する (通常は後続の) メモリ領域で破損が発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-836">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="293a5-837">結果は予測不可能で、多くの場合、致命的です。</span><span class="sxs-lookup"><span data-stu-id="293a5-837">The results are unpredictable and often fatal!</span></span> 

## <a name="memory-byte-pools"></a><span data-ttu-id="293a5-838">メモリ バイト プール</span><span class="sxs-lookup"><span data-stu-id="293a5-838">Memory Byte Pools</span></span>

<span data-ttu-id="293a5-839">ThreadX SMP のメモリ バイト プールは、標準 C ヒープに似ています。</span><span class="sxs-lookup"><span data-stu-id="293a5-839">ThreadX SMP memory byte pools are similar to a standard C heap.</span></span> <span data-ttu-id="293a5-840">標準 C ヒープとは異なり、複数のメモリ バイト プールを持つことが可能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-840">Unlike the standard C heap, it is possible to have multiple memory byte pools.</span></span> <span data-ttu-id="293a5-841">また、スレッドは、要求したメモリが使用可能になるまでプールで中断する可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-841">In addition, threads can suspend on a pool until the requested memory is available.</span></span>

<span data-ttu-id="293a5-842">メモリ バイト プールからの割り当ては、従来の *malloc* 呼び出しに似ています。これには、必要なメモリ量 (バイト単位) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="293a5-842">Allocations from memory byte pools are similar to traditional *malloc* calls, which include the amount of memory desired (in bytes).</span></span> <span data-ttu-id="293a5-843">プールからのメモリ割り当ては、"*first-fit*" の形式で行われます。つまり、要求を満たす最初の空きメモリ ブロックが使用されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-843">Memory is allocated from the pool in a *first-fit* manner; i.e., the first free memory block that satisfies the request is used.</span></span> <span data-ttu-id="293a5-844">このブロックの余剰メモリは、新しいブロックに変換され、空きメモリの一覧に戻されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-844">Excess memory from this block is converted into a new block and placed back in the free memory list.</span></span> <span data-ttu-id="293a5-845">このプロセスは "*断片化*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-845">This process is called *fragmentation*.</span></span>

<span data-ttu-id="293a5-846">以降の割り当てで十分な大きさの空きメモリ ブロックが検索されるときに、隣接する空きメモリ ブロックどうしが "*マージ*" されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-846">Adjacent free memory blocks are *merged* together during a subsequent allocation search for a large enough free memory block.</span></span> <span data-ttu-id="293a5-847">このプロセスは "*最適化*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-847">This process is called *de-fragmentation*.</span></span>

<span data-ttu-id="293a5-848">各メモリ バイト プールはパブリック リソースです。</span><span class="sxs-lookup"><span data-stu-id="293a5-848">Each memory byte pool is a public resource.</span></span> <span data-ttu-id="293a5-849">ThreadX SMP では、ISR からメモリ バイト サービスを呼び出すことができない点を除いて、プールの使用方法に関する制約はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-849">ThreadX SMP places no constraints on how pools are used, except that memory byte services cannot be called from ISRs.</span></span>

### <a name="creating-memory-byte-pools"></a><span data-ttu-id="293a5-850">メモリ バイト プールの作成</span><span class="sxs-lookup"><span data-stu-id="293a5-850">Creating Memory Byte Pools</span></span> 
<span data-ttu-id="293a5-851">メモリ バイト プールは、初期化中または実行時にアプリケーション スレッドによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-851">Memory byte pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="293a5-852">アプリケーションでのメモリ バイト プールの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-852">There is no limit on the number of memory byte pools in an application.</span></span>  

### <a name="pool-capacity"></a><span data-ttu-id="293a5-853">プールの容量</span><span class="sxs-lookup"><span data-stu-id="293a5-853">Pool Capacity</span></span> 
<span data-ttu-id="293a5-854">メモリ バイト プールの割り当て可能なバイト数は、作成時に指定した値より若干少なくなります。</span><span class="sxs-lookup"><span data-stu-id="293a5-854">The number of allocatable bytes in a memory byte pool is slightly less than what was specified during creation.</span></span> <span data-ttu-id="293a5-855">これは、空きメモリ領域の管理によってオーバーヘッドが若干発生するためです。</span><span class="sxs-lookup"><span data-stu-id="293a5-855">This is because management of the free memory area introduces some overhead.</span></span> <span data-ttu-id="293a5-856">プール内の各空きメモリ ブロックに、2 つの C ポインターに相当するオーバーヘッドが必要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-856">Each free memory block in the pool requires the equivalent of two C pointers of overhead.</span></span> <span data-ttu-id="293a5-857">また、プールは 2 つのブロックで作成されます。大きな空きブロックと、メモリ領域の末尾に永続的に割り当てられた小さなブロックです。</span><span class="sxs-lookup"><span data-stu-id="293a5-857">In addition, the pool is created with two blocks, a large free block and a small permanently allocated block at the end of the memory area.</span></span> <span data-ttu-id="293a5-858">この割り当てられたブロックは、割り当てアルゴリズムのパフォーマンスを向上させるために使用されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-858">This allocated block is used to improve performance of the allocation algorithm.</span></span> <span data-ttu-id="293a5-859">これにより、マージ中にプール領域の末尾を継続的にチェックする必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="293a5-859">It eliminates the need to continuously check for the end of the pool area during merging.</span></span>  

<span data-ttu-id="293a5-860">実行時には、通常、プールのオーバーヘッドの量が増加します。</span><span class="sxs-lookup"><span data-stu-id="293a5-860">During run-time, the amount of overhead in the pool typically increases.</span></span> <span data-ttu-id="293a5-861">奇数のバイト数の割り当てでは、次のメモリ ブロックの適切なアラインメントを保つためにパディングが行われます。</span><span class="sxs-lookup"><span data-stu-id="293a5-861">Allocations of an odd number of bytes are padded to ensure proper alignment of the next memory block.</span></span> <span data-ttu-id="293a5-862">さらに、プールの断片化が進むにつれて、オーバーヘッドが増加します。</span><span class="sxs-lookup"><span data-stu-id="293a5-862">In addition, overhead increases as the pool becomes more fragmented.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="293a5-863">プールのメモリ領域</span><span class="sxs-lookup"><span data-stu-id="293a5-863">Pool’s Memory Area</span></span>  
<span data-ttu-id="293a5-864">メモリ バイト プールのメモリ領域は、作成時に指定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-864">The memory area for a memory byte pool is specified during creation.</span></span> <span data-ttu-id="293a5-865">ThreadX SMP の他のメモリ領域と同様に、ターゲットのアドレス空間内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-865">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span> 

<span data-ttu-id="293a5-866">非常に高い柔軟性が提供されるため、これは重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-866">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="293a5-867">たとえば、ターゲット ハードウェアに高速メモリ領域と低速メモリ領域がある場合、ユーザーは、各領域にプールを作成することによって、両方の領域のメモリ割り当てを管理できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-867">For example, if the target hardware has a high-speed memory area and a low-speed memory area, the user can manage memory allocation for both areas by creating a pool in each of them.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="293a5-868">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="293a5-868">Thread Suspension</span></span>  
<span data-ttu-id="293a5-869">アプリケーション スレッドは、プールからのメモリ バイトを待機している間、中断することがあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-869">Application threads can suspend while waiting for memory bytes from a pool.</span></span> <span data-ttu-id="293a5-870">十分な連続したメモリが使用可能になると、中断されているスレッドにその要求したメモリが与えられ、スレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-870">When sufficient contiguous memory becomes available, the suspended threads are given their requested memory and the threads are resumed.</span></span> 

<span data-ttu-id="293a5-871">同じメモリ バイト プールで複数のスレッドが中断された場合、それらは中断された順序でメモリを付与 (再開) されます (FIFO)。</span><span class="sxs-lookup"><span data-stu-id="293a5-871">If multiple threads are suspended on the same memory byte pool, they are given memory (resumed) in the order they were suspended (FIFO).</span></span> 

<span data-ttu-id="293a5-872">ただし、アプリケーションでは、スレッドの中断を解除するバイト解放呼び出しの前に ***tx_byte_pool_prioritize*** を呼び出すと、優先度による再開も可能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-872">However, priority resumption is also possible if the application calls ***tx_byte_pool_prioritize*** prior to the byte release call that lifts thread suspension.</span></span> <span data-ttu-id="293a5-873">バイト プールの優先度付けサービスでは、最も優先度の高いスレッドが中断リストの先頭に配置され、他の中断されたスレッドはすべて、同じ FIFO 順序のまま残ります。</span><span class="sxs-lookup"><span data-stu-id="293a5-873">The byte pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-byte-pool-performance-information"></a><span data-ttu-id="293a5-874">実行時のバイト プール パフォーマンス情報</span><span class="sxs-lookup"><span data-stu-id="293a5-874">Run-time Byte Pool Performance Information</span></span>  
<span data-ttu-id="293a5-875">ThreadX SMP では、実行時のバイト プール パフォーマンス情報がオプションで提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-875">ThreadX SMP provides optional run-time byte pool performance information.</span></span> <span data-ttu-id="293a5-876">ThreadX SMP ライブラリとアプリケーションが ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** を定義してビルドされている場合、ThreadX SMP では次の情報が蓄積されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-876">If the ThreadX SMP library and application is built with ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="293a5-877">システム全体の合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-877">Total number for the overall system:</span></span>

- <span data-ttu-id="293a5-878">割り当て</span><span class="sxs-lookup"><span data-stu-id="293a5-878">allocations</span></span>
- <span data-ttu-id="293a5-879">リリース</span><span class="sxs-lookup"><span data-stu-id="293a5-879">releases</span></span>
- <span data-ttu-id="293a5-880">検索されたフラグメント</span><span class="sxs-lookup"><span data-stu-id="293a5-880">fragments searched</span></span>
- <span data-ttu-id="293a5-881">マージされたフラグメント</span><span class="sxs-lookup"><span data-stu-id="293a5-881">fragments merged</span></span>
- <span data-ttu-id="293a5-882">作成されたフラグメント</span><span class="sxs-lookup"><span data-stu-id="293a5-882">fragments created</span></span>
- <span data-ttu-id="293a5-883">割り当て中断</span><span class="sxs-lookup"><span data-stu-id="293a5-883">allocation suspensions</span></span>
- <span data-ttu-id="293a5-884">割り当てタイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-884">allocation timeouts</span></span>

<span data-ttu-id="293a5-885">バイト プールごとの合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-885">Total number for each byte pool:</span></span>

- <span data-ttu-id="293a5-886">割り当て</span><span class="sxs-lookup"><span data-stu-id="293a5-886">allocations</span></span>
- <span data-ttu-id="293a5-887">リリース</span><span class="sxs-lookup"><span data-stu-id="293a5-887">releases</span></span>
- <span data-ttu-id="293a5-888">検索されたフラグメント</span><span class="sxs-lookup"><span data-stu-id="293a5-888">fragments searched</span></span>
- <span data-ttu-id="293a5-889">マージされたフラグメント</span><span class="sxs-lookup"><span data-stu-id="293a5-889">fragments merged</span></span>
- <span data-ttu-id="293a5-890">作成されたフラグメント</span><span class="sxs-lookup"><span data-stu-id="293a5-890">fragments created</span></span>
- <span data-ttu-id="293a5-891">割り当て中断</span><span class="sxs-lookup"><span data-stu-id="293a5-891">allocation suspensions</span></span>
- <span data-ttu-id="293a5-892">割り当てタイムアウト</span><span class="sxs-lookup"><span data-stu-id="293a5-892">allocation timeouts</span></span>

<span data-ttu-id="293a5-893">この情報は、実行時にサービス *tx_byte_pool_performance_info_get* および *tx_byte_pool_performance_system_info_get* を通じて取得できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-893">This information is available at run-time through the services *tx_byte_pool_performance_info_get* and *tx_byte_pool_performance_system_info_get*.</span></span> <span data-ttu-id="293a5-894">バイト プールのパフォーマンス情報は、アプリケーションが正しく動作しているかどうかを判断するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-894">Byte pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="293a5-895">アプリケーションの最適化にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-895">It is also useful in optimizing the application.</span></span> <span data-ttu-id="293a5-896">たとえば、"割り当て中断" が比較的多い場合は、バイト プールが小さすぎることを示唆している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-896">For example, a relatively high number of “allocation suspensions” might suggest that the byte pool is too small.</span></span>

### <a name="memory-byte-pool-control-block-tx_byte_pool"></a><span data-ttu-id="293a5-897">メモリ バイト プール制御ブロック TX_BYTE_POOL</span><span class="sxs-lookup"><span data-stu-id="293a5-897">Memory Byte Pool Control Block TX_BYTE_POOL</span></span>  
<span data-ttu-id="293a5-898">各メモリ バイト プールの特性は、その制御ブロックに含まれています。</span><span class="sxs-lookup"><span data-stu-id="293a5-898">The characteristics of each memory byte pool are found in its control block.</span></span> <span data-ttu-id="293a5-899">これには、プールで使用可能なバイト数などの有用な情報が格納されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-899">It contains useful information such as the number of available bytes in the pool.</span></span> <span data-ttu-id="293a5-900">この構造体は ***tx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-900">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="293a5-901">プール制御ブロックは、メモリ内の任意の場所に配置することもできますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="293a5-901">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="nondeterministic-behavior"></a><span data-ttu-id="293a5-902">不確定な動作</span><span class="sxs-lookup"><span data-stu-id="293a5-902">Nondeterministic Behavior</span></span> 
<span data-ttu-id="293a5-903">メモリ バイト プールでは、最も柔軟性の高いメモリ割り当てが提供されますが、やや不確定な動作にも悩まされます。</span><span class="sxs-lookup"><span data-stu-id="293a5-903">Although memory byte pools provide the most flexible memory allocation, they also suffer from somewhat nondeterministic behavior.</span></span> <span data-ttu-id="293a5-904">たとえば、メモリ バイト プールに 2,000 バイトのメモリがあっても、1,000 バイトの割り当て要求を満たすことができない場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-904">For example, a memory byte pool may have 2,000 bytes of memory available but may not be able to satisfy an allocation request of 1,000 bytes.</span></span> <span data-ttu-id="293a5-905">これは、連続している空きバイトの数が保証されないためです。</span><span class="sxs-lookup"><span data-stu-id="293a5-905">This is because there are no guarantees on how many of the free bytes are contiguous.</span></span> <span data-ttu-id="293a5-906">1,000 バイトの空きブロックが存在する場合でも、そのブロックを見つけるのにどれだけの時間がかかるかは保証されません。</span><span class="sxs-lookup"><span data-stu-id="293a5-906">Even if a 1,000 byte free block exists, there are no guarantees on how long it might take to find the block.</span></span> <span data-ttu-id="293a5-907">1,000 バイトのブロックを見つけるために、メモリ プール全体を検索する必要がある場合もあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-907">It is completely possible that the entire memory pool would need to be searched to find the 1,000 byte block.</span></span> 

> [!IMPORTANT]
> <span data-ttu-id="293a5-908">このため、一般的には、確定的なリアルタイムの動作が必要な領域では、メモリ バイト サービスを使用しないようにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="293a5-908">Because of this, it is generally good practice to avoid using memory byte services in areas where deterministic, real-time behavior is required.</span></span> <span data-ttu-id="293a5-909">多くのアプリケーションでは、初期化中または実行時の構成中に、必要なメモリが事前に割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="293a5-909">Many applications pre-allocate their required memory during initialization or run-time configuration.</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="293a5-910">メモリ ブロックの上書き</span><span class="sxs-lookup"><span data-stu-id="293a5-910">Overwriting Memory Blocks</span></span> 
<span data-ttu-id="293a5-911">割り当てられたメモリのユーザーによって、その境界の外部に書き込まれないようにすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-911">It is important to ensure that the user of allocated memory does not write outside its boundaries.</span></span> <span data-ttu-id="293a5-912">これが発生すると、隣接する (通常は後続の) メモリ領域で破損が発生します。</span><span class="sxs-lookup"><span data-stu-id="293a5-912">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="293a5-913">結果は予測不可能で、多くの場合、致命的です。</span><span class="sxs-lookup"><span data-stu-id="293a5-913">The results are unpredictable and often fatal!</span></span> 

## <a name="application-timers"></a><span data-ttu-id="293a5-914">アプリケーション タイマー</span><span class="sxs-lookup"><span data-stu-id="293a5-914">Application Timers</span></span>

<span data-ttu-id="293a5-915">非同期外部イベントへの迅速な対応は、リアルタイム埋め込みアプリケーションの最も重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-915">Fast response to asynchronous external events is the most important function of real-time, embedded applications.</span></span> <span data-ttu-id="293a5-916">ただし、これらのアプリケーションの多くは、事前に決められた時間間隔で特定のアクティビティを実行する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-916">However, many of these applications must also perform certain activities at pre-determined intervals of time.</span></span>

<span data-ttu-id="293a5-917">ThreadX SMP のアプリケーション タイマーにより、特定の時間間隔でアプリケーション C 関数を実行する機能がアプリケーションに提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-917">ThreadX SMP application timers provide applications with the ability to execute application C functions at specific intervals of time.</span></span> <span data-ttu-id="293a5-918">アプリケーション タイマーが 1 回だけ時間切れになる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-918">It is also possible for an application timer to expire only once.</span></span> <span data-ttu-id="293a5-919">この種類のタイマーは "*ワンショット タイマー*" と呼ばれ、繰り返すインターバル タイマーは "*定期タイマー*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-919">This type of timer is called a *one-shot timer*, while repeating interval timers are called *periodic timers*.</span></span>

<span data-ttu-id="293a5-920">各アプリケーション タイマーはパブリック リソースです。</span><span class="sxs-lookup"><span data-stu-id="293a5-920">Each application timer is a public resource.</span></span> <span data-ttu-id="293a5-921">ThreadX SMP では、アプリケーション タイマーの使用方法に関する制約はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-921">ThreadX SMP places no constraints on how application timers are used.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-922">アプリケーション タイマーは、任意のコアで tx_timer_smp_core_exclude API を介して実行から除外できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-922">Application timers can be excluded from execution on any core via the tx_timer_smp_core_exclude API.</span></span>

### <a name="timer-intervals"></a><span data-ttu-id="293a5-923">タイマー間隔</span><span class="sxs-lookup"><span data-stu-id="293a5-923">Timer Intervals</span></span> 
<span data-ttu-id="293a5-924">ThreadX SMP の時間間隔は、周期的なタイマー割り込みによって測定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-924">In ThreadX SMP time intervals are measured by periodic timer interrupts.</span></span> <span data-ttu-id="293a5-925">各タイマー割り込みは、タイマー "*ティック*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-925">Each timer interrupt is called a timer *tick*.</span></span> <span data-ttu-id="293a5-926">タイマー ティック間の実際の時間はアプリケーションによって指定されますが、ほとんどの実装では 10 ミリ秒が標準です。</span><span class="sxs-lookup"><span data-stu-id="293a5-926">The actual time between timer ticks is specified by the application, but 10ms is the norm for most implementations.</span></span> <span data-ttu-id="293a5-927">定期タイマーの設定は、通常、***tx_initialize_low_level*** アセンブリ ファイルにあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-927">The periodic timer setup is typically found in the ***tx_initialize_low_level*** assembly file.</span></span>

<span data-ttu-id="293a5-928">アプリケーション タイマーが機能するためには、基になるハードウェアが周期的な割り込みを生成する機能を備えている必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="293a5-928">It is worth mentioning that the underlying hardware must have the ability to generate periodic interrupts for application timers to function.</span></span> <span data-ttu-id="293a5-929">場合によっては、プロセッサに周期的な割り込み機能が組み込まれていることもあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-929">In some cases, the processor has a built-in periodic interrupt capability.</span></span> <span data-ttu-id="293a5-930">プロセッサがこの機能を備えていない場合は、周期的な割り込みを生成できる周辺機器がユーザーのボードに搭載されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-930">If the processor doesn’t have this ability, the user’s board must have a peripheral device that can generate periodic interrupts.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="293a5-931">ThreadX SMP は、周期的な割り込みのソースがなくても機能します。</span><span class="sxs-lookup"><span data-stu-id="293a5-931">ThreadX SMP can still function even without a periodic interrupt source.</span></span> <span data-ttu-id="293a5-932">ただし、タイマーに関連するすべての処理が無効になります。</span><span class="sxs-lookup"><span data-stu-id="293a5-932">However, all timer-related processing is then disabled.</span></span> <span data-ttu-id="293a5-933">これには、タイム スライシング、中断タイムアウト、およびタイマー サービスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-933">This includes timeslicing, suspension time-outs, and timer services.</span></span>

### <a name="timer-accuracy"></a><span data-ttu-id="293a5-934">タイマー精度</span><span class="sxs-lookup"><span data-stu-id="293a5-934">Timer Accuracy</span></span> 
<span data-ttu-id="293a5-935">タイマーの有効期限は、ティックを単位として指定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-935">Timer expirations are specified in terms of ticks.</span></span> <span data-ttu-id="293a5-936">指定された有効期限の値は、タイマー ティックごとに 1 だけ減らされます。</span><span class="sxs-lookup"><span data-stu-id="293a5-936">The specified expiration value is decreased by one on each timer tick.</span></span> <span data-ttu-id="293a5-937">タイマー割り込み (つまりタイマー ティック) の直前にアプリケーション タイマーを有効にすることもできるため、実際の期限切れは最大 1 ティック早くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-937">Because an application timer could be enabled just prior to a timer interrupt (or timer tick), the actual expiration time could be up to one tick early.</span></span>

<span data-ttu-id="293a5-938">タイマー ティックの速度が 10 ミリ秒である場合、アプリケーション タイマーは最大 10 ミリ秒早く期限切れになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-938">If the timer tick rate is 10ms, application timers may expire up to 10ms early.</span></span> <span data-ttu-id="293a5-939">これには、1 秒タイマーよりも 10 ミリ秒タイマーの方が大きな影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="293a5-939">This is more significant for 10ms timers than 1 second timers.</span></span> <span data-ttu-id="293a5-940">もちろん、タイマー割り込みの頻度を高くすると、このような誤差の範囲は減少します。</span><span class="sxs-lookup"><span data-stu-id="293a5-940">Of course, increasing the timer interrupt frequency decreases this margin of error.</span></span>

### <a name="timer-execution"></a><span data-ttu-id="293a5-941">タイマー実行</span><span class="sxs-lookup"><span data-stu-id="293a5-941">Timer Execution</span></span> 
<span data-ttu-id="293a5-942">アプリケーション タイマーは、アクティブになった順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-942">Application timers execute in the order they become active.</span></span> <span data-ttu-id="293a5-943">たとえば、3 つのタイマーが同じ有効期限値で作成され、アクティブ化された場合、対応する有効期限関数は、アクティブ化された順序で実行されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-943">For example, if three timers are created with the same expiration value and activated, their corresponding expiration functions are guaranteed to execute in the order they were activated.</span></span> 

### <a name="creating-application-timers"></a><span data-ttu-id="293a5-944">アプリケーション タイマーの作成</span><span class="sxs-lookup"><span data-stu-id="293a5-944">Creating Application Timers</span></span> 
<span data-ttu-id="293a5-945">アプリケーション タイマーは、初期化中または実行時にアプリケーション スレッドによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-945">Application timers are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="293a5-946">アプリケーションでのアプリケーション タイマーの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-946">There is no limit on the number of application timers in an application.</span></span> 

### <a name="run-time-application-timer-performance-information"></a><span data-ttu-id="293a5-947">実行時のアプリケーション タイマー パフォーマンス情報</span><span class="sxs-lookup"><span data-stu-id="293a5-947">Run-time Application Timer Performance Information</span></span>  
<span data-ttu-id="293a5-948">ThreadX SMP では、実行時のアプリケーション タイマー パフォーマンス情報がオプションで提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-948">ThreadX SMP provides optional run-time application timer performance information.</span></span> <span data-ttu-id="293a5-949">ThreadX SMP ライブラリとアプリケーションが ***TX_TIMER_ENABLE_PERFORMANCE_INFO*** を定義してビルドされている場合、ThreadX SMP では次の情報が蓄積されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-949">If the ThreadX SMP library and application are built with ***TX_TIMER_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span> 

<span data-ttu-id="293a5-950">システム全体の合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-950">Total number for the overall system:</span></span>

- <span data-ttu-id="293a5-951">アクティブ化</span><span class="sxs-lookup"><span data-stu-id="293a5-951">activations</span></span>
- <span data-ttu-id="293a5-952">非アクティブ化</span><span class="sxs-lookup"><span data-stu-id="293a5-952">deactivations</span></span>
- <span data-ttu-id="293a5-953">再アクティブ化 (定期タイマー)</span><span class="sxs-lookup"><span data-stu-id="293a5-953">reactivations (periodic timers)</span></span>
- <span data-ttu-id="293a5-954">expirations</span><span class="sxs-lookup"><span data-stu-id="293a5-954">expirations</span></span>
- <span data-ttu-id="293a5-955">有効期限調整</span><span class="sxs-lookup"><span data-stu-id="293a5-955">expiration adjustments</span></span>

<span data-ttu-id="293a5-956">アプリケーション タイマーごとの合計数:</span><span class="sxs-lookup"><span data-stu-id="293a5-956">Total number for each application timer:</span></span>

- <span data-ttu-id="293a5-957">アクティブ化</span><span class="sxs-lookup"><span data-stu-id="293a5-957">activations</span></span>
- <span data-ttu-id="293a5-958">非アクティブ化</span><span class="sxs-lookup"><span data-stu-id="293a5-958">deactivations</span></span>
- <span data-ttu-id="293a5-959">再アクティブ化 (定期タイマー)</span><span class="sxs-lookup"><span data-stu-id="293a5-959">reactivations (periodic timers)</span></span>
- <span data-ttu-id="293a5-960">expirations</span><span class="sxs-lookup"><span data-stu-id="293a5-960">expirations</span></span>
- <span data-ttu-id="293a5-961">有効期限調整</span><span class="sxs-lookup"><span data-stu-id="293a5-961">expiration adjustments</span></span>

<span data-ttu-id="293a5-962">この情報は、実行時にサービス *tx_timer_performance_info_get* および *tx_timer_performance_system_info_get* を通じて取得できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-962">This information is available at run-time through the services *tx_timer_performance_info_get* and *tx_timer_performance_system_info_get*.</span></span> <span data-ttu-id="293a5-963">アプリケーション タイマーのパフォーマンス情報は、アプリケーションが正しく動作しているかどうかを判断するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-963">Application Timer performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="293a5-964">アプリケーションの最適化にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="293a5-964">It is also useful in optimizing the application.</span></span>

### <a name="application-timer-control-block-tx_timer"></a><span data-ttu-id="293a5-965">アプリケーション タイマー制御ブロック TX_TIMER</span><span class="sxs-lookup"><span data-stu-id="293a5-965">Application Timer Control Block TX_TIMER</span></span> 
<span data-ttu-id="293a5-966">各アプリケーション タイマーの特性は、その制御ブロックにあります。</span><span class="sxs-lookup"><span data-stu-id="293a5-966">The characteristics of each application timer are found in its control block.</span></span> <span data-ttu-id="293a5-967">これには、32 ビットの有効期限識別値などの有用な情報が格納されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-967">It contains useful information such as the 32-bit expiration identification value.</span></span> <span data-ttu-id="293a5-968">この構造体は ***tx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-968">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="293a5-969">アプリケーション タイマー制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="293a5-969">Application timer control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="excessive-timers"></a><span data-ttu-id="293a5-970">過剰なタイマー</span><span class="sxs-lookup"><span data-stu-id="293a5-970">Excessive Timers</span></span> 
<span data-ttu-id="293a5-971">既定では、アプリケーション タイマーは、優先度 0 で実行される隠しシステム スレッド内から実行されます。これは通常、どのアプリケーション スレッドよりも高くなります。</span><span class="sxs-lookup"><span data-stu-id="293a5-971">By default, application timers execute from within a hidden system thread that runs at priority zero, which is typically higher than any application thread.</span></span> <span data-ttu-id="293a5-972">このため、アプリケーション タイマー内の処理は最小限に抑える必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-972">Because of this, processing inside application timers should be kept to a minimum.</span></span> 

<span data-ttu-id="293a5-973">また、可能な限り、タイマー ティックごとに期限切れになるタイマーを回避することも重要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-973">It is also important to avoid, whenever possible, timers that expire every timer tick.</span></span> <span data-ttu-id="293a5-974">このような状況では、アプリケーションで過剰なオーバーヘッドが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-974">Such a situation might induce excessive overhead in the application.</span></span>

> [!WARNING]
> <span data-ttu-id="293a5-975">前述のように、アプリケーション タイマーは、隠しシステム スレッドから実行されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-975">As mentioned previously, application timers are executed from a hidden system thread.</span></span> <span data-ttu-id="293a5-976">したがって、アプリケーション タイマーの有効期限関数内から行われる ThreadX SMP サービスの呼び出しでは、中断を選択しないことが重要です。</span><span class="sxs-lookup"><span data-stu-id="293a5-976">It is, therefore, important not to select suspension on any ThreadX SMP service calls made from within the application timer’s expiration function.</span></span>

## <a name="relative-time"></a><span data-ttu-id="293a5-977">相対時間</span><span class="sxs-lookup"><span data-stu-id="293a5-977">Relative Time</span></span>

<span data-ttu-id="293a5-978">前述のアプリケーション タイマーに加えて、ThreadX SMP には、継続的にインクリメントする 32 ビットのティック カウンターが 1 つ用意されています。</span><span class="sxs-lookup"><span data-stu-id="293a5-978">In addition to the application timers mentioned previously, ThreadX SMP provides a single continuously incrementing 32-bit tick counter.</span></span> <span data-ttu-id="293a5-979">ティック カウンターつまり "*時間*" は、タイマー割り込みごとに 1 ずつ増加します。</span><span class="sxs-lookup"><span data-stu-id="293a5-979">The tick counter or *time* is increased by one on each timer interrupt.</span></span>

<span data-ttu-id="293a5-980">アプリケーションでは、それぞれ *tx_time_get* および *tx_time_set* の呼び出しを通じて、この 32 ビット カウンターを読み取りまたは設定できます。</span><span class="sxs-lookup"><span data-stu-id="293a5-980">The application can read or set this 32-bit counter through calls to *tx_time_get* and *tx_time_set*, respectively.</span></span> <span data-ttu-id="293a5-981">このティック カウンターの使用は、全面的にアプリケーションによって決定されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-981">The use of this tick counter is determined completely by the application.</span></span> <span data-ttu-id="293a5-982">ThreadX SMP によって内部的に使用されることはありません。</span><span class="sxs-lookup"><span data-stu-id="293a5-982">It is not used internally by ThreadX SMP.</span></span>

### <a name="interrupts"></a><span data-ttu-id="293a5-983">割り込み</span><span class="sxs-lookup"><span data-stu-id="293a5-983">Interrupts</span></span> 
<span data-ttu-id="293a5-984">非同期イベントへの迅速な対応は、リアルタイム埋め込みアプリケーションの主要な機能です。</span><span class="sxs-lookup"><span data-stu-id="293a5-984">Fast response to asynchronous events is the principal function of real-time, embedded applications.</span></span> <span data-ttu-id="293a5-985">アプリケーションでは、そのようなイベントが存在することをハードウェア割り込みによって認識します。</span><span class="sxs-lookup"><span data-stu-id="293a5-985">The application knows such an event is present through hardware interrupts.</span></span> 

<span data-ttu-id="293a5-986">割り込みは、プロセッサの実行の非同期的な変更です。</span><span class="sxs-lookup"><span data-stu-id="293a5-986">An interrupt is an asynchronous change in processor execution.</span></span> <span data-ttu-id="293a5-987">通常、割り込みが発生すると、プロセッサは、現在の実行の小さな部分をスタック上に保存し、該当する割り込みベクターに制御を移します。</span><span class="sxs-lookup"><span data-stu-id="293a5-987">Typically, when an interrupt occurs, the processor saves a small portion of the current execution on the stack and transfers control to the appropriate interrupt vector.</span></span> <span data-ttu-id="293a5-988">割り込みベクターは、基本的に、特定の種類の割り込みを処理するルーチンのアドレスにすぎません。</span><span class="sxs-lookup"><span data-stu-id="293a5-988">The interrupt vector is basically just the address of the routine responsible for handling the specific type interrupt.</span></span> <span data-ttu-id="293a5-989">正確な割り込み処理手順は、プロセッサに固有のものです。</span><span class="sxs-lookup"><span data-stu-id="293a5-989">The exact interrupt handling procedure is processor specific.</span></span> 

### <a name="interrupt-control"></a><span data-ttu-id="293a5-990">割り込み制御</span><span class="sxs-lookup"><span data-stu-id="293a5-990">Interrupt Control</span></span> 
<span data-ttu-id="293a5-991">*tx_interrupt_control* サービスを使用すると、アプリケーションで割り込みを有効または無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="293a5-991">The *tx_interrupt_control* service allows applications to enable and disable interrupts.</span></span> <span data-ttu-id="293a5-992">このサービスによって、前の割り込み有効/無効の状態が返されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-992">The previous interrupt enable/disable posture is returned by this service.</span></span> <span data-ttu-id="293a5-993">割り込み制御は現在実行中のプログラム セグメントにのみ影響することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="293a5-993">It is important to mention that interrupt control only affects the currently executing program segment.</span></span> <span data-ttu-id="293a5-994">たとえば、あるスレッドで割り込みを無効にした場合は、そのスレッドの実行中にのみ無効のままになります。</span><span class="sxs-lookup"><span data-stu-id="293a5-994">For example, if a thread disables interrupts, they only remain disabled during execution of that thread.</span></span> 

> [!WARNING]
> <span data-ttu-id="293a5-995">マスク不可能割り込み (NMI) は、ハードウェアによって無効にできない割り込みです。</span><span class="sxs-lookup"><span data-stu-id="293a5-995">A Non-Maskable Interrupt (NMI) is an interrupt that cannot be disabled by the hardware.</span></span> <span data-ttu-id="293a5-996">このような割り込みは、ThreadX SMP アプリケーションによって使用される場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-996">Such an interrupt may be used by ThreadX SMP applications.</span></span> <span data-ttu-id="293a5-997">ただし、アプリケーションの NMI 処理ルーチンは、ThreadX SMP のコンテキスト管理または何らかの API サービスを使用することを許可されていません。</span><span class="sxs-lookup"><span data-stu-id="293a5-997">However, the application’s NMI handling routine is not allowed to use ThreadX SMP context management or any API services.</span></span> <span data-ttu-id="293a5-998">ThreadX SMP マネージド割り込み</span><span class="sxs-lookup"><span data-stu-id="293a5-998">ThreadX SMP Managed Interrupts</span></span>

<span data-ttu-id="293a5-999">ThreadX SMP により、アプリケーションに完全な割り込み管理が提供されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-999">ThreadX SMP provides applications with complete interrupt management.</span></span> <span data-ttu-id="293a5-1000">この管理には、割り込まれた実行のコンテキストの保存と復元が含まれます。</span><span class="sxs-lookup"><span data-stu-id="293a5-1000">This management includes saving and restoring the context of the interrupted execution.</span></span> <span data-ttu-id="293a5-1001">さらに、ThreadX SMP では、割り込みサービス ルーチン (ISR) 内から特定のサービスを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="293a5-1001">In addition, ThreadX SMP allows certain services to be called from within Interrupt Service Routines (ISRs).</span></span> <span data-ttu-id="293a5-1002">アプリケーションの ISR から許可されている ThreadX SMP サービスの一覧を次に示します。</span><span class="sxs-lookup"><span data-stu-id="293a5-1002">The following is a list of ThreadX SMPservices allowed from application ISRs:</span></span>

- <span data-ttu-id="293a5-1003">tx_block_allocate</span><span class="sxs-lookup"><span data-stu-id="293a5-1003">tx_block_allocate</span></span> 
- <span data-ttu-id="293a5-1004">tx_block_pool_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1004">tx_block_pool_info_get</span></span> 
- <span data-ttu-id="293a5-1005">tx_block_pool_prioritize</span><span class="sxs-lookup"><span data-stu-id="293a5-1005">tx_block_pool_prioritize</span></span> 
- <span data-ttu-id="293a5-1006">tx_block_pool_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1006">tx_block_pool_performance_info_get</span></span> 
- <span data-ttu-id="293a5-1007">tx_block_pool_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1007">tx_block_pool_performance_system_info_get</span></span> 
- <span data-ttu-id="293a5-1008">tx_block_release</span><span class="sxs-lookup"><span data-stu-id="293a5-1008">tx_block_release</span></span> 
- <span data-ttu-id="293a5-1009">tx_byte_pool_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1009">tx_byte_pool_info_get</span></span> 
- <span data-ttu-id="293a5-1010">tx_byte_pool_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1010">tx_byte_pool_performance_info_get</span></span> 
- <span data-ttu-id="293a5-1011">tx_byte_pool_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1011">tx_byte_pool_performance_system_info_get</span></span> 
- <span data-ttu-id="293a5-1012">tx_byte_pool_prioritize</span><span class="sxs-lookup"><span data-stu-id="293a5-1012">tx_byte_pool_prioritize</span></span> 
- <span data-ttu-id="293a5-1013">tx_event_flags_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1013">tx_event_flags_info_get</span></span> 
- <span data-ttu-id="293a5-1014">tx_event_flags_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1014">tx_event_flags_get</span></span> 
- <span data-ttu-id="293a5-1015">tx_event_flags_set</span><span class="sxs-lookup"><span data-stu-id="293a5-1015">tx_event_flags_set</span></span> 
- <span data-ttu-id="293a5-1016">tx_event_flags_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1016">tx_event_flags_performance_info_get</span></span> 
- <span data-ttu-id="293a5-1017">tx_event_flags_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1017">tx_event_flags_performance_system_info_get</span></span> 
- <span data-ttu-id="293a5-1018">tx_event_flags_set_notify</span><span class="sxs-lookup"><span data-stu-id="293a5-1018">tx_event_flags_set_notify</span></span> 
- <span data-ttu-id="293a5-1019">tx_interrupt_control</span><span class="sxs-lookup"><span data-stu-id="293a5-1019">tx_interrupt_control</span></span> 
- <span data-ttu-id="293a5-1020">tx_mutex_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1020">tx_mutex_performance_info_get</span></span> 
- <span data-ttu-id="293a5-1021">tx_mutex_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1021">tx_mutex_performance_system_info_get</span></span> 
- <span data-ttu-id="293a5-1022">tx_queue_front_send</span><span class="sxs-lookup"><span data-stu-id="293a5-1022">tx_queue_front_send</span></span> 
- <span data-ttu-id="293a5-1023">tx_queue_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1023">tx_queue_info_get</span></span> 
- <span data-ttu-id="293a5-1024">tx_queue_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1024">tx_queue_performance_info_get</span></span> 
- <span data-ttu-id="293a5-1025">tx_queue_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1025">tx_queue_performance_system_info_get</span></span> 
- <span data-ttu-id="293a5-1026">tx_queue_prioritize</span><span class="sxs-lookup"><span data-stu-id="293a5-1026">tx_queue_prioritize</span></span> 
- <span data-ttu-id="293a5-1027">tx_queue_receive</span><span class="sxs-lookup"><span data-stu-id="293a5-1027">tx_queue_receive</span></span> 
- <span data-ttu-id="293a5-1028">tx_queue_send</span><span class="sxs-lookup"><span data-stu-id="293a5-1028">tx_queue_send</span></span> 
- <span data-ttu-id="293a5-1029">tx_semaphore_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1029">tx_semaphore_get</span></span> 
- <span data-ttu-id="293a5-1030">tx_queue_send_notify</span><span class="sxs-lookup"><span data-stu-id="293a5-1030">tx_queue_send_notify</span></span> 
- <span data-ttu-id="293a5-1031">tx_semaphore_ceiling_put</span><span class="sxs-lookup"><span data-stu-id="293a5-1031">tx_semaphore_ceiling_put</span></span> 
- <span data-ttu-id="293a5-1032">tx_semaphore_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1032">tx_semaphore_info_get</span></span> 
- <span data-ttu-id="293a5-1033">tx_semaphore_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1033">tx_semaphore_performance_info_get</span></span> 
- <span data-ttu-id="293a5-1034">tx_semaphore_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1034">tx_semaphore_performance_system_info_get</span></span> 
- <span data-ttu-id="293a5-1035">tx_semaphore_prioritize</span><span class="sxs-lookup"><span data-stu-id="293a5-1035">tx_semaphore_prioritize</span></span> 
- <span data-ttu-id="293a5-1036">tx_semaphore_put</span><span class="sxs-lookup"><span data-stu-id="293a5-1036">tx_semaphore_put</span></span> 
- <span data-ttu-id="293a5-1037">tx_thread_identify</span><span class="sxs-lookup"><span data-stu-id="293a5-1037">tx_thread_identify</span></span> 
- <span data-ttu-id="293a5-1038">tx_semaphore_put_notify</span><span class="sxs-lookup"><span data-stu-id="293a5-1038">tx_semaphore_put_notify</span></span> 
- <span data-ttu-id="293a5-1039">tx_thread_entry_exit_notify</span><span class="sxs-lookup"><span data-stu-id="293a5-1039">tx_thread_entry_exit_notify</span></span> 
- <span data-ttu-id="293a5-1040">tx_thread_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1040">tx_thread_info_get</span></span> 
- <span data-ttu-id="293a5-1041">tx_thread_resume</span><span class="sxs-lookup"><span data-stu-id="293a5-1041">tx_thread_resume</span></span> 
- <span data-ttu-id="293a5-1042">tx_thread_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1042">tx_thread_performance_info_get</span></span> 
- <span data-ttu-id="293a5-1043">tx_thread_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1043">tx_thread_performance_system_info_get</span></span> 
- <span data-ttu-id="293a5-1044">tx_thread_stack_error_notify</span><span class="sxs-lookup"><span data-stu-id="293a5-1044">tx_thread_stack_error_notify</span></span> 
- <span data-ttu-id="293a5-1045">tx_thread_wait_abort</span><span class="sxs-lookup"><span data-stu-id="293a5-1045">tx_thread_wait_abort</span></span> 
- <span data-ttu-id="293a5-1046">tx_time_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1046">tx_time_get</span></span> 
- <span data-ttu-id="293a5-1047">tx_time_set</span><span class="sxs-lookup"><span data-stu-id="293a5-1047">tx_time_set</span></span> 
- <span data-ttu-id="293a5-1048">tx_timer_activate</span><span class="sxs-lookup"><span data-stu-id="293a5-1048">tx_timer_activate</span></span> 
- <span data-ttu-id="293a5-1049">tx_timer_change</span><span class="sxs-lookup"><span data-stu-id="293a5-1049">tx_timer_change</span></span> 
- <span data-ttu-id="293a5-1050">tx_timer_deactivate</span><span class="sxs-lookup"><span data-stu-id="293a5-1050">tx_timer_deactivate</span></span> 
- <span data-ttu-id="293a5-1051">tx_timer_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1051">tx_timer_info_get</span></span> 
- <span data-ttu-id="293a5-1052">tx_timer_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1052">tx_timer_performance_info_get</span></span> 
- <span data-ttu-id="293a5-1053">tx_timer_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="293a5-1053">tx_timer_performance_system_info_get</span></span>

> [!WARNING]
> <span data-ttu-id="293a5-1054">ISR からの中断は許可されていません。</span><span class="sxs-lookup"><span data-stu-id="293a5-1054">Suspension is not allowed from ISRs.</span></span> <span data-ttu-id="293a5-1055">したがって、ISR から実行されるすべての ThreadX サービス呼び出しの **wait_option** パラメーターは、**TX_NO_WAIT** に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-1055">Therefore, the **wait_option** parameter for all ThreadX SMP service calls made from an ISR must be set to **TX_NO_WAIT**.</span></span>

### <a name="isr-template"></a><span data-ttu-id="293a5-1056">ISR テンプレート</span><span class="sxs-lookup"><span data-stu-id="293a5-1056">ISR Template</span></span> 
<span data-ttu-id="293a5-1057">アプリケーションの割り込みを管理するには、アプリケーションの ISR の先頭と末尾で、いくつかの ThreadX SMP ユーティリティを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-1057">To manage application interrupts, several ThreadX SMP utilities must be called in the beginning and end of application ISRs.</span></span> <span data-ttu-id="293a5-1058">割り込み処理の正確な形式は、ポートによって異なります。</span><span class="sxs-lookup"><span data-stu-id="293a5-1058">The exact format for interrupt handling varies between ports.</span></span> <span data-ttu-id="293a5-1059">ISR の管理に関する具体的な手順については、ディストリビューション ディスクの ***readme_threadx.txt*** ファイルを確認してください。</span><span class="sxs-lookup"><span data-stu-id="293a5-1059">Review the ***readme_threadx.txt*** file on the distribution disk for specific instructions on managing ISRs.</span></span>

<span data-ttu-id="293a5-1060">次の小さなコード セグメントは、ThreadX SMP で管理される ISR のほとんどで典型的なものです。</span><span class="sxs-lookup"><span data-stu-id="293a5-1060">The following small code segment is typical of most ThreadX SMP managed ISRs.</span></span> <span data-ttu-id="293a5-1061">ほとんどの場合、この処理はアセンブリ言語です。</span><span class="sxs-lookup"><span data-stu-id="293a5-1061">In most cases, this processing is in assembly language.</span></span>

<span data-ttu-id="293a5-1062">**_application_ISR_vector_entry**:</span><span class="sxs-lookup"><span data-stu-id="293a5-1062">**_application_ISR_vector_entry**:</span></span>  
<span data-ttu-id="293a5-1063">; ISR エントリ関数を呼び出して、</span><span class="sxs-lookup"><span data-stu-id="293a5-1063">; Save context and prepare for</span></span>  
<span data-ttu-id="293a5-1064">; コンテキストを保存し、ThreadX SMP の</span><span class="sxs-lookup"><span data-stu-id="293a5-1064">; ThreadX SMP use by calling the ISR</span></span>  
<span data-ttu-id="293a5-1065">; 使用に備えます。</span><span class="sxs-lookup"><span data-stu-id="293a5-1065">; entry function.</span></span>  
<span data-ttu-id="293a5-1066">CALL **_tx_thread_context_save**</span><span class="sxs-lookup"><span data-stu-id="293a5-1066">CALL **_tx_thread_context_save**</span></span>  

<span data-ttu-id="293a5-1067">; ISR で、ThreadX SMP サービスと、その独自の</span><span class="sxs-lookup"><span data-stu-id="293a5-1067">; The ISR can now call ThreadX SMP</span></span>  
<span data-ttu-id="293a5-1068">; C 関数を呼び出せるようになりました</span><span class="sxs-lookup"><span data-stu-id="293a5-1068">; services and its own C functions</span></span>  

<span data-ttu-id="293a5-1069">; ISR が終了したら、コンテキスト</span><span class="sxs-lookup"><span data-stu-id="293a5-1069">; When the ISR is finished, context</span></span>  
<span data-ttu-id="293a5-1070">; 復元関数を呼び出すことによって</span><span class="sxs-lookup"><span data-stu-id="293a5-1070">; is restored (or thread preemption)</span></span>  
<span data-ttu-id="293a5-1071">; コンテキストが復元されます</span><span class="sxs-lookup"><span data-stu-id="293a5-1071">; by calling the context restore</span></span>  
<span data-ttu-id="293a5-1072">; (またはスレッド プリエンプション)。</span><span class="sxs-lookup"><span data-stu-id="293a5-1072">; function.</span></span> <span data-ttu-id="293a5-1073">制御は戻りません。</span><span class="sxs-lookup"><span data-stu-id="293a5-1073">Control does not return!</span></span>  
<span data-ttu-id="293a5-1074">JUMP **_tx_thread_context_restore**</span><span class="sxs-lookup"><span data-stu-id="293a5-1074">JUMP **_tx_thread_context_restore**</span></span>

### <a name="high-frequency-interrupts"></a><span data-ttu-id="293a5-1075">高頻度の割り込み</span><span class="sxs-lookup"><span data-stu-id="293a5-1075">High-frequency Interrupts</span></span>  
<span data-ttu-id="293a5-1076">一部の割り込みは非常に高頻度で発生するため、割り込みのたびに完全なコンテキストの保存と復元を行うと、処理帯域幅が過剰に消費されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-1076">Some interrupts occur at such a high frequency that saving and restoring full context upon each interrupt would consume excessive processing bandwidth.</span></span> <span data-ttu-id="293a5-1077">このような場合、アプリケーションでは、このような高頻度の割り込みの大部分に対して限られた量の処理を実行する、アセンブリ言語の小規模な ISR を使用するのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="293a5-1077">In such cases, it is common for the application to have a small assembly language ISR that does a limited amount of processing for a majority of these highfrequency interrupts.</span></span> 

<span data-ttu-id="293a5-1078">特定の時点以降、この小規模な ISR では ThreadX SMP との対話が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="293a5-1078">After a certain point in time, the small ISR may need to interact with ThreadX SMP.</span></span> <span data-ttu-id="293a5-1079">これは、上記のテンプレートで説明されている entry 関数と exit 関数を呼び出すことによって実現されます。</span><span class="sxs-lookup"><span data-stu-id="293a5-1079">This is accomplished by calling the entry and exit functions described in the above template.</span></span> 

### <a name="interrupt-latency"></a><span data-ttu-id="293a5-1080">割り込み待機時間</span><span class="sxs-lookup"><span data-stu-id="293a5-1080">Interrupt Latency</span></span>  
<span data-ttu-id="293a5-1081">ThreadX SMP では、短期間だけ割り込みがロックアウトされます。</span><span class="sxs-lookup"><span data-stu-id="293a5-1081">ThreadX SMP locks out interrupts over brief periods of time.</span></span> <span data-ttu-id="293a5-1082">割り込みが無効になる最大時間は、スレッドのコンテキストを保存または復元するために必要な時間とほぼ等しくなります。</span><span class="sxs-lookup"><span data-stu-id="293a5-1082">The maximum amount of time interrupts are disabled is on the order of the time required to save or restore a thread’s context.</span></span> 