---
title: 第 1 章 - Azure RTOS ThreadX の概要
description: この章では、Azure RTOS ThreadX の概要と、そのアプリケーションおよび利点について説明します。
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 83718ddf5469238e2429855908be2ea5d405f874
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811396"
---
# <a name="chapter-1---introduction-to-azure-rtos-threadx"></a><span data-ttu-id="690b6-103">第 1 章 - Azure RTOS ThreadX の概要</span><span class="sxs-lookup"><span data-stu-id="690b6-103">Chapter 1 - Introduction to Azure RTOS ThreadX</span></span>

<span data-ttu-id="690b6-104">Azure RTOS ThreadX は、埋め込みアプリケーション専用に設計された高性能のリアルタイム カーネルです。</span><span class="sxs-lookup"><span data-stu-id="690b6-104">Azure RTOS ThreadX is a high-performance real-time kernel designed specifically for embedded applications.</span></span> <span data-ttu-id="690b6-105">この章では、製品の概要と、そのアプリケーションおよび利点について説明します。</span><span class="sxs-lookup"><span data-stu-id="690b6-105">This chapter contains an introduction to the product and a description of its applications and benefits.</span></span>

## <a name="threadx-unique-features"></a><span data-ttu-id="690b6-106">ThreadX の固有の機能</span><span class="sxs-lookup"><span data-stu-id="690b6-106">ThreadX Unique Features</span></span>

<span data-ttu-id="690b6-107">他のリアルタイム カーネルとは異なり、ThreadX は汎用性を重視して設計されており、小型マイクロコントローラーをベースとしたものから、強力な CISC、RISC、DSP プロセッサを使用するものまで、アプリケーションを容易にスケーリングできます。</span><span class="sxs-lookup"><span data-stu-id="690b6-107">Unlike other real-time kernels, ThreadX is designed to be versatile—easily scaling among small microcontroller-based applications through those that use powerful CISC, RISC, and DSP processors.</span></span>

<span data-ttu-id="690b6-108">ThreadX は、基になるアーキテクチャに従ってスケーラブルに動作します。</span><span class="sxs-lookup"><span data-stu-id="690b6-108">ThreadX is scalable based on its underlying architecture.</span></span> <span data-ttu-id="690b6-109">ThreadX サービスは C ライブラリとして実装されているため、アプリケーションによって実際に使用されるサービスのみが実行時イメージに取り込まれます。</span><span class="sxs-lookup"><span data-stu-id="690b6-109">Because ThreadX services are implemented as a C library, only those services actually used by the application are brought into the run-time image.</span></span> <span data-ttu-id="690b6-110">したがって、ThreadX の実際のサイズは、全面的にアプリケーションによって決まります。</span><span class="sxs-lookup"><span data-stu-id="690b6-110">Hence, the actual size of ThreadX is completely determined by the application.</span></span> <span data-ttu-id="690b6-111">ほとんどのアプリケーションについて、ThreadX の命令イメージのサイズは 2 KByte から 15 KByte です。</span><span class="sxs-lookup"><span data-stu-id="690b6-111">For most applications, the instruction image of ThreadX ranges between 2 KBytes and 15 KBytes in size.</span></span>

### <a name="picokerneltrade-architecture"></a><span data-ttu-id="690b6-112">*picokernel&trade; アーキテクチャ*</span><span class="sxs-lookup"><span data-stu-id="690b6-112">*picokernel&trade; Architecture*</span></span>

<span data-ttu-id="690b6-113">ThreadX サービスは、従来の "*マイクロカーネル*" アーキテクチャのようにカーネル関数を重ねていくのではなく、そのコアに直接接続します。</span><span class="sxs-lookup"><span data-stu-id="690b6-113">Instead of layering kernel functions on top of each other like traditional *microkernel* architectures, ThreadX services plug directly into its core.</span></span> <span data-ttu-id="690b6-114">これにより、コンテキスト切り替えとサービス呼び出しのパフォーマンスが最速になります。</span><span class="sxs-lookup"><span data-stu-id="690b6-114">This results in the fastest possible context switching and service call performance.</span></span> <span data-ttu-id="690b6-115">このような非レイヤー設計を *picokernel* アーキテクチャと呼んでいます。</span><span class="sxs-lookup"><span data-stu-id="690b6-115">We call this non-layering design a *picokernel* architecture.</span></span>

### <a name="ansi-c-source-code"></a><span data-ttu-id="690b6-116">ANSI C ソース コード</span><span class="sxs-lookup"><span data-stu-id="690b6-116">ANSI C Source Code</span></span>

<span data-ttu-id="690b6-117">ThreadX は主に ANSI C で記述されており、基になるターゲット プロセッサに合わせてカーネルを調整するために、少量のアセンブリ言語が必要です。</span><span class="sxs-lookup"><span data-stu-id="690b6-117">ThreadX is written primarily in ANSI C. A small amount of assembly language is needed to tailor the kernel to the underlying target processor.</span></span> <span data-ttu-id="690b6-118">この設計により、ThreadX を、非常に短い時間 (通常は数週間以内) で新しいプロセッサ ファミリーに移植できます。</span><span class="sxs-lookup"><span data-stu-id="690b6-118">This design makes it possible to port ThreadX to a new processor family in a very short time—usually within weeks!</span></span>

### <a name="advanced-technology"></a><span data-ttu-id="690b6-119">高度なテクノロジ</span><span class="sxs-lookup"><span data-stu-id="690b6-119">Advanced Technology</span></span>

<span data-ttu-id="690b6-120">ThreadX の高度なテクノロジの概要を次に示します。</span><span class="sxs-lookup"><span data-stu-id="690b6-120">The following are highlights of the ThreadX advanced technology.</span></span>
- <span data-ttu-id="690b6-121">シンプルな *picokernel* アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="690b6-121">Simple *picokernel* architecture</span></span>
- <span data-ttu-id="690b6-122">自動スケーリング (占有領域が小さい)</span><span class="sxs-lookup"><span data-stu-id="690b6-122">Automatic scaling (small footprint)</span></span>
- <span data-ttu-id="690b6-123">決定論的処理</span><span class="sxs-lookup"><span data-stu-id="690b6-123">Deterministic processing</span></span>
- <span data-ttu-id="690b6-124">高速なリアルタイムのパフォーマンス</span><span class="sxs-lookup"><span data-stu-id="690b6-124">Fast real-time performance</span></span>
- <span data-ttu-id="690b6-125">プリエンプティブ スケジューリングと協調スケジューリング</span><span class="sxs-lookup"><span data-stu-id="690b6-125">Preemptive and cooperative scheduling</span></span>
- <span data-ttu-id="690b6-126">柔軟なスレッド優先順位のサポート</span><span class="sxs-lookup"><span data-stu-id="690b6-126">Flexible thread priority support</span></span>
- <span data-ttu-id="690b6-127">システム オブジェクトの動的生成</span><span class="sxs-lookup"><span data-stu-id="690b6-127">Dynamic system object creation</span></span>
- <span data-ttu-id="690b6-128">システム オブジェクト数に制限がない</span><span class="sxs-lookup"><span data-stu-id="690b6-128">Unlimited number of system objects</span></span>
- <span data-ttu-id="690b6-129">最適化された割り込み処理</span><span class="sxs-lookup"><span data-stu-id="690b6-129">Optimized interrupt handling</span></span>
- <span data-ttu-id="690b6-130">Preemption-threshold&trade;</span><span class="sxs-lookup"><span data-stu-id="690b6-130">Preemption-threshold&trade;</span></span>
- <span data-ttu-id="690b6-131">優先度の継承</span><span class="sxs-lookup"><span data-stu-id="690b6-131">Priority inheritance</span></span>
- <span data-ttu-id="690b6-132">Event-chaining&trade;</span><span class="sxs-lookup"><span data-stu-id="690b6-132">Event-chaining&trade;</span></span>
- <span data-ttu-id="690b6-133">高速ソフトウェア タイマー</span><span class="sxs-lookup"><span data-stu-id="690b6-133">Fast software timers</span></span>
- <span data-ttu-id="690b6-134">実行時メモリの管理</span><span class="sxs-lookup"><span data-stu-id="690b6-134">Run-time memory management</span></span>
- <span data-ttu-id="690b6-135">実行時パフォーマンスの監視</span><span class="sxs-lookup"><span data-stu-id="690b6-135">Run-time performance monitoring</span></span>
- <span data-ttu-id="690b6-136">実行時スタック分析</span><span class="sxs-lookup"><span data-stu-id="690b6-136">Run-time stack analysis</span></span>
- <span data-ttu-id="690b6-137">組み込みシステム トレース</span><span class="sxs-lookup"><span data-stu-id="690b6-137">Built-in system trace</span></span>
- <span data-ttu-id="690b6-138">大規模なプロセッサのサポート</span><span class="sxs-lookup"><span data-stu-id="690b6-138">Vast processor support</span></span>
- <span data-ttu-id="690b6-139">大規模な開発ツールのサポート</span><span class="sxs-lookup"><span data-stu-id="690b6-139">Vast development tool support</span></span>
- <span data-ttu-id="690b6-140">完全なエンディアン ニュートラル</span><span class="sxs-lookup"><span data-stu-id="690b6-140">Completely endian neutral</span></span>

### <a name="not-a-black-box"></a><span data-ttu-id="690b6-141">ブラック ボックスではない</span><span class="sxs-lookup"><span data-stu-id="690b6-141">Not A Black Box</span></span>

<span data-ttu-id="690b6-142">ThreadX のほとんどのディストリビューションには、完全な C ソース コードと、プロセッサ固有のアセンブリ言語が含まれています。</span><span class="sxs-lookup"><span data-stu-id="690b6-142">Most distributions of ThreadX include the complete C source code as well as the processor-specific assembly language.</span></span> <span data-ttu-id="690b6-143">これにより、多くの商用カーネルで発生する "ブラック ボックス" の問題が解消されます。</span><span class="sxs-lookup"><span data-stu-id="690b6-143">This eliminates the "black-box" problems that occur with many commercial kernels.</span></span> <span data-ttu-id="690b6-144">ThreadX を使用すると、アプリケーション開発者が、カーネルの動作を正確に知ることができます。謎はありません。</span><span class="sxs-lookup"><span data-stu-id="690b6-144">With ThreadX, application developers can see exactly what the kernel is doing—there are no mysteries!</span></span>

<span data-ttu-id="690b6-145">また、ソース コードによって、アプリケーション固有の変更も可能です。</span><span class="sxs-lookup"><span data-stu-id="690b6-145">The source code also allows for application specific modifications.</span></span> <span data-ttu-id="690b6-146">推奨はされていませんが、どうしても必要な場合にカーネルを変更できれば、確かに便利です。</span><span class="sxs-lookup"><span data-stu-id="690b6-146">Although not recommended, it is certainly beneficial to have the ability to modify the kernel if it is absolutely required.</span></span>

<span data-ttu-id="690b6-147">これらの機能は、独自の "*社内カーネル*" の操作に慣れている開発者にとっては、特に心強いものです。</span><span class="sxs-lookup"><span data-stu-id="690b6-147">These features are especially comforting to developers accustomed to working with their own *in-house kernels*.</span></span> <span data-ttu-id="690b6-148">期待されているのは、ソース コードがあることと、カーネルを変更できることです。</span><span class="sxs-lookup"><span data-stu-id="690b6-148">They expect to have source code and the ability to modify the kernel.</span></span> <span data-ttu-id="690b6-149">ThreadX は、このような開発者のための究極のカーネルです。</span><span class="sxs-lookup"><span data-stu-id="690b6-149">ThreadX is the ultimate kernel for such developers.</span></span>

### <a name="the-rtos-standard"></a><span data-ttu-id="690b6-150">RTOS 標準</span><span class="sxs-lookup"><span data-stu-id="690b6-150">The RTOS Standard</span></span>

<span data-ttu-id="690b6-151">ThreadX は、その汎用性と高パフォーマンスの *picokernel* アーキテクチャ、高度なテクノロジ、そして実証済みの移植性により、現在 20 億台以上のデバイスにデプロイされています。</span><span class="sxs-lookup"><span data-stu-id="690b6-151">Because of its versatility, high-performance *picokernel* architecture, advanced technology, and demonstrated portability, ThreadX is deployed in more than two-billion devices today.</span></span> <span data-ttu-id="690b6-152">これにより、事実上、ThreadX は、深く埋め込まれているアプリケーションの RTOS 標準となっています。</span><span class="sxs-lookup"><span data-stu-id="690b6-152">This effectively makes ThreadX the RTOS standard for deeply embedded applications.</span></span>

## <a name="safety-certifications"></a><span data-ttu-id="690b6-153">安全性の認定</span><span class="sxs-lookup"><span data-stu-id="690b6-153">Safety Certifications</span></span>

### <a name="tv-certification"></a><span data-ttu-id="690b6-154">TÜV 認定</span><span class="sxs-lookup"><span data-stu-id="690b6-154">TÜV Certification</span></span>

<span data-ttu-id="690b6-155">ThreadX は、IEC61508 および IEC-62304 に従って、安全性が重要なシステムでの使用を SGS-TÜV Saar によって認定されています。</span><span class="sxs-lookup"><span data-stu-id="690b6-155">ThreadX has been certified by SGS-TÜV Saar for use in safety-critical systems, according to IEC61508 and IEC-62304.</span></span> <span data-ttu-id="690b6-156">この認定により、「電気・電子・プログラマブル電子安全関連系の機能安全」に関する国際電気標準会議 (IEC) 61508 および IEC 62304 の安全性の最高レベルに対応する安全関連ソフトウェアの開発で ThreadX を使用できることが確認されています。</span><span class="sxs-lookup"><span data-stu-id="690b6-156">The certification confirms that ThreadX can be used in the  development of safety related software for the highest safety integrity levels of the International Electrotechnical Commission (IEC) 61508 and IEC 62304, for the "Functional Safety of electrical, electronic, and programmable electronic safety-related systems."</span></span> <span data-ttu-id="690b6-157">ドイツの SGSGroup と TÜV Saarland の共同事業を通じて結成された SGS-TÜV Saar は、世界中の安全関連システムのための組み込みソフトウェアのテスト、監査、検証、認定を行う、世界有数の公認された独立系企業になりました。</span><span class="sxs-lookup"><span data-stu-id="690b6-157">SGS-TÜV Saar, formed through a joint venture of Germany's SGSGroup and TÜV Saarland, has become the leading accredited, independent company for testing, auditing, verifying, and certifying embedded software for safety-related systems worldwide.</span></span> <span data-ttu-id="690b6-158">工業安全規格の IEC 61508 と、それから派生したすべての標準 (IEC 62304 を含む) は、電気・電子・プログラマブル電子安全関連の医療デバイス、プロセス制御システム、工業機械、鉄道制御システムの機能安全を保証するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="690b6-158">The industrial safety standard IEC 61508, and all standards that are derived from it, including IEC 62304, are used to assure the functional safety of electrical, electronic, and programmable electronic safety-related medical devices, process control systems, industrial machinery, and railway control systems.</span></span>

<span data-ttu-id="690b6-159">SGS-TÜV Saar は、ISO 26262 標準に従って、安全性が重要な自動車システムで ThreadX を使用することを認可しました。</span><span class="sxs-lookup"><span data-stu-id="690b6-159">SGS-TÜV Saar has certified ThreadX to be used in safety-critical automotive systems, according to the ISO 26262 standard.</span></span> <span data-ttu-id="690b6-160">さらに、ThreadX は、ISO 26262 認定の最高レベルを表す Automotive Safety Integrity Level (ASIL) D に認定されています。</span><span class="sxs-lookup"><span data-stu-id="690b6-160">Furthermore, ThreadX is certified to Automotive Safety Integrity Level (ASIL) D, which represents the highest level of ISO 26262 certification.</span></span>

<span data-ttu-id="690b6-161">さらに、SGS-TÜV Saar では、ThreadX が SW-SIL 4 までの EN 50128 標準を満たしており、安全性が重要な鉄道アプリケーションで使用できるものとして認定しています。</span><span class="sxs-lookup"><span data-stu-id="690b6-161">In addition, SGS-TÜV Saar has certified ThreadX to be used in safety-critical railway applications, meeting to the EN 50128 standard up to SW-SIL 4.</span></span>

![TÜV 認定](./media/overview-threadx/partener-logo-sgs-tuv-saar-2.png)

* <span data-ttu-id="690b6-163">IEC 61508 (SIL 4 まで)</span><span class="sxs-lookup"><span data-stu-id="690b6-163">IEC 61508 up to SIL 4</span></span>

* <span data-ttu-id="690b6-164">IEC 62304 (SW 安全性クラス C まで)</span><span class="sxs-lookup"><span data-stu-id="690b6-164">IEC 62304 up to SW safety Class C</span></span>

* <span data-ttu-id="690b6-165">ISO 26262 ASIL D</span><span class="sxs-lookup"><span data-stu-id="690b6-165">ISO 26262 ASIL D</span></span>

* <span data-ttu-id="690b6-166">EN 50128 SW-SIL 4</span><span class="sxs-lookup"><span data-stu-id="690b6-166">EN 50128 SW-SIL 4</span></span>

> [!NOTE]
> <span data-ttu-id="690b6-167">*TÜV によって認定されている ThreadX のバージョンに関する情報や、テスト レポート、証明書、関連ドキュメントの入手については、Microsoft までお問い合わせください。*</span><span class="sxs-lookup"><span data-stu-id="690b6-167">*Please contact us for more information on which version(s) of ThreadX have been certified by TÜV or for the availability of test reports, certificates, and associated documentation.*</span></span>

### <a name="misra-c-compliant"></a><span data-ttu-id="690b6-168">MISRA C 準拠</span><span class="sxs-lookup"><span data-stu-id="690b6-168">MISRA C Compliant</span></span>

<span data-ttu-id="690b6-169">MISRA C は、C プログラミング言語を使用した重要なシステム用の一連のプログラミング ガイドラインです。</span><span class="sxs-lookup"><span data-stu-id="690b6-169">MISRA C is a set of programming guidelines for critical systems using the C programming language.</span></span> <span data-ttu-id="690b6-170">元の MISRA C ガイドラインは主に自動車アプリケーションを対象としていましたが、今では MISRA C は安全性が重要な任意のアプリケーションに適用可能なものとして広く認識されています。</span><span class="sxs-lookup"><span data-stu-id="690b6-170">The original MISRA C guidelines were primarily targeted toward automotive applications; however, MISRA C is now widely recognized as being applicable to any safety critical application.</span></span> <span data-ttu-id="690b6-171">ThreadX は、MISRA-C:2004 と MISRA C:2012 のすべての "必要" 規則と "必須" 規則に準拠しています。</span><span class="sxs-lookup"><span data-stu-id="690b6-171">ThreadX is compliant with all "required" and "mandatory" rules of MISRA-C:2004 and MISRA C:2012.</span></span> <span data-ttu-id="690b6-172">ThreadX は、3 つを除くすべての "推奨" 規則にも準拠しています。</span><span class="sxs-lookup"><span data-stu-id="690b6-172">ThreadX is also compliant with all but three "advisory" rules.</span></span> <span data-ttu-id="690b6-173">詳細については、***ThreadX_MISRA_Compliance.pdf*** ドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="690b6-173">Refer to the ***ThreadX_MISRA_Compliance.pdf*** document for more details.</span></span>

### <a name="ul-certification"></a><span data-ttu-id="690b6-174">UL 認定</span><span class="sxs-lookup"><span data-stu-id="690b6-174">UL Certification</span></span>

<span data-ttu-id="690b6-175">ThreadX は、プログラマブル コンポーネント内のソフトウェアに対する UL 60730-1 付属文書 H、CSA E60730-1 付属文書 H、IEC 60730-1 付属文書 H、UL 60335-1 付属文書 R、IEC 60335-1 付属文書 R、UL 1998 の各安全標準に準拠しているものとして UL によって認定されています。</span><span class="sxs-lookup"><span data-stu-id="690b6-175">ThreadX has been certified by UL for compliance with UL 60730-1 Annex H, CSA E60730-1 Annex H, IEC 60730-1 Annex H, UL 60335-1 Annex R, IEC 60335-1 Annex R, and UL 1998 safety standards for software in programmable components.</span></span> <span data-ttu-id="690b6-176">IEC/UL 60730-1 (付属文書 H に「ソフトウェアを使用した制御」に対する要件がある) と共に、IEC 60335-1 標準では、「プログラマブル電子回路」に対する要件がその付属文書 R で説明されています。IEC 60730 付属文書 R と IEC 60335-1 付属文書 R では、洗濯機、乾燥機、冷蔵庫、冷凍庫、オーブンなどのアプライアンスで使用される MCU のハードウェアとソフトウェアの安全性が取り上げられています。</span><span class="sxs-lookup"><span data-stu-id="690b6-176">Along with IEC/UL 60730-1, which has requirements for "Controls Using Software" in its Annex H, the IEC 60335-1 standard describes the requirements for "Programmable Electronic Circuits" in its Annex R. IEC 60730 Annex H and IEC 60335-1 Annex R address the safety of MCU hardware and software used in appliances such as washing machines, dishwashers, dryers, refrigerators, freezers, and ovens.</span></span>

![UL 認定](./media/overview-threadx/partener-logo-c-ru-us-2.png)

<span data-ttu-id="690b6-178">*UL/IEC 60730、UL/IEC 60335、UL 1998*</span><span class="sxs-lookup"><span data-stu-id="690b6-178">*UL/IEC 60730, UL/IEC 60335, UL 1998*</span></span>

> [!NOTE]
> <span data-ttu-id="690b6-179">*TÜV によって認定されている ThreadX のバージョンに関する情報や、テスト レポート、証明書、関連ドキュメントの入手については、Microsoft までお問い合わせください。*</span><span class="sxs-lookup"><span data-stu-id="690b6-179">*Please contact Microsoft for more information on which version(s) of ThreadX have been certified by TÜV or for the availability of test reports, certificates, and associated documentation.*</span></span>

### <a name="certification-pack"></a><span data-ttu-id="690b6-180">Certification Pack</span><span class="sxs-lookup"><span data-stu-id="690b6-180">Certification Pack</span></span>

<span data-ttu-id="690b6-181">ThreadX Certification Pack&trade; は、安全性が重要な航空、医療、工業システムに必要な最高レベルの信頼性と致命度を ThreadX ベースの製品で保証、または成功裏に遵守するために必要な ThreadX の証拠をすべて提供する、100% 完全で、すぐに使える、業界固有のスタンドアロン パッケージです。</span><span class="sxs-lookup"><span data-stu-id="690b6-181">The ThreadX Certification Pack&trade; is a 100% complete, turnkey, industry-specific, stand-alone package that provides all of the ThreadX evidence needed to certify or successfully submit the ThreadX-based product to the highest reliability and criticality levels required for safety-critical Aviation, Medical, and Industrial systems.</span></span> <span data-ttu-id="690b6-182">サポートされている認定には、DO-178B、ED-12B、DO-278、FDA510(k)、IEC62304、IEC-60601、ISO-14971、UL-1998、IEC-61508、CENELEC EN50128、BS50128、49CFR236 があります。</span><span class="sxs-lookup"><span data-stu-id="690b6-182">Certifications supported include DO-178B, ED-12B, DO-278, FDA510(k), IEC62304, IEC-60601, ISO-14971, UL-1998, IEC-61508, CENELEC EN50128, BS50128, and 49CFR236.</span></span> <span data-ttu-id="690b6-183">認定パックの詳細については、Microsoft にお問い合わせください。</span><span class="sxs-lookup"><span data-stu-id="690b6-183">Please contact Microsoft for more information on Certification Pack.</span></span>

## <a name="embedded-applications"></a><span data-ttu-id="690b6-184">埋め込みアプリケーション</span><span class="sxs-lookup"><span data-stu-id="690b6-184">Embedded Applications</span></span>

<span data-ttu-id="690b6-185">埋め込みアプリケーションは、ワイヤレス通信デバイス、自動車エンジン、レーザー プリンター、医療機器などの製品内に埋め込まれたマイクロプロセッサ上で実行されます。埋め込みアプリケーションのもう 1 つの特徴は、それを実行するソフトウェアとハードウェアに専用の用途があることです。</span><span class="sxs-lookup"><span data-stu-id="690b6-185">Embedded applications execute on microprocessors buried within products such as wireless communication devices, automobile engines, laser printers, medical devices, etc. Another distinction of embedded applications is that their software and hardware have a dedicated purpose.</span></span>

### <a name="real-time-software"></a><span data-ttu-id="690b6-186">リアルタイム ソフトウェア</span><span class="sxs-lookup"><span data-stu-id="690b6-186">Real-time Software</span></span>

<span data-ttu-id="690b6-187">アプリケーション ソフトウェアに時間的な制約が課される場合、それは "*リアルタイム*" ソフトウェアと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="690b6-187">When time constraints are imposed on the application software, it is called the *real-time* software.</span></span> <span data-ttu-id="690b6-188">埋め込みアプリケーションは、本来的に外部イベントとやり取りするものであるため、ほとんどの場合にリアルタイムです。</span><span class="sxs-lookup"><span data-stu-id="690b6-188">Embedded applications are almost always real-time because of their inherent interaction with external events.</span></span>

### <a name="multitasking"></a><span data-ttu-id="690b6-189">マルチタスキング</span><span class="sxs-lookup"><span data-stu-id="690b6-189">Multitasking</span></span>

<span data-ttu-id="690b6-190">前述のように、埋め込みアプリケーションには専用の用途があります。</span><span class="sxs-lookup"><span data-stu-id="690b6-190">As mentioned, embedded applications have a dedicated purpose.</span></span> <span data-ttu-id="690b6-191">この目的を達成するには、ソフトウェアがさまざまな "*タスク*" を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="690b6-191">To fulfill this purpose, the software must perform a variety of *tasks*.</span></span> <span data-ttu-id="690b6-192">タスクは、特定の職務を実行する、アプリケーションの半ば独立した部分です。</span><span class="sxs-lookup"><span data-stu-id="690b6-192">A task is a semi-independent portion of the application that carries out a specific duty.</span></span> <span data-ttu-id="690b6-193">また、一部のタスクは他のタスクよりも重要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="690b6-193">It is also the case that some tasks are more important than others.</span></span> <span data-ttu-id="690b6-194">埋め込みアプリケーションの大きな課題の 1 つは、さまざまなアプリケーション タスク間でプロセッサを割り振ることです。</span><span class="sxs-lookup"><span data-stu-id="690b6-194">One of the major difficulties in an embedded application is the allocation of the processor between the various application tasks.</span></span> <span data-ttu-id="690b6-195">競合するタスク間で処理を割り振ることは、ThreadX の主要な目的です。</span><span class="sxs-lookup"><span data-stu-id="690b6-195">This allocation of processing between competing tasks is the primary purpose of ThreadX.</span></span>

### <a name="tasks-vs-threads"></a><span data-ttu-id="690b6-196">タスクとスレッド</span><span class="sxs-lookup"><span data-stu-id="690b6-196">Tasks vs. Threads</span></span>

<span data-ttu-id="690b6-197">タスクのもう 1 つの特徴は、"*タスク*" という用語がさまざまな方法で使用されることです。</span><span class="sxs-lookup"><span data-stu-id="690b6-197">Another distinction about tasks is that the term *task* is used in a variety of ways.</span></span> <span data-ttu-id="690b6-198">これは、個別に読み込み可能なプログラムを意味することがあります。</span><span class="sxs-lookup"><span data-stu-id="690b6-198">It sometimes means a separately loadable program.</span></span> <span data-ttu-id="690b6-199">他の場合には、内部的なプログラム セグメントを指すことがあります。</span><span class="sxs-lookup"><span data-stu-id="690b6-199">In other instances, it may refer to an internal program segment.</span></span> <span data-ttu-id="690b6-200">このため、現代的なオペレーティング システムでは、タスクという用語を使う代わりに、大抵 "*プロセス*" と "*スレッド* " という 2 つの用語に置き換えられています。</span><span class="sxs-lookup"><span data-stu-id="690b6-200">Therefore, in contemporary operating systems, there are two terms that more or less replace the use of task: *process* and *thread*.</span></span> <span data-ttu-id="690b6-201">"*プロセス*" は、独自のアドレス空間を持つ、完全に独立したプログラムです。それに対して、"*スレッド*" は、プロセス内で実行される半ば独立したプログラム セグメントです。</span><span class="sxs-lookup"><span data-stu-id="690b6-201">A *process* is a completely independent program that has its own address space, while a *thread* is a semi-independent program segment that executes within a process.</span></span> <span data-ttu-id="690b6-202">各スレッドは、同じプロセス アドレス空間を共有します。</span><span class="sxs-lookup"><span data-stu-id="690b6-202">Threads share the same process address space.</span></span> <span data-ttu-id="690b6-203">スレッド管理に伴うオーバーヘッドは最小限に抑えられています。</span><span class="sxs-lookup"><span data-stu-id="690b6-203">The overhead associated with thread management is minimal.</span></span>

<span data-ttu-id="690b6-204">ほとんどの埋め込みアプリケーションは、本格的なプロセス指向のオペレーティング システムに付きもののオーバーヘッド (メモリとパフォーマンスの両方) を許容できません。</span><span class="sxs-lookup"><span data-stu-id="690b6-204">Most embedded applications cannot afford the overhead (both memory and performance) associated with a full-blown process-oriented operating system.</span></span> <span data-ttu-id="690b6-205">また、小規模なマイクロプロセッサには、真のプロセス指向オペレーティング システムをサポートするハードウェア アーキテクチャがありません。</span><span class="sxs-lookup"><span data-stu-id="690b6-205">In addition, smaller microprocessors don't have the hardware architecture to support a true process-oriented operating system.</span></span> <span data-ttu-id="690b6-206">このような理由から、ThreadX ではスレッド モデルを実装します。これは、ほとんどのリアルタイム埋め込みアプリケーションの場合に、非常に効率的かつ実用的です。</span><span class="sxs-lookup"><span data-stu-id="690b6-206">For these reasons, ThreadX implements a thread model, which is both extremely efficient and practical for most real-time embedded applications.</span></span>

<span data-ttu-id="690b6-207">混乱を避けるため、ThreadX では "*タスク*" という用語は使用されていません。</span><span class="sxs-lookup"><span data-stu-id="690b6-207">To avoid confusion, ThreadX does not use the term *task*.</span></span> <span data-ttu-id="690b6-208">代わりに、よりわかりやすく現代風の名称である "*スレッド*" が使用されています。</span><span class="sxs-lookup"><span data-stu-id="690b6-208">Instead, the more descriptive and contemporary name *thread* is used.</span></span>

## <a name="threadx-benefits"></a><span data-ttu-id="690b6-209">ThreadX の利点</span><span class="sxs-lookup"><span data-stu-id="690b6-209">ThreadX Benefits</span></span>

<span data-ttu-id="690b6-210">ThreadX を使用すると、埋め込みアプリケーションに多くの利点がもたらされます。</span><span class="sxs-lookup"><span data-stu-id="690b6-210">Using ThreadX provides many benefits to embedded applications.</span></span> <span data-ttu-id="690b6-211">もちろん、主な利点は、埋め込みアプリケーション スレッドに処理時間が割り当てられる方法にあります。</span><span class="sxs-lookup"><span data-stu-id="690b6-211">Of course, the primary benefit rests in how embedded application threads are allocated processing time.</span></span>

### <a name="improved-responsiveness"></a><span data-ttu-id="690b6-212">応答性の向上</span><span class="sxs-lookup"><span data-stu-id="690b6-212">Improved Responsiveness</span></span>

<span data-ttu-id="690b6-213">ThreadX のようなリアルタイム カーネルが登場する前には、ほとんどの埋め込みアプリケーションは単純な制御ループを使用して処理時間を割り当てていました。通常は C の *main* 関数内からです。</span><span class="sxs-lookup"><span data-stu-id="690b6-213">Prior to real-time kernels like ThreadX, most embedded applications allocated processing time with a simple control loop, usually from within the C *main* function.</span></span> <span data-ttu-id="690b6-214">この方法は、ごく小規模な、または単純なアプリケーションでは今でも使用されています。</span><span class="sxs-lookup"><span data-stu-id="690b6-214">This approach is still used in very small or simple applications.</span></span> <span data-ttu-id="690b6-215">ただし、大規模または複雑なアプリケーションでは、これは実用的ではありません。イベントへの応答時間が、制御ループを 1 回通過するのに要する最悪の場合の処理時間の関数になるからです。</span><span class="sxs-lookup"><span data-stu-id="690b6-215">However, in large or complex applications, it is not practical because the response time to any event is a function of the worst case processing time of one pass through the control loop.</span></span> 

<span data-ttu-id="690b6-216">さらに悪いことに、制御ループに変更を加えるたびに、アプリケーションのタイミング特性が変化します。</span><span class="sxs-lookup"><span data-stu-id="690b6-216">Making matters worse, the timing characteristics of the application change whenever modifications are made to the control loop.</span></span> <span data-ttu-id="690b6-217">これにより、アプリケーションが本質的に不安定になり、保守と改良が困難になります。</span><span class="sxs-lookup"><span data-stu-id="690b6-217">This makes the application inherently unstable and difficult to maintain and improve on.</span></span>

<span data-ttu-id="690b6-218">ThreadX では、重要な外部イベントに対して高速かつ決定論的な応答時間が提供されます。</span><span class="sxs-lookup"><span data-stu-id="690b6-218">ThreadX provides fast and deterministic response times to important external events.</span></span> <span data-ttu-id="690b6-219">ThreadX では、プリエンプティブで優先順位に基づくスケジューリング アルゴリズムを通じてこれを実現します。これにより、優先度の高いスレッドは、実行中の優先度の低いスレッドを横取りできます。</span><span class="sxs-lookup"><span data-stu-id="690b6-219">ThreadX accomplishes this through its preemptive, priority based scheduling algorithm, which allows a higher priority thread to preempt an executing lower-priority thread.</span></span> <span data-ttu-id="690b6-220">結果として、最悪の場合の応答時間は、コンテキストの切り替えを実行するのに必要な時間に近くなります。</span><span class="sxs-lookup"><span data-stu-id="690b6-220">As a result, the worst-case response time approaches the time required to perform a context switch.</span></span> <span data-ttu-id="690b6-221">これは決定論的であるだけでなく、非常に高速でもあります。</span><span class="sxs-lookup"><span data-stu-id="690b6-221">This is not only deterministic, but it is also extremely fast.</span></span>

### <a name="software-maintenance"></a><span data-ttu-id="690b6-222">ソフトウェアのメンテナンス</span><span class="sxs-lookup"><span data-stu-id="690b6-222">Software Maintenance</span></span>

<span data-ttu-id="690b6-223">ThreadX カーネルを使用すると、アプリケーションの開発者は、アプリケーションの他の領域のタイミングが変わってしまうことを心配せずに、アプリケーション スレッドの特定の要件に専念できます。</span><span class="sxs-lookup"><span data-stu-id="690b6-223">The ThreadX kernel enables application developers to concentrate on specific requirements of their application threads without having to worry about changing the timing of other areas of the application.</span></span> <span data-ttu-id="690b6-224">また、この特徴のおかげで、ThreadX を利用するアプリケーションの修復や拡張がはるかに簡単になります。</span><span class="sxs-lookup"><span data-stu-id="690b6-224">This feature also makes it much easier to repair or enhance an application that utilizes ThreadX.</span></span>

### <a name="increased-throughput"></a><span data-ttu-id="690b6-225">スループットの向上</span><span class="sxs-lookup"><span data-stu-id="690b6-225">Increased Throughput</span></span>

<span data-ttu-id="690b6-226">制御ループの応答時間の問題を回避する 1 つの方法は、ポーリングをさらに追加することです。</span><span class="sxs-lookup"><span data-stu-id="690b6-226">A possible work-around to the control loop response time problem is to add more polling.</span></span> <span data-ttu-id="690b6-227">これにより応答性は向上しますが、最悪の場合の応答時間が一定になることは保証されず、アプリケーションの将来の変更に対応する面では効果がありません。</span><span class="sxs-lookup"><span data-stu-id="690b6-227">This improves the responsiveness, but it still doesn't guarantee a constant worst-case response time and does nothing to enhance future modification of the application.</span></span> <span data-ttu-id="690b6-228">また、追加のポーリングが原因で、プロセッサが行う不要な処理が増えてしまいます。</span><span class="sxs-lookup"><span data-stu-id="690b6-228">Also, the processor is now performing even more unnecessary processing because of the extra polling.</span></span> <span data-ttu-id="690b6-229">このような不要な処理によって、システムの全体的なスループットが低下します。</span><span class="sxs-lookup"><span data-stu-id="690b6-229">All of this unnecessary processing reduces the overall throughput of the system.</span></span>

<span data-ttu-id="690b6-230">オーバーヘッドに関する興味深い点は、多くの開発者が ThreadX のようなマルチスレッド環境ではオーバーヘッドが増加し、システム全体のスループットに悪影響が出ると見なしていることです。</span><span class="sxs-lookup"><span data-stu-id="690b6-230">An interesting point regarding overhead is that many developers assume that multithreaded environments like ThreadX increase overhead and have a negative impact on total system throughput.</span></span> <span data-ttu-id="690b6-231">しかし、場合によっては、マルチスレッドにより、制御ループ環境で発生する冗長なポーリングがすべて排除されて、実際にはオーバーヘッドが軽減されます。</span><span class="sxs-lookup"><span data-stu-id="690b6-231">But in some cases, multithreading actually reduces overhead by eliminating all of the redundant polling that occurs in control loop environments.</span></span> <span data-ttu-id="690b6-232">通常、マルチスレッド カーネルに関連するオーバーヘッドは、コンテキストの切り替えに必要な時間の関数です。</span><span class="sxs-lookup"><span data-stu-id="690b6-232">The overhead associated with multithreaded kernels is typically a function of the time required for context switching.</span></span> <span data-ttu-id="690b6-233">コンテキストの切り替え時間がポーリング プロセスよりも短い場合、ThreadX で提供されるソリューションによってオーバーヘッドが減り、スループットが向上する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="690b6-233">If the context switch time is less than the polling process, ThreadX provides a solution with the potential of less overhead and more throughput.</span></span> <span data-ttu-id="690b6-234">そのため、ある程度の複雑さやサイズを持つアプリケーションに対して、ThreadX は明らかに有利な選択肢になります。</span><span class="sxs-lookup"><span data-stu-id="690b6-234">This makes ThreadX an obvious choice for applications that have any degree of complexity or size.</span></span>

### <a name="processor-isolation"></a><span data-ttu-id="690b6-235">プロセッサの分離</span><span class="sxs-lookup"><span data-stu-id="690b6-235">Processor Isolation</span></span>

<span data-ttu-id="690b6-236">ThreadX では、アプリケーションと基になるプロセッサの間に、プロセッサに依存しない堅牢なインターフェイスが提供されます。</span><span class="sxs-lookup"><span data-stu-id="690b6-236">ThreadX provides a robust processor-independent interface between the application and the underlying processor.</span></span> <span data-ttu-id="690b6-237">これにより、開発者はかなりの時間をかけてハードウェアについて詳細に学習する代わりに、アプリケーションに専念できます。</span><span class="sxs-lookup"><span data-stu-id="690b6-237">This allows developers to concentrate on the application rather than spending a significant amount of time learning hardware details.</span></span>

### <a name="dividing-the-application"></a><span data-ttu-id="690b6-238">アプリケーションの分割</span><span class="sxs-lookup"><span data-stu-id="690b6-238">Dividing the Application</span></span>

<span data-ttu-id="690b6-239">制御ループをベースにしたアプリケーションでは、各開発者は、アプリケーション全体の実行時の動作と要件について詳細な知識を持っている必要があります。</span><span class="sxs-lookup"><span data-stu-id="690b6-239">In control loop-based applications, each developer must have an intimate knowledge of the entire application's run-time behavior and requirements.</span></span> <span data-ttu-id="690b6-240">これは、プロセッサの割り当てロジックがアプリケーション全体にわたって分散されているためです。</span><span class="sxs-lookup"><span data-stu-id="690b6-240">This is because the processor allocation logic is dispersed throughout the entire application.</span></span> <span data-ttu-id="690b6-241">アプリケーションのサイズや複雑さが増すにつれて、すべての開発者がアプリケーション全体の正確な処理要件を覚えていることは不可能になります。</span><span class="sxs-lookup"><span data-stu-id="690b6-241">As an application increases in size or complexity, it becomes impossible for all developers to remember the precise processing requirements of the entire application.</span></span>

<span data-ttu-id="690b6-242">ThreadX を使用すると、各開発者はプロセッサの割り当てに関連する心配から解放され、埋め込みアプリケーションの特定の部分に集中できるようになります。</span><span class="sxs-lookup"><span data-stu-id="690b6-242">ThreadX frees each developer from the worries associated with processor allocation and allows them to concentrate on their specific piece of the embedded application.</span></span> <span data-ttu-id="690b6-243">さらに、ThreadX を使用すると、アプリケーションは明確に定義されたスレッドに強制的に分割されることになります。</span><span class="sxs-lookup"><span data-stu-id="690b6-243">In addition, ThreadX forces the application to be divided into clearly defined threads.</span></span> <span data-ttu-id="690b6-244">そのようにしてアプリケーションをスレッドに分割することで、自ずと開発がはるかにシンプルになります。</span><span class="sxs-lookup"><span data-stu-id="690b6-244">By itself, this division of the application into threads makes development much simpler.</span></span>

### <a name="ease-of-use"></a><span data-ttu-id="690b6-245">使いやすさ</span><span class="sxs-lookup"><span data-stu-id="690b6-245">Ease of Use</span></span>

<span data-ttu-id="690b6-246">ThreadX は、アプリケーション開発者を念頭に置いて設計されています。</span><span class="sxs-lookup"><span data-stu-id="690b6-246">ThreadX is designed with the application developer in mind.</span></span> <span data-ttu-id="690b6-247">ThreadX のアーキテクチャとサービス コール インターフェイスは、簡単に理解できるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="690b6-247">The ThreadX architecture and service call interface are designed to be easily understood.</span></span> <span data-ttu-id="690b6-248">その結果、ThreadX 開発者は、その高度な機能をすぐに使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="690b6-248">As a result, ThreadX developers can quickly use its advanced features.</span></span>

### <a name="improve-time-to-market"></a><span data-ttu-id="690b6-249">市場投入までの時間の短縮</span><span class="sxs-lookup"><span data-stu-id="690b6-249">Improve Time-to-market</span></span>

<span data-ttu-id="690b6-250">ThreadX のすべての利点により、ソフトウェア開発プロセスが高速化されます。</span><span class="sxs-lookup"><span data-stu-id="690b6-250">All of the benefits of ThreadX accelerate the software development process.</span></span> <span data-ttu-id="690b6-251">ThreadX により、プロセッサに関するほとんどの問題と、最も一般的な安全性に関する認定が処理されるため、それらに関連した労力を開発スケジュールから取り除くことができます。</span><span class="sxs-lookup"><span data-stu-id="690b6-251">ThreadX takes care of most processor issues and the most common safety certifications, thereby removing this effort from the development schedule.</span></span> <span data-ttu-id="690b6-252">その結果、市場投入までの時間が短縮されることになります。</span><span class="sxs-lookup"><span data-stu-id="690b6-252">All of this results in a faster time to market!</span></span>

### <a name="protecting-the-software-investment"></a><span data-ttu-id="690b6-253">ソフトウェア投資の保護</span><span class="sxs-lookup"><span data-stu-id="690b6-253">Protecting the Software Investment</span></span>

<span data-ttu-id="690b6-254">このようなアーキテクチャのおかげで、ThreadX は新しいプロセッサや開発ツール環境に簡単に移植できます。</span><span class="sxs-lookup"><span data-stu-id="690b6-254">Because of its architecture, ThreadX is easily ported to new processor and/or development tool environments.</span></span> <span data-ttu-id="690b6-255">このことと、ThreadX によって基になるプロセッサの詳細からアプリケーションが分離されるという事実が相まって、ThreadX アプリケーションの移植性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="690b6-255">This, coupled with the fact that ThreadX insulates applications from details of the underlying processors, makes ThreadX applications highly portable.</span></span> <span data-ttu-id="690b6-256">その結果、アプリケーションの移行パスが保証され、元の開発投資が保護されます。</span><span class="sxs-lookup"><span data-stu-id="690b6-256">As a result, the application's migration path is guaranteed, and the original development investment is protected.</span></span>
