---
title: 第 1 章 - Azure RTOS ThreadX の概要
description: この章では、Azure RTOS ThreadX の概要と、そのアプリケーションおよび利点について説明します。
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 83718ddf5469238e2429855908be2ea5d405f874
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811396"
---
# <a name="chapter-1---introduction-to-azure-rtos-threadx"></a>第 1 章 - Azure RTOS ThreadX の概要

Azure RTOS ThreadX は、埋め込みアプリケーション専用に設計された高性能のリアルタイム カーネルです。 この章では、製品の概要と、そのアプリケーションおよび利点について説明します。

## <a name="threadx-unique-features"></a>ThreadX の固有の機能

他のリアルタイム カーネルとは異なり、ThreadX は汎用性を重視して設計されており、小型マイクロコントローラーをベースとしたものから、強力な CISC、RISC、DSP プロセッサを使用するものまで、アプリケーションを容易にスケーリングできます。

ThreadX は、基になるアーキテクチャに従ってスケーラブルに動作します。 ThreadX サービスは C ライブラリとして実装されているため、アプリケーションによって実際に使用されるサービスのみが実行時イメージに取り込まれます。 したがって、ThreadX の実際のサイズは、全面的にアプリケーションによって決まります。 ほとんどのアプリケーションについて、ThreadX の命令イメージのサイズは 2 KByte から 15 KByte です。

### <a name="picokerneltrade-architecture"></a>*picokernel&trade; アーキテクチャ*

ThreadX サービスは、従来の "*マイクロカーネル*" アーキテクチャのようにカーネル関数を重ねていくのではなく、そのコアに直接接続します。 これにより、コンテキスト切り替えとサービス呼び出しのパフォーマンスが最速になります。 このような非レイヤー設計を *picokernel* アーキテクチャと呼んでいます。

### <a name="ansi-c-source-code"></a>ANSI C ソース コード

ThreadX は主に ANSI C で記述されており、基になるターゲット プロセッサに合わせてカーネルを調整するために、少量のアセンブリ言語が必要です。 この設計により、ThreadX を、非常に短い時間 (通常は数週間以内) で新しいプロセッサ ファミリーに移植できます。

### <a name="advanced-technology"></a>高度なテクノロジ

ThreadX の高度なテクノロジの概要を次に示します。
- シンプルな *picokernel* アーキテクチャ
- 自動スケーリング (占有領域が小さい)
- 決定論的処理
- 高速なリアルタイムのパフォーマンス
- プリエンプティブ スケジューリングと協調スケジューリング
- 柔軟なスレッド優先順位のサポート
- システム オブジェクトの動的生成
- システム オブジェクト数に制限がない
- 最適化された割り込み処理
- Preemption-threshold&trade;
- 優先度の継承
- Event-chaining&trade;
- 高速ソフトウェア タイマー
- 実行時メモリの管理
- 実行時パフォーマンスの監視
- 実行時スタック分析
- 組み込みシステム トレース
- 大規模なプロセッサのサポート
- 大規模な開発ツールのサポート
- 完全なエンディアン ニュートラル

### <a name="not-a-black-box"></a>ブラック ボックスではない

ThreadX のほとんどのディストリビューションには、完全な C ソース コードと、プロセッサ固有のアセンブリ言語が含まれています。 これにより、多くの商用カーネルで発生する "ブラック ボックス" の問題が解消されます。 ThreadX を使用すると、アプリケーション開発者が、カーネルの動作を正確に知ることができます。謎はありません。

また、ソース コードによって、アプリケーション固有の変更も可能です。 推奨はされていませんが、どうしても必要な場合にカーネルを変更できれば、確かに便利です。

これらの機能は、独自の "*社内カーネル*" の操作に慣れている開発者にとっては、特に心強いものです。 期待されているのは、ソース コードがあることと、カーネルを変更できることです。 ThreadX は、このような開発者のための究極のカーネルです。

### <a name="the-rtos-standard"></a>RTOS 標準

ThreadX は、その汎用性と高パフォーマンスの *picokernel* アーキテクチャ、高度なテクノロジ、そして実証済みの移植性により、現在 20 億台以上のデバイスにデプロイされています。 これにより、事実上、ThreadX は、深く埋め込まれているアプリケーションの RTOS 標準となっています。

## <a name="safety-certifications"></a>安全性の認定

### <a name="tv-certification"></a>TÜV 認定

ThreadX は、IEC61508 および IEC-62304 に従って、安全性が重要なシステムでの使用を SGS-TÜV Saar によって認定されています。 この認定により、「電気・電子・プログラマブル電子安全関連系の機能安全」に関する国際電気標準会議 (IEC) 61508 および IEC 62304 の安全性の最高レベルに対応する安全関連ソフトウェアの開発で ThreadX を使用できることが確認されています。 ドイツの SGSGroup と TÜV Saarland の共同事業を通じて結成された SGS-TÜV Saar は、世界中の安全関連システムのための組み込みソフトウェアのテスト、監査、検証、認定を行う、世界有数の公認された独立系企業になりました。 工業安全規格の IEC 61508 と、それから派生したすべての標準 (IEC 62304 を含む) は、電気・電子・プログラマブル電子安全関連の医療デバイス、プロセス制御システム、工業機械、鉄道制御システムの機能安全を保証するために使用されます。

SGS-TÜV Saar は、ISO 26262 標準に従って、安全性が重要な自動車システムで ThreadX を使用することを認可しました。 さらに、ThreadX は、ISO 26262 認定の最高レベルを表す Automotive Safety Integrity Level (ASIL) D に認定されています。

さらに、SGS-TÜV Saar では、ThreadX が SW-SIL 4 までの EN 50128 標準を満たしており、安全性が重要な鉄道アプリケーションで使用できるものとして認定しています。

![TÜV 認定](./media/overview-threadx/partener-logo-sgs-tuv-saar-2.png)

* IEC 61508 (SIL 4 まで)

* IEC 62304 (SW 安全性クラス C まで)

* ISO 26262 ASIL D

* EN 50128 SW-SIL 4

> [!NOTE]
> *TÜV によって認定されている ThreadX のバージョンに関する情報や、テスト レポート、証明書、関連ドキュメントの入手については、Microsoft までお問い合わせください。*

### <a name="misra-c-compliant"></a>MISRA C 準拠

MISRA C は、C プログラミング言語を使用した重要なシステム用の一連のプログラミング ガイドラインです。 元の MISRA C ガイドラインは主に自動車アプリケーションを対象としていましたが、今では MISRA C は安全性が重要な任意のアプリケーションに適用可能なものとして広く認識されています。 ThreadX は、MISRA-C:2004 と MISRA C:2012 のすべての "必要" 規則と "必須" 規則に準拠しています。 ThreadX は、3 つを除くすべての "推奨" 規則にも準拠しています。 詳細については、***ThreadX_MISRA_Compliance.pdf*** ドキュメントを参照してください。

### <a name="ul-certification"></a>UL 認定

ThreadX は、プログラマブル コンポーネント内のソフトウェアに対する UL 60730-1 付属文書 H、CSA E60730-1 付属文書 H、IEC 60730-1 付属文書 H、UL 60335-1 付属文書 R、IEC 60335-1 付属文書 R、UL 1998 の各安全標準に準拠しているものとして UL によって認定されています。 IEC/UL 60730-1 (付属文書 H に「ソフトウェアを使用した制御」に対する要件がある) と共に、IEC 60335-1 標準では、「プログラマブル電子回路」に対する要件がその付属文書 R で説明されています。IEC 60730 付属文書 R と IEC 60335-1 付属文書 R では、洗濯機、乾燥機、冷蔵庫、冷凍庫、オーブンなどのアプライアンスで使用される MCU のハードウェアとソフトウェアの安全性が取り上げられています。

![UL 認定](./media/overview-threadx/partener-logo-c-ru-us-2.png)

*UL/IEC 60730、UL/IEC 60335、UL 1998*

> [!NOTE]
> *TÜV によって認定されている ThreadX のバージョンに関する情報や、テスト レポート、証明書、関連ドキュメントの入手については、Microsoft までお問い合わせください。*

### <a name="certification-pack"></a>Certification Pack

ThreadX Certification Pack&trade; は、安全性が重要な航空、医療、工業システムに必要な最高レベルの信頼性と致命度を ThreadX ベースの製品で保証、または成功裏に遵守するために必要な ThreadX の証拠をすべて提供する、100% 完全で、すぐに使える、業界固有のスタンドアロン パッケージです。 サポートされている認定には、DO-178B、ED-12B、DO-278、FDA510(k)、IEC62304、IEC-60601、ISO-14971、UL-1998、IEC-61508、CENELEC EN50128、BS50128、49CFR236 があります。 認定パックの詳細については、Microsoft にお問い合わせください。

## <a name="embedded-applications"></a>埋め込みアプリケーション

埋め込みアプリケーションは、ワイヤレス通信デバイス、自動車エンジン、レーザー プリンター、医療機器などの製品内に埋め込まれたマイクロプロセッサ上で実行されます。埋め込みアプリケーションのもう 1 つの特徴は、それを実行するソフトウェアとハードウェアに専用の用途があることです。

### <a name="real-time-software"></a>リアルタイム ソフトウェア

アプリケーション ソフトウェアに時間的な制約が課される場合、それは "*リアルタイム*" ソフトウェアと呼ばれます。 埋め込みアプリケーションは、本来的に外部イベントとやり取りするものであるため、ほとんどの場合にリアルタイムです。

### <a name="multitasking"></a>マルチタスキング

前述のように、埋め込みアプリケーションには専用の用途があります。 この目的を達成するには、ソフトウェアがさまざまな "*タスク*" を実行する必要があります。 タスクは、特定の職務を実行する、アプリケーションの半ば独立した部分です。 また、一部のタスクは他のタスクよりも重要な場合があります。 埋め込みアプリケーションの大きな課題の 1 つは、さまざまなアプリケーション タスク間でプロセッサを割り振ることです。 競合するタスク間で処理を割り振ることは、ThreadX の主要な目的です。

### <a name="tasks-vs-threads"></a>タスクとスレッド

タスクのもう 1 つの特徴は、"*タスク*" という用語がさまざまな方法で使用されることです。 これは、個別に読み込み可能なプログラムを意味することがあります。 他の場合には、内部的なプログラム セグメントを指すことがあります。 このため、現代的なオペレーティング システムでは、タスクという用語を使う代わりに、大抵 "*プロセス*" と "*スレッド* " という 2 つの用語に置き換えられています。 "*プロセス*" は、独自のアドレス空間を持つ、完全に独立したプログラムです。それに対して、"*スレッド*" は、プロセス内で実行される半ば独立したプログラム セグメントです。 各スレッドは、同じプロセス アドレス空間を共有します。 スレッド管理に伴うオーバーヘッドは最小限に抑えられています。

ほとんどの埋め込みアプリケーションは、本格的なプロセス指向のオペレーティング システムに付きもののオーバーヘッド (メモリとパフォーマンスの両方) を許容できません。 また、小規模なマイクロプロセッサには、真のプロセス指向オペレーティング システムをサポートするハードウェア アーキテクチャがありません。 このような理由から、ThreadX ではスレッド モデルを実装します。これは、ほとんどのリアルタイム埋め込みアプリケーションの場合に、非常に効率的かつ実用的です。

混乱を避けるため、ThreadX では "*タスク*" という用語は使用されていません。 代わりに、よりわかりやすく現代風の名称である "*スレッド*" が使用されています。

## <a name="threadx-benefits"></a>ThreadX の利点

ThreadX を使用すると、埋め込みアプリケーションに多くの利点がもたらされます。 もちろん、主な利点は、埋め込みアプリケーション スレッドに処理時間が割り当てられる方法にあります。

### <a name="improved-responsiveness"></a>応答性の向上

ThreadX のようなリアルタイム カーネルが登場する前には、ほとんどの埋め込みアプリケーションは単純な制御ループを使用して処理時間を割り当てていました。通常は C の *main* 関数内からです。 この方法は、ごく小規模な、または単純なアプリケーションでは今でも使用されています。 ただし、大規模または複雑なアプリケーションでは、これは実用的ではありません。イベントへの応答時間が、制御ループを 1 回通過するのに要する最悪の場合の処理時間の関数になるからです。 

さらに悪いことに、制御ループに変更を加えるたびに、アプリケーションのタイミング特性が変化します。 これにより、アプリケーションが本質的に不安定になり、保守と改良が困難になります。

ThreadX では、重要な外部イベントに対して高速かつ決定論的な応答時間が提供されます。 ThreadX では、プリエンプティブで優先順位に基づくスケジューリング アルゴリズムを通じてこれを実現します。これにより、優先度の高いスレッドは、実行中の優先度の低いスレッドを横取りできます。 結果として、最悪の場合の応答時間は、コンテキストの切り替えを実行するのに必要な時間に近くなります。 これは決定論的であるだけでなく、非常に高速でもあります。

### <a name="software-maintenance"></a>ソフトウェアのメンテナンス

ThreadX カーネルを使用すると、アプリケーションの開発者は、アプリケーションの他の領域のタイミングが変わってしまうことを心配せずに、アプリケーション スレッドの特定の要件に専念できます。 また、この特徴のおかげで、ThreadX を利用するアプリケーションの修復や拡張がはるかに簡単になります。

### <a name="increased-throughput"></a>スループットの向上

制御ループの応答時間の問題を回避する 1 つの方法は、ポーリングをさらに追加することです。 これにより応答性は向上しますが、最悪の場合の応答時間が一定になることは保証されず、アプリケーションの将来の変更に対応する面では効果がありません。 また、追加のポーリングが原因で、プロセッサが行う不要な処理が増えてしまいます。 このような不要な処理によって、システムの全体的なスループットが低下します。

オーバーヘッドに関する興味深い点は、多くの開発者が ThreadX のようなマルチスレッド環境ではオーバーヘッドが増加し、システム全体のスループットに悪影響が出ると見なしていることです。 しかし、場合によっては、マルチスレッドにより、制御ループ環境で発生する冗長なポーリングがすべて排除されて、実際にはオーバーヘッドが軽減されます。 通常、マルチスレッド カーネルに関連するオーバーヘッドは、コンテキストの切り替えに必要な時間の関数です。 コンテキストの切り替え時間がポーリング プロセスよりも短い場合、ThreadX で提供されるソリューションによってオーバーヘッドが減り、スループットが向上する可能性があります。 そのため、ある程度の複雑さやサイズを持つアプリケーションに対して、ThreadX は明らかに有利な選択肢になります。

### <a name="processor-isolation"></a>プロセッサの分離

ThreadX では、アプリケーションと基になるプロセッサの間に、プロセッサに依存しない堅牢なインターフェイスが提供されます。 これにより、開発者はかなりの時間をかけてハードウェアについて詳細に学習する代わりに、アプリケーションに専念できます。

### <a name="dividing-the-application"></a>アプリケーションの分割

制御ループをベースにしたアプリケーションでは、各開発者は、アプリケーション全体の実行時の動作と要件について詳細な知識を持っている必要があります。 これは、プロセッサの割り当てロジックがアプリケーション全体にわたって分散されているためです。 アプリケーションのサイズや複雑さが増すにつれて、すべての開発者がアプリケーション全体の正確な処理要件を覚えていることは不可能になります。

ThreadX を使用すると、各開発者はプロセッサの割り当てに関連する心配から解放され、埋め込みアプリケーションの特定の部分に集中できるようになります。 さらに、ThreadX を使用すると、アプリケーションは明確に定義されたスレッドに強制的に分割されることになります。 そのようにしてアプリケーションをスレッドに分割することで、自ずと開発がはるかにシンプルになります。

### <a name="ease-of-use"></a>使いやすさ

ThreadX は、アプリケーション開発者を念頭に置いて設計されています。 ThreadX のアーキテクチャとサービス コール インターフェイスは、簡単に理解できるように設計されています。 その結果、ThreadX 開発者は、その高度な機能をすぐに使用できるようになります。

### <a name="improve-time-to-market"></a>市場投入までの時間の短縮

ThreadX のすべての利点により、ソフトウェア開発プロセスが高速化されます。 ThreadX により、プロセッサに関するほとんどの問題と、最も一般的な安全性に関する認定が処理されるため、それらに関連した労力を開発スケジュールから取り除くことができます。 その結果、市場投入までの時間が短縮されることになります。

### <a name="protecting-the-software-investment"></a>ソフトウェア投資の保護

このようなアーキテクチャのおかげで、ThreadX は新しいプロセッサや開発ツール環境に簡単に移植できます。 このことと、ThreadX によって基になるプロセッサの詳細からアプリケーションが分離されるという事実が相まって、ThreadX アプリケーションの移植性が高くなります。 その結果、アプリケーションの移行パスが保証され、元の開発投資が保護されます。
