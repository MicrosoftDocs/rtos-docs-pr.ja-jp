---
title: 第 3 章 - Azure RTOS NetX の機能コンポーネント
description: この章では、機能の観点から見た高パフォーマンスの Azure RTOS NetX TCP/IP スタックについて説明します。
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: db23aa152b2765ac7cc9be098723fc5df0947484
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811702"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx"></a><span data-ttu-id="b956a-103">第 3 章 - Azure RTOS NetX の機能コンポーネント</span><span class="sxs-lookup"><span data-stu-id="b956a-103">Chapter 3 - Functional Components of Azure RTOS NetX</span></span>

<span data-ttu-id="b956a-104">この章では、機能の観点から見た高パフォーマンスの Azure RTOS NetX TCP/IP スタックについて説明します。</span><span class="sxs-lookup"><span data-stu-id="b956a-104">This chapter contains a description of the high-performance Azure RTOS NetX TCP/IP stack from a functional perspective.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="b956a-105">実行の概要</span><span class="sxs-lookup"><span data-stu-id="b956a-105">Execution Overview</span></span>

<span data-ttu-id="b956a-106">NetX アプリケーション内のプログラム実行には、初期化、アプリケーション インターフェイス呼び出し、内部 IP スレッド、IP の定期的なタイマー、およびネットワーク ドライバーの 5 種類があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-106">There are five types of program execution within a NetX application: initialization, application interface calls, internal IP thread, IP periodic timers, and the network driver.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-107">NetX には、ThreadX のインストールが必要で、スレッドの実行、中断、定期的なタイマー、および相互排他設備に依存します。</span><span class="sxs-lookup"><span data-stu-id="b956a-107">NetX requires the installation of ThreadX and depends on its thread execution, suspension, periodic timers, and mutual exclusion facilities.</span></span>

### <a name="initialization"></a><span data-ttu-id="b956a-108">初期化</span><span class="sxs-lookup"><span data-stu-id="b956a-108">Initialization</span></span>

<span data-ttu-id="b956a-109">サービス \***nx_system_initialize** _ は、他の NetX サービスが呼び出される前に呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-109">The service \***nx_system_initialize** _ must be called before any other NetX service is called.</span></span> <span data-ttu-id="b956a-110">システムの初期化は、ThreadX _ *_tx_application_define_*\* ルーチンから、またはアプリケーション スレッドから呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-110">System initialization can be called either from the ThreadX _ *_tx_application_define_*\* routine or from application threads.</span></span>

<span data-ttu-id="b956a-111">\***nx_system_initialize** _ が返されると、パケット プールと IP インスタンスを作成する準備がシステムで整います。</span><span class="sxs-lookup"><span data-stu-id="b956a-111">After \***nx_system_initialize** _ returns, the system is ready to create packet pools and IP instances.</span></span> <span data-ttu-id="b956a-112">IP インスタンスを作成するには既定のパケット プールが必要であるため、IP インスタンスを作成する前に少なくとも 1 つの NetX パケット プールが存在している必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-112">Because creating an IP instance requires a default packet pool, at least one NetX packet pool must exist prior to creating an IP instance.</span></span> <span data-ttu-id="b956a-113">ThreadX 初期化関数 _ *_tx_application_define_*\* とアプリケーション スレッドから、パケット プールと IP インスタンスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-113">Creating packet pools and IP instances are allowed from the ThreadX initialization function _ *_tx_application_define_*\* and from application threads.</span></span>

<span data-ttu-id="b956a-114">内部的には、IP インスタンスの作成は 2 段階で行われます。</span><span class="sxs-lookup"><span data-stu-id="b956a-114">Internally, creating an IP instance is accomplished in two parts.</span></span> <span data-ttu-id="b956a-115">最初の段階は、***tx_application_define*** またはアプリケーション スレッドのコンテキストのいずれかから、呼び出し元のコンテキスト内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-115">The first part is done within the context of the caller, either from ***tx_application_define*** or from an application thread's context.</span></span> <span data-ttu-id="b956a-116">これには、IP データ構造の設定やさまざまな IP リソースの作成が含まれます (内部 IP スレッドを含む)。</span><span class="sxs-lookup"><span data-stu-id="b956a-116">This includes setting up the IP data structure and creating various IP resources, including the internal IP thread.</span></span> <span data-ttu-id="b956a-117">2 番目の段階は、内部 IP スレッドからの初期実行時に実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-117">The second part is performed during the initial execution from the internal IP thread.</span></span> <span data-ttu-id="b956a-118">ここで、IP 作成の第 1 段階で提供されるネットワーク ドライバーが最初に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-118">This is where the network driver, supplied during the first part of IP creation, is first called.</span></span> <span data-ttu-id="b956a-119">内部 IP スレッドからネットワーク ドライバーを呼び出すと、ドライバーは、I/O を実行して初期化処理中に一時停止できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-119">Calling the network driver from the internal IP thread enables the driver to perform I/O and suspend during its initialization processing.</span></span> <span data-ttu-id="b956a-120">初期化処理からネットワーク ドライバーが返されると、IP の作成が完了します。</span><span class="sxs-lookup"><span data-stu-id="b956a-120">When the network driver returns from its initialization processing, the IP creation is complete.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-121">NetX サービス **nx_ip_status_check** は、IP インスタンスとそのプライマリ インターフェイスの状態に関する情報を取得するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-121">The NetX service **nx_ip_status_check** is available to obtain information on the IP instance and its primary interface status.</span></span> <span data-ttu-id="b956a-122">このような状態情報には、リンクが初期化され、有効になっていて、IP アドレスが解決されているかどうかが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-122">Such status information includes whether or not the link is initialized, enabled, and IP address is resolved.</span></span> <span data-ttu-id="b956a-123">この情報は、新しく作成された IP インスタンスを使用する必要があるアプリケーション スレッドを同期するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-123">This information is used to synchronize application threads needing to use a newly created IP instance.</span></span> <span data-ttu-id="b956a-124">マルチホーム システムについては、以下の「マルチホーム サポート」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b956a-124">For multihome systems, see "Multihome Support" below.</span></span> <span data-ttu-id="b956a-125">指定されたインターフェイスに関する情報を取得するために **nx_ip_interface_status_check** を使用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-125">**nx_ip_interface_status_check** is available to obtain information on the specified interface.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="b956a-126">アプリケーション インターフェイス呼び出し</span><span class="sxs-lookup"><span data-stu-id="b956a-126">Application Interface Calls</span></span>

<span data-ttu-id="b956a-127">アプリケーションからの呼び出しは、ほとんどの場合、ThreadX RTOS で実行されているアプリケーション スレッドから作成されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-127">Calls from the application are largely made from application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="b956a-128">ただし、一部の初期化、作成、および有効化のサービスは ***tx_application_define*** から呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-128">However, some initialization, create, and enable services may be called from ***tx_application_define***.</span></span> <span data-ttu-id="b956a-129">第 4 章の許可元に関するセクションでは、各 NetX サービスをどこから呼び出せるかを示しています。</span><span class="sxs-lookup"><span data-stu-id="b956a-129">The "Allowed From" sections in Chapter 4 indicate from which each NetX service can be called.</span></span>

<span data-ttu-id="b956a-130">ほとんどの場合、チェックサムの計算などの負荷の高いアクティビティは、他のスレッドの IP インスタンスへのアクセスをブロックすることなく、呼び出し元スレッドのコンテキスト内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-130">For the most part, processing intensive activities such as computing checksums is done within the calling thread's context—without blocking the access of other threads to the IP instance.</span></span> <span data-ttu-id="b956a-131">たとえば、送信時に、基になる IP 送信関数を呼び出す前に、***nx_udp_socket_send*** サービス内で UDP チェックサム計算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-131">For example, on transmission, the UDP checksum calculation is performed inside the ***nx_udp_socket_send*** service, prior to calling the underlying IP send function.</span></span> <span data-ttu-id="b956a-132">受信したパケットでは、***nx_udp_socket_receive*** サービスで UDP チェックサムが計算され、アプリケーション スレッドのコンテキストで実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-132">On a received packet, the UDP checksum is calculated in the ***nx_udp_socket_receive*** service, executed in the context of the application thread.</span></span> <span data-ttu-id="b956a-133">これにより、優先度の低いスレッドで負荷の高いチェックサム計算が行われることが原因で、優先順位の高いスレッドのネットワーク要求が停止されるのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-133">This helps prevent stalling network requests of higher-priority threads because of processing intensive checksum computation in lower-priority threads.</span></span>

<span data-ttu-id="b956a-134">IP アドレスやポート番号などの値は、ホストのバイト順で API 関数に渡されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-134">Values, such as IP addresses and port numbers, are passed to API functions in host byte order.</span></span> <span data-ttu-id="b956a-135">内部的には、これらの値はホストのバイト順で格納もされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-135">Internally these values are stored in host byte order as well.</span></span> <span data-ttu-id="b956a-136">これにより、開発者はデバッガーを使用して値を簡単に表示できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-136">This enables developers to easily view the values via a debugger.</span></span> <span data-ttu-id="b956a-137">これらの値は、送信のためにフレーム内にプログラミングされた場合、ネットワークのバイト順に変換されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-137">When these values are programmed into a frame for transmission, they are converted to network byte order.</span></span>

### <a name="internal-ip-thread"></a><span data-ttu-id="b956a-138">内部 IP スレッド</span><span class="sxs-lookup"><span data-stu-id="b956a-138">Internal IP Thread</span></span>

<span data-ttu-id="b956a-139">前述のように、NetX の各 IP インスタンスには独自のスレッドがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-139">As mentioned, each IP instance in NetX has its own thread.</span></span> <span data-ttu-id="b956a-140">内部 IP スレッドの優先順位とスタック サイズは、***nx_ip_create*** サービスで定義されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-140">The priority and stack size of the internal IP thread is defined in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="b956a-141">内部 IP スレッドは、実行可能モードで作成されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-141">The internal IP thread is created in a ready-to-execute mode.</span></span> <span data-ttu-id="b956a-142">IP スレッドの優先順位が呼び出し元のスレッドよりも高い場合、IP 作成呼び出しの内部でプリエンプションが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-142">If the IP thread has a higher priority than the calling thread, preemption may occur inside the IP create call.</span></span>

<span data-ttu-id="b956a-143">内部 IP スレッドのエントリ ポイントは、内部関数 ***_nx_ip_thread_entry*** にあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-143">The entry point of the internal IP thread is at the internal function ***_nx_ip_thread_entry***.</span></span> <span data-ttu-id="b956a-144">開始されると、内部 IP スレッドでは最初にネットワーク ドライバーの初期化が完了されます。これは、アプリケーション固有のネットワーク ドライバーに対する 3 回の呼び出しで構成されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-144">When started, the internal IP thread first completes network driver initialization, which consists of making three calls to the application-specific network driver.</span></span> <span data-ttu-id="b956a-145">最初の呼び出しでは、ネットワーク ドライバーを IP インスタンスに接続した後、初期化呼び出しを実行します。これにより、ネットワーク ドライバーは初期化プロセスを実行できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-145">The first call is to attach the network driver to the IP instance, followed by an initialization call, which allows the network driver to go through the initialization process.</span></span> <span data-ttu-id="b956a-146">ネットワーク ドライバーが初期化から戻されると (ハードウェアが適切に設定されるのを待機している間に停止される場合があります)、内部 IP スレッドはネットワーク ドライバーを再度呼び出して、リンクを有効にします。</span><span class="sxs-lookup"><span data-stu-id="b956a-146">After the network driver returns from initialization (it may suspend while waiting for the hardware to be properly set up), the internal IP thread calls the network driver again to enable the link.</span></span> 

<span data-ttu-id="b956a-147">ネットワーク ドライバーがリンク有効化の呼び出しから戻されると、内部 IP スレッドは無限ループに入り、この IP インスタンスの処理を必要とするさまざまなイベントを確認します。</span><span class="sxs-lookup"><span data-stu-id="b956a-147">After the network driver returns from the link enable call, the internal IP thread enters an endless loop checking for various events that need processing for this IP instance.</span></span> <span data-ttu-id="b956a-148">このループで処理されるイベントには、遅延 IP パケット受信、IP パケット フラグメント アセンブリ、ICMP ping 処理、IGMP 処理、TCP パケット キュー処理、TCP 周期処理、IP フラグメント アセンブリ タイムアウト、および IGMP 周期処理が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-148">Events processed in this loop include deferred IP packet reception, IP packet fragment assembly, ICMP ping processing, IGMP processing, TCP packet queue processing, TCP periodic processing, IP fragment assembly timeouts, and IGMP periodic processing.</span></span> <span data-ttu-id="b956a-149">イベントには、アドレス解決アクティビティ (IP ネットワークでの ARP パケット処理と ARP の周期処理) も含まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-149">Events also include address resolution activities: ARP packet processing and ARP periodic processing in the IP network.</span></span>

> [!NOTE]
> <span data-ttu-id="b956a-150">*リッスンや切断のコールバックを含む NetX コールバック関数は、元の呼び出し元スレッドではなく、内部 IP スレッドから呼び出されます。アプリケーションは、NetX コールバック関数内で中断しないように注意する必要があります。*</span><span class="sxs-lookup"><span data-stu-id="b956a-150">*The NetX callback functions, including listen and disconnect callbacks, are called from the internal IP thread—not the original calling thread. The application must take care not to suspend inside any NetX callback function.*</span></span>

### <a name="ip-periodic-timers"></a><span data-ttu-id="b956a-151">IP の定期的なタイマー</span><span class="sxs-lookup"><span data-stu-id="b956a-151">IP Periodic Timers</span></span>
<span data-ttu-id="b956a-152">各 IP インスタンスには、ThreadX の定期的なタイマーが 2 つ使用されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-152">There are two ThreadX periodic timers used for each IP instance.</span></span> <span data-ttu-id="b956a-153">1 つ目は、ARP、IGMP、TCP タイムアウト用の 1 秒のタイマーで、IP フラグメントの再アセンブル処理にも使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-153">The first one is a one-second timer for ARP, IGMP, TCP timeout, and it also drives IP fragment reassemble processing.</span></span> <span data-ttu-id="b956a-154">2 つ目のタイマーは、TCP 再送信タイムアウトに使用される 100 ミリ秒タイマーです。</span><span class="sxs-lookup"><span data-stu-id="b956a-154">The second timer is a 100ms timer to drive the TCP retransmission timeout.</span></span>

### <a name="network-driver"></a><span data-ttu-id="b956a-155">ネットワーク ドライバー</span><span class="sxs-lookup"><span data-stu-id="b956a-155">Network Driver</span></span>
<span data-ttu-id="b956a-156">NetX の各 IP インスタンスには、プライマリ インターフェイスがあります。これは、***nx_ip_create*** サービスで指定されているデバイス ドライバーによって識別されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-156">Each IP instance in NetX has a primary interface, which is identified by its device driver specified in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="b956a-157">ネットワーク ドライバーでは、パケットの伝送、パケットの受信、状態と制御の要求など、さまざまな NetX 要求が処理されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-157">The network driver is responsible for handling various NetX requests, including packet transmission, packet reception, and requests for status and control.</span></span>

<span data-ttu-id="b956a-158">マルチホーム システムの場合、IP インスタンスは複数のインターフェイスを持ち、それぞれのインターフェイスでこれらのタスクを実行するネットワーク ドライバーが関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="b956a-158">For a multi-home system, the IP instance has multiple interfaces, each with an associated network driver that performs these tasks for the respective interface.</span></span>

<span data-ttu-id="b956a-159">ネットワーク ドライバーでは、メディアで発生している非同期イベントも処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-159">The network driver must also handle asynchronous events occurring on the media.</span></span> <span data-ttu-id="b956a-160">メディアからの非同期イベントには、パケットの受信、パケット転送の完了、および状態の変更が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-160">Asynchronous events from the media include packet reception, packet transmission completion, and status changes.</span></span> <span data-ttu-id="b956a-161">NetX では、さまざまなイベントを処理するいくつかのアクセス関数がネットワーク ドライバーに提供されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-161">NetX provides the network driver with several access functions to handle various events.</span></span> <span data-ttu-id="b956a-162">これらの関数は、ネットワーク ドライバーの割り込みサービスのルーチン部分から呼び出されるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-162">These functions are designed to be called from the interrupt service routine portion of the network driver.</span></span> <span data-ttu-id="b956a-163">IP ネットワークの場合、ネットワーク ドライバーは、受信したすべての ARP パケットを \* **_nx_arp_packet_deferred_receive** _ 内部関数に転送する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-163">For IP networks, the network driver should forward all ARP packets received to the \***_nx_arp_packet_deferred_receive** _ internal function.</span></span> <span data-ttu-id="b956a-164">すべての RARP パケットは _ *_ _nx_rarp_packet_deferred_receive_* _ 内部関数に転送される必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-164">All RARP packets should be forwarded to _ *_ _nx_rarp_packet_deferred_receive_* _ internal function.</span></span> <span data-ttu-id="b956a-165">IP パケットには 2 つのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-165">There are two options for IP packets.</span></span> <span data-ttu-id="b956a-166">IP パケットの高速ディスパッチが必要な場合は、受信 IP パケットを _ *_ _nx_ip_packet_receive_* _ に転送してすぐに処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-166">If fast dispatch of IP packets is required, incoming IP packets should be forwarded to _ *_ _nx_ip_packet_receive_* _ for immediate processing.</span></span> <span data-ttu-id="b956a-167">これにより、IP パケットを処理する際の NetX パフォーマンスが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="b956a-167">This greatly improves NetX performance in handling IP packets.</span></span> <span data-ttu-id="b956a-168">それ以外の場合、ネットワーク ドライバーでは、IP パケットを _\*_ _nx_ip_packet_deferred_receive_\*\* に転送する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-168">Otherwise, the network driver should forward IP packets to _\*_ _nx_ip_packet_deferred_receive_\*\*.</span></span> <span data-ttu-id="b956a-169">このサービスでは、IP パケットが遅延処理キューに配置されます。このキューでパケットは内部 IP スレッドによって処理されます。これにより、ISR 処理時間が最短になります。</span><span class="sxs-lookup"><span data-stu-id="b956a-169">This service places the IP packet in the deferred processing queue where it is then handled by the internal IP thread, which results in the least amount of ISR processing time.</span></span>

<span data-ttu-id="b956a-170">また、ネットワーク ドライバーでは、割り込み処理を遅延させて、IP スレッドのコンテキストから実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="b956a-170">The network driver can also defer interrupt processing to run out of the context of the IP thread.</span></span> <span data-ttu-id="b956a-171">このモードの ISR では、必要な情報が保存され、内部関数 ***_nx_ip_driver_deferred_processing*** が呼び出されて、割り込みコントローラーが確認されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-171">In this mode, the ISR shall save the necessary information, call the internal function ***_nx_ip_driver_deferred_processing***, and acknowledge the interrupt controller.</span></span> <span data-ttu-id="b956a-172">このサービスでは、割り込みを発生させるイベントの処理を完了するために、デバイス ドライバーへのコールバックをスケジュールするように、IP スレッドに通知されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-172">This service notifies IP thread to schedule a callback to the device driver to complete the processing of the event that causes the interrupt.</span></span>

<span data-ttu-id="b956a-173">一部のネットワーク コントローラーでは、貴重な CPU リソースを消費することなく、ハードウェアで TCP/IP ヘッダー チェックサムの計算と検証が実行されるようにできます。</span><span class="sxs-lookup"><span data-stu-id="b956a-173">Some network controllers are capable of performing TCP/IP header checksum computation and validation in hardware, without taking up valuable CPU resources.</span></span> <span data-ttu-id="b956a-174">ハードウェア機能を利用するために、NetX では、コンパイル時にさまざまなソフトウェア チェックサム計算を有効または無効にしたり、実行時にチェックサム計算をオンまたはオフにしたりするためのオプションが用意されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-174">To take advantage of the hardware capability feature, NetX provides options to enable or disable various software checksum computation at compilation time, as well as turning on or off checksum computation at run time.</span></span> <span data-ttu-id="b956a-175">NetX ネットワーク ドライバーの記述の詳細については、「[第 5 章 NetX ネットワーク ドライバー](chapter5.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b956a-175">See "[Chapter 5 NetX Network Drivers](chapter5.md)" for more detailed information on writing NetX network drivers.</span></span>

### <a name="multihome-support"></a><span data-ttu-id="b956a-176">マルチホーム サポート</span><span class="sxs-lookup"><span data-stu-id="b956a-176">Multihome Support</span></span>
<span data-ttu-id="b956a-177">NetX では、単一の IP インスタンスを使用して複数の物理デバイスに接続されたシステムがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-177">NetX supports systems connected to multiple physical devices using a single IP instance.</span></span> <span data-ttu-id="b956a-178">各物理インターフェイスは、IP インスタンス内のインターフェイス制御ブロックに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b956a-178">Each physical interface is assigned to an interface control block in the IP instance.</span></span> <span data-ttu-id="b956a-179">マルチホーム システムを使用するアプリケーションでは、**NX_MAX_PHSYCIAL_INTERFACES** の値をシステムに接続されている物理デバイスの数に定義し、NetX ライブラリを再構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-179">Applications wishing to use a multihome system must define the value for **NX_MAX_PHSYCIAL_INTERFACES** to the number of physical devices attached to the system, and rebuild NetX library.</span></span> <span data-ttu-id="b956a-180">既定では **NX_MAX_PHYSICAL_INTERFACES** が 1 に設定され、IP インスタンスに 1 つのインターフェイス制御ブロックが作成されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-180">By default **NX_MAX_PHYSICAL_INTERFACES** is set to one, creating one interface control block in the IP instance.</span></span>

<span data-ttu-id="b956a-181">NetX アプリケーションでは、\***nx_ip_create** _ サービスを使用して、プライマリ デバイス用の単一の IP インスタンスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-181">The NetX application creates a single IP instance for the primary device using the \***nx_ip_create** _ service.</span></span> <span data-ttu-id="b956a-182">追加のネットワーク デバイスごとに、アプリケーションで _ *_nx_ip_interface_attach_*\* サービスを使用して、デバイスが IP インスタンスに接続されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-182">For each additional network devices, the application attaches the device to the IP instance using the _ *_nx_ip_interface_attach_*\* service.</span></span>

<span data-ttu-id="b956a-183">各ネットワーク インターフェイス構造には、IP 制御ブロックに含まれるネットワーク インターフェイスに関するネットワーク情報のサブセットが含まれています。これには、インターフェイス IP アドレス、サブネット マスク、IP MTU サイズ、および MAC レイヤー アドレス情報が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-183">Each network interface structure contains a subset of network information about the network interface that is contained in the IP control block, including interface IP address, subnet mask, IP MTU size, and MAC-layer address information.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-184">*マルチホーム サポートが有効な NetX には、以前のバージョンの NetX との下位互換性があります。明示的なインターフェイス情報を受け取らないサービスは、既定でプライマリ ネットワーク デバイスに設定されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-184">*NetX with multihome support is backward compatible with earlier versions of NetX. Services that do not take explicit interface information default to the primary network device.*</span></span>

<span data-ttu-id="b956a-185">IP インスタンスの一覧で、プライマリ インターフェイスはインデックス 0 になります。</span><span class="sxs-lookup"><span data-stu-id="b956a-185">The primary interface has index zero in the IP instance list.</span></span> <span data-ttu-id="b956a-186">IP インスタンスに接続されているそれ以降の各デバイスには、次のインデックスが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b956a-186">Each subsequent device attached to the IP instance is assigned the next index.</span></span>

<span data-ttu-id="b956a-187">IP インスタンスが有効になっているすべての上位層プロトコル サービス (TCP、UDP、ICMP、IGMP を含む) は、接続されているすべてのデバイスで使用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-187">All upper layer protocol services for which the IP instance is enabled, including TCP, UDP, ICMP, and IGMP, are available to all the attached devices.</span></span>

<span data-ttu-id="b956a-188">ほとんどの場合、NetX ではパケットの送信時に使用する最適な送信元アドレスを決定できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-188">In most cases, NetX can determine the best source address to use when transmitting a packet.</span></span> <span data-ttu-id="b956a-189">送信元アドレスの選択は、送信先アドレスに基づいています。</span><span class="sxs-lookup"><span data-stu-id="b956a-189">The source address selection is based on the destination address.</span></span> <span data-ttu-id="b956a-190">NetX サービスは、送信先アドレスによって最適な送信元アドレスを特定できない場合に、使用する特定の送信元アドレスをアプリケーションで指定できるように提供されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-190">NetX services are provided to allow applications to specify a specific source address to use, in cases where the most suitable one cannot be determined by the destination address.</span></span> <span data-ttu-id="b956a-191">例として、アプリケーションが IP ブロードキャストまたはマルチキャストの送信先アドレスにパケットを送信する必要があるマルチホーム システムの場合を考えます。</span><span class="sxs-lookup"><span data-stu-id="b956a-191">An example would be in a multihome system, an application needs to send a packet to an IP broadcast or multicast destination addresses.</span></span>

<span data-ttu-id="b956a-192">マルチホーム アプリケーションの開発に特化したサービスには、次のものがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-192">Services specifically for developing multihome applications include the following:</span></span>

<span data-ttu-id="b956a-193">*nx_igmp_multicast_interface_join nx_ip_driver_interface_direct_command nx_ip_interface_address_get nx_ip_interface_address_set nx_ip_interface_attach nx_ip_interface_info_get nx_ip_interface_status_check nx_ip_raw_packet_interface_send nx_udp_socket_interface_send*</span><span class="sxs-lookup"><span data-stu-id="b956a-193">*nx_igmp_multicast_interface_join nx_ip_driver_interface_direct_command nx_ip_interface_address_get nx_ip_interface_address_set nx_ip_interface_attach nx_ip_interface_info_get nx_ip_interface_status_check nx_ip_raw_packet_interface_send nx_udp_socket_interface_send*</span></span>

<span data-ttu-id="b956a-194">これらのサービスの詳細については「[第 4 章 - Azure RTOS NetX サービスの説明](chapter4.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b956a-194">These services are explained in greater detail in "[Chapter 4 - Description of Azure RTOS NetX Services](chapter4.md)".</span></span>

### <a name="loopback-interface"></a><span data-ttu-id="b956a-195">ループバック インターフェイス</span><span class="sxs-lookup"><span data-stu-id="b956a-195">Loopback Interface</span></span>
<span data-ttu-id="b956a-196">ループバック インターフェイスは、物理リンクがアタッチされていない特殊なネットワーク インターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="b956a-196">The loopback interface is a special network interface without an physical link attached to.</span></span> <span data-ttu-id="b956a-197">ループバック インターフェイスは、アプリケーションが IP ループバック アドレス 127.0.0.1 を使用して通信することを許可します。</span><span class="sxs-lookup"><span data-stu-id="b956a-197">The loopback interface allows applications to communicate using the IP loopback address 127.0.0.1</span></span>

<span data-ttu-id="b956a-198">論理ループバック インターフェイスを利用するには、構成可能なオプション ***NX_DISABLE_LOOPBACK_INTERFACE*** が設定されていないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="b956a-198">To utilize a logical loopback interface, ensure the configurable option ***NX_DISABLE_LOOPBACK_INTERFACE*** is not set.</span></span>

### <a name="interface-control-blocks"></a><span data-ttu-id="b956a-199">インターフェイス制御ブロック</span><span class="sxs-lookup"><span data-stu-id="b956a-199">Interface Control Blocks</span></span>
<span data-ttu-id="b956a-200">IP インスタンス内のインターフェイス制御ブロックの数は、物理インターフェイスの数 (\***NX_MAX_PHYSICAL_INTERFACES** _ によって定義されます) に、ループバック インターフェイス (有効になっている場合) を加算したものです。</span><span class="sxs-lookup"><span data-stu-id="b956a-200">The number of interface control blocks in the IP instance is the number of physical interfaces (defined by \***NX_MAX_PHYSICAL_INTERFACES** _) plus the loopback interface if it is enabled.</span></span> <span data-ttu-id="b956a-201">インターフェイスの合計数は、_*_NX_MAX_IP_INTERFACES_*\* で定義されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-201">The total number of interfaces is defined in _\*_NX_MAX_IP_INTERFACES_\*\*.</span></span>

## <a name="protocol-layering"></a><span data-ttu-id="b956a-202">プロトコルのレイヤー化</span><span class="sxs-lookup"><span data-stu-id="b956a-202">Protocol Layering</span></span>

<span data-ttu-id="b956a-203">NetX によって実装される TCP/IP は、レイヤー化されたプロトコルです。これは、より複雑なプロトコルが、より単純な基盤となるプロトコルの上に構築されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="b956a-203">The TCP/IP implemented by NetX is a layered protocol, which means more complex protocols are built on top of simpler underlying protocols.</span></span> <span data-ttu-id="b956a-204">TCP/IP では、最下位層のプロトコルが "*リンク層*" にあり、ネットワーク ドライバーによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-204">In TCP/ IP, the lowest layer protocol is at the *link Layer* and is handled by the network driver.</span></span> <span data-ttu-id="b956a-205">このレベルは、通常、イーサネットを対象としていますが、ファイバー、シリアル、または事実上すべての物理メディアである可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-205">This level is typically targeted towards Ethernet, but it could also be fiber, serial, or virtually any physical media.</span></span>

<span data-ttu-id="b956a-206">リンク層の上には、"*ネットワーク層*" があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-206">On top of the link layer is the *Network layer*.</span></span> <span data-ttu-id="b956a-207">TCP/IP ではこれが IP です。基本的には単純なパケットを送受信する役割を担い、ベストエフォートとしてはネットワーク全体でこれを行います。</span><span class="sxs-lookup"><span data-stu-id="b956a-207">In TCP/IP, this is the IP, which is basically responsible for sending and receiving simple packets, in a best-effort manner, across the network.</span></span> <span data-ttu-id="b956a-208">ICMP や IGMP などの管理の種類のプロトコルは、通常、送信と受信のために IP に依存している場合でも、ネットワーク層として分類されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-208">Management type protocols like ICMP and IGMP are typically also categorized as network layers, even though they rely on IP for sending and receiving.</span></span>

<span data-ttu-id="b956a-209">"*トランスポート層*" は、ネットワーク層の上に置かれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-209">The *Transport layer* rests on top of the network layer.</span></span> <span data-ttu-id="b956a-210">この層は、ネットワーク上でホスト間のデータ フローを管理する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="b956a-210">This layer is responsible for managing the flow of data between hosts on the network.</span></span> <span data-ttu-id="b956a-211">NetX でサポートされる転送サービスには、UDP と TCP の 2 種類があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-211">There are two types of transport services supported by NetX: UDP and TCP.</span></span> <span data-ttu-id="b956a-212">UDP サービスは、コネクションレス方式で 2 つのホスト間でデータをベストエフォートで送受信します。一方、TCP は、2 つのホスト エンティティ間に信頼性の高い接続指向サービスを提供します。</span><span class="sxs-lookup"><span data-stu-id="b956a-212">UDP services provide best-effort sending and receiving of data between two hosts in a connectionless manner, while TCP provides reliable connection-oriented service between two host entities.</span></span>

<span data-ttu-id="b956a-213">このレイヤー化は、実際のネットワーク データ パケットに反映されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-213">This layering is reflected in the actual network data packets.</span></span> <span data-ttu-id="b956a-214">TCP/IP の各層には、ヘッダーと呼ばれる情報のブロックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-214">Each layer in TCP/IP contains a block of information called a header.</span></span> <span data-ttu-id="b956a-215">データ (および場合によってはプロトコル情報) をヘッダーで囲むこの手法は、一般にデータのカプセル化と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-215">This technique of surrounding data (and possibly protocol information) with a header is typically called data encapsulation.</span></span> <span data-ttu-id="b956a-216">図 1 は、NetX のレイヤー化の例を示し、図 2 は、送信される UDP データのデータ カプセル化を示しています。</span><span class="sxs-lookup"><span data-stu-id="b956a-216">Figure 1 shows an example of NetX layering and Figure 2 shows the resulting data encapsulation for UDP data being sent.</span></span>

![プロトコルのレイヤー化](./media/user-guide/protocol-layering.png)

<span data-ttu-id="b956a-218">**図 1. プロトコルのレイヤー化**</span><span class="sxs-lookup"><span data-stu-id="b956a-218">**FIGURE 1. Protocol Layering**</span></span>

![UDP データのカプセル化](./media/user-guide/udp-data-encapsulation.png)

<span data-ttu-id="b956a-220">**図 2. UDP データのカプセル化**</span><span class="sxs-lookup"><span data-stu-id="b956a-220">**FIGURE 2. UDP Data Encapsulation**</span></span>

## <a name="packet-pools"></a><span data-ttu-id="b956a-221">パケット プール</span><span class="sxs-lookup"><span data-stu-id="b956a-221">Packet Pools</span></span>

<span data-ttu-id="b956a-222">パケットを高速かつ決定論的な方法で割り当てることは、常に、リアルタイム ネットワーク アプリケーションの課題です。</span><span class="sxs-lookup"><span data-stu-id="b956a-222">Allocating packets in a fast and deterministic manner is always a challenge in real-time networking applications.</span></span> <span data-ttu-id="b956a-223">これを念頭に置いて、NetX では、固定サイズのネットワーク パケットの複数のプールを作成および管理する機能が提供されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-223">With this in mind, NetX provides the ability to create and manage multiple pools of fixed-size network packets.</span></span>

<span data-ttu-id="b956a-224">NetX パケット プールは固定サイズのメモリ ブロックで構成されているため、内部断片化の問題は発生しません。</span><span class="sxs-lookup"><span data-stu-id="b956a-224">Because NetX packet pools consist of fixed-size memory blocks, there are never any internal fragmentation problems.</span></span> <span data-ttu-id="b956a-225">もちろん、断片化によって本質的に非決定論的な動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="b956a-225">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span>

<span data-ttu-id="b956a-226">さらに、NetX パケットを割り当てて解放するために必要な時間は、単純なリンクリスト操作と同等です。</span><span class="sxs-lookup"><span data-stu-id="b956a-226">In addition, the time required to allocate and free a NetX packet amounts to simple linked-list manipulation.</span></span> <span data-ttu-id="b956a-227">さらに、使用可能な一覧の先頭でパケットの割り当てと割り当て解除が行われます。</span><span class="sxs-lookup"><span data-stu-id="b956a-227">Furthermore, packet allocation and deallocation is done at the head of the available list.</span></span> <span data-ttu-id="b956a-228">これにより、可能なリンク リストの処理が最速になります。</span><span class="sxs-lookup"><span data-stu-id="b956a-228">This provides the fastest possible linked list processing.</span></span>

<span data-ttu-id="b956a-229">通常、固定サイズのパケット プールの主な欠点は、柔軟性の欠如です。</span><span class="sxs-lookup"><span data-stu-id="b956a-229">Lack of flexibility is typically the main drawback of fixed-size packet pools.</span></span> <span data-ttu-id="b956a-230">最悪の場合の受信パケットも処理できる最適なパケット ペイロード サイズを判断することは、困難な作業です。</span><span class="sxs-lookup"><span data-stu-id="b956a-230">Determining the optimal packet payload size that also handles the worst-case incoming packet is a difficult task.</span></span> <span data-ttu-id="b956a-231">NetX パケットは、"*パケット チェーン*" と呼ばれるオプションの機能を使用してこの問題に対処します。</span><span class="sxs-lookup"><span data-stu-id="b956a-231">NetX packets address this problem with an optional feature called *packet chaining*.</span></span> <span data-ttu-id="b956a-232">実際のネットワーク パケットは、互いにリンクされた 1 つ以上の NetX パケットで構成されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-232">An actual network packet can be made of one or more NetX packets linked together.</span></span> <span data-ttu-id="b956a-233">また、パケット ヘッダーはパケットの先頭へのポインターを保持します。</span><span class="sxs-lookup"><span data-stu-id="b956a-233">In addition, the packet header maintains a pointer to the top of the packet.</span></span> <span data-ttu-id="b956a-234">プロトコルが追加されると、このポインターは単純に後方に移動されて、新しいヘッダーがデータの前に直接書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-234">As additional protocols are added, this pointer is simply moved backwards and the new header is written directly in front of the data.</span></span> <span data-ttu-id="b956a-235">柔軟なパケット テクノロジを使用しない場合、スタックは別のバッファーを割り当て、新しいヘッダーを使用して新しいバッファーにデータをコピーする必要があります。これは、負荷の高い処理です。</span><span class="sxs-lookup"><span data-stu-id="b956a-235">Without the flexible packet technology, the stack would have to allocate another buffer and copy the data into a new buffer with the new header, which is processing intensive.</span></span>

<span data-ttu-id="b956a-236">各パケットのペイロード サイズは特定のパケット プールに対して固定されているため、ペイロード サイズを超えるアプリケーション データでは、複数のパケットが連結されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-236">Since each packet payload size is fixed for a given packet pool, application data larger than the payload size  requires multiple packets chained together.</span></span> <span data-ttu-id="b956a-237">パケットにユーザー データを入力する場合は、アプリケーションでサービス ***nx_packet_data_append*** を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-237">When filling a packet with user data, the application must use the service ***nx_packet_data_append***.</span></span> <span data-ttu-id="b956a-238">このサービスによって、アプリケーション データがパケットに移動されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-238">This service moves application data into a packet.</span></span> <span data-ttu-id="b956a-239">パケットがユーザー データを保持するのに十分でない場合は、ユーザー データを格納するための追加のパケットが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b956a-239">In situations where a packet is not enough to hold user data, additional packets are allocated to store user data.</span></span> <span data-ttu-id="b956a-240">パケット チェーンを使用するには、ドライバーがチェーン化されたパケットとの間で送受信できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-240">To use packet chaining, the driver must be able to receive into or transmit from chained packets.</span></span>

<span data-ttu-id="b956a-241">各 NetX パケット メモリ プールは、パブリック リソースです。</span><span class="sxs-lookup"><span data-stu-id="b956a-241">Each NetX packet memory pool is a public resource.</span></span> <span data-ttu-id="b956a-242">NetX では、パケット プールの使用方法に関する制約はありません。</span><span class="sxs-lookup"><span data-stu-id="b956a-242">NetX places no constraints on how packet pools are used.</span></span>

### <a name="packet-pool-memory-area"></a><span data-ttu-id="b956a-243">パケット プールのメモリ領域</span><span class="sxs-lookup"><span data-stu-id="b956a-243">Packet Pool Memory Area</span></span>
<span data-ttu-id="b956a-244">パケット プールのメモリ領域は、作成時に指定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-244">The memory area for the packet pool is specified during creation.</span></span> <span data-ttu-id="b956a-245">ThreadX オブジェクトと NetX オブジェクトの他のメモリ領域と同様に、ターゲットのアドレス空間内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-245">Like other memory areas for ThreadX and NetX objects, it can be located anywhere in the target's address space.</span></span> <span data-ttu-id="b956a-246">アプリケーションに非常に高い柔軟性が提供されるため、これは重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="b956a-246">This is an important feature because of the considerable flexibility it gives the application.</span></span> <span data-ttu-id="b956a-247">たとえば、ネットワーク バッファー用に高速メモリ領域がある通信製品を考えます。</span><span class="sxs-lookup"><span data-stu-id="b956a-247">For example, suppose that a communication product has a high-speed memory area for network buffers.</span></span> <span data-ttu-id="b956a-248">このメモリ領域を NetX パケット メモリ プール内に作成することで、この領域を簡単に利用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-248">This memory area is easily utilized by making it into a NetX packet memory pool.</span></span>

### <a name="creating-packet-pools"></a><span data-ttu-id="b956a-249">パケット プールの作成</span><span class="sxs-lookup"><span data-stu-id="b956a-249">Creating Packet Pools</span></span>
<span data-ttu-id="b956a-250">パケット プールは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-250">Packet pools are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="b956a-251">NetX アプリケーションのパケット メモリ プールの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="b956a-251">There are no limits on the number of packet memory pools in a NetX application.</span></span>

### <a name="packet-header-nx_packet"></a><span data-ttu-id="b956a-252">パケット ヘッダー NX_PACKET</span><span class="sxs-lookup"><span data-stu-id="b956a-252">Packet Header NX_PACKET</span></span>
<span data-ttu-id="b956a-253">既定では、NetX ではパケット ペイロード領域の直前にパケット ヘッダーが配置されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-253">By default, NetX places the packet header immediately before the packet payload area.</span></span> <span data-ttu-id="b956a-254">パケット メモリ プールは基本的に一連のパケットで、ヘッダーの直後にパケット ペイロードが続きます。</span><span class="sxs-lookup"><span data-stu-id="b956a-254">The packet memory pool is basically a series of packets—headers followed immediately by the packet payload.</span></span> <span data-ttu-id="b956a-255">パケット ヘッダー (***NX_PACKET***) とパケット プールのレイアウトを図 3 に示します。</span><span class="sxs-lookup"><span data-stu-id="b956a-255">The packet header (***NX_PACKET***) and the layout of the packet pool are pictured in Figure 3.</span></span>

<span data-ttu-id="b956a-256">ゼロ コピー操作を実行できるネットワーク デバイス ドライバーでは、通常、パケット ペイロード領域の開始アドレスが DMA ロジックにプログラミングされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-256">For network devices driver that are able to perform zero copy operations, typically the starting address of the packet payload area is programmed into the DMA logic.</span></span> <span data-ttu-id="b956a-257">特定の DMA エンジンでは、ペイロード領域にアラインメントの要件があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-257">Certain DMA engines have alignment requirement on the payload area.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-258">\*パケットの送信が完了したときに、ネットワーク ドライバーで \***nx_packet_transmit_release** _ 関数を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-258">\*The network driver to must call the \***nx_packet_transmit_release** _ function when the transmission of a packet is complete.</span></span> <span data-ttu-id="b956a-259">この関数によって、パケットが使用可能なプールに実際に戻される前に、TCP 出力キューに含まれていないことが確認されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-259">This function checks to make sure the packet is not part of a TCP output queue before it is actually placed back in the available pool.</span></span> <span data-ttu-id="b956a-260">この関数の呼び出しに失敗すると、予期しない動作になる可能性があります。_</span><span class="sxs-lookup"><span data-stu-id="b956a-260">Failure to call this function can result in unpredictable behavior._</span></span>

![パケット ヘッダーとパケット プールのレイアウト](./media/user-guide/packet-header-packet-pool-layout.png)

<span data-ttu-id="b956a-262">**図 3. パケット ヘッダーとパケット プールのレイアウト**</span><span class="sxs-lookup"><span data-stu-id="b956a-262">**FIGURE 3. Packet Header and Packet Pool Layout**</span></span>

<span data-ttu-id="b956a-263">パケット ヘッダーのフィールドは、次の表に示すように定義されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-263">The fields of the packet header are defined as shown in the following table.</span></span> <span data-ttu-id="b956a-264">この表は、*NX_PACKET* 構造のすべてのメンバーの包括的な一覧ではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b956a-264">Note that this table is not a comprehensive list of all the members in the *NX_PACKET* structure.</span></span>

| <span data-ttu-id="b956a-265">パケット ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b956a-265">Packet header</span></span>          | <span data-ttu-id="b956a-266">目的</span><span class="sxs-lookup"><span data-stu-id="b956a-266">Purpose</span></span>                                                                                                                                                                                                                                                                                                                            |
|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="b956a-267">*nx_packet_pool_owner*</span><span class="sxs-lookup"><span data-stu-id="b956a-267">*nx_packet_pool_owner*</span></span>   | <span data-ttu-id="b956a-268">このフィールドは、この特定のパケットを所有するパケット プールを指します。</span><span class="sxs-lookup"><span data-stu-id="b956a-268">This field points to the packet pool that owns this particular packet.</span></span> <span data-ttu-id="b956a-269">パケットが解放されると、この特定のプールに解放されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-269">When the packet is released, it is released to this particular pool.</span></span> <span data-ttu-id="b956a-270">各パケット内のプール所有権に基づいて、データグラムが複数のパケット プールの複数のパケットにまたがる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-270">With the pool ownership inside each packet, it is possible for a datagram to span multiple packets from multiple packet pools.</span></span>                                                         |
| <span data-ttu-id="b956a-271">*nx_packet_next*</span><span class="sxs-lookup"><span data-stu-id="b956a-271">*nx_packet_next*</span></span>         | <span data-ttu-id="b956a-272">このフィールドは、同じフレーム内の次のパケットを指します。</span><span class="sxs-lookup"><span data-stu-id="b956a-272">This field points to the next packet within the same frame.</span></span> <span data-ttu-id="b956a-273">NULL の場合、フレームに含まれる追加のパケットはありません。</span><span class="sxs-lookup"><span data-stu-id="b956a-273">If NULL, there are no additional packets that are part of the frame.</span></span> |
| <span data-ttu-id="b956a-274">*nx_packet_last*</span><span class="sxs-lookup"><span data-stu-id="b956a-274">*nx_packet_last*</span></span>         | <span data-ttu-id="b956a-275">このフィールドは、同じネットワーク パケット内の最後のパケットを指します。</span><span class="sxs-lookup"><span data-stu-id="b956a-275">This field points to the last packet within the same network packet.</span></span> <span data-ttu-id="b956a-276">NULL の場合、このパケットはネットワーク パケット全体を表します。</span><span class="sxs-lookup"><span data-stu-id="b956a-276">If NULL, this packet represents the entire network packet.</span></span>  |
| <span data-ttu-id="b956a-277">*nx_packet_length*</span><span class="sxs-lookup"><span data-stu-id="b956a-277">*nx_packet_length*</span></span>       | <span data-ttu-id="b956a-278">このフィールドには、ネットワーク パケット全体の合計バイト数が含まれます。これには、*nx_packet_next* メンバーによって連結されているすべてのパケットの合計バイト数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-278">This field contains the total number of bytes in the entire network packet, including the total of all bytes in all packets chained together by the *nx_packet_next* member.</span></span> |
| <span data-ttu-id="b956a-279">*nx_packet_ip_interface*</span><span class="sxs-lookup"><span data-stu-id="b956a-279">*nx_packet_ip_interface*</span></span> | <span data-ttu-id="b956a-280">このフィールドは、インターフェイス ドライバーによって、また送信パケットのために NetX によって受信されるときにパケットに割り当てられるインターフェイス制御ブロックです。</span><span class="sxs-lookup"><span data-stu-id="b956a-280">This field is the interface control block which is assigned to the packet when it is received by the interface driver, and by NetX for outgoing packets.</span></span> <span data-ttu-id="b956a-281">インターフェイス制御ブロックはインターフェイスを記述します。たとえば、ネットワーク アドレス、MAC アドレス、IP アドレス、インターフェイスの状態 (リンクが有効、物理マッピングが必要、など) を表します。</span><span class="sxs-lookup"><span data-stu-id="b956a-281">An interface control block describes the interface e.g. network address, MAC address, IP address and interface status such as link enabled and physical mapping required.</span></span> |
| <span data-ttu-id="b956a-282">*nx_packet_data_start*</span><span class="sxs-lookup"><span data-stu-id="b956a-282">*nx_packet_data_start*</span></span>   | <span data-ttu-id="b956a-283">このフィールドは、このパケットの物理ペイロード領域の開始位置を示します。</span><span class="sxs-lookup"><span data-stu-id="b956a-283">This field points to the start of the physical payload area of this packet.</span></span> <span data-ttu-id="b956a-284">NX_PACKET ヘッダーの直後に配置する必要はありませんが、これが ***nx_packet_pool_create*** サービスの既定の設定です。</span><span class="sxs-lookup"><span data-stu-id="b956a-284">It does not have to be immediately following the NX_PACKET header, but that is the default for the ***nx_packet_pool_create*** service.</span></span> |
| <span data-ttu-id="b956a-285">*nx_packet_data_end*</span><span class="sxs-lookup"><span data-stu-id="b956a-285">*nx_packet_data_end*</span></span>     | <span data-ttu-id="b956a-286">このフィールドは、このパケットの物理ペイロード領域の最後を指しています。</span><span class="sxs-lookup"><span data-stu-id="b956a-286">This field points to the end of the physical payload area of this packet.</span></span> <span data-ttu-id="b956a-287">このフィールドと nx_packet_data_start フィールドの差は、ペイロード サイズを表します。</span><span class="sxs-lookup"><span data-stu-id="b956a-287">The difference between this field and the nx_packet_data_start field represents the payload size.</span></span> |
| <span data-ttu-id="b956a-288">*nx_packet_prepend_ptr*</span><span class="sxs-lookup"><span data-stu-id="b956a-288">*nx_packet_prepend_ptr*</span></span>  | <span data-ttu-id="b956a-289">このフィールドは、パケット データ (プロトコル ヘッダーまたは実際のデータ) が、パケット ペイロード領域内の既存のパケット データ (存在する場合) の前に追加される場所を指します。</span><span class="sxs-lookup"><span data-stu-id="b956a-289">This field points to the location of where packet data, either protocol header or actual data, is added in front of the existing packet data (if any) in the packet payload area.</span></span> <span data-ttu-id="b956a-290">*nx_packet_data_start* ポインターの位置以上で、*nx_packet_append_ptr* ポインター以下である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-290">It must be greater than or equal to the *nx_packet_data_start* pointer location and less than or equal to the *nx_packet_append_ptr* pointer.</span></span>  <span data-ttu-id="b956a-291">*NetX では、パフォーマンス上の理由から、パケットが伝送のために NetX サービスに渡されるときに、先頭のポインターがロング ワード単位で揃えたアドレスを指していることを前提としています。*</span><span class="sxs-lookup"><span data-stu-id="b956a-291">*For performance reasons, NetX assumes that when the packet is passed into NetX services for transmission, the prepend pointer points to long word aligned address.*</span></span> |
| <span data-ttu-id="b956a-292">*nx_packet_append_ptr*</span><span class="sxs-lookup"><span data-stu-id="b956a-292">*nx_packet_append_ptr*</span></span>    | <span data-ttu-id="b956a-293">このフィールドは、現在パケット ペイロード領域にあるデータの末尾を指します。</span><span class="sxs-lookup"><span data-stu-id="b956a-293">This field points to the end of the data currently in the packet payload area.</span></span> <span data-ttu-id="b956a-294">これは、*nx_packet_prepend_ptr* と *nx_packet_data_end* によって示されるメモリ位置の間にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-294">It must be in between the memory location pointed to by *nx_packet_prepend_ptr* and *nx_packet_data_end*.</span></span> <span data-ttu-id="b956a-295">このフィールドと *nx_packet_prepend_ptr* フィールドの差は、このパケット内のデータの量を表します。</span><span class="sxs-lookup"><span data-stu-id="b956a-295">The difference between this field and the *nx_packet_prepend_ptr* field represents the amount of data in this packet.</span></span> |
| <span data-ttu-id="b956a-296">*nx_packet_fragment_next*</span><span class="sxs-lookup"><span data-stu-id="b956a-296">*nx_packet_fragment_next*</span></span> | <span data-ttu-id="b956a-297">このフィールドは、パケット全体を再アセンブルできるようになるまで、断片化されたパケットを保持するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-297">This field is used to hold fragmented packets until the entire packet can be re-assembled.</span></span> |
| <span data-ttu-id="b956a-298">*nx_packet_pad*</span><span class="sxs-lookup"><span data-stu-id="b956a-298">*nx_packet_pad*</span></span>           | <span data-ttu-id="b956a-299">このフィールドでは、必要なアラインメント要件を達成するために、4 バイト ワードの埋め込みの長さを定義します。</span><span class="sxs-lookup"><span data-stu-id="b956a-299">This fields defines the length of padding in 4- byte words to achieve the desired alignment requirement.</span></span> <span data-ttu-id="b956a-300">*NX_PACKET_HEADER_PAD* が定義されていない場合、このフィールドは削除されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-300">This field is removed if *NX_PACKET_HEADER_PAD* is not defined.</span></span> |
|  |  |

### <a name="packet-header-offsets"></a><span data-ttu-id="b956a-301">パケット ヘッダーのオフセット</span><span class="sxs-lookup"><span data-stu-id="b956a-301">Packet Header Offsets</span></span>

<span data-ttu-id="b956a-302">ヘッダーのサイズを格納するのに十分な領域を確保するために、パケット ヘッダーのサイズが定義されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-302">Packet header size is defined to allow enough room to accommodate the size of the header.</span></span> <span data-ttu-id="b956a-303">*nx_packet_allocate* サービスは、パケットを割り当て、指定されたパケットの種類に従ってパケット内の先頭のポインターを調整するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-303">The *nx_packet_allocate* service is used to allocate a packet and adjusts the prepend pointer in the packet according to the type of packet specified.</span></span> <span data-ttu-id="b956a-304">パケットの種類によって、プロトコルのデータの前にプロトコル ヘッダー (UDP、TCP、ICMP など) を挿入するために必要なオフセットが NetX に示されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-304">The packet type tells NetX the offset required for inserting the protocol header (such as UDP, TCP, or ICMP) in front of the protocol data.</span></span>

<span data-ttu-id="b956a-305">パケット内の IP ヘッダーと物理層 (イーサネット) ヘッダーを考慮するために、NetX で次の種類が定義されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-305">The following types are defined in NetX to take into account the IP header and physical layer (Ethernet) header in the packet.</span></span> <span data-ttu-id="b956a-306">後者の場合は、必要な 4 バイトのアラインメントを考慮して、16 バイトであると想定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-306">In the latter case, it is assumed to be 16 bytes taking the required 4-byte alignment into consideration.</span></span> <span data-ttu-id="b956a-307">IP ネットワークのパケットを割り当てるために、アプリケーション向けに NetX で IP パケットが引き続き定義されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-307">IP packets are still defined in NetX for applications to allocate packets for IP networks.</span></span> <span data-ttu-id="b956a-308">次の表に定義されている記号を示します。</span><span class="sxs-lookup"><span data-stu-id="b956a-308">The following table shows symbols defined:</span></span>

| <span data-ttu-id="b956a-309">パケットの種類</span><span class="sxs-lookup"><span data-stu-id="b956a-309">Packet Type</span></span>   | <span data-ttu-id="b956a-310">値</span><span class="sxs-lookup"><span data-stu-id="b956a-310">Value</span></span> |
|---------------|-------|
| <span data-ttu-id="b956a-311">NX_IP_PACKET</span><span class="sxs-lookup"><span data-stu-id="b956a-311">NX_IP_PACKET</span></span>  | <span data-ttu-id="b956a-312">0x24</span><span class="sxs-lookup"><span data-stu-id="b956a-312">0x24</span></span>  |
| <span data-ttu-id="b956a-313">NX_UDP_PACKET</span><span class="sxs-lookup"><span data-stu-id="b956a-313">NX_UDP_PACKET</span></span> | <span data-ttu-id="b956a-314">0x2c</span><span class="sxs-lookup"><span data-stu-id="b956a-314">0x2c</span></span>  |
| <span data-ttu-id="b956a-315">NX_TCP_PACKET</span><span class="sxs-lookup"><span data-stu-id="b956a-315">NX_TCP_PACKET</span></span> | <span data-ttu-id="b956a-316">0x38</span><span class="sxs-lookup"><span data-stu-id="b956a-316">0x38</span></span>  |
|               |       |

### <a name="pool-capacity"></a><span data-ttu-id="b956a-317">プールの容量</span><span class="sxs-lookup"><span data-stu-id="b956a-317">Pool Capacity</span></span>
<span data-ttu-id="b956a-318">パケット プール内のパケット数は、ペイロード サイズと、パケット プール作成サービスに渡されるメモリ領域内の合計バイト数と相関しています。</span><span class="sxs-lookup"><span data-stu-id="b956a-318">The number of packets in a packet pool is a function of the payload size and the total number of bytes in the memory area supplied to the packet pool create service.</span></span> <span data-ttu-id="b956a-319">プールの容量は、パケット サイズ (NX_PACKET ヘッダーのサイズ、ペイロード サイズ、適切なアラインメントなど) で、指定されたメモリ領域の合計バイト数を除算して計算されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-319">The capacity of the pool is calculated by dividing the packet size (including the size of the NX_PACKET header, the payload size, and proper alignment) into the total number of bytes in the supplied memory area.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="b956a-320">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="b956a-320">Thread Suspension</span></span>
<span data-ttu-id="b956a-321">空のプールからのパケットを待機している間に、アプリケーション スレッドが停止する場合があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-321">Application threads can suspend while waiting for a packet from an empty pool.</span></span> <span data-ttu-id="b956a-322">パケットがプールに返されると、停止されていたスレッドにこのパケットが割り当てられ、再開されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-322">When a packet is returned to the pool, the suspended thread is given this packet and resumed.</span></span>

<span data-ttu-id="b956a-323">同じパケット プールで複数のスレッドが停止された場合、それらは停止された順序で再開されます (FIFO)。</span><span class="sxs-lookup"><span data-stu-id="b956a-323">If multiple threads are suspended on the same packet pool, they are resumed in the order they were suspended (FIFO).</span></span>

### <a name="pool-statistics-and-errors"></a><span data-ttu-id="b956a-324">プールの統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b956a-324">Pool Statistics and Errors</span></span>
<span data-ttu-id="b956a-325">有効にすると、NetX パケット管理ソフトウェアの **Errors** によって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-325">If enabled, the NetX packet management software **Errors** keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b956a-326">次の統計情報とエラー レポートがパケット プール向けに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-326">The following statistics and error reports are maintained for packet pools:</span></span>

* <span data-ttu-id="b956a-327">プール内の合計パケット数</span><span class="sxs-lookup"><span data-stu-id="b956a-327">Total Packets in Pool</span></span>
* <span data-ttu-id="b956a-328">プール内の空きパケット数</span><span class="sxs-lookup"><span data-stu-id="b956a-328">Free Packets in Pool</span></span>
* <span data-ttu-id="b956a-329">プールの空の割り当て要求</span><span class="sxs-lookup"><span data-stu-id="b956a-329">Pool Empty Allocation Requests</span></span>
* <span data-ttu-id="b956a-330">プールの空の割り当て保留</span><span class="sxs-lookup"><span data-stu-id="b956a-330">Pool Empty Allocation Suspensions</span></span>
* <span data-ttu-id="b956a-331">無効なパケットの解放</span><span class="sxs-lookup"><span data-stu-id="b956a-331">Invalid Packet Releases</span></span>

<span data-ttu-id="b956a-332">これらの統計情報およびエラー レポートはすべて、プール内の合計パケット数と空きパケット数を除いて、\***NX_DISABLE_PACKET_INFO** _ が定義されていない限り、NetX ライブラリに組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-332">All of these statistics and error reports, except for total and free packet count in pool, are built into NetX library unless \***NX_DISABLE_PACKET_INFO** _ is defined.</span></span> <span data-ttu-id="b956a-333">このデータは、アプリケーションで _ *_nx_packet_pool_info_get_*\* サービスと共に使用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-333">This data is available to the application with the _ *_nx_packet_pool_info_get_*\* service.</span></span>

### <a name="packet-pool-control-block-nx_packet_pool"></a><span data-ttu-id="b956a-334">パケット プール制御ブロック NX_PACKET_POOL</span><span class="sxs-lookup"><span data-stu-id="b956a-334">Packet Pool Control Block NX_PACKET_POOL</span></span>

<span data-ttu-id="b956a-335">各パケット メモリ プールの特性は、その制御ブロックに含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-335">The characteristics of each packet memory pool are found in its control block.</span></span> <span data-ttu-id="b956a-336">ここには、空きパケットのリンク リスト、空きパケットの数、このプール内のパケットのペイロード サイズなどの有用な情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-336">It contains useful information such as the linked list of free packets, the number of free packets, and the payload size for packets in this pool.</span></span> <span data-ttu-id="b956a-337">この構造体は *nx_api.h* ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-337">This structure is defined in the *nx_api.h* file.</span></span>

<span data-ttu-id="b956a-338">パケット プール制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="b956a-338">Packet pool control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

## <a name="ip-protocol"></a><span data-ttu-id="b956a-339">IP プロトコル</span><span class="sxs-lookup"><span data-stu-id="b956a-339">IP Protocol</span></span>

<span data-ttu-id="b956a-340">NetX のインターネット プロトコル (IP) コンポーネントは、インターネット上で IP パケットを送受信する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="b956a-340">The Internet Protocol (IP) component of NetX is responsible for sending and receiving IP packets on the Internet.</span></span> <span data-ttu-id="b956a-341">このコンポーネントは、NetX では、基盤となるネットワーク ドライバーを使用して、TCP、UDP、ICMP、および IGMP メッセージの送信および受信を最終的に担います。</span><span class="sxs-lookup"><span data-stu-id="b956a-341">In NetX, it is the component ultimately responsible for sending and receiving TCP, UDP, ICMP, and IGMP messages, utilizing the underlying network driver.</span></span>

<span data-ttu-id="b956a-342">NetX は IP プロトコルをサポートします (RFC 791)</span><span class="sxs-lookup"><span data-stu-id="b956a-342">NetX supports IP protocol (RFC 791)</span></span>

### <a name="ip-addresses"></a><span data-ttu-id="b956a-343">IP アドレス</span><span class="sxs-lookup"><span data-stu-id="b956a-343">IP Addresses</span></span>

<span data-ttu-id="b956a-344">インターネット上の各ホストには、IP アドレスと呼ばれる 32 ビットの一意の識別子があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-344">Each host on the Internet has a unique 32-bit identifier called an IP address.</span></span> <span data-ttu-id="b956a-345">図 4 に示すように、IP アドレスには 5 つのクラスがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-345">There are five classes of IP addresses as described in Figure 4.</span></span> <span data-ttu-id="b956a-346">5 つの IP アドレス クラスの範囲は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b956a-346">The ranges of the five IP address classes are as follows:</span></span>

| <span data-ttu-id="b956a-347">クラス</span><span class="sxs-lookup"><span data-stu-id="b956a-347">Class</span></span> | <span data-ttu-id="b956a-348">Range</span><span class="sxs-lookup"><span data-stu-id="b956a-348">Range</span></span>                        |
|-------|------------------------------|
| <span data-ttu-id="b956a-349">A</span><span class="sxs-lookup"><span data-stu-id="b956a-349">A</span></span>     | <span data-ttu-id="b956a-350">0.0.0.0 ～ 127.255.255.255</span><span class="sxs-lookup"><span data-stu-id="b956a-350">0.0.0.0 to 127.255.255.255</span></span>   |
| <span data-ttu-id="b956a-351">B</span><span class="sxs-lookup"><span data-stu-id="b956a-351">B</span></span>     | <span data-ttu-id="b956a-352">128.0.0.0 ～ 191.255.255.255</span><span class="sxs-lookup"><span data-stu-id="b956a-352">128.0.0.0 to 191.255.255.255</span></span> |
| <span data-ttu-id="b956a-353">C</span><span class="sxs-lookup"><span data-stu-id="b956a-353">C</span></span>     | <span data-ttu-id="b956a-354">192.0.0.0 ～ 223.255.255.255</span><span class="sxs-lookup"><span data-stu-id="b956a-354">192.0.0.0 to 223.255.255.255</span></span> |
| <span data-ttu-id="b956a-355">D</span><span class="sxs-lookup"><span data-stu-id="b956a-355">D</span></span>     | <span data-ttu-id="b956a-356">224.0.0.0 ～ 239.255.255.255</span><span class="sxs-lookup"><span data-stu-id="b956a-356">224.0.0.0 to 239.255.255.255</span></span> |
| <span data-ttu-id="b956a-357">E</span><span class="sxs-lookup"><span data-stu-id="b956a-357">E</span></span>     | <span data-ttu-id="b956a-358">240.0.0.0 ～ 247.255.255.255</span><span class="sxs-lookup"><span data-stu-id="b956a-358">240.0.0.0 to 247.255.255.255</span></span> |

<span data-ttu-id="b956a-359">**7 ビット 24 ビット**</span><span class="sxs-lookup"><span data-stu-id="b956a-359">**7 bits 24 bits**</span></span>

![IP アドレスの構造](./media/user-guide/ip-address-structure.png)

<span data-ttu-id="b956a-361">**図 4. IP アドレスの構造**</span><span class="sxs-lookup"><span data-stu-id="b956a-361">**FIGURE 4. IP Address Structure**</span></span>

<span data-ttu-id="b956a-362">アドレス指定には、"*ユニキャスト*"、"*ブロードキャスト*"、"*マルチキャスト*" の 3 つの種類があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-362">There are also three types of address specifications: *unicast*, *broadcast*, and *multicast*.</span></span> <span data-ttu-id="b956a-363">ユニキャスト アドレスは、インターネット上の特定のホストを識別する IP アドレスです。</span><span class="sxs-lookup"><span data-stu-id="b956a-363">Unicast addresses are those IP addresses that identify a specific host on the Internet.</span></span> <span data-ttu-id="b956a-364">ユニキャスト アドレスには、送信元または宛先の IP アドレスを指定できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-364">Unicast addresses can be either a source or a destination IP address.</span></span> <span data-ttu-id="b956a-365">ブロードキャスト アドレスは、特定のネットワークまたはサブネットワーク上のすべてのホストを識別し、宛先アドレスとしてのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-365">A broadcast address identifies all hosts on a specific network or sub-network and can only be used as destination addresses.</span></span> <span data-ttu-id="b956a-366">ブロードキャスト アドレスは、アドレスのホスト ID 部分を 1 に設定することによって指定します。</span><span class="sxs-lookup"><span data-stu-id="b956a-366">Broadcast addresses are specified by having the host ID portion of the address set to ones.</span></span> <span data-ttu-id="b956a-367">マルチキャスト アドレス (クラス D) は、インターネット上のホストの動的なグループを指定します。</span><span class="sxs-lookup"><span data-stu-id="b956a-367">Multicast addresses (Class D) specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="b956a-368">マルチキャスト グループのメンバーは、いつでも参加し離脱することができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-368">Members of the multicast group may join and leave whenever they wish.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-369">*UDP over IP のようなコネクションレス プロトコルでのみ、ブロードキャストと、マルチキャスト グループの制限付きブロードキャスト機能を利用できます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-369">*Only connectionless protocols like UDP over IP can utilize broadcast and the limited broadcast capability of the multicast group.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-370">*マクロ* IP_ADDRESS *は* \***nx_api.h** _ で定義されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-370">*The macro* IP_ADDRESS *is defined in* \***nx_api.h** _.</span></span> <span data-ttu-id="b956a-371">これにより、ピリオドではなくコンマを使用して IP アドレスを簡単に指定できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-371">It allows easy specification of IP addresses using commas instead of a periods.</span></span> <span data-ttu-id="b956a-372">たとえば、図 4 に示すように、IP_ADDRESS(128,0,0,0)_ では最初のクラス B アドレスが指定されます。\*</span><span class="sxs-lookup"><span data-stu-id="b956a-372">For example, IP_ADDRESS(128,0,0,0) _specifies the first class B address shown in Figure 4.\*</span></span>

### <a name="ip-gateway-address"></a><span data-ttu-id="b956a-373">IP ゲートウェイ アドレス</span><span class="sxs-lookup"><span data-stu-id="b956a-373">IP Gateway Address</span></span>

<span data-ttu-id="b956a-374">ネットワーク ゲートウェイは、ネットワーク上のホストが、ローカル ドメインの外部の宛先に送信するパケットをリレーするのを支援します。</span><span class="sxs-lookup"><span data-stu-id="b956a-374">Network gateways assist hosts on their networks to relay packets destined to destinations outside the local domain.</span></span> <span data-ttu-id="b956a-375">送信先が近隣ノードのいずれかなのか、または、事前にプログラミングされた静的ルーティング テーブルを使用するのか、といった、送信先となるネクスト ホップに関するいくつかの情報が各ノードにあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-375">Each node has some knowledge of which next hop to send to, either the destination one of its neighbors, or through a pre-programmed static routing table.</span></span> <span data-ttu-id="b956a-376">ただし、これらのアプローチが失敗した場合、ノードはパケットを既定のゲートウェイに転送する必要があります。ここには、パケットを送信先にルーティングする方法についてより詳細な情報があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-376">However if these approaches fail, the node should forward the packet to its default gateway which has more information on how to route the packet to its destination.</span></span> <span data-ttu-id="b956a-377">既定のゲートウェイは、IP インスタンスに接続されている物理インターフェイスの 1 つを介して直接アクセスできる必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b956a-377">Note that the default gateway must be directly accessible through one of the physical interfaces attached to the IP instance.</span></span> <span data-ttu-id="b956a-378">アプリケーションは ***nx_ip_gateway_address_set*** を呼び出して、IP の既定のゲートウェイ アドレスを構成します。</span><span class="sxs-lookup"><span data-stu-id="b956a-378">The application calls ***nx_ip_gateway_address_set*** to configure IP default gateway address.</span></span>

### <a name="ip-header"></a><span data-ttu-id="b956a-379">IP ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b956a-379">IP Header</span></span>

<span data-ttu-id="b956a-380">インターネット上で送信されるすべての IP パケットについて、IP ヘッダーが必要です。</span><span class="sxs-lookup"><span data-stu-id="b956a-380">For any IP packet to be sent on the Internet, it must have an IP header.</span></span> <span data-ttu-id="b956a-381">上位レベルのプロトコル (UDP、TCP、ICMP、または IGMP) がパケットを送信するために IP コンポーネントを呼び出すと、IP 送信モジュールによってデータの前に IP ヘッダーが配置されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-381">When higher-level protocols (UDP, TCP, ICMP, or IGMP) call the IP component to send a packet, the IP transmit module places an IP header in front of the data.</span></span> <span data-ttu-id="b956a-382">逆に、IP パケットをネットワークから受信した場合、IP コンポーネントでは、上位レベルのプロトコルにパケットを配信する前に IP ヘッダーを削除します。</span><span class="sxs-lookup"><span data-stu-id="b956a-382">Conversely, when IP packets are received from the network, the IP component removes the IP header from the packet before delivery to the higher-level protocols.</span></span> <span data-ttu-id="b956a-383">図 5 は、IP ヘッダーの形式を示しています。</span><span class="sxs-lookup"><span data-stu-id="b956a-383">Figure 5 shows the format of the IP header.</span></span>

![IP ヘッダーの形式](./media/user-guide/ip-header-format.png)

<span data-ttu-id="b956a-385">**図 5. IP ヘッダーの形式**</span><span class="sxs-lookup"><span data-stu-id="b956a-385">**FIGURE 5. IP Header Format**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-386">*TCP/IP 実装のすべてのヘッダーは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに配置されます。たとえば、IP ヘッダーの 4 ビットのバージョンと 4 ビットのヘッダー長は、ヘッダーの最初のバイトに配置する必要があります。*</span><span class="sxs-lookup"><span data-stu-id="b956a-386">*All headers in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address. For example, the 4-bit version and the 4-bit header length of the IP header must be located on the first byte of the header.*</span></span>

<span data-ttu-id="b956a-387">IP ヘッダーのフィールドは次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-387">The fields of the IP header are defined as follows:</span></span>

<span data-ttu-id="b956a-388">**IP ヘッダー フィールドの目的**</span><span class="sxs-lookup"><span data-stu-id="b956a-388">**IP Header Field Purpose**</span></span>

<span data-ttu-id="b956a-389">"***4 ビットのバージョン***" このフィールドには、このヘッダーが表す IP のバージョンが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-389">***4-bit version*** This field contains the version of IP this header represents.</span></span> <span data-ttu-id="b956a-390">NetX でサポートされている IP バージョン 4 では、このフィールドの値は 4 です。</span><span class="sxs-lookup"><span data-stu-id="b956a-390">For IP version 4, which is what NetX supports, the value of this field is 4.</span></span>

<span data-ttu-id="b956a-391">"***4 ビットのヘッダー長***" このフィールドは、IP ヘッダー内の 32 ビット ワードの数を指定します。</span><span class="sxs-lookup"><span data-stu-id="b956a-391">***4-bit header length*** This field specifies the number of 32-bit words in the IP header.</span></span> <span data-ttu-id="b956a-392">オプションのワードが存在しない場合、このフィールドの値は 5 になります。</span><span class="sxs-lookup"><span data-stu-id="b956a-392">If no option words are present, the value for this field is 5.</span></span>

<span data-ttu-id="b956a-393">"***8 ビットのサービス タイプ (TOS)***" このフィールドは、この IP パケットに要求されるサービスの種類を指定します。</span><span class="sxs-lookup"><span data-stu-id="b956a-393">***8-bit type of service (TOS)*** This field specifies the type of service requested for this IP packet.</span></span> <span data-ttu-id="b956a-394">有効な要求を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b956a-394">Valid requests are as follows:</span></span>

| <span data-ttu-id="b956a-395">**TOS 要求**</span><span class="sxs-lookup"><span data-stu-id="b956a-395">**TOS Request**</span></span>     | <span data-ttu-id="b956a-396">**Value**</span><span class="sxs-lookup"><span data-stu-id="b956a-396">**Value**</span></span> |
| ------------------- | --------- |
| <span data-ttu-id="b956a-397">Normal</span><span class="sxs-lookup"><span data-stu-id="b956a-397">Normal</span></span>              | <span data-ttu-id="b956a-398">0x00</span><span class="sxs-lookup"><span data-stu-id="b956a-398">0x00</span></span>      |
| <span data-ttu-id="b956a-399">最小遅延</span><span class="sxs-lookup"><span data-stu-id="b956a-399">Minimum Delay</span></span>       | <span data-ttu-id="b956a-400">0x10</span><span class="sxs-lookup"><span data-stu-id="b956a-400">0x10</span></span>      |
| <span data-ttu-id="b956a-401">最大データ</span><span class="sxs-lookup"><span data-stu-id="b956a-401">Maximum Data</span></span>        | <span data-ttu-id="b956a-402">0x08</span><span class="sxs-lookup"><span data-stu-id="b956a-402">0x08</span></span>      |
| <span data-ttu-id="b956a-403">最大の信頼性</span><span class="sxs-lookup"><span data-stu-id="b956a-403">Maximum Reliability</span></span> | <span data-ttu-id="b956a-404">0x04</span><span class="sxs-lookup"><span data-stu-id="b956a-404">0x04</span></span>      |
| <span data-ttu-id="b956a-405">最小コスト</span><span class="sxs-lookup"><span data-stu-id="b956a-405">Minimum Cost</span></span>        | <span data-ttu-id="b956a-406">0x02</span><span class="sxs-lookup"><span data-stu-id="b956a-406">0x02</span></span>      |

<span data-ttu-id="b956a-407">"***16 ビットの合計長***" このフィールドには、IP ヘッダーを含む IP データグラムの合計長がバイト単位で表示されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-407">***16-bit total length*** This field contains the total length of the IP datagram in bytes, including the IP header.</span></span> <span data-ttu-id="b956a-408">IP データグラムは、TCP/IP インターネットで検出された情報の基本単位です。</span><span class="sxs-lookup"><span data-stu-id="b956a-408">An IP datagram is the basic unit of information found on a TCP/IP Internet.</span></span> <span data-ttu-id="b956a-409">これには、データに加えて、宛先と送信元のアドレスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-409">It contains a destination and source address in addition to data.</span></span> <span data-ttu-id="b956a-410">これは 16 ビットのフィールドであるため、IP データグラムの最大サイズは 65,535 バイトです。</span><span class="sxs-lookup"><span data-stu-id="b956a-410">Because it is a 16-bit field, the maximum size of an IP datagram is 65,535 bytes.</span></span>

<span data-ttu-id="b956a-411">"***16 ビットの ID***" このフィールドは、ホストから送信された各 IP データグラムを一意に識別するために使用される番号です。</span><span class="sxs-lookup"><span data-stu-id="b956a-411">***16-bit identification*** The field is a number used to uniquely identify each IP datagram sent from a host.</span></span> <span data-ttu-id="b956a-412">通常、この番号は IP データグラムの送信後にインクリメントされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-412">This number is typically incremented after an IP datagram is sent.</span></span> <span data-ttu-id="b956a-413">これは、受信した IP パケット フラグメントをアセンブルする場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="b956a-413">It is especially useful in assembling received IP packet fragments.</span></span>

<span data-ttu-id="b956a-414">"***3 ビットのフラグ***" このフィールドには IP の断片化に関する情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-414">***3-bit flags*** This field contains IP fragmentation information.</span></span> <span data-ttu-id="b956a-415">ビット 14 は "フラグメント禁止" ビットです。</span><span class="sxs-lookup"><span data-stu-id="b956a-415">Bit 14 is the "don't fragment" bit.</span></span> <span data-ttu-id="b956a-416">このビットが設定されている場合、発信 IP データグラムは断片化されません。</span><span class="sxs-lookup"><span data-stu-id="b956a-416">If this bit is set, the outgoing IP datagram will not be fragmented.</span></span> <span data-ttu-id="b956a-417">ビット 13 は "フラグメント継続" ビットです。</span><span class="sxs-lookup"><span data-stu-id="b956a-417">Bit 13 is the "more fragments" bit.</span></span> <span data-ttu-id="b956a-418">このビットが設定されている場合は、断片化が継続されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-418">If this bit is set, there are more fragments.</span></span> <span data-ttu-id="b956a-419">このビットがクリアされている場合、これは IP パケットの最後のフラグメントです。</span><span class="sxs-lookup"><span data-stu-id="b956a-419">If this bit is clear, this is the last fragment of the IP packet.</span></span>

<span data-ttu-id="b956a-420">**IP ヘッダー フィールドの目的**</span><span class="sxs-lookup"><span data-stu-id="b956a-420">**IP Header Field Purpose**</span></span>

<span data-ttu-id="b956a-421">"***13 ビットのフラグメント オフセット***" このフィールドには、フラグメント オフセットの上位 13 ビットが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-421">***13-bit fragment offset*** This field contains the upper 13-bits of the fragment offset.</span></span> <span data-ttu-id="b956a-422">このため、フラグメント オフセットは 8 バイト境界でのみ許可されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-422">Because of this, fragment offsets are only allowed on 8-byte boundaries.</span></span> <span data-ttu-id="b956a-423">断片化された IP データグラムの最初のフラグメントには、"フラグメント継続" ビットが設定され、オフセットは 0 になります。</span><span class="sxs-lookup"><span data-stu-id="b956a-423">The first fragment of a fragmented IP datagram will have the “more fragments” bit set and have an offset of 0.</span></span>

<span data-ttu-id="b956a-424">"***8 ビットの Time to Live (TTL)***" このフィールドには、このデータグラムが通過できるルーターの数が含まれます。これにより、データグラムの有効期間が制限されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-424">***8-bit time to live (TTL)*** This field contains the number of routers this datagram can pass, which limits the lifetime of the datagram.</span></span>

<span data-ttu-id="b956a-425">"***8 ビットのプロトコル***" このフィールドでは、IP データグラムを使用しているプロトコルを指定します。</span><span class="sxs-lookup"><span data-stu-id="b956a-425">***8-bit protocol*** This field specifies which protocol is using the IP datagram.</span></span> <span data-ttu-id="b956a-426">有効なプロトコルとその値の一覧を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b956a-426">The following is a list of valid protocols and their values:</span></span>

| <span data-ttu-id="b956a-427">Protocol</span><span class="sxs-lookup"><span data-stu-id="b956a-427">Protocol</span></span> | <span data-ttu-id="b956a-428">値</span><span class="sxs-lookup"><span data-stu-id="b956a-428">Value</span></span> |
|----------|-------|
| <span data-ttu-id="b956a-429">ICMP</span><span class="sxs-lookup"><span data-stu-id="b956a-429">ICMP</span></span>     | <span data-ttu-id="b956a-430">0x01</span><span class="sxs-lookup"><span data-stu-id="b956a-430">0x01</span></span>  |
| <span data-ttu-id="b956a-431">IGMP</span><span class="sxs-lookup"><span data-stu-id="b956a-431">IGMP</span></span>     | <span data-ttu-id="b956a-432">0x02</span><span class="sxs-lookup"><span data-stu-id="b956a-432">0x02</span></span>  |
| <span data-ttu-id="b956a-433">TCP</span><span class="sxs-lookup"><span data-stu-id="b956a-433">TCP</span></span>      | <span data-ttu-id="b956a-434">0X06</span><span class="sxs-lookup"><span data-stu-id="b956a-434">0X06</span></span>  |
| <span data-ttu-id="b956a-435">UDP</span><span class="sxs-lookup"><span data-stu-id="b956a-435">UDP</span></span>      | <span data-ttu-id="b956a-436">0X11</span><span class="sxs-lookup"><span data-stu-id="b956a-436">0X11</span></span>  |
|          |       |


<span data-ttu-id="b956a-437">"***16 ビットのチェックサム***" このフィールドには、IP ヘッダーのみを対象とする 16 ビットのチェックサムが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-437">***16-bit checksum*** This field contains the 16-bit checksum that covers the IP header only.</span></span> <span data-ttu-id="b956a-438">上位レベルのプロトコルには、IP ペイロードに対応する追加のチェックサムがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-438">There are additional checksums in the higher level protocols that cover the IP payload.</span></span>

<span data-ttu-id="b956a-439">"***32 ビットの送信元 IP アドレス***" このフィールドには送信元の IP アドレスが含まれます。これは常にホスト アドレスです。</span><span class="sxs-lookup"><span data-stu-id="b956a-439">***32-bit source IP address*** This field contains the IP address of the sender and is always a host address.</span></span>

<span data-ttu-id="b956a-440">"***32 ビットの宛先 IP アドレス***" このフィールドには、アドレスがブロードキャストまたはマルチキャスト アドレスの場合、単一または複数の受信側の IP アドレスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-440">***32-bit destination IP address*** This field contains the IP address of the receiver or receivers if the address is a broadcast or multicast address.</span></span>

### <a name="creating-ip-instances"></a><span data-ttu-id="b956a-441">IP インスタンスの作成</span><span class="sxs-lookup"><span data-stu-id="b956a-441">Creating IP Instances</span></span>

<span data-ttu-id="b956a-442">IP インスタンスは、アプリケーション スレッドによる初期化中またはランタイムに作成されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-442">IP instances are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="b956a-443">内部 IP スレッドの初期 IP アドレス、ネットワーク マスク、既定のパケット プール、メディア ドライバー、およびメモリと優先順位は、*nx_ip_create* サービスによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-443">The initial IP address, network mask, default packet pool, media driver, and memory and priority of the internal IP thread are defined by the *nx_ip_create* service.</span></span> <span data-ttu-id="b956a-444">IP アドレスが無効なアドレス (0.0.0.0) に設定されている IP インスタンスをアプリケーションで初期化する場合は、後で RARP や、DHCP または同様のプロトコルを使用して、インターフェイス アドレスが手動構成によって解決されることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="b956a-444">If the application initializes the IP instance with its IP address set to an invalid address(0.0.0.0), it is assumed that the interface address is going to resolved by manual configuration later, via RARP, or through DHCP or similar protocols.</span></span>

<span data-ttu-id="b956a-445">複数のネットワーク インターフェイスがあるシステムでは、*nx_ip_create* を呼び出すときにプライマリ インターフェイスが指定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-445">For systems with multiple network interfaces, the primary interface is designated when calling *nx_ip_create*.</span></span> <span data-ttu-id="b956a-446">*nx_ip_interface_attach* を呼び出すことによって、追加の各インターフェイスを同じ IP インスタンスにアタッチできます。</span><span class="sxs-lookup"><span data-stu-id="b956a-446">Each additional interface can be attached to the same IP instance by calling *nx_ip_interface_attach*.</span></span> <span data-ttu-id="b956a-447">このサービスでは、ネットワーク インターフェイスに関する情報 (IP アドレス、ネットワーク マスクなど) をインターフェイス制御ブロックに格納し、ドライバー インスタンスを IP インスタンスのインターフェイス制御ブロックに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="b956a-447">This service stores information about the network interface (such as IP address, network mask) in the interface control block, and associates the driver instance with the interface control block in the IP instance.</span></span> <span data-ttu-id="b956a-448">ドライバーでは、データ パケットが受信されたら、IP 受信ロジックに転送する前に、インターフェイス情報を NX_PACKET 構造体に格納する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-448">As the driver receives a data packet, it needs to store the interface information in the NX_PACKET structure before forwarding it to the IP receive logic.</span></span> <span data-ttu-id="b956a-449">IP インスタンスは、インターフェイスをアタッチする前に既に作成されている必要があることに注意します。</span><span class="sxs-lookup"><span data-stu-id="b956a-449">Note an IP instance must already be created before attaching any interfaces.</span></span>

 ### <a name="ip-send"></a><span data-ttu-id="b956a-450">IP 送信</span><span class="sxs-lookup"><span data-stu-id="b956a-450">IP Send</span></span>
 <span data-ttu-id="b956a-451">NetX の IP 送信処理は非常に合理化されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-451">The IP send processing in NetX is very streamlined.</span></span>

<span data-ttu-id="b956a-452">パケット内の先頭のポインターは、IP ヘッダーを格納するために後方に移動されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-452">The prepend pointer in the packet is moved backwards to accommodate the IP header.</span></span> <span data-ttu-id="b956a-453">IP ヘッダーが完了し (呼び出し元のプロトコル レイヤーで指定されたすべてのオプションが使用されます)、IP チェックサムがインラインで計算され、関連付けられているネットワーク ドライバーにパケットがディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-453">The IP header is completed (with all the options specified by the calling protocol layer), the IP checksum is computed in-line, and the packet is dispatched to the associated network driver.</span></span> <span data-ttu-id="b956a-454">また、送信の断片化は、IP 送信処理内からも調整されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-454">In addition, outgoing fragmentation is also coordinated from within the IP send processing.</span></span>

<span data-ttu-id="b956a-455">IP で宛先 IP アドレスに物理マッピングが必要な場合、NetX で ARP 要求が開始されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-455">For IP, NetX initiates ARP requests if physical mapping is needed for the destination IP address.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-456">*IP 接続では、キューに格納されているパケットの数が ARP キューの深さ (* *シンボル **NX_ARP_MAX_QUEUE_DEPTH** によって定義されている) を超えない限り、IP アドレス解決 (つまり、物理マッピング) を必要とするパケットは ARP キューにエンキューされます。* *キューの深さに達した場合、NetX ではキューの最も古いパケットが削除され、エンキューされた残りのアドレスの解決を待機し続けます。一方、ARP エントリが解決されない場合、ARP エントリの保留中のパケットは、ARP エントリのタイムアウト時に解放されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-456">*For IP connectivity, packets that require IP address resolution (i.e., physical mapping) are enqueued on the ARP queue until the number of packets queued exceeds the ARP queue depth (defined by the* *symbol **NX_ARP_MAX_QUEUE_DEPTH**). If the* *queue depth is reached, NetX will remove the oldest packet on the queue and continue waiting for address resolution for the remaining packets enqueued. On the other hand, if an ARP entry is not resolved, the pending packets on the ARP entry are released upon ARP entry timeout.*</span></span>

<span data-ttu-id="b956a-457">複数のネットワーク インターフェイスがあるシステムでは、NetX は宛先 IP アドレスに基づいてインターフェイスを選択します。</span><span class="sxs-lookup"><span data-stu-id="b956a-457">For systems with multiple network interfaces, NetX chooses an interface based on the destination IP address.</span></span> <span data-ttu-id="b956a-458">選択プロセスには、次の手順が適用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-458">The following procedure applies to the selection process:</span></span>

1. <span data-ttu-id="b956a-459">宛先アドレスが IP ブロードキャストまたはマルチキャストで、有効な発信インターフェイスが指定されている場合は、そのインターフェイスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-459">If a destination address is IP broadcast or multicast, and if a valid outgoing interface is specified, use that interface.</span></span> <span data-ttu-id="b956a-460">それ以外の場合は、最初の物理インターフェイスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-460">Otherwise, the first physical interface is used.</span></span>

2. <span data-ttu-id="b956a-461">宛先アドレスが静的ルーティング テーブルで見つかった場合は、そのゲートウェイに関連付けられているインターフェイスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-461">If the destination address is found in the static routing table, the interface associated with the gateway is used.</span></span>

3. <span data-ttu-id="b956a-462">宛先がオンリンクの場合は、オンリンク インターフェイスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-462">If the destination is on-link, the on-link interface is used.</span></span>

4. <span data-ttu-id="b956a-463">宛先アドレスがループバック アドレス 127.0.0.1 の場合、ループバック インターフェイスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-463">If the destination address is a loopback address 127.0.0.1, the loopback interface is used.</span></span>

5. <span data-ttu-id="b956a-464">既定のゲートウェイが適切に構成されている場合は、既定のゲートウェイに関連付けられているインターフェイスを使用してパケットを転送します。</span><span class="sxs-lookup"><span data-stu-id="b956a-464">If the default gateway is properly configured, use the interface associated with the default gateway to transmit the packet.</span></span>

6. <span data-ttu-id="b956a-465">上記のすべてが失敗した場合、出力パケットはドロップされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-465">The output packet is dropped if all the above fails.</span></span>

### <a name="ip-receive"></a><span data-ttu-id="b956a-466">IP 受信</span><span class="sxs-lookup"><span data-stu-id="b956a-466">IP Receive</span></span>

<span data-ttu-id="b956a-467">IP 受信処理は、ネットワーク ドライバーまたは内部 IP スレッドから呼び出されます (遅延受信パケット キューのパケットを処理するため)。</span><span class="sxs-lookup"><span data-stu-id="b956a-467">The IP receive processing is either called from the network driver or the internal IP thread (for processing packets on the deferred received packet queue).</span></span> <span data-ttu-id="b956a-468">IP 受信処理では、プロトコル フィールドを調べて、適切なプロトコル コンポーネントにパケットをディスパッチしようとします。</span><span class="sxs-lookup"><span data-stu-id="b956a-468">The IP receive processing examines the protocol field and attempts to dispatch the packet to the proper protocol component.</span></span> <span data-ttu-id="b956a-469">パケットが実際にディスパッチされる前に、IP ヘッダーの前に先頭のポインターを移動することで、IP ヘッダーが削除されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-469">Before the packet is actually dispatched, the IP header is removed by advancing the prepend pointer past the IP header.</span></span>

<span data-ttu-id="b956a-470">IP 受信処理では、断片化された IP パケットも検出されて、断片化が有効になっている場合に再アセンブルするために必要な手順が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-470">IP receive processing also detects fragmented IP packets and performs the necessary steps to reassemble them if fragmentation is enabled.</span></span> <span data-ttu-id="b956a-471">断片化が必要でも有効になっていない場合、パケットはドロップされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-471">If fragmentation is needed but not enabled, the packet is dropped.</span></span>

<span data-ttu-id="b956a-472">NetX では、パケットに指定されたインターフェイスに基づいて、適切なネットワーク インターフェイスが決定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-472">NetX determines the appropriate network interface based on the interface specified in the packet.</span></span> <span data-ttu-id="b956a-473">パケット インターフェイスが NULL の場合、NetX では既定でプライマリ インターフェイスに設定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-473">If the packet interface is NULL, NetX defaults to the primary interface.</span></span> <span data-ttu-id="b956a-474">これは、NetX のレガシ イーサネット ドライバーとの互換性を保証するために行われます。</span><span class="sxs-lookup"><span data-stu-id="b956a-474">This is done to guarantee compatibility with legacy NetX Ethernet drivers.</span></span>

### <a name="raw-ip-send"></a><span data-ttu-id="b956a-475">生 IP 送信</span><span class="sxs-lookup"><span data-stu-id="b956a-475">Raw IP Send</span></span>

<span data-ttu-id="b956a-476">生 IP パケットは、NetX によって直接はサポート (および処理) されない上位層プロトコル ペイロードを含む IP フレームです。</span><span class="sxs-lookup"><span data-stu-id="b956a-476">A raw IP packet is an IP frame that contains upper layer protocol payload not directly supported (and processed) by NetX.</span></span> <span data-ttu-id="b956a-477">生のパケットを使用すると、開発者は独自の IP ベースのアプリケーションを定義できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-477">A raw packet allows developers to define their own IP-based applications.</span></span> <span data-ttu-id="b956a-478">生 IP パケット処理が _*_nx_ip_raw_packet_enabled_*_ サービスで有効になっている場合、アプリケーションでは \***nx_ip_raw_packet_send** _ サービスを使用して生 IP パケットを直接送信できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-478">An application may send raw IP packets directly using the ***nx_ip_raw_packet_send** _ service if raw IP packet processing has been enabled with the _*_nx_ip_raw_packet_enabled_\*_ service.</span></span> <span data-ttu-id="b956a-479">宛先アドレスがマルチキャストまたはブロードキャスト アドレスの場合でも、NetX では既定で最初の (プライマリ) インターフェイスが設定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-479">If the destination address is a multicast or broadcast address, however, NetX defaults to the first (primary) interface.</span></span> <span data-ttu-id="b956a-480">そのため、このようなパケットをセカンダリ インターフェイスで送信するには、アプリケーションで _ *_nx_ip_raw_packet_interface_send_*\* サービスを使用して、発信パケットに使用する送信元アドレスを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-480">Therefore, to send such packets out on secondary interfaces, the application must use the _ *_nx_ip_raw_packet_interface_send_*\* service to specify the source address to use for the outgoing packet.</span></span>

### <a name="raw-ip-receive"></a><span data-ttu-id="b956a-481">生 IP 受信</span><span class="sxs-lookup"><span data-stu-id="b956a-481">Raw IP Receive</span></span>

<span data-ttu-id="b956a-482">生 IP パケット処理が有効になっている場合、アプリケーションは \***nx_ip_raw_packet_receive** _ サービスを通じて生 IP パケットを受信する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-482">If raw IP packet processing is enabled, the application may receive raw IP packets through the \***nx_ip_raw_packet_receive** _ service.</span></span> <span data-ttu-id="b956a-483">すべての受信パケットは、IP ヘッダーで指定されたプロトコルに従って処理されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-483">All incoming packets are processed according to the protocol specified in the IP header.</span></span> <span data-ttu-id="b956a-484">プロトコルで UDP、TCP、IGMP、ICMP のいずれかが指定されている場合、NetX ではパケット プロトコルの種類に適したハンドラーを使用してパケットを処理します。</span><span class="sxs-lookup"><span data-stu-id="b956a-484">If the protocol specifies UDP, TCP, IGMP or ICMP, NetX will process the packet using the appropriate handler for the packet protocol type.</span></span> <span data-ttu-id="b956a-485">プロトコルがこれらのプロトコルのいずれかではなく、生 IP 受信が有効になっている場合、受信パケットは生パケット キューに格納されて、アプリケーションで _ *_nx_ip_raw_packet_receive_*\* サービスを介して受信されるのを待機します。</span><span class="sxs-lookup"><span data-stu-id="b956a-485">If the protocol is not one of these protocols, and raw IP receive is enabled, the incoming packet will be put into the raw packet queue waiting for the application to receive it via the _ *_nx_ip_raw_packet_receive_*\* service.</span></span> <span data-ttu-id="b956a-486">また、生 IP パケットを待機している間に、オプションのタイムアウトでアプリケーション スレッドが停止されることもあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-486">In addition, application threads may suspend with an optional timeout while waiting for a raw IP packet.</span></span>

### <a name="default-packet-pool"></a><span data-ttu-id="b956a-487">既定のパケット プール</span><span class="sxs-lookup"><span data-stu-id="b956a-487">Default Packet Pool</span></span>

<span data-ttu-id="b956a-488">各 IP インスタンスには、作成時に既定のパケット プールが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b956a-488">Each IP instance is given a default packet pool during creation.</span></span> <span data-ttu-id="b956a-489">このパケット プールは、ARP、RARP、ICMP、IGMP、さまざまな TCP 制御パケット (SYN、ACK など) にパケットを割り当てるために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-489">This packet pool is used to allocate packets for ARP, RARP, ICMP, IGMP, various TCP control packets (such as SYN, ACK).</span></span> <span data-ttu-id="b956a-490">NetX がパケットを割り当てる必要があるときに既定のパケット プールが空の場合、NetX で特定の操作を中止することが必要になる場合があり、可能な場合はエラー メッセージを返します。</span><span class="sxs-lookup"><span data-stu-id="b956a-490">If the default packet pool is empty when NetX needs to allocate a packet, NetX may have to abort the particular operation, and will return an error message if possible.</span></span>

### <a name="ip-helper-thread"></a><span data-ttu-id="b956a-491">IP ヘルパー スレッド</span><span class="sxs-lookup"><span data-stu-id="b956a-491">IP Helper Thread</span></span>

<span data-ttu-id="b956a-492">各 IP インスタンスには、ヘルパー スレッドがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-492">Each IP instance has a helper thread.</span></span> <span data-ttu-id="b956a-493">このスレッドは、すべての遅延パケット処理とすべての周期処理を担います。</span><span class="sxs-lookup"><span data-stu-id="b956a-493">This thread is responsible for handling all deferred packet processing and all periodic processing.</span></span> <span data-ttu-id="b956a-494">IP ヘルパー スレッドは ***nx_ip_create*** で作成されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-494">The IP helper thread is created in ***nx_ip_create.***</span></span> <span data-ttu-id="b956a-495">ここで、スレッドのスタックと優先順位が指定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-495">This is where the thread is given its stack and priority.</span></span> <span data-ttu-id="b956a-496">IP ヘルパー スレッドでの最初の処理は、IP 作成サービスに関連付けられているネットワーク ドライバーの初期化を完了することである点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="b956a-496">Note that the first processing in the IP helper thread is to finish the network driver initialization associated with the IP create service.</span></span> <span data-ttu-id="b956a-497">ネットワーク ドライバーの初期化が完了すると、ヘルパー スレッドはパケットと定期的な要求を処理するために無限ループを開始します。</span><span class="sxs-lookup"><span data-stu-id="b956a-497">After the network driver initialization is complete, the helper thread starts an endless loop to process packet and periodic requests.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-498">*IP ヘルパー スレッド内で予期しない動作が見られた場合、最初のデバッグ手順は、IP 作成サービス中にスタック サイズを増やすことです。スタックが小さすぎる場合に、IP ヘルパー スレッドによってメモリが上書きされている可能性があります。これにより、通常とは異なる問題が発生することがあります。*</span><span class="sxs-lookup"><span data-stu-id="b956a-498">*If unexplained behavior is seen within the IP helper thread, increasing its stack size during the IP create service is the first debugging step. If the stack is too small, the IP helper thread could possibly be overwriting memory, which may cause unusual problems.*</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="b956a-499">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="b956a-499">Thread Suspension</span></span>

<span data-ttu-id="b956a-500">生 IP パケットを受信しようとしているときに、アプリケーション スレッドが中断されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-500">Application threads can suspend while attempting to receive raw IP packets.</span></span> <span data-ttu-id="b956a-501">生のパケットを受信すると、中断された最初のスレッドに新しいパケットが渡され、そのスレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-501">After a raw packet is received, the new packet is given to the first thread suspended and that thread is resumed.</span></span> <span data-ttu-id="b956a-502">パケットを受信するためのすべての NetX サービスには、省略可能な中断タイムアウトがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-502">NetX services for receiving packets all have an optional suspension timeout.</span></span> <span data-ttu-id="b956a-503">パケットが受信されるか、タイムアウトが経過すると、適切な完了ステータスでアプリケーション スレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-503">When a packet is received or the timeout expires, the application thread is resumed with the appropriate completion status.</span></span>

### <a name="ip-statistics-and-errors"></a><span data-ttu-id="b956a-504">IP の統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b956a-504">IP Statistics and Errors</span></span>

<span data-ttu-id="b956a-505">有効にした場合、NetX では、アプリケーションに役立つ可能性のあるいくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-505">If enabled, the NetX keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b956a-506">次の統計およびエラー レポートは、IP インスタンスごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-506">The following statistics and error reports are maintained for each IP instance:</span></span>

- <span data-ttu-id="b956a-507">送信された IP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-507">Total IP Packets Sent</span></span>
- <span data-ttu-id="b956a-508">送信された IP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-508">Total IP Bytes Sent</span></span>
- <span data-ttu-id="b956a-509">受信した IP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-509">Total IP Packets Received</span></span>
- <span data-ttu-id="b956a-510">受信した IP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-510">Total IP Bytes Received</span></span>
- <span data-ttu-id="b956a-511">無効な IP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-511">Total IP Invalid Packets</span></span>
- <span data-ttu-id="b956a-512">ドロップされた IP 受信パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-512">Total IP Receive Packets Dropped</span></span>
- <span data-ttu-id="b956a-513">IP 受信チェックサム エラーの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-513">Total IP Receive Checksum Errors</span></span>
- <span data-ttu-id="b956a-514">ドロップされた IP 送信パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-514">Total IP Send Packets Dropped</span></span>
- <span data-ttu-id="b956a-515">送信された IP フラグメントの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-515">Total IP Fragments Sent</span></span>
- <span data-ttu-id="b956a-516">受信した IP フラグメントの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-516">Total IP Fragments Received</span></span>

<span data-ttu-id="b956a-517">これらの統計およびエラー レポートはすべて、***nx_ip_info_get*** サービスを使用してアプリケーションで利用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-517">All of these statistics and error reports are available to the application with the ***nx_ip_info_get*** service.</span></span>

### <a name="ip-control-block-nx_ip"></a><span data-ttu-id="b956a-518">IP 制御ブロック NX_IP</span><span class="sxs-lookup"><span data-stu-id="b956a-518">IP Control Block NX_IP</span></span>

<span data-ttu-id="b956a-519">各 IP インスタンスの特性は、制御ブロックにあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-519">The characteristics of each IP instance are found in its control block.</span></span> <span data-ttu-id="b956a-520">これには、各ネットワーク デバイスの IP アドレスとネットワーク マスク、近隣 IP および物理ハードウェア アドレス マッピングのテーブルなどの有用な情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-520">It contains useful information such as the IP addresses and network masks of each network device, and a table of neighbor IP and physical hardware address mapping.</span></span> <span data-ttu-id="b956a-521">この構造体は ***nx_api.h*** で定義されています。IP インスタンスの制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="b956a-521">This structure is defined in the ***nx_api.h*** IP instance control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="static-ip-routing"></a><span data-ttu-id="b956a-522">静的 IP ルーティング</span><span class="sxs-lookup"><span data-stu-id="b956a-522">Static IP Routing</span></span>

<span data-ttu-id="b956a-523">静的ルーティング機能を使用すると、アプリケーションでは、特定のネットワーク外の宛先 IP アドレスに対して IP ネットワークとネクスト ホップ アドレスを指定できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-523">The static routing feature allows an application to specify an IP network and next hop address for specific out of network destination IP addresses.</span></span> <span data-ttu-id="b956a-524">静的ルーティングが有効になっている場合、NetX は静的ルーティング テーブルを検索し、送信するパケットの宛先アドレスと一致するエントリを検索します。</span><span class="sxs-lookup"><span data-stu-id="b956a-524">If static routing is enabled, NetX searches through the static routing table for an entry matching the destination address of the packet to send.</span></span> <span data-ttu-id="b956a-525">一致するものが見つからない場合、NetX は物理インターフェイスの一覧を検索し、宛先 IP アドレスとネットワーク マスクに基づいて、送信元 IP アドレスとネクスト ホップ アドレスを選択します。</span><span class="sxs-lookup"><span data-stu-id="b956a-525">If no match is found, NetX searches through the list of physical interfaces and chooses a source IP address and next hop address based on the destination IP address and the network mask.</span></span> <span data-ttu-id="b956a-526">IP インスタンスに接続されているネットワーク ドライバーのどの IP アドレスとも宛先が一致しない場合、NetX は、既定のゲートウェイに直接接続されているインターフェイスを選択し、送信元アドレスとしてインターフェイスの IP アドレスを使用し、ネクスト ホップとして既定のゲートウェイを使用します。</span><span class="sxs-lookup"><span data-stu-id="b956a-526">If the destination does not match any of the IP addresses of the network drivers attached to the IP instance, NetX chooses an interface that is directly connected to the default gateway, and uses the IP address of the interface as source address, and the default gateway as the next hop.</span></span>

<span data-ttu-id="b956a-527">***nx_ip_static_route_add*** と \***nx_ip_static_route_delete** _ サービスをそれぞれ使用して、静的ルーティング テーブルのエントリを追加および削除できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-527">Entries can be added and removed from the static routing table using the ***nx_ip_static_route_add*** and \***nx_ip_static_route_delete** _ services, respectively.</span></span> <span data-ttu-id="b956a-528">静的ルーティングを使用するには、_ *_NX_ENABLE_IP_STATIC_ROUTING_*\* を定義して、ホスト アプリケーションでこの機能を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-528">To use static routing, the host application must enable this feature by defining _ *_NX_ENABLE_IP_STATIC_ROUTING_*.\*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-529">*静的ルーティング テーブルにエントリを追加するときに、NetX では、指定された宛先アドレスに一致するエントリがテーブル内に既に存在するかどうかを確認します。存在する場合は、ネットワーク マスクの中で、より小さいネットワーク (長いプレフィックス) のエントリを優先します。*</span><span class="sxs-lookup"><span data-stu-id="b956a-529">*When adding an entry to the static routing table, NetX checks for a matching entry for the specified destination address already in the table. If one exists, it gives preference to the entry with the smaller network (longer prefix) in the network mask.*</span></span>

### <a name="ip-fragmentation"></a><span data-ttu-id="b956a-530">IP の断片化</span><span class="sxs-lookup"><span data-stu-id="b956a-530">IP Fragmentation</span></span>

<span data-ttu-id="b956a-531">ネットワーク デバイスには、送信パケットのサイズに制限がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-531">The network device may have limits on the size of outgoing packets.</span></span> <span data-ttu-id="b956a-532">この制限は、最大転送単位 (MTU) と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-532">This limit is called the maximum transmission unit (MTU).</span></span> <span data-ttu-id="b956a-533">IP の MTU は、IP パケットを断片化せずにリンク レイヤー ドライバーで送信できる最大 IP フレーム サイズです。</span><span class="sxs-lookup"><span data-stu-id="b956a-533">IP MTU is the largest IP frame size a link layer driver is able to transmit without fragmenting the IP packet.</span></span> <span data-ttu-id="b956a-534">デバイス ドライバーの初期化フェーズでは、ドライバー モジュールはサービス ***nx_ip_interface_mtu_set*** を介して IP の MTU サイズを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-534">During a device driver initialization phase, the driver module must configure its IP MTU size via the service \***nx_ip_interface_mtu_set**.\*</span></span>

<span data-ttu-id="b956a-535">推奨されませんが、アプリケーションでは、デバイスでサポートされている基になる IP MTU よりも大きいデータグラムが生成される場合があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-535">Although not recommended, the application may generate datagrams larger than the underlying IP MTU supported by the device.</span></span> <span data-ttu-id="b956a-536">このような IP データグラムを送信する前に、IP レイヤーはこれらのパケットを断片化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-536">Before transmitting such IP datagram, the IP layer must fragment these packets.</span></span> <span data-ttu-id="b956a-537">断片化された IP フレームを受信する場合、受信側は同じ断片化 ID を持つ断片化されたすべての IP フレームを格納し、順番に再アセンブルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-537">On receiving fragmented IP frames, the receiving end must store all fragmented IP frames with the same fragmentation ID, and reassemble them in order.</span></span> <span data-ttu-id="b956a-538">IP 受信ロジックがすべてのフラグメントを収集して元の IP フレームを時間内に復元できない場合は、すべてのフラグメントが解放されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-538">If the IP receive logic is unable to collect all the fragments to restore the original IP frame in time, all the fragments are released.</span></span> <span data-ttu-id="b956a-539">このようなパケット損失を検出して回復する作業は、上位層プロトコルが担います。</span><span class="sxs-lookup"><span data-stu-id="b956a-539">It is up to the upper layer protocol to detect such packet loss and recover from it.</span></span>

<span data-ttu-id="b956a-540">IP の断片化と再アセンブリの操作をサポートするために、システム デザイナーは、***nx_ip_fragment_enable*** サービスを使用して NetX の IP の断片化機能を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-540">In order to support IP fragmentation and reassembly operation, the system designer must enable the IP fragmentation feature in NetX using the ***nx_ip_fragment_enable*** service.</span></span> <span data-ttu-id="b956a-541">この機能が有効になっていない場合は、断片化された受信 IP パケットだけでなく、ネットワーク ドライバーの MTU を超えるパケットも破棄されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-541">If this feature is not enabled, incoming fragmented IP packets are discarded, as well as packets that exceed the network driver's MTU.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-542">*IP 断片化ロジックは、NetX ライブラリを構築するときに、*  \***NX_DISABLE_FRAGMENTATION** _ _を定義することで完全に削除できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-542">*The IP Fragmentation logic can be removed completely by defining* \***NX_DISABLE_FRAGMENTATION** _ _when building theNetX library.</span></span> <span data-ttu-id="b956a-543">これにより、NetX のコード サイズを減らすことができます。\*</span><span class="sxs-lookup"><span data-stu-id="b956a-543">Doing so helps reduce the code size of NetX.\*</span></span>

## <a name="address-resolution-protocol-arp-in-ip"></a><span data-ttu-id="b956a-544">IP のアドレス解決プロトコル (ARP)</span><span class="sxs-lookup"><span data-stu-id="b956a-544">Address Resolution Protocol (ARP) in IP</span></span>

<span data-ttu-id="b956a-545">アドレス解決プロトコル (ARP) は、32 ビットの IP アドレスを、基になる物理メディアの IP アドレスに動的にマッピングする役割を担います (RFC 826)。</span><span class="sxs-lookup"><span data-stu-id="b956a-545">The Address Resolution Protocol (ARP) is responsible for dynamically mapping 32-bit IP addresses to those of the underlying physical media (RFC 826).</span></span> <span data-ttu-id="b956a-546">イーサネットは最も一般的な物理メディアであり、48 ビットのアドレスをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b956a-546">Ethernet is the most typical physical media, and it supports 48-bit addresses.</span></span> <span data-ttu-id="b956a-547">ARP の必要性は、***nx_ip_create*** サービスに提供されるネットワーク ドライバーによって決まります。</span><span class="sxs-lookup"><span data-stu-id="b956a-547">The need for ARP is determined by the network driver supplied to the ***nx_ip_create*** service.</span></span> <span data-ttu-id="b956a-548">物理マッピングが必要な場合、ネットワーク ドライバーはインターフェイス構造の ***nx_interface_address_mapping_needed*** にフラグを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-548">If physical mapping is required, the network driver must set the flag ***nx_interface_address_mapping_needed*** in the interface strcuture.</span></span>

### <a name="arp-enable"></a><span data-ttu-id="b956a-549">ARP 有効化</span><span class="sxs-lookup"><span data-stu-id="b956a-549">ARP Enable</span></span>
<span data-ttu-id="b956a-550">ARP を正常に機能させるには、最初に ***nx_arp_enable*** サービスを使用してアプリケーションで有効化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-550">For ARP to function properly, it must first be enabled by the application with the ***nx_arp_enable*** service.</span></span> <span data-ttu-id="b956a-551">このサービスでは、ARP 有効化サービスに提供されるメモリからの ARP キャッシュ領域の作成など、ARP 処理用にさまざまなデータ構造が設定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-551">This service sets up various data structures for ARP processing, including the creation of an ARP cache area from the memory supplied to the ARP enable service.</span></span>

### <a name="arp-cache"></a><span data-ttu-id="b956a-552">ARP キャッシュ</span><span class="sxs-lookup"><span data-stu-id="b956a-552">ARP Cache</span></span>
<span data-ttu-id="b956a-553">ARP キャッシュは、内部 ARP マッピング データ構造の配列として表示できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-553">The ARP cache can be viewed as an array of internal ARP mapping data structures.</span></span> <span data-ttu-id="b956a-554">各内部構造によって、IP アドレスと物理ハードウェア アドレスの間の関係を維持することができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-554">Each internal structure is capable of maintaining the relationship between an IP address and a physical hardware address.</span></span> <span data-ttu-id="b956a-555">さらに、各データ構造にリンク ポインターがあるため、複数のリンク リストに含めることができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-555">In addition, each data structure has link pointers so it can be part of multiple linked lists.</span></span>

<span data-ttu-id="b956a-556">ARP テーブルにマッピングが存在する場合、アプリケーションでは、サービス \***nx_arp_ip_address_find** _ を使用してハードウェア MAC アドレスを指定することにより、ARP キャッシュから IP アドレスを検索できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-556">Application can look up an IP address from the ARP cache by supplying hardware MAC address using the service \***nx_arp_ip_address_find** _ if the mapping exists in the ARP table.</span></span> <span data-ttu-id="b956a-557">同様に、サービス _ *_nx_arp_hardware_address_find_*\* では、指定された IP アドレスの MAC アドレスが返されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-557">Similarly, the service _ *_nx_arp_hardware_address_find_*\* returns the MAC address for a given IP address.</span></span>


### <a name="arp-dynamic-entries"></a><span data-ttu-id="b956a-558">ARP 動的エントリ</span><span class="sxs-lookup"><span data-stu-id="b956a-558">ARP Dynamic Entries</span></span>

<span data-ttu-id="b956a-559">既定では、ARP 有効化サービスは、ARP キャッシュ内のすべてのエントリを、使用可能な動的 ARP エントリの一覧に配置します。</span><span class="sxs-lookup"><span data-stu-id="b956a-559">By default, the ARP enable service places all entries in the ARP cache on the list of available dynamic ARP entries.</span></span> <span data-ttu-id="b956a-560">マップされていない IP アドレスへの送信要求が検出されると、このリストから動的 ARP エントリが NetX によって割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b956a-560">A dynamic ARP entry is allocated from this list by NetX when a send request to an unmapped IP address is detected.</span></span> <span data-ttu-id="b956a-561">割り当てが完了すると、ARP エントリがセットアップされ、ARP 要求が物理メディアに送信されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-561">After allocation, the ARP entry is set up and an ARP request is sent to the physical media.</span></span>

<span data-ttu-id="b956a-562">動的エントリは、サービス ***nx_arp_dynamic_entry_set*** で作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="b956a-562">A dynamic entry can also be created by the service ***nx_arp_dynamic_entry_set***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-563">*すべての動的 ARP エントリが使用されている場合、最も長く使用されていない ARP エントリが新しいマッピングに置き換えられます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-563">*If all dynamic ARP entries are in use, the least recently used ARP entry is replaced with a new mapping.*</span></span>

### <a name="arp-static-entries"></a><span data-ttu-id="b956a-564">ARP 静的エントリ</span><span class="sxs-lookup"><span data-stu-id="b956a-564">ARP Static Entries</span></span>
<span data-ttu-id="b956a-565">アプリケーションでは、***nx_arp_static_entry_create*** サービスを使用して静的 ARP マッピングを設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="b956a-565">The application can also set up static ARP mapping by using the ***nx_arp_static_entry_create*** service.</span></span> <span data-ttu-id="b956a-566">このサービスは、動的 ARP エントリ リストから ARP エントリを割り当て、アプリケーションから提供されたマッピング情報を使用して静的リストに配置します。</span><span class="sxs-lookup"><span data-stu-id="b956a-566">This service allocates an ARP entry from the dynamic ARP entry list and places it on the static list with the mapping information supplied by the application.</span></span> <span data-ttu-id="b956a-567">静的 ARP エントリは、再利用またはエージングの対象になりません。</span><span class="sxs-lookup"><span data-stu-id="b956a-567">Static ARP entries are not subject to reuse or aging.</span></span> <span data-ttu-id="b956a-568">アプリケーションでは、サービス ***nx_arp_static_entry_delete*** を使用して静的エントリを削除できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-568">The application can delete a static entry by using the service ***nx_arp_static_entry_delete***.</span></span>
<span data-ttu-id="b956a-569">ARP テーブル内のすべての静的エントリを削除するために、アプリケーションでサービス ***nx_arp_static_entries_delete*** が使用されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-569">To remove all static entries in the ARP table, the application may use the service ***nx_arp_static_entries_delete***.</span></span>

### <a name="automatic-arp-entry"></a><span data-ttu-id="b956a-570">自動 ARP 入力</span><span class="sxs-lookup"><span data-stu-id="b956a-570">Automatic ARP Entry</span></span>
<span data-ttu-id="b956a-571">NetX は、ARP 要求に対するピアの応答後に、ピアの IP/MAC マッピングを記録します。</span><span class="sxs-lookup"><span data-stu-id="b956a-571">NetX records the peer's IP/MAC mapping after the peer responses to the ARP request.</span></span> <span data-ttu-id="b956a-572">NetX には、ネットワークからの要請されていない ARP 要求に基づいて、ピア IP/MAC アドレスのマッピングを記録する自動 ARP 入力機能も実装されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-572">NetX also implements the automatic ARP entry feature where it records peer IP/MAC address mapping based on unsolicited ARP requests from the network.</span></span> <span data-ttu-id="b956a-573">この機能を使用すると、ARP テーブルにピア情報が入力されるため、ARP 要求/応答サイクルを実行するために必要な遅延を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-573">This feature allows the ARP table to be populated with peer information, reducing the delay needed to go through the ARP request/response cycle.</span></span> <span data-ttu-id="b956a-574">ただし、自動 ARP を有効にした場合の欠点は、ローカル リンク上に多数のノードがあるビジー状態のネットワークでは、ARP テーブルがすぐにいっぱいになる傾向があることです。これが最終的には ARP エントリの置換につながります。</span><span class="sxs-lookup"><span data-stu-id="b956a-574">However the downside with enabling automatic ARP is that the ARP table tend to fill up quickly on a busy network with many nodes on the local link, which would eventually lead to ARP entry replacement.</span></span>

<span data-ttu-id="b956a-575">この機能は、既定で有効になっています。</span><span class="sxs-lookup"><span data-stu-id="b956a-575">This feature is enabled by default.</span></span> <span data-ttu-id="b956a-576">無効にするには、定義されたシンボル ***NX_DISABLE_ARP_AUTO_ENTRY*** を使用して NetX ライブラリをコンパイルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-576">To disable it, the NetX library must be compiled with the symbol ***NX_DISABLE_ARP_AUTO_ENTRY*** defined.</span></span>

### <a name="arp-messages"></a><span data-ttu-id="b956a-577">ARP メッセージ</span><span class="sxs-lookup"><span data-stu-id="b956a-577">ARP Messages</span></span>

<span data-ttu-id="b956a-578">前に説明したように、IP アドレスにマッピングが必要であることが IP タスクによって検出されると、ARP 要求メッセージが送信されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-578">As mentioned previously, an ARP request message is sent when the IP task detects that mapping is needed for an IP address.</span></span> <span data-ttu-id="b956a-579">ARP 要求は、対応する ARP 応答を受信するまで、(\***NX_ARP_UPDATE_RATE** _ 秒ごとに) 定期的に送信されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-579">ARP requests are sent periodically (every \***NX_ARP_UPDATE_RATE** _ seconds) until a corresponding ARP response is received.</span></span> <span data-ttu-id="b956a-580">ARP の試行が破棄される前に、合計で _ *_NX_ARP_MAXIMUM_RETRIES_*\* 回の ARP 要求が行われます。</span><span class="sxs-lookup"><span data-stu-id="b956a-580">A total of _ *_NX_ARP_MAXIMUM_RETRIES_*\* ARP requests are made before the ARP attempt is abandoned.</span></span> <span data-ttu-id="b956a-581">ARP 応答を受信すると、関連付けられている物理アドレス情報がキャッシュ内の ARP エントリに格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-581">When an ARP response is received, the associated physical address information is stored in the ARP entry that is in the cache.</span></span>

<span data-ttu-id="b956a-582">マルチホーム システムの場合、NetX では、指定された宛先アドレスに基づいて ARP 要求と応答を送信するインターフェイスが決定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-582">For multihome systems, NetX determines which interface to send the ARP requests and responses based on destination address specified.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-583">*送信 IP パケットは、NetX が ARP 応答を待機している間、キューに登録されます。キューに置かれる発信 IP* *パケットの数は、定数*  ***NX_ARP_MAX_QUEUE_DEPTH*** によって定義されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-583">*Outgoing IP packets are queued while NetX waits for the ARP response. The number of outgoing IP* *packets queued is defined by the constant* \***NX_ARP_MAX_QUEUE_DEPTH**.\*</span></span>

<span data-ttu-id="b956a-584">NetX は、ローカル IP ネットワーク上の他のノードからの ARP 要求にも応答します。</span><span class="sxs-lookup"><span data-stu-id="b956a-584">NetX also responds to ARP requests from other nodes on the local IP network.</span></span> <span data-ttu-id="b956a-585">ARP 要求を受信するインターフェイスの現在の IP アドレスと一致する外部 ARP 要求が行われると、NetX は、現在の物理アドレスを含む ARP 応答メッセージを構築します。</span><span class="sxs-lookup"><span data-stu-id="b956a-585">When an external ARP request is made that matches the current IP address of the interface that receives the ARP request, NetX builds an ARP response message that contains the current physical address.</span></span>

<span data-ttu-id="b956a-586">イーサネットの ARP 要求と応答の形式を図 6 に示し、次に説明します。</span><span class="sxs-lookup"><span data-stu-id="b956a-586">The formats of Ethernet ARP requests and responses are shown in Figure 6 and are described below:</span></span>

| <span data-ttu-id="b956a-587">要求/応答フィールド</span><span class="sxs-lookup"><span data-stu-id="b956a-587">Request/Response Field</span></span>       | <span data-ttu-id="b956a-588">目的</span><span class="sxs-lookup"><span data-stu-id="b956a-588">Purpose</span></span>    |
|------------------------------|-----------------|
| <span data-ttu-id="b956a-589">イーサネットの宛先アドレス</span><span class="sxs-lookup"><span data-stu-id="b956a-589">Ethernet Destination Address</span></span> | <span data-ttu-id="b956a-590">この 6 バイトのフィールドには、ARP 応答の宛先アドレスが格納され、ARP 要求の場合はブロードキャスト (すべて) になります。</span><span class="sxs-lookup"><span data-stu-id="b956a-590">This 6-byte field contains the destination address for the ARP response and is a broadcast (all ones) for ARP requests.</span></span> <span data-ttu-id="b956a-591">このフィールドは、ネットワーク ドライバーによって設定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-591">This field is setup by the network driver.</span></span> |
| <span data-ttu-id="b956a-592">イーサネットの送信元アドレス</span><span class="sxs-lookup"><span data-stu-id="b956a-592">Ethernet Source Address</span></span>      | <span data-ttu-id="b956a-593">この 6 バイトのフィールドには、ARP 要求または応答の送信者のアドレスが格納され、ネットワーク ドライバーによって設定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-593">This 6-byte field contains the address of the sender of the ARP request or response and is set up by the network driver.</span></span> |
| <span data-ttu-id="b956a-594">フレームの種類</span><span class="sxs-lookup"><span data-stu-id="b956a-594">Frame Type</span></span>                   | <span data-ttu-id="b956a-595">この 2 バイトのフィールドには、存在するイーサネット フレームの種類が格納されます。ARP 要求と応答の場合、これは 0x0806 に相当します。</span><span class="sxs-lookup"><span data-stu-id="b956a-595">This 2-byte field contains the type of Ethernet frame present and, for ARP requests and responses, this is equal to 0x0806.</span></span> <span data-ttu-id="b956a-596">これは、ネットワーク ドライバーで設定される最後のフィールドです。</span><span class="sxs-lookup"><span data-stu-id="b956a-596">This is the last field the network driver is responsible for setting up.</span></span> |
| <span data-ttu-id="b956a-597">ハードウェアの種類</span><span class="sxs-lookup"><span data-stu-id="b956a-597">Hardware Type</span></span>                | <span data-ttu-id="b956a-598">この 2 バイトのフィールドには、ハードウェアの種類が格納されます。イーサネットの場合は 0x0001 です。</span><span class="sxs-lookup"><span data-stu-id="b956a-598">This 2-byte field contains the hardware type, which is 0x0001 for Ethernet.</span></span> |
| <span data-ttu-id="b956a-599">プロトコル タイプ</span><span class="sxs-lookup"><span data-stu-id="b956a-599">Protocol Type</span></span>                | <span data-ttu-id="b956a-600">この 2 バイトのフィールドには、プロトコルの種類が格納されます。IP アドレスの場合は 0x0800 です。</span><span class="sxs-lookup"><span data-stu-id="b956a-600">This 2-byte field contains the protocol type, which is 0x0800 for IP addresses.</span></span> |
| <span data-ttu-id="b956a-601">ハードウェア サイズ</span><span class="sxs-lookup"><span data-stu-id="b956a-601">Hardware Size</span></span>                | <span data-ttu-id="b956a-602">この 1 バイトのフィールドには、ハードウェア アドレスのサイズが格納されます。イーサネット アドレスの場合は 6 です。</span><span class="sxs-lookup"><span data-stu-id="b956a-602">This 1-byte field contains the hardware address size, which is 6 for Ethernet addresses.</span></span> |


![ARP パケット形式](./media/user-guide/arp-packet-format.png)

<span data-ttu-id="b956a-604">**図 6. ARP パケット形式**</span><span class="sxs-lookup"><span data-stu-id="b956a-604">**FIGURE 6. ARP Packet Format**</span></span>

| <span data-ttu-id="b956a-605">要求/応答フィールド</span><span class="sxs-lookup"><span data-stu-id="b956a-605">Request/Response Field</span></span> | <span data-ttu-id="b956a-606">目的</span><span class="sxs-lookup"><span data-stu-id="b956a-606">Purpose</span></span>  |
|---|---|
| <span data-ttu-id="b956a-607">プロトコル サイズ</span><span class="sxs-lookup"><span data-stu-id="b956a-607">Protocol Size</span></span> | <span data-ttu-id="b956a-608">この 1 バイトのフィールドには IP アドレスのサイズが格納されます。IP アドレスの場合は 4 です。</span><span class="sxs-lookup"><span data-stu-id="b956a-608">This 1-byte field contains the IP address size, which is 4 for IP addresses.</span></span>  |
| <span data-ttu-id="b956a-609">オペレーション コード</span><span class="sxs-lookup"><span data-stu-id="b956a-609">Operation Code</span></span> | <span data-ttu-id="b956a-610">この 2 バイトのフィールドには、この ARP パケットに対する操作が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-610">This 2-byte field contains the operation for this ARP packet.</span></span> <span data-ttu-id="b956a-611">ARP 要求は 0x0001 の値で指定され、ARP 応答は 0x0002 の値で表されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-611">An ARP request is specified with the value of 0x0001, while an ARP response is represented by a value of 0x0002.</span></span>  |
| <span data-ttu-id="b956a-612">送信者のイーサネット アドレス</span><span class="sxs-lookup"><span data-stu-id="b956a-612">Sender Ethernet Address</span></span> | <span data-ttu-id="b956a-613">この 6 バイトのフィールドには、送信者のイーサネット アドレスが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-613">This 6-byte field contains the sender's Ethernet address.</span></span> |
| <span data-ttu-id="b956a-614">送信者の IP アドレス</span><span class="sxs-lookup"><span data-stu-id="b956a-614">Sender IP Address</span></span> | <span data-ttu-id="b956a-615">この 4 バイトのフィールドには、送信者の IP アドレスが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-615">This 4-byte field contains the sender's IP address.</span></span> |
| <span data-ttu-id="b956a-616">ターゲット イーサネット アドレス</span><span class="sxs-lookup"><span data-stu-id="b956a-616">Target Ethernet Address</span></span> | <span data-ttu-id="b956a-617">この 6 バイトのフィールドには、ターゲットのイーサネット アドレスが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-617">This 6-byte field contains the target's Ethernet address.</span></span> |
| <span data-ttu-id="b956a-618">ターゲット IP アドレス</span><span class="sxs-lookup"><span data-stu-id="b956a-618">Target IP Address</span></span> | <span data-ttu-id="b956a-619">この 4 バイトのフィールドには、ターゲットの IP アドレスが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-619">This 4-byte field contains the target's IP address.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="b956a-620">*ARP の要求と応答は、イーサネットレベルのパケットです。その他のすべての TCP/IP パケットは、IP パケット ヘッダーによってカプセル化されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-620">*ARP requests and responses are Ethernet-level packets. All other TCP/IP packets are encapsulated by an IP packet header.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-621">*TCP/IP 実装のすべての ARP メッセージは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-621">*All ARP messages in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="arp-aging"></a><span data-ttu-id="b956a-622">ARP のエージング</span><span class="sxs-lookup"><span data-stu-id="b956a-622">ARP Aging</span></span>

<span data-ttu-id="b956a-623">NetX では、動的 ARP 入力の自動無効化がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b956a-623">NetX supports automatic dynamic ARP entry invalidation.</span></span><span data-ttu-id="b956a-624">\ ***NX_ARP_EXPIRATION_RATE** _ は、物理マッピングに対して確立された IP アドレスが有効な秒数を指定します。</span><span class="sxs-lookup"><span data-stu-id="b956a-624">\ ***NX_ARP_EXPIRATION_RATE** _specifies the number of seconds an established IP address to physical mapping stays valid.</span></span> <span data-ttu-id="b956a-625">有効期限が切れると、ARP キャッシュから ARP エントリが削除されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-625">After expiration, the ARP entry is removed from the ARP cache.</span></span> <span data-ttu-id="b956a-626">対応する IP アドレスへの送信を次に試行したときに、新しい ARP 要求が発生します。</span><span class="sxs-lookup"><span data-stu-id="b956a-626">The next attempt to send to the corresponding IP address will result in a new ARP request.</span></span> <span data-ttu-id="b956a-627">_ *_NX_ARP_EXPIRATION_RATE_*\* を 0 に設定すると、ARP のエージングが無効になります。これは既定の構成です。</span><span class="sxs-lookup"><span data-stu-id="b956a-627">Setting _ *_NX_ARP_EXPIRATION_RATE_*\* to zero disables ARP aging, which is the default configuration.</span></span>

### <a name="arp-defend"></a><span data-ttu-id="b956a-628">ARP の防御</span><span class="sxs-lookup"><span data-stu-id="b956a-628">ARP Defend</span></span>

<span data-ttu-id="b956a-629">ARP 要求または ARP 応答パケットが受信され、送信元の IP アドレスが同じで、このノードの IP アドレスと競合している場合、NetX によってそのアドレスに対する ARP 要求が防御として送信されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-629">When an ARP request or ARP response packet is received and the sender has the same IP address, which conflicts with the IP address of this node, NetX sends an ARP request for that address as a defense.</span></span> <span data-ttu-id="b956a-630">競合する ARP パケットが 10 秒以内に複数回受信された場合、NetX はそれ以上の防御パケットを送信しません。</span><span class="sxs-lookup"><span data-stu-id="b956a-630">If the conflict ARP packet is received more than once in 10 seconds, NetX does not send more defend packets.</span></span> <span data-ttu-id="b956a-631">既定の間隔は 10 秒で、\***NX_ARP_DEFEND_INTERVAL** _ で再定義できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-631">The default interval 10 seconds can be redefined by \***NX_ARP_DEFEND_INTERVAL** _.</span></span> <span data-ttu-id="b956a-632">この動作は、RFC5227 の 2.4(c) で指定されたポリシーに従います。</span><span class="sxs-lookup"><span data-stu-id="b956a-632">This behavior follows the policy specified in 2.4(c) of RFC5227.</span></span> <span data-ttu-id="b956a-633">Windows XP では ARP プローブの応答として ARP アナウンスが無視されるため、ユーザーは _*_NX_ARP_DEFEND_BY_REPLY_*\* を定義して、追加の防御として ARP 応答を送信できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-633">Since Windows XP ignores ARP announcement as a response for its ARP probe, user can define _\*_NX_ARP_DEFEND_BY_REPLY_\*\*to send ARP response as additional defence.</span></span>

### <a name="arp-statistics-and-errors"></a><span data-ttu-id="b956a-634">ARP の統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b956a-634">ARP Statistics and Errors</span></span>

<span data-ttu-id="b956a-635">有効にすると、NetX ARP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-635">If enabled, the NetX ARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b956a-636">次の統計およびエラー レポートは、IP の ARP 処理ごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-636">The following statistics and error reports are maintained for each IP's ARP processing:</span></span>

- <span data-ttu-id="b956a-637">送信された ARP 要求の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-637">Total ARP Requests Sent</span></span>
- <span data-ttu-id="b956a-638">受信した ARP 要求の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-638">Total ARP Requests Received</span></span>
- <span data-ttu-id="b956a-639">送信された ARP 応答の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-639">Total ARP Responses Sent</span></span>
- <span data-ttu-id="b956a-640">受信した ARP 応答の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-640">Total ARP Responses Received</span></span>
- <span data-ttu-id="b956a-641">ARP 動的エントリの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-641">Total ARP Dynamic Entries</span></span>
- <span data-ttu-id="b956a-642">ARP 静的エントリの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-642">Total ARP Static Entries</span></span>
- <span data-ttu-id="b956a-643">ARP 期限切れエントリの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-643">Total ARP Aged Entries</span></span>
- <span data-ttu-id="b956a-644">ARP 無効メッセージの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-644">Total ARP Invalid Messages</span></span>

<span data-ttu-id="b956a-645">これらの統計およびエラー レポートはすべて、***nx_arp_info_get*** サービスを使用してアプリケーションで利用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-645">All these statistics and error reports are available to the application with the ***nx_arp_info_get*** service.</span></span>

## <a name="reverse-address-resolution-protocol-rarp-in-ip"></a><span data-ttu-id="b956a-646">IP の逆アドレス解決プロトコル (RARP)</span><span class="sxs-lookup"><span data-stu-id="b956a-646">Reverse Address Resolution Protocol (RARP) in IP</span></span>

<span data-ttu-id="b956a-647">逆アドレス解決プロトコル (RARP) は、ホストの 32 ビット IP アドレスのネットワーク割り当てを要求するためのプロトコルです (RFC 903)。</span><span class="sxs-lookup"><span data-stu-id="b956a-647">The Reverse Address Resolution Protocol (RARP) is the protocol for requesting network assignment of the host's 32-bit IP addresses (RFC 903).</span></span> <span data-ttu-id="b956a-648">これは RARP 要求によって行われ、ネットワーク メンバーが RARP 応答でホスト ネットワーク インターフェイスに IP アドレスを割り当てるまで定期的に継続されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-648">This is done through an RARP request and continues periodically until a network member assigns an IP address to the host network interface in an RARP response.</span></span> <span data-ttu-id="b956a-649">アプリケーションは、サービス ***nx_ip_create*** を使用して、IP インスタンスを IP アドレス 0 で作成します。</span><span class="sxs-lookup"><span data-stu-id="b956a-649">The application creates an IP instance by the service ***nx_ip_create*** with a zero IP address.</span></span> <span data-ttu-id="b956a-650">RARP がアプリケーションで有効化されている場合は、RARP プロトコルを使用して、IP アドレスが 0 のインターフェイスを介してアクセス可能なネットワーク サーバーから IP アドレスを要求できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-650">If RARP is enabled by the application, it can use the RARP protocol to request an IP address from the network server accessible through the interface that has a zero IP address.</span></span>

### <a name="rarp-enable"></a><span data-ttu-id="b956a-651">RARP 有効化</span><span class="sxs-lookup"><span data-stu-id="b956a-651">RARP Enable</span></span>

<span data-ttu-id="b956a-652">RARP を使用するには、アプリケーションで IP アドレスが 0 の IP インスタンスを作成してから、サービス ***nx_rarp_enable*** を使用して RARP を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-652">To use RARP, the application must create the IP instance with an IP address of zero, then enable RARP using the service ***nx_rarp_enable***.</span></span> <span data-ttu-id="b956a-653">マルチホーム システムの場合は、IP インスタンスに関連付けられている少なくとも 1 つのネットワーク デバイスの IP アドレスが 0 である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-653">For multihome systems, at least one network device associated with the IP instance must have an IP address of zero.</span></span> <span data-ttu-id="b956a-654">RARP の処理では、ネットワークに指定された IP アドレスを持つ有効な RARP 応答を受信するまで、IP アドレスを必要とする NetX システムの RARP 要求メッセージが定期的に送信されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-654">The RARP processing periodically sends RARP request messages for the NetX system requiring an IP address until a valid RARP reply with the network designated IP address is received.</span></span> <span data-ttu-id="b956a-655">この時点で、RARP 処理は完了します。</span><span class="sxs-lookup"><span data-stu-id="b956a-655">At this point, RARP processing is complete.</span></span>

<span data-ttu-id="b956a-656">RARP は、有効化された後ですべてのインターフェイス アドレスが解決されると、自動的に無効になります。</span><span class="sxs-lookup"><span data-stu-id="b956a-656">After RARP has been enabled, it is disabled automatically after all interface addresses are resolved.</span></span> <span data-ttu-id="b956a-657">アプリケーションは、サービス ***nx_rarp_disable*** を使用して、RARP を強制的に終了させることができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-657">The application may force RARP to terminate by using the service ***nx_rarp_disable***.</span></span>

###  <a name="rarp-request"></a><span data-ttu-id="b956a-658">RARP 要求</span><span class="sxs-lookup"><span data-stu-id="b956a-658">RARP Request</span></span>

<span data-ttu-id="b956a-659">RARP 要求パケットの形式は、トピック「[ARP メッセージ](#arp-messages)」の図 6 に示されている ARP パケットとほぼ同じです。唯一の違いは、フレームの種類フィールドが 0x8035 で、*操作コード* フィールドが 3 で RARP 要求が指定されていることです。</span><span class="sxs-lookup"><span data-stu-id="b956a-659">The format of an RARP request packet is almost identical to the ARP packet shown in Figure 6 in the topic [ARP Messages](#arp-messages).The only difference is the frame type field is 0x8035 and the *Operation Code* field is 3, designating an RARP request.</span></span> <span data-ttu-id="b956a-660">前述のように、ネットワークで割り当てられた IP アドレスを持つ RARP 応答を受信するまで、RARP 要求は定期的に送信されます (***NX_RARP_UPDATE_RATE*** 秒ごと)。</span><span class="sxs-lookup"><span data-stu-id="b956a-660">As mentioned previously, RARP requests will be sent periodically (every ***NX_RARP_UPDATE_RATE*** seconds) until a RARP reply with the network assigned IP address is received.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-661">*TCP/IP 実装のすべての RARP メッセージは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-661">*All RARP messages in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="rarp-reply"></a><span data-ttu-id="b956a-662">RARP 応答</span><span class="sxs-lookup"><span data-stu-id="b956a-662">RARP Reply</span></span>

<span data-ttu-id="b956a-663">RARP 応答メッセージはネットワークから受信され、このホストに対するネットワーク割り当て IP アドレスが格納されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-663">RARP reply messages are received from the network and contain the network assigned IP address for this host.</span></span> <span data-ttu-id="b956a-664">RARP 応答パケットの形式は、図 6 に示されている ARP パケットとほぼ同じです。</span><span class="sxs-lookup"><span data-stu-id="b956a-664">The format of an RARP reply packet is almost identical to the ARP packet shown in Figure 6.</span></span> <span data-ttu-id="b956a-665">唯一の違いは、フレームの種類フィールドが 0x8035 で、*操作コード* フィールドは 4 で、RARP 応答を指定することです。</span><span class="sxs-lookup"><span data-stu-id="b956a-665">The only difference is the frame type field is 0x8035 and the *Operation Code* field is 4, which designates an RARP reply.</span></span> <span data-ttu-id="b956a-666">受信後に、IP アドレスが IP インスタンスで設定され、RARP の定期的な要求は無効になり、IP インスタンスで通常のネットワーク操作ができるようになります。</span><span class="sxs-lookup"><span data-stu-id="b956a-666">After received, the IP address is setup in the IP instance, the periodic RARP request is disabled, and the IP instance is now ready for normal network operation.</span></span>

<span data-ttu-id="b956a-667">マルチホーム ホストでは、要求元のネットワーク インターフェイスに IP アドレスが適用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-667">For multihome hosts, the IP address is applied to the requesting network interface.</span></span> <span data-ttu-id="b956a-668">まだ IP アドレスの割り当てを要求している他のネットワーク インターフェイスがある場合、すべてのインターフェイス IP アドレス要求が解決されるまで、定期的に RARP サービスが続行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-668">If there are other network interfaces still requesting an IP address assignment, the periodic RARP service continues until all interface IP address requests are resolved.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-669">*アプリケーションでは、RARP 処理が完了するまで IP インスタンスを使用しないようにします。\*\*nx_ip_status_check*\* は、アプリケーションで RARP の完了を待機するために使用される場合があります。マルチホーム システムの場合、要求しているインターフェイスで RARP 処理が完了するまで、アプリケーションによってそのインターフェイスが使用されないようにします。セカンダリ デバイスの IP アドレスの状態は、**nx_ip_interface_status_check** サービスを使用して確認できます。\*</span><span class="sxs-lookup"><span data-stu-id="b956a-669">*The application should not use the IP instance until the RARP processing is complete. The **nx_ip_status_check** may be used by applications to wait for the RARP completion. For multihome systems, the application should not use the requesting interface until the RARP processing is complete on that interface. Status of the IP address on the secondary device can be checked with the **nx_ip_interface_status_check** service.*</span></span>

### <a name="rarp-statistics-and-errors"></a><span data-ttu-id="b956a-670">RARP の統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b956a-670">RARP Statistics and Errors</span></span>

<span data-ttu-id="b956a-671">有効にすると、NetX RARP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-671">If enabled, the NetX RARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b956a-672">次の統計およびエラー レポートは、IP の RARP 処理ごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-672">The following statistics and error reports are maintained for each IP's RARP processing:</span></span>

- <span data-ttu-id="b956a-673">送信された RARP 要求の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-673">Total RARP Requests Sent</span></span>
- <span data-ttu-id="b956a-674">受信した RARP 応答の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-674">Total RARP Responses Received</span></span>
- <span data-ttu-id="b956a-675">RARP 無効メッセージの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-675">Total RARP Invalid Messages</span></span>

<span data-ttu-id="b956a-676">これらの統計およびエラー レポートはすべて、***nx_rarp_info_get*** サービスを使用してアプリケーションで利用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-676">All these statistics and error reports are available to the application with the ***nx_rarp_info_get*** service.</span></span>

## <a name="internet-control-message-protocol-icmp"></a><span data-ttu-id="b956a-677">インターネット制御メッセージ プロトコル (ICMP)</span><span class="sxs-lookup"><span data-stu-id="b956a-677">Internet Control Message Protocol (ICMP)</span></span>

<span data-ttu-id="b956a-678">IP のインターネット制御メッセージ プロトコル (ICMP) は、IP ネットワークのメンバー間でエラーおよび制御情報を渡すことに制限されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-678">Internet Control Message Protocol for IP (ICMP) is limited to passing error and control information between IP network members.</span></span>

<span data-ttu-id="b956a-679">他のほとんどのアプリケーション レイヤー (TCP/IP など) メッセージと同様に、ICMP メッセージは ICMP プロトコルの指定を使用して IP ヘッダーでカプセル化されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-679">Like most other application layer (e.g., TCP/IP) messages, ICMP messages are encapsulated by an IP header with the ICMP protocol designation.</span></span>

### <a name="icmp-statistics-and-errors"></a><span data-ttu-id="b956a-680">ICMP の統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b956a-680">ICMP Statistics and Errors</span></span>

<span data-ttu-id="b956a-681">有効にした場合、NetX では、アプリケーションに役立つ可能性のあるいくつかの ICMP 統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-681">If enabled, NetX keeps track of several ICMP statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b956a-682">次の統計およびエラー レポートは、IP の ICMP 処理ごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-682">The following statistics and error reports are maintained for each IP's ICMP processing:</span></span>

- <span data-ttu-id="b956a-683">送信された ICMP ping の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-683">Total ICMP Pings Sent</span></span>
- <span data-ttu-id="b956a-684">ICMP ping タイムアウトの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-684">Total ICMP Ping Timeouts</span></span>
- <span data-ttu-id="b956a-685">中断された ICMP ping スレッドの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-685">Total ICMP Ping Threads Suspended</span></span>
- <span data-ttu-id="b956a-686">受信した ICMP ping 応答の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-686">Total ICMP Ping Responses Received</span></span>
- <span data-ttu-id="b956a-687">ICMP チェックサム エラーの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-687">Total ICMP Checksum Errors</span></span>
- <span data-ttu-id="b956a-688">未処理の ICMP メッセージの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-688">Total ICMP Unhandled Messages</span></span>

<span data-ttu-id="b956a-689">これらの統計およびエラー レポートはすべて、***nx_icmp_info_get*** サービスを使用してアプリケーションで利用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-689">All these statistics and error reports are available to the application with the ***nx_icmp_info_get*** service.</span></span>

### <a name="icmp-enable"></a><span data-ttu-id="b956a-690">ICMP の有効化</span><span class="sxs-lookup"><span data-stu-id="b956a-690">ICMP Enable</span></span>
<span data-ttu-id="b956a-691">NetX で ICMP メッセージを処理する前に、アプリケーションは ***nx_icmp_enable*** サービスを呼び出して ICMP 処理を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-691">Before ICMP messages can be processed by NetX, the application must call the ***nx_icmp_enable*** service to enable ICMP processing.</span></span> <span data-ttu-id="b956a-692">この処理が完了すると、アプリケーションは ping 要求とフィールド受信 ping パケットを発行できるようになります。</span><span class="sxs-lookup"><span data-stu-id="b956a-692">After this is done, the application can issue ping requests and field incoming ping packets.</span></span>

### <a name="icmp-echo-request"></a><span data-ttu-id="b956a-693">ICMP エコー要求</span><span class="sxs-lookup"><span data-stu-id="b956a-693">ICMP Echo Request</span></span>
<span data-ttu-id="b956a-694">エコー要求は、通常、ホスト IP アドレスによって識別される、ネットワークにある特定ノードの存在を確認するために使用される ICMP メッセージの 1 つの種類です。</span><span class="sxs-lookup"><span data-stu-id="b956a-694">An echo request is one type of ICMP message that is typically used to check for the existence of a specific node on the network, as identified by its host IP address.</span></span> <span data-ttu-id="b956a-695">一般的な ping コマンドは、ICMP エコー要求/エコー応答メッセージを使用して実装されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-695">The popular ping command is implemented using ICMP echo request/echo reply messages.</span></span> <span data-ttu-id="b956a-696">特定のホストが存在する場合、そのネットワーク スタックは ping の要求と応答を ping 応答と共に処理します。</span><span class="sxs-lookup"><span data-stu-id="b956a-696">If the specific host is present, its network stack processes the ping request and responses with a ping response.</span></span> <span data-ttu-id="b956a-697">図 7 では、ICMP ping メッセージの形式について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="b956a-697">Figure 7 details the ICMP ping message format.</span></span>

![ICMP ping メッセージ](./media/user-guide/icmp-ping-message.png)

<span data-ttu-id="b956a-699">**図 7. ICMP ping メッセージ**</span><span class="sxs-lookup"><span data-stu-id="b956a-699">**FIGURE 7. ICMP Ping Message**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-700">*TCP/IP 実装のすべての ICMP メッセージは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-700">*All ICMP messages in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="b956a-701">次の表に、ICMP ヘッダー形式について説明します。</span><span class="sxs-lookup"><span data-stu-id="b956a-701">The following table describes the ICMP header format:</span></span>

| <span data-ttu-id="b956a-702">ヘッダー フィールド</span><span class="sxs-lookup"><span data-stu-id="b956a-702">Header Field</span></span>    | <span data-ttu-id="b956a-703">目的</span><span class="sxs-lookup"><span data-stu-id="b956a-703">Purpose</span></span> |
|-----------------|---------------------------------------------------|
| <span data-ttu-id="b956a-704">種類</span><span class="sxs-lookup"><span data-stu-id="b956a-704">Type</span></span>            | <span data-ttu-id="b956a-705">このフィールドでは、ICMP メッセージを指定します (ビット 31-24)。</span><span class="sxs-lookup"><span data-stu-id="b956a-705">This field specifies the ICMP message (bits 31- 24).</span></span> <span data-ttu-id="b956a-706">最も一般的なのは、0 のエコー応答と 8 のエコー要求です。</span><span class="sxs-lookup"><span data-stu-id="b956a-706">The most common are:   0 Echo Reply   8 Echo Request</span></span> |
| <span data-ttu-id="b956a-707">コード</span><span class="sxs-lookup"><span data-stu-id="b956a-707">Code</span></span>            | <span data-ttu-id="b956a-708">このフィールドは、タイプ フィールドに固有のコンテキストです (ビット 23-16)。</span><span class="sxs-lookup"><span data-stu-id="b956a-708">This field is context specific on the type field (bits 23-16).</span></span> <span data-ttu-id="b956a-709">エコー要求または応答の場合、コードは 0 に設定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-709">For an echo request or reply the code is set to zero.</span></span> |
| <span data-ttu-id="b956a-710">Checksum</span><span class="sxs-lookup"><span data-stu-id="b956a-710">Checksum</span></span>        | <span data-ttu-id="b956a-711">このフィールドには、タイプ フィールドで始まる ICMP ヘッダー全体を含めた、ICMP メッセージの 1 の補数和の 16 ビット チェックサムが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-711">This field contains the 16-bit checksum of the one's complement sum of the ICMP message including the entire the ICMP header starting with the Type field.</span></span> <span data-ttu-id="b956a-712">チェックサムを生成する前に、チェックサム フィールドはクリアされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-712">Before generating the checksum, the checksum field is cleared.</span></span>                 |
| <span data-ttu-id="b956a-713">識別</span><span class="sxs-lookup"><span data-stu-id="b956a-713">Identification</span></span>  | <span data-ttu-id="b956a-714">このフィールドには、ホストを識別する ID 値が格納されています。ホストは、ECHO REPLY のエコー要求から抽出された ID を使用する必要があります (ビット 31-16)。</span><span class="sxs-lookup"><span data-stu-id="b956a-714">This field contains an ID value identifying the host; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span> |
| <span data-ttu-id="b956a-715">Sequence number</span><span class="sxs-lookup"><span data-stu-id="b956a-715">Sequence number</span></span> | <span data-ttu-id="b956a-716">このフィールドには、ID 値が格納されています。ホストは、ECHO REPLY のエコー要求から抽出された ID を使用する必要があります (ビット 31-16)。</span><span class="sxs-lookup"><span data-stu-id="b956a-716">This field contains an ID value; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span> <span data-ttu-id="b956a-717">識別子フィールドとは異なり、この値は同じホストからの後続のエコー要求で変更されます (ビット 15-0)。</span><span class="sxs-lookup"><span data-stu-id="b956a-717">Unlike the identifier field, this value will change in a subsequent Echo request from the same host (bits 15-0).</span></span> |


### <a name="icmp-echo-response"></a><span data-ttu-id="b956a-718">ICMP エコー応答</span><span class="sxs-lookup"><span data-stu-id="b956a-718">ICMP Echo Response</span></span>
<span data-ttu-id="b956a-719">ping 応答は、外部の ping 要求に応答して ICMP コンポーネントによって内部的に生成される別の種類の ICMP メッセージです。</span><span class="sxs-lookup"><span data-stu-id="b956a-719">A ping response is another type of ICMP message that is generated internally by the ICMP component in response to an external ping request.</span></span> <span data-ttu-id="b956a-720">ping 応答には、確認応答に加えて、ping 要求に指定されたユーザー データのコピーも含まれます。</span><span class="sxs-lookup"><span data-stu-id="b956a-720">In addition to acknowledgement, the ping response also contains a copy of the user data supplied in the ping request.</span></span>

## <a name="internet-group-management-protocol-igmp"></a><span data-ttu-id="b956a-721">インターネット グループ管理プロトコル (IGMP)</span><span class="sxs-lookup"><span data-stu-id="b956a-721">Internet Group Management Protocol (IGMP)</span></span>

<span data-ttu-id="b956a-722">インターネット グループ管理プロトコル (IGMP) は、受信または参加を意図している近隣やそのルーターと通信するデバイスに、IP マルチキャスト グループを提供します (RFC 1112 および RFC 2236)。</span><span class="sxs-lookup"><span data-stu-id="b956a-722">The Internet Group Management Protocol (IGMP) provides a device to communicate with its neighbors and its routers that it intends to receive, or join, an IP multicast group (RFC 1112 and RFC 2236).</span></span> <span data-ttu-id="b956a-723">マルチキャスト グループは、基本的にはネットワーク メンバーの動的なコレクションであり、クラス D の IP アドレスで表されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-723">A multicast group is basically a dynamic collection of network members and is represented by a Class D IP address.</span></span> <span data-ttu-id="b956a-724">マルチキャスト グループのメンバーは、いつでも離脱することができ、新しいメンバーはいつでも参加できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-724">Members of the multicast group may leave at any time, and new members may join at any time.</span></span> <span data-ttu-id="b956a-725">グループへの参加と離脱に関係する調整は、IGMP の役割です。</span><span class="sxs-lookup"><span data-stu-id="b956a-725">The coordination involved in joining and leaving the group is the responsibility of IGMP.</span></span>

### <a name="igmp-enable"></a><span data-ttu-id="b956a-726">IGMP の有効化</span><span class="sxs-lookup"><span data-stu-id="b956a-726">IGMP Enable</span></span>

<span data-ttu-id="b956a-727">NetX でマルチキャスト アクティビティを実行する前に、アプリケーションで ***nx_igmp_enable*** サービスを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-727">Before any multicasting activity can take place in NetX, the application must call the ***nx_igmp_enable*** service.</span></span> <span data-ttu-id="b956a-728">このサービスによって、マルチキャスト要求に対する準備の基本的な IGMP 初期化が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-728">This service performs basic IGMP initialization in preparation for multicast requests.</span></span>

### <a name="multicast-ip-addressing"></a><span data-ttu-id="b956a-729">マルチキャスト IP アドレス指定</span><span class="sxs-lookup"><span data-stu-id="b956a-729">Multicast IP Addressing</span></span>

<span data-ttu-id="b956a-730">前述のように、マルチキャスト アドレスは、ページ 58 の図 4 に示すように、実際にはクラス D の IP アドレスです。</span><span class="sxs-lookup"><span data-stu-id="b956a-730">As mentioned previously, multicast addresses are actually Class D IP addresses as shown in Figure 4 on page 58.</span></span> <span data-ttu-id="b956a-731">クラス D アドレスの下位 28 ビットは、マルチキャスト グループ ID に対応しています。</span><span class="sxs-lookup"><span data-stu-id="b956a-731">The lower 28-bits of the Class D address correspond to the multicast group ID.</span></span> <span data-ttu-id="b956a-732">あらかじめ定義されているマルチキャスト アドレスがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-732">There are a series of pre-defined multicast addresses.</span></span> <span data-ttu-id="b956a-733">ただし、IGMP 処理には、"*すべてのホスト アドレス*" (244.0.0.1) が特に重要です。</span><span class="sxs-lookup"><span data-stu-id="b956a-733">However, the *all hosts address* (244.0.0.1) is particularly important to IGMP processing.</span></span> <span data-ttu-id="b956a-734">"*すべてのホスト アドレス*" は、ルーターが、すべてのマルチキャスト メンバーを照会して、所属するマルチキャスト グループを報告するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-734">The *all hosts address* is used by routers to query all multicast members to report on which multicast groups they belong to.</span></span>

### <a name="physical-address-mapping-in-ip"></a><span data-ttu-id="b956a-735">IP での物理アドレスのマッピング</span><span class="sxs-lookup"><span data-stu-id="b956a-735">Physical Address Mapping in IP</span></span>

<span data-ttu-id="b956a-736">クラス D マルチキャスト アドレスは、01.00.5e.00.00.00 から 01.00.5e.7f.ff.ff の範囲内の物理イーサネット アドレスに直接マップされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-736">Class D multicast addresses map directly to physical Ethernet addresses ranging from 01.00.5e.00.00.00 through 01.00.5e.7f.ff.ff.</span></span> <span data-ttu-id="b956a-737">IP マルチキャスト アドレスの下位 23 ビットは、イーサネット アドレスの下位 23 ビットに直接マップされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-737">The lower 23 bits of the IP multicast address map directly to the lower 23 bits of the Ethernet address.</span></span>

### <a name="multicast-group-join"></a><span data-ttu-id="b956a-738">マルチキャスト グループへの参加</span><span class="sxs-lookup"><span data-stu-id="b956a-738">Multicast Group Join</span></span>

<span data-ttu-id="b956a-739">特定のマルチキャスト グループに参加する必要があるアプリケーションでは、***nx_igmp_multicast_join*** サービスを呼び出して参加することができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-739">Applications that need to join a particular multicast group may do so by calling the ***nx_igmp_multicast_join*** service.</span></span> <span data-ttu-id="b956a-740">このサービスは、このマルチキャスト グループに参加する要求の数を追跡します。</span><span class="sxs-lookup"><span data-stu-id="b956a-740">This service keeps track of the number of requests to join this multicast group.</span></span> <span data-ttu-id="b956a-741">これがマルチキャスト グループに参加するアプリケーションの最初の要求である場合は、このホストがグループに参加することを示す IGMP レポートがプライマリ ネットワークに送信されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-741">If this is the first application request to join the multicast group, an IGMP report is sent out on the primary network indicating this host's intention to join the group.</span></span> <span data-ttu-id="b956a-742">次に、ネットワーク ドライバーを呼び出して、このマルチキャスト グループのイーサネット アドレスを持つパケットをリッスンするように設定します。</span><span class="sxs-lookup"><span data-stu-id="b956a-742">Next, the network driver is called to set up for listening for packets with the Ethernet address for this multicast group.</span></span>

<span data-ttu-id="b956a-743">マルチホーム システムでは、特定のインターフェイスを介してマルチキャスト グループにアクセスできる場合、アプリケーションは ***nx_igmp_multicast_join*** ではなく、サービス ***nx_igmp_multicast_interface_join*** を使用します。これは、プライマリ ネットワーク上のマルチキャスト グループに限定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-743">In a multihome system, if the multicast group is accessible via a specific interface, application shall use the service ***nx_igmp_multicast_interface_join*** instead of \***nx_igmp_multicast_join**,\* which is limited to multicast groups on the primary network.</span></span>

### <a name="multicast-group-leave"></a><span data-ttu-id="b956a-744">マルチキャスト グループからの離脱</span><span class="sxs-lookup"><span data-stu-id="b956a-744">Multicast Group Leave</span></span>

<span data-ttu-id="b956a-745">以前に参加したマルチキャスト グループを離脱する必要があるアプリケーションでは、***nx_igmp_multicast_leave*** サービスを呼び出すことによってこれを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-745">Applications that need to leave a previously joined multicast group may do so by calling the ***nx_igmp_multicast_leave*** service.</span></span> <span data-ttu-id="b956a-746">このサービスは、グループへの参加回数に関連付けられた内部カウントを減らします。</span><span class="sxs-lookup"><span data-stu-id="b956a-746">This service reduces the internal count associated with how many times the group was joined.</span></span> <span data-ttu-id="b956a-747">グループに対する未処理の参加要求がない場合、このマルチキャスト グループのイーサネット アドレスを持つパケットのリッスンを無効にするために、ネットワーク ドライバーが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-747">If there are no outstanding join requests for a group, the network driver is called to disable listening for packets with this multicast group's Ethernet address</span></span>

### <a name="multicast-loopback"></a><span data-ttu-id="b956a-748">マルチキャスト ループバック</span><span class="sxs-lookup"><span data-stu-id="b956a-748">Multicast Loopback</span></span>

<span data-ttu-id="b956a-749">アプリケーションでは、同じノードのいずれかのソースから送信されたマルチキャスト トラフィックを受信したい場合があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-749">An application may wish to receive multicast traffic originated from one of the sources on the same node.</span></span> <span data-ttu-id="b956a-750">これには、サービス ***nx_igmp_loopback_enable*** を使用して、IP マルチキャスト コンポーネントでループバックが有効になっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-750">This requires the IP multicast component to have loopback enabled by using the service ***nx_igmp_loopback_enable***.</span></span>

### <a name="igmp-report-message"></a><span data-ttu-id="b956a-751">IGMP レポート メッセージ</span><span class="sxs-lookup"><span data-stu-id="b956a-751">IGMP Report Message</span></span>

<span data-ttu-id="b956a-752">アプリケーションがマルチキャスト グループに参加すると、IGMP レポート メッセージがネットワーク経由で送信され、ホストが特定のマルチキャスト グループに参加することが示されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-752">When the application joins a multicast group, an IGMP report message is sent via the network to indicate the host's intention to join a particular multicast group.</span></span> <span data-ttu-id="b956a-753">IGMP レポート メッセージの形式を図 8 に示します。</span><span class="sxs-lookup"><span data-stu-id="b956a-753">The format of the IGMP report message is shown in Figure 8.</span></span> <span data-ttu-id="b956a-754">マルチキャスト グループ アドレスは、IGMP レポート メッセージのグループ メッセージと宛先 IP アドレスの両方に使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-754">The multicast group address is used for both the group message in the IGMP report message and the destination IP address.</span></span>

![IGMP レポート メッセージ](./media/user-guide/igmp-report-message.png)

<span data-ttu-id="b956a-756">**図 8. IGMP レポート メッセージ**</span><span class="sxs-lookup"><span data-stu-id="b956a-756">**FIGURE 8. IGMP Report Message**</span></span>

<span data-ttu-id="b956a-757">上の図 (図 8) では、IGMP ヘッダーには、バージョン/タイプ フィールド、最大応答時間、チェックサム フィールド、およびマルチキャスト グループ アドレス フィールドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-757">In the figure above (Figure 8), the IGMP header contains a version/type field, maximum response time, a checksum field, and a multicast group address field.</span></span> <span data-ttu-id="b956a-758">IGMPv1 メッセージの場合、最大応答時間フィールドは、IGMPv1 プロトコルの一部ではないため、常に 0 に設定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-758">For IGMPv1 messages, the Maximum Response Time field is always set to zero, as this is not part of the IGMPv1 protocol.</span></span> <span data-ttu-id="b956a-759">最大応答時間フィールドは、IGMPv2 プロトコルで定義されているように、ホストがクエリ タイプとして IGMP メッセージを受信したときに設定され、ホストが別のホストのレポート タイプのメッセージを受信したときにクリアされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-759">The Maximum Response Time field is set when the host receives a Query type IGMP message and cleared when a host receives another host's Report type message as defined by the IGMPv2 protocol.</span></span>

<span data-ttu-id="b956a-760">次に、IGMP ヘッダー形式について説明します。</span><span class="sxs-lookup"><span data-stu-id="b956a-760">The following describes the IGMP header format:</span></span>

| <span data-ttu-id="b956a-761">**ヘッダー フィールド**</span><span class="sxs-lookup"><span data-stu-id="b956a-761">**Header Field**</span></span>          | <span data-ttu-id="b956a-762">**目的**</span><span class="sxs-lookup"><span data-stu-id="b956a-762">**Purpose**</span></span> |
|-----------------------|--------------------------------------------------------------------|
| <span data-ttu-id="b956a-763">Version</span><span class="sxs-lookup"><span data-stu-id="b956a-763">Version</span></span>               | <span data-ttu-id="b956a-764">このフィールドでは、IGMP バージョンを指定します (ビット 31-28)。</span><span class="sxs-lookup"><span data-stu-id="b956a-764">This field specifies the IGMP version (bits 31- 28).</span></span>                                                                               |
| <span data-ttu-id="b956a-765">Type</span><span class="sxs-lookup"><span data-stu-id="b956a-765">Type</span></span>                  | <span data-ttu-id="b956a-766">このフィールドでは、IGMP メッセージのタイプを指定します (ビット 27-24)。</span><span class="sxs-lookup"><span data-stu-id="b956a-766">This field specifies the type of IGMP message (bits 27 -24).</span></span>                                                                       |
| <span data-ttu-id="b956a-767">最大応答時間</span><span class="sxs-lookup"><span data-stu-id="b956a-767">Maximum Response Time</span></span> | <span data-ttu-id="b956a-768">IGMPv1 では使用されません。</span><span class="sxs-lookup"><span data-stu-id="b956a-768">Not used in IGMPv1.</span></span> <span data-ttu-id="b956a-769">IGMPv2 では、このフィールドは最大応答時間として機能します。</span><span class="sxs-lookup"><span data-stu-id="b956a-769">In IGMPv2 this field serves as the maximum response time.</span></span>                                                      |
| <span data-ttu-id="b956a-770">Checksum</span><span class="sxs-lookup"><span data-stu-id="b956a-770">Checksum</span></span>              | <span data-ttu-id="b956a-771">このフィールドには、IGMP バージョンで始まる IGMP メッセージの 1 の補数和の 16 ビット チェックサムが格納されます (ビット 0-15)。</span><span class="sxs-lookup"><span data-stu-id="b956a-771">This field contains the 16-bit checksum of the one's complement sum of the IGMP message starting with the IGMP version (bits 0-15)</span></span> |
| <span data-ttu-id="b956a-772">グループ アドレス</span><span class="sxs-lookup"><span data-stu-id="b956a-772">Group Address</span></span>         | <span data-ttu-id="b956a-773">32 ビット クラス D グループ IP アドレス</span><span class="sxs-lookup"><span data-stu-id="b956a-773">32-bit class D group IP address</span></span> |


<span data-ttu-id="b956a-774">IGMP レポート メッセージは、マルチキャスト ルーターによって送信される IGMP クエリ メッセージに応答して送信されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-774">IGMP report messages are also sent in response to IGMP query messages sent by a multicast router.</span></span> <span data-ttu-id="b956a-775">マルチキャスト ルーターは、クエリ メッセージを定期的に送信して、まだグループ メンバーシップが必要なホストを確認します。</span><span class="sxs-lookup"><span data-stu-id="b956a-775">Multicast routers periodically send query messages out to see which hosts still require group membership.</span></span> <span data-ttu-id="b956a-776">クエリ メッセージの形式は、図 8 に示す IGMP レポート メッセージと同じです。</span><span class="sxs-lookup"><span data-stu-id="b956a-776">Query messages have the same format as the IGMP Report message shown in Figure 8.</span></span> <span data-ttu-id="b956a-777">唯一の違いは、IGMP タイプが 1 で、グループ アドレス フィールドが 0 に設定されていることです。</span><span class="sxs-lookup"><span data-stu-id="b956a-777">The only differences are the IGMP type is equal to 1 and the group address field is set to 0.</span></span> <span data-ttu-id="b956a-778">IGMP クエリ メッセージは、マルチキャスト ルーターによって "*すべてのホスト*" の IP アドレスに送信されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-778">IGMP Query messages are sent to the *all hosts* IP address by the multicast router.</span></span> <span data-ttu-id="b956a-779">グループ メンバーシップを引き続き維持するホストは、別の IGMP レポート メッセージを送信することによって応答します。</span><span class="sxs-lookup"><span data-stu-id="b956a-779">A host that still wishes to maintain group membership responds by sending another IGMP Report message.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-780">*TCP/IP 実装のすべてのメッセージは、\*\*ビッグ エンディアン*\* 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。\*</span><span class="sxs-lookup"><span data-stu-id="b956a-780">*All messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="igmp-statistics-and-errors"></a><span data-ttu-id="b956a-781">IGMP の統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b956a-781">IGMP Statistics and Errors</span></span>

<span data-ttu-id="b956a-782">有効にすると、NetX IGMP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-782">If enabled, the NetX IGMP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b956a-783">次の統計およびエラー レポートは、IP の IGMP 処理ごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-783">The following statistics and error reports are maintained for each IP's IGMP processing:</span></span>

- <span data-ttu-id="b956a-784">送信された IGMP レポートの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-784">Total IGMP Reports Sent</span></span>
- <span data-ttu-id="b956a-785">受信した IGMP クエリの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-785">Total IGMP Queries Received</span></span>
- <span data-ttu-id="b956a-786">IGMP チェックサム エラーの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-786">Total IGMP Checksum Errors</span></span>
- <span data-ttu-id="b956a-787">現在参加している IGMP グループの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-787">Total IGMP Current Groups Joined</span></span>

<span data-ttu-id="b956a-788">これらの統計およびエラー レポートはすべて、***nx_igmp_info_get*** サービスを使用してアプリケーションで利用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-788">All these statistics and error reports are available to the application with the ***nx_igmp_info_get*** service.</span></span>

## <a name="user-datagram-protocol-udp"></a><span data-ttu-id="b956a-789">ユーザー データグラム プロトコル (UDP)</span><span class="sxs-lookup"><span data-stu-id="b956a-789">User Datagram Protocol (UDP)</span></span>

<span data-ttu-id="b956a-790">ユーザー データグラム プロトコル (UDP) は、ネットワーク メンバー間で最も単純な形式のデータ転送を提供します (RFC 768)。</span><span class="sxs-lookup"><span data-stu-id="b956a-790">The User Datagram Protocol (UDP) provides the simplest form of data transfer between network members (RFC 768).</span></span> <span data-ttu-id="b956a-791">UDP データ パケットは、ベスト エフォート方式でネットワーク メンバー間で送信されます。つまり、パケット受信者による確認応答用メカニズムは組み込まれていません。</span><span class="sxs-lookup"><span data-stu-id="b956a-791">UDP data packets are sent from one network member to another in a best effort fashion; i.e., there is no built-in mechanism for acknowledgement by the packet recipient.</span></span> <span data-ttu-id="b956a-792">さらに、UDP パケットを送信する場合、事前に接続を確立する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b956a-792">In addition, sending a UDP packet does not require any connection to be established in advance.</span></span> <span data-ttu-id="b956a-793">このため、UDP パケット転送は非常に効率的です。</span><span class="sxs-lookup"><span data-stu-id="b956a-793">Because of this, UDP packet transmission is very efficient.</span></span>

### <a name="udp-header"></a><span data-ttu-id="b956a-794">UDP ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b956a-794">UDP Header</span></span>
<span data-ttu-id="b956a-795">UDP は、送信時にアプリケーションのデータの前に単純なパケット ヘッダーを配置し、受信時にパケットから同様の UDP ヘッダーを削除してから、受信した UDP パケットをアプリケーションに配信します。</span><span class="sxs-lookup"><span data-stu-id="b956a-795">UDP places a simple packet header in front of the application's data on transmission, and removes a similar UDP header from the packet on reception before delivering a received UDP packet to the application.</span></span> <span data-ttu-id="b956a-796">UDP はパケットを送受信するために IP プロトコルを使用します。つまり、パケットがネットワーク上にあるときに UDP ヘッダーの前に IP ヘッダーが存在することを意味します。</span><span class="sxs-lookup"><span data-stu-id="b956a-796">UDP utilizes the IP protocol for sending and receiving packets, which means there is an IP header in front of the UDP header when the packet is on the network.</span></span> <span data-ttu-id="b956a-797">図 9 は、UDP ヘッダーの形式を示しています。</span><span class="sxs-lookup"><span data-stu-id="b956a-797">Figure 9 shows the format of the UDP header.</span></span>

![UDP ヘッダー](./media/user-guide/udp-header.png)

<span data-ttu-id="b956a-799">**図 9. UDP ヘッダー**</span><span class="sxs-lookup"><span data-stu-id="b956a-799">**FIGURE 9. UDP Header**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-800">*UDP/IP 実装のすべてのヘッダーは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-800">*All headers in the UDP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="b956a-801">次に、UDP ヘッダー形式について説明します。</span><span class="sxs-lookup"><span data-stu-id="b956a-801">The following describes the UDP header format:</span></span>

| <span data-ttu-id="b956a-802">ヘッダー フィールド</span><span class="sxs-lookup"><span data-stu-id="b956a-802">Header Field</span></span>                   | <span data-ttu-id="b956a-803">目的</span><span class="sxs-lookup"><span data-stu-id="b956a-803">Purpose</span></span> |
|--------------------------------|---------------------------------------------|
| <span data-ttu-id="b956a-804">16 ビットの送信元ポート番号</span><span class="sxs-lookup"><span data-stu-id="b956a-804">16-bit source port number</span></span>      | <span data-ttu-id="b956a-805">このフィールドには、UDP パケットの送信元のポートが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-805">This field contains the port on which the UDP packet is being sent from.</span></span> <span data-ttu-id="b956a-806">有効な UDP ポートの範囲は 1 ～ 0xFFFF です。</span><span class="sxs-lookup"><span data-stu-id="b956a-806">Valid UDP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="b956a-807">16 ビットの宛先ポート番号</span><span class="sxs-lookup"><span data-stu-id="b956a-807">16-bit destination port number</span></span> | <span data-ttu-id="b956a-808">このフィールドには、パケットの送信先の UDP ポートが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-808">This field contains the UDP port to which the packet is being sent to.</span></span> <span data-ttu-id="b956a-809">有効な UDP ポートの範囲は 1 ～ 0xFFFF です。</span><span class="sxs-lookup"><span data-stu-id="b956a-809">Valid UDP ports range from 1 through 0xFFFF.</span></span>   |
| <span data-ttu-id="b956a-810">16 ビットの UDP の長さ</span><span class="sxs-lookup"><span data-stu-id="b956a-810">16-bit UDP length</span></span>   | <span data-ttu-id="b956a-811">このフィールドには、UDP ヘッダーのサイズを含む、UDP パケットのバイト数が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-811">This field contains the number of bytes in the UDP packet, including the size of the UDP header.</span></span>                                  |
| <span data-ttu-id="b956a-812">16 ビットの UDP チェックサム</span><span class="sxs-lookup"><span data-stu-id="b956a-812">16-bit UDP checksum</span></span> | <span data-ttu-id="b956a-813">このフィールドには、UDP ヘッダー、パケット データ領域、擬似 IP ヘッダーなど、パケットの 16 ビットのチェックサムが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-813">This field contains the 16-bit checksum for the packet, including the UDP header, the packet data area, and the pseudo IP header.</span></span> |

### <a name="udp-enable"></a><span data-ttu-id="b956a-814">UDP 有効化</span><span class="sxs-lookup"><span data-stu-id="b956a-814">UDP Enable</span></span>

<span data-ttu-id="b956a-815">UDP パケット転送が可能になる前に、アプリケーションはまず、***nx_udp_enable*** サービスを呼び出して UDP を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-815">Before UDP packet transmission is possible, the application must first enable UDP by calling the ***nx_udp_enable*** service.</span></span> <span data-ttu-id="b956a-816">有効にすると、アプリケーションは UDP パケットを送信および受信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="b956a-816">After enabled, the application is free to send and receive UDP packets.</span></span>

### <a name="udp-socket-create"></a><span data-ttu-id="b956a-817">UDP ソケットの作成</span><span class="sxs-lookup"><span data-stu-id="b956a-817">UDP Socket Create</span></span>

<span data-ttu-id="b956a-818">UDP ソケットは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-818">UDP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="b956a-819">サービスの初期のタイプ、有効期限、および受信キューの深さは、***nx_udp_socket_create*** サービスによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-819">The initial type of service, time to live, and receive queue depth are defined by the ***nx_udp_socket_create*** service.</span></span> <span data-ttu-id="b956a-820">アプリケーションの UDP ソケットの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="b956a-820">There are no limits on the number of UDP sockets in an application.</span></span>

### <a name="udp-checksum"></a><span data-ttu-id="b956a-821">UDP チェックサム</span><span class="sxs-lookup"><span data-stu-id="b956a-821">UDP Checksum</span></span>

<span data-ttu-id="b956a-822">UDP は、IP 擬似ヘッダー (送信元 IP アドレス、宛先 IP アドレス、プロトコル/長さ IP ワードで構成される)、UDP ヘッダー、および UDP パケット データを対象とする、1 の補数の 16 ビット チェックサムを指定します。</span><span class="sxs-lookup"><span data-stu-id="b956a-822">UDP specifies a one's complement 16-bit checksum that covers the IP pseudo header (consisting of the source IP address, destination IP address, and the protocol/length IP word), the UDP header, and the UDP packet data.</span></span> <span data-ttu-id="b956a-823">計算された UDP チェックサムが 0 の場合は、すべて 1 として格納されます (0xFFFF)。</span><span class="sxs-lookup"><span data-stu-id="b956a-823">If the calculated UDP checksum is 0, it is stored as all ones (0xFFFF).</span></span> <span data-ttu-id="b956a-824">送信ソケットの UDP チェックサム ロジックが無効になっている場合、チェックサムが計算されなかったことを示すために、UDP チェックサム フィールドに 0 が配置されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-824">If the sending socket has the UDP checksum logic disabled, a zero is placed in the UDP checksum field to indicate the checksum was not calculated.</span></span> <span data-ttu-id="b956a-825">UDP チェックサムが受信側によって計算されたチェックサムと一致しない場合、UDP パケットは単純に破棄されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-825">If the UDP checksum does not match the computed checksum by the receiver, the UDP packet is simply discarded.</span></span>

<span data-ttu-id="b956a-826">IP ネットワークでは、UDP チェックサムは省略可能です。</span><span class="sxs-lookup"><span data-stu-id="b956a-826">On the IP network, UDP checksum is optional.</span></span> <span data-ttu-id="b956a-827">NetX を使用すると、アプリケーションは、ソケットごとに UDP チェックサムの計算を有効または無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-827">NetX allows an application to enable or disable UDP checksum calculation on a per-socket basis.</span></span> <span data-ttu-id="b956a-828">既定では、UDP ソケット チェックサム ロジックが有効になっています。</span><span class="sxs-lookup"><span data-stu-id="b956a-828">By default, the UDP socket checksum logic is enabled.</span></span> <span data-ttu-id="b956a-829">アプリケーションは、***nx_udp_socket_checksum_disable*** サービスを呼び出すことによって、特定の UDP ソケットのチェックサム ロジックを無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-829">The application can disable checksum logic for a particular UDP socket by calling the ***nx_udp_socket_checksum_disable*** service.</span></span>

<span data-ttu-id="b956a-830">特定のイーサネット コントローラーは、その場で UDP チェックサムを生成することができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-830">Certain Ethernet controllers are able to generate the UDP checksum on the fly.</span></span> <span data-ttu-id="b956a-831">システムがハードウェア チェックサム計算機能を使用できる場合、チェックサム ロジックを使用せずに NetX ライブラリを構築できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-831">If the system is able to use hardware checksum computation feature, the NetX library can be built without the checksum logic.</span></span> <span data-ttu-id="b956a-832">UDP ソフトウェア チェックサムを無効にするには、***NX_DISABLE_UDP_TX_CHECKSUM*** と ***NX_DISABLE_UDP_RX_CHECKSUM* *_ のシンボルを定義して NetX ライブラリを構築する必要があります ([第 2 章](chapter2.md)で説明)。構成オプションを使用すると、NetX から UDP チェックサム ロジックが完全に削除されますが、_* nx_udp_socket_checksum_disable**\* サービスを呼び出すと、アプリケーションはソケットごとに IP UDP チェックサム処理を無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-832">To disable UDP software checksum, the NetX library must be built with the following symbols defined: ***NX_DISABLE_UDP_TX_CHECKSUM*** and ***NX_DISABLE_UDP_RX_CHECKSUM\*\*_ (described in [Chapter 2](chapter2.md)). The configuration options remove UDP checksum logic from NetX entirely, while calling the _* nx_udp_socket_checksum_disable**\* service allows the application to disable IP UDP checksum processing on a per socket basis.</span></span>

### <a name="udp-ports-and-binding"></a><span data-ttu-id="b956a-833">UDP ポートとバインド</span><span class="sxs-lookup"><span data-stu-id="b956a-833">UDP Ports and Binding</span></span>

<span data-ttu-id="b956a-834">UDP ポートは、UDP プロトコルの論理エンド ポイントです。</span><span class="sxs-lookup"><span data-stu-id="b956a-834">A UDP port is a logical end point in the UDP protocol.</span></span> <span data-ttu-id="b956a-835">NetX の UDP コンポーネントには、1 ～ 0xFFFF の範囲で、65,535 の有効なポートがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-835">There are 65,535 valid ports in the UDP component of NetX, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="b956a-836">UDP データを送受信するには、まず、アプリケーションで UDP ソケットを作成してから、目的のポートにバインドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-836">To send or receive UDP data, the application must first create a UDP socket, then bind it to a desired port.</span></span> <span data-ttu-id="b956a-837">UDP ソケットをポートにバインドした後、アプリケーションはそのソケットでデータを送受信できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-837">After binding a UDP socket to a port, the application may send and receive data on that socket.</span></span>

### <a name="udp-fast-pathtrade"></a><span data-ttu-id="b956a-838">UDP Fast Path&trade;</span><span class="sxs-lookup"><span data-stu-id="b956a-838">UDP Fast Path&trade;</span></span>

<span data-ttu-id="b956a-839">UDP Fast Path&trade; は、NetX UDP 実装を介した低パケット オーバーヘッド パスの名前です。</span><span class="sxs-lookup"><span data-stu-id="b956a-839">The UDP Fast Path&trade; is the name for a low packet overhead path through the NetX UDP implementation.</span></span> <span data-ttu-id="b956a-840">UDP パケットを送信するには、***nx_udp_socket_send** _ と _*_nx_ip_packet_send_\*_ の関数を呼び出して、最終的にネットワーク ドライバーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b956a-840">Sending a UDP packet requires just a few function calls: ***nx_udp_socket_send** _, _*_nx_ip_packet_send_\*_, and the eventual call to the network driver.</span></span> <span data-ttu-id="b956a-841">_*_nx_udp_socket_send_*_ は、既存の NetX アプリケーション向けに NetX で使用でき、IP パケットにのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-841">_*_nx_udp_socket_send_*_ is available in NetX for existing NetX applications and is only applicable for IP packets.</span></span> <span data-ttu-id="b956a-842">ただし、推奨される方法は、以下で説明する _ *_nx_udp_socket_send_*\* サービスを使用することです。</span><span class="sxs-lookup"><span data-stu-id="b956a-842">The preferred method, however, is to use _ *_nx_udp_socket_send_*\* service discussed below.</span></span> <span data-ttu-id="b956a-843">UDP パケット受信では、UDP パケットは適切な UDP ソケット受信キューに配置されるか、ネットワーク ドライバーの受信割り込み処理からの単一の関数呼び出しで、中断されたアプリケーション スレッドに配信されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-843">On UDP packet reception, the UDP packet is either placed on the appropriate UDP socket receive queue or delivered to a suspended application thread in a single function call from the network driver's receive interrupt processing.</span></span> <span data-ttu-id="b956a-844">UDP パケットを送受信するための高度に最適化されたロジックは、UDP Fast Path テクノロジの本質です。</span><span class="sxs-lookup"><span data-stu-id="b956a-844">This highly optimized logic for sending and receiving UDP packets is the essence of UDP Fast Path technology.</span></span>

### <a name="udp-packet-send"></a><span data-ttu-id="b956a-845">UDP パケット送信</span><span class="sxs-lookup"><span data-stu-id="b956a-845">UDP Packet Send</span></span>

<span data-ttu-id="b956a-846">IP ネットワーク経由での UDP データの送信は、\***nx_udp_socket_send** _ 関数を呼び出すことによって簡単に実現できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-846">Sending UDP data over IP networks is easily accomplished by calling the \***nx_udp_socket_send** _ function.</span></span> <span data-ttu-id="b956a-847">呼び出し元は、_"IP アドレス"\* フィールドに IP バージョンを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-847">The caller must set the IP version in the _IP address\* field.</span></span> <span data-ttu-id="b956a-848">NetX では、送信先 IP アドレスに基づいて、送信される UDP パケットの最適な送信元アドレスが決定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-848">NetX will determine the best source address for transmitted UDP packets based on the destination IP address.</span></span> <span data-ttu-id="b956a-849">このサービスは、パケット データの前に UDP ヘッダーを配置し、内部 IP 送信ルーチンを使用してネットワークに送信します。</span><span class="sxs-lookup"><span data-stu-id="b956a-849">This service places a UDP header in front of the packet data and sends it out onto the network using an internal IP send routine.</span></span> <span data-ttu-id="b956a-850">UDP パケットの送信では、すべての UDP パケット転送が直ちに処理されるため、スレッドが中断されることはありません。</span><span class="sxs-lookup"><span data-stu-id="b956a-850">There is no thread suspension on sending UDP packets because all UDP packet transmissions are processed immediately.</span></span>

<span data-ttu-id="b956a-851">マルチキャストまたはブロードキャストの宛先で、NetX デバイスに選択できる IP アドレスが複数ある場合に、アプリケーションで使用する送信元 IP アドレスを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-851">For multicast or broadcast destinations, the application should specify the source IP address to use if the NetX device has multiple IP addresses to choose from.</span></span> <span data-ttu-id="b956a-852">これは、サービス ***nx_udp_socket_interface_send*** を使用して行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-852">This can be done with the services ***nx_udp_socket_interface_send.***</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-853">*マルチキャストまたはブロードキャスト パケットの送信に **nx_udp_socket_send** が使用されている場合、最初のインターフェイスの IP アドレスが送信元アドレスとして使用されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-853">*If **nx_udp_socket_send** is used for transmitting multicast or broadcast packets, the IP address of the first interface is used as source address.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-854">*このソケットに対して UDP チェックサム ロジックが有効になっている場合、チェックサム操作は、UDP または IP のデータ構造へのアクセスをブロックすることなく、呼び出し元のスレッドのコンテキストで実行されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-854">*If UDP checksum logic is enabled for this socket, the checksum operation is performed in the context of the calling thread, without blocking access to the UDP or IP data structures.*</span></span>

> [!NOTE]
> <span data-ttu-id="b956a-855">***NX_PACKET** 構造に存在する UDP ペイロード データは、長いワード境界に配置する必要があります。アプリケーションでは、先頭のポインターと NetX のデータ開始ポインターの間に十分な領域を残して、UDP、IP、および物理メディアのヘッダーを配置する必要があります。*</span><span class="sxs-lookup"><span data-stu-id="b956a-855">*The UDP payload data residing in the **NX_PACKET** structure should reside on a long-word boundary. The application needs to leave sufficient space between the prepend pointer and the data start pointer for NetX to place the UDP, IP, and physical media headers.*</span></span>

### <a name="udp-packet-receive"></a><span data-ttu-id="b956a-856">UDP パケット受信</span><span class="sxs-lookup"><span data-stu-id="b956a-856">UDP Packet Receive</span></span>

<span data-ttu-id="b956a-857">アプリケーション スレッドは、***nx_udp_socket_receive*** を呼び出すことによって、特定のソケットから UDP パケットを受信する場合があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-857">Application threads may receive UDP packets from a particular socket by calling ***nx_udp_socket_receive***.</span></span> <span data-ttu-id="b956a-858">ソケット受信関数は、ソケットの受信キューで最も古いパケットを配信します。</span><span class="sxs-lookup"><span data-stu-id="b956a-858">The socket receive function delivers the oldest packet on the socket's receive queue.</span></span> <span data-ttu-id="b956a-859">受信キューにパケットがない場合、呼び出し元のスレッドは、パケットが到着するまで (オプションのタイムアウトで) 中断できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-859">If there are no packets on the receive queue, the calling thread can suspend (with an optional timeout) until a packet arrives.</span></span>

<span data-ttu-id="b956a-860">UDP 受信パケット処理 (通常はネットワーク ドライバーの受信割り込みハンドラーから呼び出されます) は、パケットを UDP ソケットの受信キューに配置するか、パケットを待機している最初に中断されたスレッドに配信する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="b956a-860">The UDP receive packet processing (usually called from the network driver's receive interrupt handler) is responsible for either placing the packet on the UDP socket's receive queue or delivering it to the first suspended thread waiting for a packet.</span></span> <span data-ttu-id="b956a-861">パケットがキューに置かれている場合は、受信処理によって、ソケットに関連付けられている最大受信キューの深さも確認されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-861">If the packet is queued, the receive processing also checks the maximum receive queue depth associated with the socket.</span></span> <span data-ttu-id="b956a-862">新しくキューに入れられたパケットがキューの深さを超えると、キュー内の最も古いパケットが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-862">If this newly queued packet exceeds the queue depth, the oldest packet in the queue is discarded.</span></span>

### <a name="udp-receive-notify"></a><span data-ttu-id="b956a-863">UDP 受信通知</span><span class="sxs-lookup"><span data-stu-id="b956a-863">UDP Receive Notify</span></span>

<span data-ttu-id="b956a-864">アプリケーション スレッドが複数のソケットから受信したデータを処理する必要がある場合は、***nx_udp_socket_receive_notify*** 関数を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-864">If the application thread needs to process received data from more than one socket, the ***nx_udp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="b956a-865">この関数は、ソケットの受信パケット コールバック関数を登録します。</span><span class="sxs-lookup"><span data-stu-id="b956a-865">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="b956a-866">ソケットでパケットが受信されるたびに、コールバック関数が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-866">Whenever a packet is received on the socket, the callback function is executed.</span></span>

<span data-ttu-id="b956a-867">コールバック関数の内容は、アプリケーション固有です。</span><span class="sxs-lookup"><span data-stu-id="b956a-867">The contents of the callback function is application-specific.</span></span> <span data-ttu-id="b956a-868">ただし、最も高い可能性として、パケットが対応するソケットで利用できるようになったことを処理スレッドに通知するロジックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-868">However, it would most likely contain logic to inform the processing thread that a packet is now available on the corresponding socket.</span></span>

### <a name="peer-address-and-port"></a><span data-ttu-id="b956a-869">ピア アドレスとポート</span><span class="sxs-lookup"><span data-stu-id="b956a-869">Peer Address and Port</span></span>

<span data-ttu-id="b956a-870">UDP パケットを受信すると、アプリケーションでは、サービス ***nx_udp_packet_info_extract*** を使用して、送信者の IP アドレスとポート番号を見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-870">On receiving a UDP packet, application may find the sender's IP address and port number by using the service ***nx_udp_packet_info_extract***.</span></span> <span data-ttu-id="b956a-871">正常に返された場合、このサービスは、送信者の IP アドレス、送信者のポート番号、およびパケットの受信に使用されたローカル インターフェイスに関する情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="b956a-871">On successful return, this service provides information on the sender's IP address, sender's port number, and the local interface through which the packet was received.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="b956a-872">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="b956a-872">Thread Suspension</span></span>

<span data-ttu-id="b956a-873">前述のように、特定の UDP ポートで UDP パケットを受信しようとしている間に、アプリケーション スレッドが中断されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-873">As mentioned previously, application threads can suspend while attempting to receive a UDP packet on a particular UDP port.</span></span> <span data-ttu-id="b956a-874">そのポートでパケットが受信されると、最初に中断されたスレッドに渡され、そのスレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-874">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="b956a-875">UDP 受信パケットで中断する場合は、オプションのタイムアウトを使用できます。これは、ほとんどの NetX サービスで利用可能な機能です。</span><span class="sxs-lookup"><span data-stu-id="b956a-875">An optional timeout is available when suspending on a UDP receive packet, a feature available for most NetX services.</span></span>

### <a name="udp-socket-statistics-and-errors"></a><span data-ttu-id="b956a-876">UDP ソケットの統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b956a-876">UDP Socket Statistics and Errors</span></span>

<span data-ttu-id="b956a-877">有効にすると、NetX UDP ソケット ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-877">If enabled, the NetX UDP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b956a-878">次の統計およびエラー レポートは、IP/UDP インスタンスごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-878">The following statistics and error reports are maintained for each IP/UDP instance:</span></span>

- <span data-ttu-id="b956a-879">送信された UDP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-879">Total UDP Packets Sent</span></span>
- <span data-ttu-id="b956a-880">送信された UDP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-880">Total UDP Bytes Sent</span></span>
- <span data-ttu-id="b956a-881">受信した UDP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-881">Total UDP Packets Received</span></span>
- <span data-ttu-id="b956a-882">受信した UDP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-882">Total UDP Bytes Received</span></span>
- <span data-ttu-id="b956a-883">無効な UDP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-883">Total UDP Invalid Packets</span></span>
- <span data-ttu-id="b956a-884">ドロップされた UDP 受信パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-884">Total UDP Receive Packets Dropped</span></span>
- <span data-ttu-id="b956a-885">UDP 受信チェックサム エラーの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-885">Total UDP Receive Checksum Errors</span></span>
- <span data-ttu-id="b956a-886">送信された UDP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b956a-886">UDP Socket Packets Sent</span></span>
- <span data-ttu-id="b956a-887">送信された UDP ソケット バイト数</span><span class="sxs-lookup"><span data-stu-id="b956a-887">UDP Socket Bytes Sent</span></span>
- <span data-ttu-id="b956a-888">受信した UDP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b956a-888">UDP Socket Packets Received</span></span>
- <span data-ttu-id="b956a-889">受信した UDP ソケット バイト数</span><span class="sxs-lookup"><span data-stu-id="b956a-889">UDP Socket Bytes Received</span></span>
- <span data-ttu-id="b956a-890">キューに登録された UDP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b956a-890">UDP Socket Packets Queued</span></span>
- <span data-ttu-id="b956a-891">ドロップされた UDP ソケット受信パケット数</span><span class="sxs-lookup"><span data-stu-id="b956a-891">UDP Socket Receive Packets Dropped</span></span>
- <span data-ttu-id="b956a-892">UDP ソケット チェックサム エラー</span><span class="sxs-lookup"><span data-stu-id="b956a-892">UDP Socket Checksum Errors</span></span>

<span data-ttu-id="b956a-893">これらのすべての統計およびエラー レポートをアプリケーションで使用するには、すべての UDP ソケットで集められた UDP 統計は ***nx_udp_info_get*** サービスを使用し、指定された UDP ソケットの UDP 統計情報は ***nx_udp_socket_info_get*** サービスを使用します。</span><span class="sxs-lookup"><span data-stu-id="b956a-893">All these statistics and error reports are available to the application with the ***nx_udp_info_get*** service for UDP statistics amassed over all UDP sockets, and the ***nx_udp_socket_info_get*** service for UDP statistics on the specified UDP socket.</span></span>

### <a name="udp-socket-control-block-nx_udp_socket"></a><span data-ttu-id="b956a-894">UDP ソケット制御ブロック NX_UDP_SOCKET</span><span class="sxs-lookup"><span data-stu-id="b956a-894">UDP Socket Control Block NX_UDP_SOCKET</span></span>

<span data-ttu-id="b956a-895">各 UDP ソケットの特性は、関連付けられている **NX_UDP_SOCKET** 制御ブロックにあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-895">The characteristics of each UDP socket are found in the associated **NX_UDP_SOCKET** control block.</span></span> <span data-ttu-id="b956a-896">これには、IP データ構造へのリンク、送信パスと受信パスのネットワーク インターフェイス、バインドされたポート、受信パケット キューなどの有用な情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-896">It contains useful information such as the link to the IP data structure, the network interface for the sending and receiving paths, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="b956a-897">この構造体は **_nx_api.h_** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-897">This structure is defined in the **_nx_api.h_** file.</span></span>

## <a name="transmission-control-protocol-tcp"></a><span data-ttu-id="b956a-898">伝送制御プロトコル (TCP)</span><span class="sxs-lookup"><span data-stu-id="b956a-898">Transmission Control Protocol (TCP)</span></span>

<span data-ttu-id="b956a-899">伝送制御プロトコル (TCP) は、2 つのネットワーク メンバー間で信頼性の高いストリーム データ転送を提供します (RFC 793)。</span><span class="sxs-lookup"><span data-stu-id="b956a-899">The Transmission Control Protocol (TCP) provides reliable stream data transfer between two network members (RFC 793).</span></span> <span data-ttu-id="b956a-900">1 つのネットワーク メンバーから送信されたすべてのデータは、受信側メンバーによって検証され、確認されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-900">All data sent from one network member are verified and acknowledged by the receiving member.</span></span> <span data-ttu-id="b956a-901">また、この 2 つのメンバーは、データ転送の前に接続を確立している必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-901">In addition, the two members must have established a connection prior to any data transfer.</span></span> <span data-ttu-id="b956a-902">これにより、信頼性の高いデータ転送が行われるようになります。ただし、前述の UDP データ転送よりもかなり多くのオーバーヘッドが必要になります。</span><span class="sxs-lookup"><span data-stu-id="b956a-902">All this results in reliable data transfer; however, it does require substantially more overhead than the previously described UDP data transfer.</span></span>

### <a name="tcp-header"></a><span data-ttu-id="b956a-903">TCP ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b956a-903">TCP Header</span></span>

<span data-ttu-id="b956a-904">送信時には、TCP ヘッダーがユーザーが提供するデータの前に配置されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-904">On transmission, TCP header is placed in front of the data from the user.</span></span> <span data-ttu-id="b956a-905">受信時には、TCP ヘッダーが受信パケットから削除され、アプリケーションで使用できるユーザー データだけが残ります。</span><span class="sxs-lookup"><span data-stu-id="b956a-905">On reception, TCP header is removed from the incoming packet, leaving only the user data available to the application.</span></span> <span data-ttu-id="b956a-906">TCP は IP プロトコルを使用してパケットを送受信します。これは、パケットがネットワーク上にあるときに、TCP ヘッダーの前に IP ヘッダーがあることを意味します。</span><span class="sxs-lookup"><span data-stu-id="b956a-906">TCP utilizes the IP protocol to send and receive packets, which means there is an IP header in front of the TCP header when the packet is on the network.</span></span> <span data-ttu-id="b956a-907">図 10 は、TCP ヘッダーの形式を示しています。</span><span class="sxs-lookup"><span data-stu-id="b956a-907">Figure 10 shows the format of the TCP header.</span></span>

![TCP ヘッダー](./media/user-guide/tcp-header.png)

<span data-ttu-id="b956a-909">**図 10. TCP ヘッダー**</span><span class="sxs-lookup"><span data-stu-id="b956a-909">**FIGURE 10. TCP Header**</span></span>

<span data-ttu-id="b956a-910">次に、TCP ヘッダー形式について説明します。</span><span class="sxs-lookup"><span data-stu-id="b956a-910">The following describes the TCP header format:</span></span>

| <span data-ttu-id="b956a-911">ヘッダー フィールド</span><span class="sxs-lookup"><span data-stu-id="b956a-911">Header Field</span></span> | <span data-ttu-id="b956a-912">目的</span><span class="sxs-lookup"><span data-stu-id="b956a-912">Purpose</span></span> |
|---|---|
| <span data-ttu-id="b956a-913">16 ビットの送信元ポート番号</span><span class="sxs-lookup"><span data-stu-id="b956a-913">16-bit source port number</span></span> | <span data-ttu-id="b956a-914">このフィールドには、TCP パケットが送信されるポートが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-914">This field contains the port the TCP packet is being sent out on.</span></span> <span data-ttu-id="b956a-915">有効な TCP ポートの範囲は 1 ～ 0xFFFF です。</span><span class="sxs-lookup"><span data-stu-id="b956a-915">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="b956a-916">16 ビットの宛先ポート番号</span><span class="sxs-lookup"><span data-stu-id="b956a-916">16-bit destination port number</span></span> | <span data-ttu-id="b956a-917">このフィールドには、パケット送信先の TCP ポートが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-917">This field contains the TCP port the packet is being sent to.</span></span> <span data-ttu-id="b956a-918">有効な TCP ポートの範囲は 1 ～ 0xFFFF です。</span><span class="sxs-lookup"><span data-stu-id="b956a-918">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="b956a-919">32 ビットのシーケンス番号</span><span class="sxs-lookup"><span data-stu-id="b956a-919">32-bit sequence number</span></span> | <span data-ttu-id="b956a-920">このフィールドには、接続のこちら側から送信されるデータのシーケンス番号が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-920">This field contains the sequence number for data sent from this end of the connection.</span></span> <span data-ttu-id="b956a-921">元のシーケンスは、2 つの TCP ノード間の最初の接続シーケンス中に確立されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-921">The original sequence is established during the initial connection sequence between two TCP nodes.</span></span> <span data-ttu-id="b956a-922">その時点以降のすべてのデータ転送で、送信されたバイト数ずつシーケンス番号がインクリメントされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-922">Every data transfer from that point results in an increment of the sequence number by the amount bytes sent.</span></span> |
| <span data-ttu-id="b956a-923">32 ビットの確認応答番号</span><span class="sxs-lookup"><span data-stu-id="b956a-923">32-bit acknowledgement number</span></span> | <span data-ttu-id="b956a-924">このフィールドには、接続のこちら側で受信した最後のバイトに対応するシーケンス番号が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-924">This field contains the sequence number corresponding to the last byte received by this side of the connection.</span></span> <span data-ttu-id="b956a-925">これは、以前に送信されたデータが、接続の反対側で正常に受信されたかどうかを判断するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-925">This is used to determine whether or not data previously sent has successfully been received by the other end of the connection.</span></span> |
| <span data-ttu-id="b956a-926">4 ビットのヘッダー長</span><span class="sxs-lookup"><span data-stu-id="b956a-926">4-bit header length</span></span>           | <span data-ttu-id="b956a-927">このフィールドには、TCP ヘッダー内の 32 ビット ワードの数が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-927">This field contains the number of 32-bit words in the TCP header.</span></span> <span data-ttu-id="b956a-928">TCP ヘッダーにオプションが存在しない場合、このフィールドは 5 です。</span><span class="sxs-lookup"><span data-stu-id="b956a-928">If no options are present in the TCP header, this field is 5.</span></span> |
| <span data-ttu-id="b956a-929">6 ビットのコード ビット</span><span class="sxs-lookup"><span data-stu-id="b956a-929">6-bit code bits</span></span>               | <span data-ttu-id="b956a-930">このフィールドには、接続に関連付けられたさまざまな制御情報を示すために使用される 6 つの異なるコード ビットが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-930">This field contains the six different code bits used to indicate various control information associated with the connection.</span></span> <span data-ttu-id="b956a-931">制御ビットは次のように定義されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-931">The control bits are defined as follows:</span></span> |



| <span data-ttu-id="b956a-932">名前</span><span class="sxs-lookup"><span data-stu-id="b956a-932">Name</span></span> | <span data-ttu-id="b956a-933">ビット</span><span class="sxs-lookup"><span data-stu-id="b956a-933">Bit</span></span> | <span data-ttu-id="b956a-934">意味</span><span class="sxs-lookup"><span data-stu-id="b956a-934">Meaning</span></span>                                                     |
|------|-----|-------------------------------------------------------------|
| <span data-ttu-id="b956a-935">URG</span><span class="sxs-lookup"><span data-stu-id="b956a-935">URG</span></span>  | <span data-ttu-id="b956a-936">21</span><span class="sxs-lookup"><span data-stu-id="b956a-936">21</span></span>  | <span data-ttu-id="b956a-937">緊急データあり</span><span class="sxs-lookup"><span data-stu-id="b956a-937">Urgent data present</span></span>                                         |
| <span data-ttu-id="b956a-938">ACK</span><span class="sxs-lookup"><span data-stu-id="b956a-938">ACK</span></span>  | <span data-ttu-id="b956a-939">20</span><span class="sxs-lookup"><span data-stu-id="b956a-939">20</span></span>  | <span data-ttu-id="b956a-940">確認応答番号は有効</span><span class="sxs-lookup"><span data-stu-id="b956a-940">Acknowledgement number is valid</span></span>                             |
| <span data-ttu-id="b956a-941">PSH</span><span class="sxs-lookup"><span data-stu-id="b956a-941">PSH</span></span>  | <span data-ttu-id="b956a-942">19</span><span class="sxs-lookup"><span data-stu-id="b956a-942">19</span></span>  | <span data-ttu-id="b956a-943">このデータをすぐに処理</span><span class="sxs-lookup"><span data-stu-id="b956a-943">Handle this data immediately</span></span>                                |
| <span data-ttu-id="b956a-944">RST</span><span class="sxs-lookup"><span data-stu-id="b956a-944">RST</span></span>  | <span data-ttu-id="b956a-945">18</span><span class="sxs-lookup"><span data-stu-id="b956a-945">18</span></span>  | <span data-ttu-id="b956a-946">接続をリセット</span><span class="sxs-lookup"><span data-stu-id="b956a-946">Reset the connection</span></span>                                        |
| <span data-ttu-id="b956a-947">SYN</span><span class="sxs-lookup"><span data-stu-id="b956a-947">SYN</span></span>  | <span data-ttu-id="b956a-948">17</span><span class="sxs-lookup"><span data-stu-id="b956a-948">17</span></span>  | <span data-ttu-id="b956a-949">シーケンス番号を同期 (接続の確立に使用)</span><span class="sxs-lookup"><span data-stu-id="b956a-949">Synchronize sequence numbers (used to establish connection)</span></span> |
| <span data-ttu-id="b956a-950">FIN</span><span class="sxs-lookup"><span data-stu-id="b956a-950">FIN</span></span>  | <span data-ttu-id="b956a-951">16</span><span class="sxs-lookup"><span data-stu-id="b956a-951">16</span></span>  | <span data-ttu-id="b956a-952">送信側が送信を完了 (接続終了に使用)</span><span class="sxs-lookup"><span data-stu-id="b956a-952">Sender is finished with transmit (used to close connection)</span></span> |

<span data-ttu-id="b956a-953">**16 ビットのウィンドウ**</span><span class="sxs-lookup"><span data-stu-id="b956a-953">**16-bit window**</span></span>

<span data-ttu-id="b956a-954">このフィールドはフロー制御に使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-954">This field is used for flow control.</span></span> <span data-ttu-id="b956a-955">これには、ソケットが現在受信できるバイト数が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-955">It contains the amount of bytes the socket can currently receive.</span></span> <span data-ttu-id="b956a-956">これは基本的にフロー制御に使用されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-956">This basically is used for flow control.</span></span> <span data-ttu-id="b956a-957">送信元は、送信するデータが受信側の公開されたウィンドウに適合することを確認する責任があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-957">The sender is responsible for making sure the data to send will fit into the receiver’s advertised window.</span></span>

| <span data-ttu-id="b956a-958">**ヘッダー フィールド**</span><span class="sxs-lookup"><span data-stu-id="b956a-958">**Header Field**</span></span>          | <span data-ttu-id="b956a-959">**目的**</span><span class="sxs-lookup"><span data-stu-id="b956a-959">**Purpose**</span></span> |
| ------------------------- | --- |
| <span data-ttu-id="b956a-960">**16 ビットの TCP チェックサム**</span><span class="sxs-lookup"><span data-stu-id="b956a-960">**16-bit TCP checksum**</span></span>   | <span data-ttu-id="b956a-961">このフィールドには、TCP ヘッダー、パケット データ領域、擬似 IP ヘッダーなど、パケットの 16 ビットのチェックサムが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-961">This field contains the 16-bit checksum for the packet including the TCP header, the packet data area, and the pseudo IP header.</span></span>                |
| <span data-ttu-id="b956a-962">**16 ビットの緊急ポインター**</span><span class="sxs-lookup"><span data-stu-id="b956a-962">**16-bit urgent pointer**</span></span> | <span data-ttu-id="b956a-963">このフィールドには、緊急データの最後のバイトの正のオフセットが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-963">This field contains the positive offset of the last byte of the urgent data.</span></span> <span data-ttu-id="b956a-964">このフィールドは、ヘッダーに URG コード ビットが設定されている場合にのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="b956a-964">This field is only valid if the URG code bit is set in the header.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="b956a-965">*TCP/IP 実装のすべてのヘッダーは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-965">*All headers in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="tcp-enable"></a><span data-ttu-id="b956a-966">TCP 有効化</span><span class="sxs-lookup"><span data-stu-id="b956a-966">TCP Enable</span></span>

<span data-ttu-id="b956a-967">TCP 接続とパケット転送を可能にするには、まず、アプリケーションで nx_tcp_enable サービスを呼び出して TCP を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-967">Before TCP connections and packet transmissions are possible, the application must first enable TCP by calling the nx_tcp_enable service.</span></span> <span data-ttu-id="b956a-968">有効にすると、アプリケーションはすべての TCP サービスに自由にアクセスできるようになります。</span><span class="sxs-lookup"><span data-stu-id="b956a-968">After enabled, the application is free to access all TCP services.</span></span>

### <a name="tcp-socket-create"></a><span data-ttu-id="b956a-969">TCP ソケットの作成</span><span class="sxs-lookup"><span data-stu-id="b956a-969">TCP Socket Create</span></span>

<span data-ttu-id="b956a-970">TCP ソケットは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-970">TCP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="b956a-971">サービスの初期のタイプ、有効期限、およびウィンドウ サイズは、***nx_tcp_socket_create*** サービスによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-971">The initial type of service, time to live, and window size are defined by the ***nx_tcp_socket_create*** service.</span></span> <span data-ttu-id="b956a-972">アプリケーションの TCP ソケットの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="b956a-972">There are no limits on the number of TCP sockets in an application.</span></span>

### <a name="tcp-checksum"></a><span data-ttu-id="b956a-973">TCP チェックサム</span><span class="sxs-lookup"><span data-stu-id="b956a-973">TCP Checksum</span></span>

<span data-ttu-id="b956a-974">TCP は、IP 擬似ヘッダー (送信元 IP アドレス、宛先 IP アドレス、プロトコル/長さ IP ワードで構成される)、TCP ヘッダー、および TCP パケット データを対象とする、1 の補数の 16 ビット チェックサムを指定します。</span><span class="sxs-lookup"><span data-stu-id="b956a-974">TCP specifies a one’s complement 16-bit checksum that covers the IP pseudo header, (consisting of the source IP address, destination IP address, and the protocol/length IP word), the TCP header, and the TCP packet data.</span></span>

<span data-ttu-id="b956a-975">特定のネットワーク コントローラーでは、ハードウェアで TCP チェックサムの計算と検証を実行できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-975">Certain network controllers are able to perform TCP checksum computation and validation in hardware.</span></span> <span data-ttu-id="b956a-976">このようなシステムでは、実行時のオーバーヘッドを減らすために、アプリケーションでは、可能な限りハードウェア チェックサム ロジックを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-976">For such systems, applications may want to use hardware checksum logic as much as possible to reduce runtime overhead.</span></span> <span data-ttu-id="b956a-977">アプリケーションでは、**NX_DISABLE_TCP_TX_CHECKSUM** と **NX_DISABLE_TCP_RX_CHECKSUM** を定義することによって、NetX ライブラリからの TCP チェックサム計算ロジックをビルド時に完全に無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-977">Applications may disable TCP checksum computation logic from the NetX library altogether at build time by defining **NX_DISABLE_TCP_TX_CHECKSUM** and **NX_DISABLE_TCP_RX_CHECKSUM**.</span></span> <span data-ttu-id="b956a-978">このようにして、TCP チェックサム コードはコンパイルされません。</span><span class="sxs-lookup"><span data-stu-id="b956a-978">This way, the TCP checksum code is not compiled in.</span></span>

### <a name="tcp-port"></a><span data-ttu-id="b956a-979">[TCP ポート]</span><span class="sxs-lookup"><span data-stu-id="b956a-979">TCP Port</span></span>

<span data-ttu-id="b956a-980">TCP ポートは、TCP プロトコルの論理接続ポイントです。</span><span class="sxs-lookup"><span data-stu-id="b956a-980">A TCP port is a logical connection point in the TCP protocol.</span></span> <span data-ttu-id="b956a-981">NetX の TCP コンポーネントには、1 ～ 0xFFFF の範囲で、65,535 の有効なポートがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-981">There are 65,535 valid ports in the TCP component of NetX, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="b956a-982">1 つのポートのデータを任意の他の宛先ポートに送信できる UDP とは異なり、TCP ポートは特定のもう 1 つの TCP ポートに接続されており、この接続が確立されたときにのみ、接続を構成する 2 つのポート間でのみデータ転送が行われます。</span><span class="sxs-lookup"><span data-stu-id="b956a-982">Unlike UDP in which data from one port can be sent to any other destination port, a TCP port is connected to another specific TCP port, and only when this connection is established can any data transfer take place—and only between the two ports making up the connection.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-983">*TCP ポートは、UDP ポートと完全に分離されています。たとえば、UDP ポート番号 1 は TCP ポート番号 1 とは関係ありません。*</span><span class="sxs-lookup"><span data-stu-id="b956a-983">*TCP ports are completely separate from UDP ports; e.g., UDP port number 1 has no relation to TCP port number 1.*</span></span>

## <a name="client-server-model"></a><span data-ttu-id="b956a-984">クライアントサーバー モデル</span><span class="sxs-lookup"><span data-stu-id="b956a-984">Client-Server Model</span></span>

<span data-ttu-id="b956a-985">データ転送に TCP を使用するには、最初に 2 つの TCP ソケット間に接続を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-985">To use TCP for data transfer, a connection must first be established between the two TCP sockets.</span></span> <span data-ttu-id="b956a-986">接続の確立は、クライアントサーバー形式で行われます。</span><span class="sxs-lookup"><span data-stu-id="b956a-986">The establishment of the connection is done in a client-server fashion.</span></span> <span data-ttu-id="b956a-987">接続のクライアント側は接続を開始する側であり、サーバー側は、クライアント接続要求を待機してからすべての処理を実行します。</span><span class="sxs-lookup"><span data-stu-id="b956a-987">The client side of the connection is the side that initiates the connection, while the server side simply waits for client connection requests before any processing is done.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-988">*マルチホーム デバイスの場合、NetX は接続に使用する送信元アドレスと、接続の宛先 IP アドレスに基づいたネクスト ホップ アドレスを自動的に判定します。*</span><span class="sxs-lookup"><span data-stu-id="b956a-988">*For multihome devices, NetX automatically determines the source address to use for the connection, and the next hop address based on the destination IP address of the connection.*</span></span>

### <a name="tcp-socket-state-machine"></a><span data-ttu-id="b956a-989">TCP ソケットの状態機械</span><span class="sxs-lookup"><span data-stu-id="b956a-989">TCP Socket State Machine</span></span>

<span data-ttu-id="b956a-990">2 つの TCP ソケット (クライアント 1 つとサーバー 1 つ) 間の接続は複雑で、状態機械方式で管理されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-990">The connection between two TCP sockets (one client and one server) is complex and is managed in a state machine manner.</span></span> <span data-ttu-id="b956a-991">各 TCP ソケットは、CLOSED 状態で開始されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-991">Each TCP socket starts in a CLOSED state.</span></span> <span data-ttu-id="b956a-992">接続イベントを通じて、各ソケットの状態機械が ESTABLISHED 状態に移行します。この状態で、TCP でのデータ転送の大部分が行われます。</span><span class="sxs-lookup"><span data-stu-id="b956a-992">Through connection events each socket's state machine migrates into the ESTABLISHED state, which is where the bulk of the data transfer in TCP takes place.</span></span> <span data-ttu-id="b956a-993">接続の一方の側がデータを送信する必要がなくなった場合、接続は切断されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-993">When one side of the connection no longer wishes to send data, it disconnects.</span></span> <span data-ttu-id="b956a-994">もう一方の側が切断すると、最終的に TCP ソケットは CLOSED 状態に戻ります。</span><span class="sxs-lookup"><span data-stu-id="b956a-994">After the other side disconnects, eventually the TCP socket returns to the CLOSED state.</span></span> <span data-ttu-id="b956a-995">このプロセスは、TCP クライアントとサーバーが接続を確立して閉じるたびに繰り返されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-995">This process repeats each time a TCP client and server establish and close a connection.</span></span> <span data-ttu-id="b956a-996">図 11 は、TCP 状態機械のさまざまな状態を示しています。</span><span class="sxs-lookup"><span data-stu-id="b956a-996">Figure 11 shows the various states of the TCP state machine.</span></span>

![TCP 状態機械の状態](./media/user-guide/states-tcp-state-machine.png)

### <a name="figure-11-states-of-the-tcp-state-machine"></a><span data-ttu-id="b956a-998">図 11.</span><span class="sxs-lookup"><span data-stu-id="b956a-998">FIGURE 11.</span></span> <span data-ttu-id="b956a-999">TCP 状態機械の状態</span><span class="sxs-lookup"><span data-stu-id="b956a-999">States of the TCP State Machine</span></span>

### <a name="tcp-client-connection"></a><span data-ttu-id="b956a-1000">TCP クライアント接続</span><span class="sxs-lookup"><span data-stu-id="b956a-1000">TCP Client Connection</span></span>

<span data-ttu-id="b956a-1001">前述のように、TCP 接続のクライアント側は、TCP サーバーへの接続要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1001">As mentioned previously, the client side of the TCP connection initiates a connection request to a TCP server.</span></span> <span data-ttu-id="b956a-1002">接続要求を行う前に、クライアントの IP インスタンスで TCP を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1002">Before a connection request can be made, TCP must be enabled on the client IP instance.</span></span> <span data-ttu-id="b956a-1003">さらに、***nx_tcp_socket_create** _ サービスを使用して次にクライアントの TCP ソケットを作成し、_*_nx_tcp_client_socket_bind_\*_ サービスを介してポートにバインドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1003">In addition, the client TCP socket must next be created with the ***nx_tcp_socket_create** _ service and bound to a port via the _*_nx_tcp_client_socket_bind_\*_ service.</span></span> <span data-ttu-id="b956a-1004">クライアント ソケットをバインドした後、_ *_nx_tcp_client_socket_connect_*\* サービスを使用して、TCP サーバーとの接続を確立します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1004">After the client socket is bound, the _ *_nx_tcp_client_socket_connect_*\* service is used to establish a connection with a TCP server.</span></span> <span data-ttu-id="b956a-1005">接続試行を開始するには、ソケットが CLOSED 状態になっている必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b956a-1005">Note the socket must be in a CLOSED state to initiate a connection attempt.</span></span> <span data-ttu-id="b956a-1006">接続を確立するには、まず、NetX で SYN パケットを発行し、サーバーからの SYN ACK パケットを待機します。これは、接続要求の受け入れを示します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1006">Establishing the connection starts with NetX issuing a SYN packet and then waiting for a SYN ACK packet back from the server, which signifies acceptance of the connection request.</span></span> <span data-ttu-id="b956a-1007">SYN ACK を受信した後、NetX は ACK パケットで応答し、ESTABLISHED 状態にクライアント ソケットを昇格させます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1007">After the SYN ACK is received, NetX responds with an ACK packet and promotes the client socket to the ESTABLISHED state.</span></span>

### <a name="tcp-client-disconnection"></a><span data-ttu-id="b956a-1008">TCP クライアント切断</span><span class="sxs-lookup"><span data-stu-id="b956a-1008">TCP Client Disconnection</span></span>

<span data-ttu-id="b956a-1009">接続の終了は、***nx_tcp_socket_disconnect*** の呼び出しで行われます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1009">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="b956a-1010">中断が指定されていない場合、クライアント ソケットは RST パケットをサーバー ソケットに送信し、ソケットを CLOSED 状態にします。</span><span class="sxs-lookup"><span data-stu-id="b956a-1010">If no suspension is specified, the client socket sends a RST packet to the server socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="b956a-1011">それ以外の場合、中断が要求されると、次のように完全な TCP 切断プロトコルが実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1011">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</span></span>

- <span data-ttu-id="b956a-1012">サーバーが以前に切断要求を開始した場合 (クライアント ソケットが既に FIN パケットを受信していて、ACK で応答し、CLOSE WAIT 状態にある場合)、NetX ではクライアントの TCP ソケットの状態が LAST ACK 状態に昇格され、FIN パケットが送信されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1012">If the server previously initiated a disconnect request (the client socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX promotes the client TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="b956a-1013">次に、サーバーからの ACK を待機してから切断を完了し、CLOSED 状態に入ります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1013">It then waits for an ACK from the server before completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="b956a-1014">一方、クライアントが最初に切断要求を開始する場合 (サーバーが切断されていない状態で、ソケットがまだ ESTABLISHED 状態である場合)、NetX では FIN パケットが送信されて切断が開始し、サーバーからの FIN と ACK の受信を待機してから切断を完了してソケットが CLOSED 状態になります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1014">If on the other hand, the client is the first to initiate a disconnect request (the server has not disconnected and the socket is still in the ESTABLISHED state), NetX sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the server before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="b956a-1015">ソケットの送信キューにパケットが残っている場合、NetX は指定されたタイムアウトの間中断して、パケットが確認されるようにします。</span><span class="sxs-lookup"><span data-stu-id="b956a-1015">If there are still packets on the socket transmit queue, NetX suspends for the specified timeout to allow the packets to be acknowledged.</span></span> <span data-ttu-id="b956a-1016">タイムアウトが経過すると、NetX はクライアント ソケットの送信キューを空にします。</span><span class="sxs-lookup"><span data-stu-id="b956a-1016">If the timeout expires, NetX empties the transmit queue of the client socket.</span></span>

<span data-ttu-id="b956a-1017">クライアント ソケットからポートのバインドを解除するために、アプリケーションは ***nx_tcp_client_socket_unbind*** を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1017">To unbind the port from the client socket, the application calls ***nx_tcp_client_socket_unbind***.</span></span> <span data-ttu-id="b956a-1018">ソケットは、ポートが解放される前に、CLOSED 状態であるか、切断処理中 (つまり、TIMED WAIT 状態) である必要があります。それ以外の場合は、エラーが返されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1018">The socket must be in a CLOSED state or in the process of disconnecting (i.e., TIMED WAIT state) before the port is released; otherwise, an error is returned.</span></span>

<span data-ttu-id="b956a-1019">最後に、アプリケーションがクライアント ソケットを必要としなくなった場合は、***nx_tcp_socket_delete*** を呼び出してソケットを削除します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1019">Finally, if the application no longer needs the client socket, it calls ***nx_tcp_socket_delete*** to delete the socket.</span></span>

### <a name="tcp-server-connection"></a><span data-ttu-id="b956a-1020">TCP サーバー接続</span><span class="sxs-lookup"><span data-stu-id="b956a-1020">TCP Server Connection</span></span>

<span data-ttu-id="b956a-1021">TCP 接続のサーバー側はパッシブです。つまり、サーバーは、クライアントが接続要求を開始するのを待機します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1021">The server side of a TCP connection is passive; i.e., the server waits for a client to initiate connection request.</span></span> <span data-ttu-id="b956a-1022">クライアント接続を受け入れるには、まず、サービス \***nx_tcp_enable** _ を呼び出して、IP インスタンスで TCP を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1022">To accept a client connection, TCP must first be enabled on the IP instance by calling the service \***nx_tcp_enable** _.</span></span> <span data-ttu-id="b956a-1023">次に、アプリケーションは _ *_nx_tcp_socket_create_*\* サービスを使用して TCP ソケットを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1023">Next, the application must create a TCP socket using the _ *_nx_tcp_socket_create_*\* service.</span></span>

<span data-ttu-id="b956a-1024">また、サーバー ソケットを、接続要求をリッスンするように設定する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1024">The server socket must also be set up for listening for connection requests.</span></span> <span data-ttu-id="b956a-1025">これは、***nx_tcp_server_socket_listen*** サービスを使用して行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1025">This is achieved by using the ***nx_tcp_server_socket_listen*** service.</span></span> <span data-ttu-id="b956a-1026">このサービスは、サーバー ソケットを LISTEN 状態にし、指定されたサーバー ポートをソケットにバインドします。</span><span class="sxs-lookup"><span data-stu-id="b956a-1026">This service places the server socket in the LISTEN state and binds the specified server port to the socket.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-1027">*ソケット リッスン コールバック ルーチンを設定するには、アプリケーションで **nx_tcp_server_socket_listen** サービスの tcp_listen_callback 引数に適切なコールバック関数を指定します。このサーバー ポートで新しい接続が要求されるたびに、このアプリケーション コールバック関数が NetX によって実行されます。コールバックでの処理は、アプリケーションで制御されます。*</span><span class="sxs-lookup"><span data-stu-id="b956a-1027">*To set a socket listen callback routine the application specifies the appropriate callback function for the tcp_listen_callback argument of the **nx_tcp_server_socket_listen** service. This application callback function is then executed by NetX whenever a new connection is requested on this server port. The processing in the callback is under application control.*</span></span>

<span data-ttu-id="b956a-1028">クライアント接続要求を受け入れるために、アプリケーションは \***nx_tcp_server_socket_accept** _ サービスを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1028">To accept client connection requests, the application calls the \***nx_tcp_server_socket_accept** _ service.</span></span> <span data-ttu-id="b956a-1029">受け入れサービスを呼び出すには、サーバー ソケットが LISTEN 状態または SYN RECEIVED 状態のいずれかである必要があります (つまり、サーバーが LISTEN 状態であり、接続を要求しているクライアントから SYN パケットを受信した状態)。</span><span class="sxs-lookup"><span data-stu-id="b956a-1029">The server socket must either be in a LISTEN state or a SYN RECEIVED state (i.e., the server is in the LISTEN state and has received a SYN packet from a client requesting a connection) to call the accept service.</span></span> <span data-ttu-id="b956a-1030">_ *_nx_tcp_server_socket_accept_*\* から返される正常の状態は、接続が設定されており、サーバー ソケットが ESTABLISHED 状態であることを示します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1030">A successful return status from _ *_nx_tcp_server_socket_accept_*\* indicates the connection has been set up and the server socket is in the ESTABLISHED state.</span></span>

<span data-ttu-id="b956a-1031">サーバー ソケットに有効な接続がある状態になったら、追加のクライアント接続要求が、*listen_queue_size* によって指定された深さまでキューに登録され、\***nx_tcp_server_socket_listen** _ サービスに渡されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1031">After the server socket has a valid connection, additional client connection requests are queued up to the depth specified by the *listen_queue_size*, passed into the \***nx_tcp_server_socket_listen** _ service.</span></span> <span data-ttu-id="b956a-1032">サーバー ポートで以降の接続を処理するには、アプリケーションは使用可能なソケット (つまり、CLOSED 状態のソケット) を使用して _ *_nx_tcp_server_socket_relisten_*\* を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1032">In order to process subsequent connections on a server port, the application must call _ *_nx_tcp_server_socket_relisten_*\* with an available socket (i.e., a socket in a CLOSED state).</span></span> <span data-ttu-id="b956a-1033">ソケットに関連付けられている以前の接続が終了し、ソケットが CLOSED 状態になっている場合は、同じサーバー ソケットを使用できることに注意します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1033">Note that the same server socket could be used if the previous connection associated with the socket is now finished and the socket is in the CLOSED state.</span></span>

### <a name="tcp-server-disconnection"></a><span data-ttu-id="b956a-1034">TCP サーバー切断</span><span class="sxs-lookup"><span data-stu-id="b956a-1034">TCP Server Disconnection</span></span>

<span data-ttu-id="b956a-1035">接続の終了は、***nx_tcp_socket_disconnect*** の呼び出しで行われます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1035">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="b956a-1036">中断が指定されていない場合、サーバー ソケットは RST パケットをクライアント ソケットに送信し、ソケットを CLOSED 状態にします。</span><span class="sxs-lookup"><span data-stu-id="b956a-1036">If no suspension is specified, the server socket sends a RST packet to the client socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="b956a-1037">それ以外の場合、中断が要求されると、次のように完全な TCP 切断プロトコルが実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1037">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows: |</span></span>

- <span data-ttu-id="b956a-1038">クライアントが以前に切断要求を開始した場合 (サーバー ソケットが既に FIN パケットを受信していて、ACK で応答し、CLOSE WAIT 状態にある場合)、NetX は TCP ソケット状態を LAST ACK 状態に昇格し、FIN パケットを送信します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1038">If the client previously initiated a disconnect request (the server socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX promotes the TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="b956a-1039">次に、クライアントからの ACK を待機してから切断を完了し、CLOSED 状態に入ります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1039">It then waits for an ACK from the client before completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="b956a-1040">一方、サーバーが最初に切断要求を開始する場合 (クライアントが切断されていない状態で、ソケットがまだ ESTABLISHED 状態である場合)、NetX は FIN パケットを送信して切断を開始し、クライアントからの FIN と ACK の受信を待機してから切断を完了してソケットを CLOSED 状態にします。</span><span class="sxs-lookup"><span data-stu-id="b956a-1040">If on the other hand, the server is the first to initiate a disconnect request (the client has not disconnected and the socket is still in the ESTABLISHED state), NetX sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the client before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="b956a-1041">ソケットの送信キューにパケットが残っている場合、NetX は指定されたタイムアウトの間中断して、それらのパケットが確認されるようにします。</span><span class="sxs-lookup"><span data-stu-id="b956a-1041">If there are still packets on the socket transmit queue, NetX suspends for the specified timeout to allow those packets to be acknowledged.</span></span> <span data-ttu-id="b956a-1042">タイムアウトが経過すると、NetX はサーバー ソケットの送信キューをフラッシュします。</span><span class="sxs-lookup"><span data-stu-id="b956a-1042">If the timeout expires, NetX flushes the transmit queue of the server socket.</span></span>

<span data-ttu-id="b956a-1043">切断処理が完了し、サーバー ソケットが CLOSED 状態になった後、このソケットとサーバー ポートの関連付けを終了するために、アプリケーションでは ***nx_tcp_server_socket_unaccept*** サービスを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1043">After the disconnect processing is complete and the server socket is in the CLOSED state, the application must call the ***nx_tcp_server_socket_unaccept*** service to end the association of this socket with the server port.</span></span> <span data-ttu-id="b956a-1044">このサービスは、***nx_tcp_socket_disconnect*** または \***nx_tcp_server_socket_accept** _ がエラー状態を返す場合でも、アプリケーションによって呼び出される必要があることに注意します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1044">Note this service must be called by the application even if ***nx_tcp_socket_disconnect*** or \***nx_tcp_server_socket_accept** _ return an error status.</span></span> <span data-ttu-id="b956a-1045">_ *_nx_tcp_server_socket_unaccept_*\* が返された後、ソケットをクライアントまたはサーバー ソケットとして使用したり、不要になった場合は削除することもできます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1045">After the _ *_nx_tcp_server_socket_unaccept_*\* returns, the socket can be used as a client or server socket, or even deleted if it is no longer needed.</span></span> <span data-ttu-id="b956a-1046">同じサーバー ポートで別のクライアント接続を受け入れる必要がある場合は、このソケットで ***nx_tcp_server_socket_relisten*** サービスを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1046">If accepting another client connection on the same server port is desired, the ***nx_tcp_server_socket_relisten*** service should be called on this socket.</span></span>

<span data-ttu-id="b956a-1047">次のコード セグメントは、一般的な TCP サーバーで使用される一連の呼び出しを示しています。</span><span class="sxs-lookup"><span data-stu-id="b956a-1047">The following code segment illustrates the sequence of calls a typical TCP server uses:</span></span>

```c
/* Set up a previously created TCP socket to listen on port 12 */

nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1) {

    /* Wait for a client socket connection request for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on the port. */

    nx_tcp_server_socket_unaccept(&server_socket);

    /* Set up server socket to relisten on the same port for the next
    client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a><span data-ttu-id="b956a-1048">MSS 検証</span><span class="sxs-lookup"><span data-stu-id="b956a-1048">MSS Validation</span></span>

<span data-ttu-id="b956a-1049">最大セグメント サイズ (MSS) は、基になる IP レイヤーによって断片化されることなく TCP ホストが受信できる最大バイト数です。</span><span class="sxs-lookup"><span data-stu-id="b956a-1049">The Maximum Segment Size (MSS) is the maximum amount of bytes a TCP host can receive without being fragmented by the underlying IP layer.</span></span> <span data-ttu-id="b956a-1050">TCP 接続の確立フェーズでは、両端でそれぞれの TCP MSS 値が交換されます。これにより、送信側は、受信側の MSS よりも大きい TCP データ セグメントを送信しません。</span><span class="sxs-lookup"><span data-stu-id="b956a-1050">During TCP connection establishment phase, both ends exchanges its own TCP MSS value, so that the sender does not send a TCP data segment that is larger than the receiver's MSS.</span></span> <span data-ttu-id="b956a-1051">NetX TCP モジュールは、接続を確立する前に、必要に応じてピアの公開済み MSS 値を検証します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1051">NetX TCP module will optionally validate its peer's advertised MSS value before establishing a connection.</span></span> <span data-ttu-id="b956a-1052">既定では、NetX はこのようなチェックを有効にしません。</span><span class="sxs-lookup"><span data-stu-id="b956a-1052">By default NetX does not enable such a check.</span></span> <span data-ttu-id="b956a-1053">MSS 検証を実行するアプリケーションでは、NetX ライブラリを構築するときに ***NX_ENABLE_TCP_MSS_CHECKING** _ を定義する必要があり、最小値は _*_NX_TCP_MSS_MINIMUM_\*_ で定義します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1053">Applications wishing to perform MSS validation shall define ***NX_ENABLE_TCP_MSS_CHECKING** _ when building the NetX library, and the minimum value shall be defined in _*_NX_TCP_MSS_MINIMUM_\*_.</span></span> <span data-ttu-id="b956a-1054">_ *_NX_TCP_MSS_MINIMUM_*\* の下にある MSS 値を持つ受信 TCP 接続はドロップされます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1054">Incoming TCP connections with MSS values below _ *_NX_TCP_MSS_MINIMUM_*\* are dropped.</span></span>

### <a name="stop-listening-on-a-server-port"></a><span data-ttu-id="b956a-1055">サーバー ポートでのリッスン停止</span><span class="sxs-lookup"><span data-stu-id="b956a-1055">Stop Listening on a Server Port</span></span>

<span data-ttu-id="b956a-1056">以前に ***nx_tcp_server_socket_listen** _ サービスの呼び出しで指定されたサーバー ポートでクライアント接続要求をリッスンする必要がなくなった場合、アプリケーションでは、単純に _ *_nx_tcp_server_socket_unlisten_** サービスを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1056">If the application no longer wishes to listen for client connection requests on a server port that was previously specified by a call to the ***nx_tcp_server_socket_listen** _ service, the application simply calls the _ *_nx_tcp_server_socket_unlisten_** service.</span></span> <span data-ttu-id="b956a-1057">このサービスは、接続を待機しているソケットをすべて CLOSED 状態に戻し、キューに置かれたクライアント接続要求パケットをすべて解放します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1057">This service places any socket waiting for a connection back in the CLOSED state and releases any queued client connection request packets.</span></span>

### <a name="tcp-window-size"></a><span data-ttu-id="b956a-1058">TCP ウィンドウ サイズ</span><span class="sxs-lookup"><span data-stu-id="b956a-1058">TCP Window Size</span></span>

<span data-ttu-id="b956a-1059">接続のセットアップ フェーズとデータ転送フェーズの両方で、各ポートは、ウィンドウ サイズと呼ばれる処理可能なデータの量を報告します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1059">During both the setup and data transfer phases of the connection, each port reports the amount of data it can handle, which is called its window size.</span></span> <span data-ttu-id="b956a-1060">データが受信されて処理されると、このウィンドウ サイズは動的に調整されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1060">As data are received and processed, this window size is adjusted dynamically.</span></span> <span data-ttu-id="b956a-1061">TCP では、送信側は受信側のウィンドウに収まる量のデータのみを送信できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1061">In TCP, a sender can only send an amount of data that fits into the receiver's window.</span></span> <span data-ttu-id="b956a-1062">基本的に、ウィンドウ サイズは、接続の各方向でのデータ転送のフロー制御を提供します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1062">In essence, the window size provides flow control for data transfer in each direction of the connection.</span></span>

### <a name="tcp-packet-send"></a><span data-ttu-id="b956a-1063">TCP パケット送信</span><span class="sxs-lookup"><span data-stu-id="b956a-1063">TCP Packet Send</span></span>

<span data-ttu-id="b956a-1064">TCP データの送信は、***nx_tcp_socket_send*** 関数を呼び出すことによって簡単に実現できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1064">Sending TCP data is easily accomplished by calling the ***nx_tcp_socket_send*** function.</span></span> <span data-ttu-id="b956a-1065">送信されるデータのサイズがソケットの MSS 値または、現在のピアの受信ウィンドウ サイズ (どちらか小さいほう) より大きい場合は、TCP 内部ロジックによって、伝送のための最小 (MSS、ピア受信ウィンドウ) に収まるデータに切り分けられます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1065">If the size of the data being transmitted is larger than the MSS value of the socket or the current peer receive window size, whichever is smaller, TCP internal logic carves off the data that fits into min (MSS, peer receive Window) for transmission.</span></span> <span data-ttu-id="b956a-1066">その後、このサービスによってパケットの前に TCP ヘッダーが作成されます (チェックサムの計算も含まれます)。</span><span class="sxs-lookup"><span data-stu-id="b956a-1066">This service then builds a TCP header in front of the packet (including the checksum calculation).</span></span> <span data-ttu-id="b956a-1067">受信側のウィンドウ サイズが 0 でない場合、呼び出し元は受信側のウィンドウ サイズいっぱいまでデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1067">If the receiver's window size is not zero, the caller will send as much data as it can to fill up the receiver window size.</span></span> <span data-ttu-id="b956a-1068">受信ウィンドウが 0 になった場合、呼び出し元は中断し、受信側のウィンドウ サイズがこのパケットの送信に十分な大きさになるまで待機することがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1068">If the receive window becomes zero, the caller may suspend and wait for the receiver's window size to increase enough for this packet to be sent.</span></span> <span data-ttu-id="b956a-1069">任意の時点で、同じソケットを介してデータを送信しようとしている間に、複数のスレッドが中断されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1069">At any given time, multiple threads may suspend while trying to send data through the same socket.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-1070">*NX_PACKET 構造に存在する TCP データは、長いワード境界に配置する必要があります。さらに、先頭のポインターとデータの開始ポインターの間に、TCP、IP、および物理メディアのヘッダーを配置するために十分な領域がある必要があります。*</span><span class="sxs-lookup"><span data-stu-id="b956a-1070">*The TCP data residing in the NX_PACKET structure should reside on a long-word boundary. In addition, there needs to be sufficient space between the prepend pointer and the data start pointer to place the TCP, IP, and physical media headers.*</span></span>

### <a name="tcp-packet-retransmit"></a><span data-ttu-id="b956a-1071">TCP パケットの再送信</span><span class="sxs-lookup"><span data-stu-id="b956a-1071">TCP Packet Retransmit</span></span>

<span data-ttu-id="b956a-1072">以前に送信された TCP パケットは、接続の相手側から ACK が返されるまで、実際には内部的に格納されていました。</span><span class="sxs-lookup"><span data-stu-id="b956a-1072">Previously transmitted TCP packets sent actually stored internally until an ACK is returned from the other side of the connection.</span></span> <span data-ttu-id="b956a-1073">転送されたデータがタイムアウト期間内に確認されない場合、保存されているパケットは再送信され、次のタイムアウト期間が設定されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1073">If transmitted data is not acknowledged within the timeout period, the stored packet is re-sent and the next timeout period is set.</span></span> <span data-ttu-id="b956a-1074">ACK を受信すると、内部送信キューの確認応答番号によってカバーされるすべてのパケットが最終的に解放されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1074">When an ACK is received, all packets covered by the acknowledgement number in the internal transmit queue are finally released.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b956a-1075">*アプリケーションは、\*\*\*nx_tcp_socket_send*\* _ 関数が NX_SUCCESS を返した後は、パケットを再利用したり、パケットの内容を変更したりすることはありません。</span><span class="sxs-lookup"><span data-stu-id="b956a-1075">\*Application shall not reuse the packet or alter the contents of the packet after the \***nx_tcp_socket_send** _ function returns with NX_SUCCESS.</span></span> <span data-ttu-id="b956a-1076">送信パケットは、データが相手側で確認された後、NetX 内部処理によって最終的に解放されます。_</span><span class="sxs-lookup"><span data-stu-id="b956a-1076">The transmitted packet is eventually released by NetX internal processing after the data is acknowledged by the other end._</span></span>

### <a name="tcp-keepalive"></a><span data-ttu-id="b956a-1077">TCP Keepalive</span><span class="sxs-lookup"><span data-stu-id="b956a-1077">TCP Keepalive</span></span>

<span data-ttu-id="b956a-1078">TCP Keepalive 機能を使用すると、ピアが適切に終了せずに切断したかどうか (ピアがクラッシュした場合など) をソケットで検出したり、アイドル状態が長く、特定のネットワーク監視機能が接続を終了するのを防いだりできます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1078">TCP Keepalive feature allows a socket to detect whether or not its peer disconnects without proper termination (for example, the peer crashed), or to prevent certain network monitoring facilities to terminate a connection for long periods of idle.</span></span> <span data-ttu-id="b956a-1079">TCP Keepalive は、データのない TCP フレームを定期的に送信し、シーケンス番号を現在のシーケンス番号よりも 1 小さい値に設定することによって機能します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1079">TCP Keepalive works by periodically sending a TCP frame with no data, and the sequence number set to one less than the current sequence number.</span></span> <span data-ttu-id="b956a-1080">このような TCP Keepalive フレームを受け取ると、受信者は、まだ稼動している場合は、現在のシーケンス番号に対して ACK で応答します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1080">On receiving such TCP Keepalive frame, the recipient, if still alive, responses with an ACK for its current sequence number.</span></span> <span data-ttu-id="b956a-1081">これで、Keepalive トランザクションが完了します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1081">This completes the keepalive transaction.</span></span>

<span data-ttu-id="b956a-1082">既定では、Keepalive 機能は有効になっていません。</span><span class="sxs-lookup"><span data-stu-id="b956a-1082">By default the keepalive feature is not enabled.</span></span> <span data-ttu-id="b956a-1083">この機能を使用するには、NetX ライブラリを \***NX_ENABLE_TCP_KEEPALIVE** _ を定義して構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1083">To use this feature, NetX library must be built with \***NX_ENABLE_TCP_KEEPALIVE** _ defined.</span></span> <span data-ttu-id="b956a-1084">シンボル _ *_NX_TCP_KEEPALIVE_INITIAL_*\* は、Keepalive フレームが開始されるまでの非アクティブな秒数を指定します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1084">The symbol _ *_NX_TCP_KEEPALIVE_INITIAL_*\* specifies the number of seconds of inactivity before the keepalive frame is initiated.</span></span>

### <a name="tcp-packet-receive"></a><span data-ttu-id="b956a-1085">TCP パケット受信</span><span class="sxs-lookup"><span data-stu-id="b956a-1085">TCP Packet Receive</span></span>

<span data-ttu-id="b956a-1086">TCP の受信パケット処理 (IP ヘルパー スレッドから呼び出されます) は、さまざまな接続および切断アクションだけでなく、確認応答処理も送信します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1086">The TCP receive packet processing (called from the IP helper thread) is responsible for handling various connection and disconnection actions as well as transmit acknowledge processing.</span></span> <span data-ttu-id="b956a-1087">さらに、TCP 受信パケット処理は、受信データを持つパケットを適切な TCP ソケットの受信キューに格納したり、パケットを待機している最初の中断されたスレッドにパケットを配信したりする役割を担います。</span><span class="sxs-lookup"><span data-stu-id="b956a-1087">In addition, the TCP receive packet processing is responsible for placing packets with receive data on the appropriate TCP socket's receive queue or delivering the packet to the first suspended thread waiting for a packet.</span></span>

### <a name="tcp-receive-notify"></a><span data-ttu-id="b956a-1088">TCP 受信通知</span><span class="sxs-lookup"><span data-stu-id="b956a-1088">TCP Receive Notify</span></span>

<span data-ttu-id="b956a-1089">アプリケーション スレッドが複数のソケットから受信したデータを処理する必要がある場合は、***nx_tcp_socket_receive_notify*** 関数を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1089">If the application thread needs to process received data from more than one socket, the ***nx_tcp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="b956a-1090">この関数は、ソケットの受信パケット コールバック関数を登録します。</span><span class="sxs-lookup"><span data-stu-id="b956a-1090">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="b956a-1091">ソケットでパケットが受信されるたびに、コールバック関数が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1091">Whenever a packet is received on the socket, the callback function is executed.</span></span>

<span data-ttu-id="b956a-1092">コールバック関数の内容はアプリケーション固有です。ただし、最も高い可能性として、関数には、パケットが対応するソケットで使用可能であることを処理スレッドに通知するロジックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b956a-1092">The contents of the callback function are application-specific; however, the function would most likely contain logic to inform the processing thread that a packet is available on the corresponding socket.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="b956a-1093">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="b956a-1093">Thread Suspension</span></span>

<span data-ttu-id="b956a-1094">前述のように、特定の TCP ポートからデータを受信しようとしている間に、アプリケーション スレッドが中断されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1094">As mentioned previously, application threads can suspend while attempting to receive data from a particular TCP port.</span></span> <span data-ttu-id="b956a-1095">そのポートでパケットが受信されると、最初に中断されたスレッドに渡され、そのスレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1095">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="b956a-1096">TCP 受信パケットで中断する場合は、オプションのタイムアウトを使用できます。これは、ほとんどの NetX サービスで利用可能な機能です。</span><span class="sxs-lookup"><span data-stu-id="b956a-1096">An optional timeout is available when suspending on a TCP receive packet, a feature available for most NetX services.</span></span>

<span data-ttu-id="b956a-1097">スレッドの中断は、接続 (クライアントとサーバーの両方)、クライアント バインド、および切断サービスでも使用できます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1097">Thread suspension is also available for connection (both client and server), client binding, and disconnection services.</span></span>

### <a name="tcp-socket-statistics-and-errors"></a><span data-ttu-id="b956a-1098">TCP ソケットの統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b956a-1098">TCP Socket Statistics and Errors</span></span>

<span data-ttu-id="b956a-1099">有効にすると、NetX TCP ソケット ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1099">If enabled, the NetX TCP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b956a-1100">次の統計およびエラー レポートは、IP/TCP インスタンスごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1100">The following statistics and error reports are maintained for each IP/TCP instance:</span></span>

- <span data-ttu-id="b956a-1101">送信された TCP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1101">Total TCP Packets Sent</span></span>
- <span data-ttu-id="b956a-1102">送信された TCP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1102">Total TCP Bytes Sent</span></span>
- <span data-ttu-id="b956a-1103">受信した TCP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1103">Total TCP Packets Received</span></span>
- <span data-ttu-id="b956a-1104">受信した TCP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1104">Total TCP Bytes Received</span></span>
- <span data-ttu-id="b956a-1105">無効な TCP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1105">Total TCP Invalid Packets</span></span>
- <span data-ttu-id="b956a-1106">ドロップされた TCP 受信パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1106">Total TCP Receive Packets Dropped</span></span>
- <span data-ttu-id="b956a-1107">TCP 受信チェックサム エラーの合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1107">Total TCP Receive Checksum Errors</span></span>
- <span data-ttu-id="b956a-1108">TCP 接続の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1108">Total TCP Connections</span></span>
- <span data-ttu-id="b956a-1109">TCP 切断の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1109">Total TCP Disconnections</span></span>
- <span data-ttu-id="b956a-1110">ドロップされた TCP 接続の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1110">Total TCP Connections Dropped</span></span>
- <span data-ttu-id="b956a-1111">TCP パケットの再送信の合計数</span><span class="sxs-lookup"><span data-stu-id="b956a-1111">Total TCP Packet Retransmits</span></span>
- <span data-ttu-id="b956a-1112">送信された TCP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b956a-1112">TCP Socket Packets Sent</span></span>
- <span data-ttu-id="b956a-1113">送信された TCP ソケット バイト数</span><span class="sxs-lookup"><span data-stu-id="b956a-1113">TCP Socket Bytes Sent</span></span>
- <span data-ttu-id="b956a-1114">受信した TCP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b956a-1114">TCP Socket Packets Received</span></span>
- <span data-ttu-id="b956a-1115">受信した TCP ソケット バイト数</span><span class="sxs-lookup"><span data-stu-id="b956a-1115">TCP Socket Bytes Received</span></span>
- <span data-ttu-id="b956a-1116">TCP ソケット パケットの再送信数</span><span class="sxs-lookup"><span data-stu-id="b956a-1116">TCP Socket Packet Retransmits</span></span>
- <span data-ttu-id="b956a-1117">キューに登録された TCP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b956a-1117">TCP Socket Packets Queued</span></span>
- <span data-ttu-id="b956a-1118">TCP ソケット チェックサム エラー</span><span class="sxs-lookup"><span data-stu-id="b956a-1118">TCP Socket Checksum Errors</span></span>
- <span data-ttu-id="b956a-1119">TCP ソケットの状態</span><span class="sxs-lookup"><span data-stu-id="b956a-1119">TCP Socket State</span></span>
- <span data-ttu-id="b956a-1120">TCP ソケット送信キューの深さ</span><span class="sxs-lookup"><span data-stu-id="b956a-1120">TCP Socket Transmit Queue Depth</span></span>
- <span data-ttu-id="b956a-1121">TCP ソケット送信ウィンドウ サイズ</span><span class="sxs-lookup"><span data-stu-id="b956a-1121">TCP Socket Transmit Window Size</span></span>
- <span data-ttu-id="b956a-1122">TCP ソケット受信ウィンドウ サイズ</span><span class="sxs-lookup"><span data-stu-id="b956a-1122">TCP Socket Receive Window Size</span></span>

<span data-ttu-id="b956a-1123">これらのすべての統計およびエラー レポートは、合計 TCP 統計情報については ***nx_tcp_info_get** _ サービスを使用し、ソケットごとの TCP 統計情報については _ *_nx_tcp_socket_info_get_** サービスを使用すると、アプリケーションで使用可能になります。</span><span class="sxs-lookup"><span data-stu-id="b956a-1123">All these statistics and error reports are available to the application with the ***nx_tcp_info_get** _ service for total TCP statistics and the _ *_nx_tcp_socket_info_get_** service for TCP statistics per socket.</span></span>

## <a name="tcp-socket-control-block-nx_tcp_socket"></a><span data-ttu-id="b956a-1124">TCP ソケット制御ブロック NX_TCP_SOCKET</span><span class="sxs-lookup"><span data-stu-id="b956a-1124">TCP Socket Control Block NX_TCP_SOCKET</span></span>

<span data-ttu-id="b956a-1125">各 TCP ソケットの特性は、関連付けられている *NX_TCP_SOCKET* 制御ブロックにあります。これには、IP データ構造へのリンク、ネットワーク接続インターフェイス、バインドされたポート、受信パケット キューなどの有用な情報が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b956a-1125">The characteristics of each TCP socket are found in the associated *NX_TCP_SOCKET* control block, which contains useful information such as the link to the IP data structure, the network connection interface, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="b956a-1126">この構造体は ***nx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="b956a-1126">This structure is defined in the ***nx_api.h*** file.</span></span>
