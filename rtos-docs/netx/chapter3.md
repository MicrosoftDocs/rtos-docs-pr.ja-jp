---
title: 第 3 章 - Azure RTOS NetX の機能コンポーネント
description: この章では、機能の観点から見た高パフォーマンスの Azure RTOS NetX TCP/IP スタックについて説明します。
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: db23aa152b2765ac7cc9be098723fc5df0947484
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811702"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx"></a>第 3 章 - Azure RTOS NetX の機能コンポーネント

この章では、機能の観点から見た高パフォーマンスの Azure RTOS NetX TCP/IP スタックについて説明します。 

## <a name="execution-overview"></a>実行の概要

NetX アプリケーション内のプログラム実行には、初期化、アプリケーション インターフェイス呼び出し、内部 IP スレッド、IP の定期的なタイマー、およびネットワーク ドライバーの 5 種類があります。

> [!IMPORTANT]
> NetX には、ThreadX のインストールが必要で、スレッドの実行、中断、定期的なタイマー、および相互排他設備に依存します。

### <a name="initialization"></a>初期化

サービス ***nx_system_initialize** _ は、他の NetX サービスが呼び出される前に呼び出す必要があります。 システムの初期化は、ThreadX _ *_tx_application_define_** ルーチンから、またはアプリケーション スレッドから呼び出すことができます。

***nx_system_initialize** _ が返されると、パケット プールと IP インスタンスを作成する準備がシステムで整います。 IP インスタンスを作成するには既定のパケット プールが必要であるため、IP インスタンスを作成する前に少なくとも 1 つの NetX パケット プールが存在している必要があります。 ThreadX 初期化関数 _ *_tx_application_define_** とアプリケーション スレッドから、パケット プールと IP インスタンスを作成できます。

内部的には、IP インスタンスの作成は 2 段階で行われます。 最初の段階は、***tx_application_define*** またはアプリケーション スレッドのコンテキストのいずれかから、呼び出し元のコンテキスト内で実行されます。 これには、IP データ構造の設定やさまざまな IP リソースの作成が含まれます (内部 IP スレッドを含む)。 2 番目の段階は、内部 IP スレッドからの初期実行時に実行されます。 ここで、IP 作成の第 1 段階で提供されるネットワーク ドライバーが最初に呼び出されます。 内部 IP スレッドからネットワーク ドライバーを呼び出すと、ドライバーは、I/O を実行して初期化処理中に一時停止できます。 初期化処理からネットワーク ドライバーが返されると、IP の作成が完了します。

> [!IMPORTANT]
> NetX サービス **nx_ip_status_check** は、IP インスタンスとそのプライマリ インターフェイスの状態に関する情報を取得するために使用できます。 このような状態情報には、リンクが初期化され、有効になっていて、IP アドレスが解決されているかどうかが含まれます。 この情報は、新しく作成された IP インスタンスを使用する必要があるアプリケーション スレッドを同期するために使用されます。 マルチホーム システムについては、以下の「マルチホーム サポート」を参照してください。 指定されたインターフェイスに関する情報を取得するために **nx_ip_interface_status_check** を使用できます。

### <a name="application-interface-calls"></a>アプリケーション インターフェイス呼び出し

アプリケーションからの呼び出しは、ほとんどの場合、ThreadX RTOS で実行されているアプリケーション スレッドから作成されます。 ただし、一部の初期化、作成、および有効化のサービスは ***tx_application_define*** から呼び出すことができます。 第 4 章の許可元に関するセクションでは、各 NetX サービスをどこから呼び出せるかを示しています。

ほとんどの場合、チェックサムの計算などの負荷の高いアクティビティは、他のスレッドの IP インスタンスへのアクセスをブロックすることなく、呼び出し元スレッドのコンテキスト内で実行されます。 たとえば、送信時に、基になる IP 送信関数を呼び出す前に、***nx_udp_socket_send*** サービス内で UDP チェックサム計算が実行されます。 受信したパケットでは、***nx_udp_socket_receive*** サービスで UDP チェックサムが計算され、アプリケーション スレッドのコンテキストで実行されます。 これにより、優先度の低いスレッドで負荷の高いチェックサム計算が行われることが原因で、優先順位の高いスレッドのネットワーク要求が停止されるのを防ぐことができます。

IP アドレスやポート番号などの値は、ホストのバイト順で API 関数に渡されます。 内部的には、これらの値はホストのバイト順で格納もされます。 これにより、開発者はデバッガーを使用して値を簡単に表示できます。 これらの値は、送信のためにフレーム内にプログラミングされた場合、ネットワークのバイト順に変換されます。

### <a name="internal-ip-thread"></a>内部 IP スレッド

前述のように、NetX の各 IP インスタンスには独自のスレッドがあります。 内部 IP スレッドの優先順位とスタック サイズは、***nx_ip_create*** サービスで定義されます。 内部 IP スレッドは、実行可能モードで作成されます。 IP スレッドの優先順位が呼び出し元のスレッドよりも高い場合、IP 作成呼び出しの内部でプリエンプションが発生する可能性があります。

内部 IP スレッドのエントリ ポイントは、内部関数 ***_nx_ip_thread_entry*** にあります。 開始されると、内部 IP スレッドでは最初にネットワーク ドライバーの初期化が完了されます。これは、アプリケーション固有のネットワーク ドライバーに対する 3 回の呼び出しで構成されます。 最初の呼び出しでは、ネットワーク ドライバーを IP インスタンスに接続した後、初期化呼び出しを実行します。これにより、ネットワーク ドライバーは初期化プロセスを実行できます。 ネットワーク ドライバーが初期化から戻されると (ハードウェアが適切に設定されるのを待機している間に停止される場合があります)、内部 IP スレッドはネットワーク ドライバーを再度呼び出して、リンクを有効にします。 

ネットワーク ドライバーがリンク有効化の呼び出しから戻されると、内部 IP スレッドは無限ループに入り、この IP インスタンスの処理を必要とするさまざまなイベントを確認します。 このループで処理されるイベントには、遅延 IP パケット受信、IP パケット フラグメント アセンブリ、ICMP ping 処理、IGMP 処理、TCP パケット キュー処理、TCP 周期処理、IP フラグメント アセンブリ タイムアウト、および IGMP 周期処理が含まれます。 イベントには、アドレス解決アクティビティ (IP ネットワークでの ARP パケット処理と ARP の周期処理) も含まれます。

> [!NOTE]
> *リッスンや切断のコールバックを含む NetX コールバック関数は、元の呼び出し元スレッドではなく、内部 IP スレッドから呼び出されます。アプリケーションは、NetX コールバック関数内で中断しないように注意する必要があります。*

### <a name="ip-periodic-timers"></a>IP の定期的なタイマー
各 IP インスタンスには、ThreadX の定期的なタイマーが 2 つ使用されています。 1 つ目は、ARP、IGMP、TCP タイムアウト用の 1 秒のタイマーで、IP フラグメントの再アセンブル処理にも使用されます。 2 つ目のタイマーは、TCP 再送信タイムアウトに使用される 100 ミリ秒タイマーです。

### <a name="network-driver"></a>ネットワーク ドライバー
NetX の各 IP インスタンスには、プライマリ インターフェイスがあります。これは、***nx_ip_create*** サービスで指定されているデバイス ドライバーによって識別されます。 ネットワーク ドライバーでは、パケットの伝送、パケットの受信、状態と制御の要求など、さまざまな NetX 要求が処理されます。

マルチホーム システムの場合、IP インスタンスは複数のインターフェイスを持ち、それぞれのインターフェイスでこれらのタスクを実行するネットワーク ドライバーが関連付けられています。

ネットワーク ドライバーでは、メディアで発生している非同期イベントも処理する必要があります。 メディアからの非同期イベントには、パケットの受信、パケット転送の完了、および状態の変更が含まれます。 NetX では、さまざまなイベントを処理するいくつかのアクセス関数がネットワーク ドライバーに提供されます。 これらの関数は、ネットワーク ドライバーの割り込みサービスのルーチン部分から呼び出されるように設計されています。 IP ネットワークの場合、ネットワーク ドライバーは、受信したすべての ARP パケットを * **_nx_arp_packet_deferred_receive** _ 内部関数に転送する必要があります。 すべての RARP パケットは _ *_ _nx_rarp_packet_deferred_receive_* _ 内部関数に転送される必要があります。 IP パケットには 2 つのオプションがあります。 IP パケットの高速ディスパッチが必要な場合は、受信 IP パケットを _ *_ _nx_ip_packet_receive_* _ に転送してすぐに処理する必要があります。 これにより、IP パケットを処理する際の NetX パフォーマンスが大幅に向上します。 それ以外の場合、ネットワーク ドライバーでは、IP パケットを _*_ _nx_ip_packet_deferred_receive_** に転送する必要があります。 このサービスでは、IP パケットが遅延処理キューに配置されます。このキューでパケットは内部 IP スレッドによって処理されます。これにより、ISR 処理時間が最短になります。

また、ネットワーク ドライバーでは、割り込み処理を遅延させて、IP スレッドのコンテキストから実行することもできます。 このモードの ISR では、必要な情報が保存され、内部関数 ***_nx_ip_driver_deferred_processing*** が呼び出されて、割り込みコントローラーが確認されます。 このサービスでは、割り込みを発生させるイベントの処理を完了するために、デバイス ドライバーへのコールバックをスケジュールするように、IP スレッドに通知されます。

一部のネットワーク コントローラーでは、貴重な CPU リソースを消費することなく、ハードウェアで TCP/IP ヘッダー チェックサムの計算と検証が実行されるようにできます。 ハードウェア機能を利用するために、NetX では、コンパイル時にさまざまなソフトウェア チェックサム計算を有効または無効にしたり、実行時にチェックサム計算をオンまたはオフにしたりするためのオプションが用意されています。 NetX ネットワーク ドライバーの記述の詳細については、「[第 5 章 NetX ネットワーク ドライバー](chapter5.md)」を参照してください。

### <a name="multihome-support"></a>マルチホーム サポート
NetX では、単一の IP インスタンスを使用して複数の物理デバイスに接続されたシステムがサポートされます。 各物理インターフェイスは、IP インスタンス内のインターフェイス制御ブロックに割り当てられます。 マルチホーム システムを使用するアプリケーションでは、**NX_MAX_PHSYCIAL_INTERFACES** の値をシステムに接続されている物理デバイスの数に定義し、NetX ライブラリを再構築する必要があります。 既定では **NX_MAX_PHYSICAL_INTERFACES** が 1 に設定され、IP インスタンスに 1 つのインターフェイス制御ブロックが作成されます。

NetX アプリケーションでは、***nx_ip_create** _ サービスを使用して、プライマリ デバイス用の単一の IP インスタンスが作成されます。 追加のネットワーク デバイスごとに、アプリケーションで _ *_nx_ip_interface_attach_** サービスを使用して、デバイスが IP インスタンスに接続されます。

各ネットワーク インターフェイス構造には、IP 制御ブロックに含まれるネットワーク インターフェイスに関するネットワーク情報のサブセットが含まれています。これには、インターフェイス IP アドレス、サブネット マスク、IP MTU サイズ、および MAC レイヤー アドレス情報が含まれます。

> [!IMPORTANT]
> *マルチホーム サポートが有効な NetX には、以前のバージョンの NetX との下位互換性があります。明示的なインターフェイス情報を受け取らないサービスは、既定でプライマリ ネットワーク デバイスに設定されます。*

IP インスタンスの一覧で、プライマリ インターフェイスはインデックス 0 になります。 IP インスタンスに接続されているそれ以降の各デバイスには、次のインデックスが割り当てられます。

IP インスタンスが有効になっているすべての上位層プロトコル サービス (TCP、UDP、ICMP、IGMP を含む) は、接続されているすべてのデバイスで使用できます。

ほとんどの場合、NetX ではパケットの送信時に使用する最適な送信元アドレスを決定できます。 送信元アドレスの選択は、送信先アドレスに基づいています。 NetX サービスは、送信先アドレスによって最適な送信元アドレスを特定できない場合に、使用する特定の送信元アドレスをアプリケーションで指定できるように提供されています。 例として、アプリケーションが IP ブロードキャストまたはマルチキャストの送信先アドレスにパケットを送信する必要があるマルチホーム システムの場合を考えます。

マルチホーム アプリケーションの開発に特化したサービスには、次のものがあります。

*nx_igmp_multicast_interface_join nx_ip_driver_interface_direct_command nx_ip_interface_address_get nx_ip_interface_address_set nx_ip_interface_attach nx_ip_interface_info_get nx_ip_interface_status_check nx_ip_raw_packet_interface_send nx_udp_socket_interface_send*

これらのサービスの詳細については「[第 4 章 - Azure RTOS NetX サービスの説明](chapter4.md)」を参照してください。

### <a name="loopback-interface"></a>ループバック インターフェイス
ループバック インターフェイスは、物理リンクがアタッチされていない特殊なネットワーク インターフェイスです。 ループバック インターフェイスは、アプリケーションが IP ループバック アドレス 127.0.0.1 を使用して通信することを許可します。

論理ループバック インターフェイスを利用するには、構成可能なオプション ***NX_DISABLE_LOOPBACK_INTERFACE*** が設定されていないことを確認します。

### <a name="interface-control-blocks"></a>インターフェイス制御ブロック
IP インスタンス内のインターフェイス制御ブロックの数は、物理インターフェイスの数 (***NX_MAX_PHYSICAL_INTERFACES** _ によって定義されます) に、ループバック インターフェイス (有効になっている場合) を加算したものです。 インターフェイスの合計数は、_*_NX_MAX_IP_INTERFACES_** で定義されています。

## <a name="protocol-layering"></a>プロトコルのレイヤー化

NetX によって実装される TCP/IP は、レイヤー化されたプロトコルです。これは、より複雑なプロトコルが、より単純な基盤となるプロトコルの上に構築されることを意味します。 TCP/IP では、最下位層のプロトコルが "*リンク層*" にあり、ネットワーク ドライバーによって処理されます。 このレベルは、通常、イーサネットを対象としていますが、ファイバー、シリアル、または事実上すべての物理メディアである可能性もあります。

リンク層の上には、"*ネットワーク層*" があります。 TCP/IP ではこれが IP です。基本的には単純なパケットを送受信する役割を担い、ベストエフォートとしてはネットワーク全体でこれを行います。 ICMP や IGMP などの管理の種類のプロトコルは、通常、送信と受信のために IP に依存している場合でも、ネットワーク層として分類されます。

"*トランスポート層*" は、ネットワーク層の上に置かれます。 この層は、ネットワーク上でホスト間のデータ フローを管理する役割を担います。 NetX でサポートされる転送サービスには、UDP と TCP の 2 種類があります。 UDP サービスは、コネクションレス方式で 2 つのホスト間でデータをベストエフォートで送受信します。一方、TCP は、2 つのホスト エンティティ間に信頼性の高い接続指向サービスを提供します。

このレイヤー化は、実際のネットワーク データ パケットに反映されます。 TCP/IP の各層には、ヘッダーと呼ばれる情報のブロックが含まれています。 データ (および場合によってはプロトコル情報) をヘッダーで囲むこの手法は、一般にデータのカプセル化と呼ばれます。 図 1 は、NetX のレイヤー化の例を示し、図 2 は、送信される UDP データのデータ カプセル化を示しています。

![プロトコルのレイヤー化](./media/user-guide/protocol-layering.png)

**図 1. プロトコルのレイヤー化**

![UDP データのカプセル化](./media/user-guide/udp-data-encapsulation.png)

**図 2. UDP データのカプセル化**

## <a name="packet-pools"></a>パケット プール

パケットを高速かつ決定論的な方法で割り当てることは、常に、リアルタイム ネットワーク アプリケーションの課題です。 これを念頭に置いて、NetX では、固定サイズのネットワーク パケットの複数のプールを作成および管理する機能が提供されています。

NetX パケット プールは固定サイズのメモリ ブロックで構成されているため、内部断片化の問題は発生しません。 もちろん、断片化によって本質的に非決定論的な動作が発生します。

さらに、NetX パケットを割り当てて解放するために必要な時間は、単純なリンクリスト操作と同等です。 さらに、使用可能な一覧の先頭でパケットの割り当てと割り当て解除が行われます。 これにより、可能なリンク リストの処理が最速になります。

通常、固定サイズのパケット プールの主な欠点は、柔軟性の欠如です。 最悪の場合の受信パケットも処理できる最適なパケット ペイロード サイズを判断することは、困難な作業です。 NetX パケットは、"*パケット チェーン*" と呼ばれるオプションの機能を使用してこの問題に対処します。 実際のネットワーク パケットは、互いにリンクされた 1 つ以上の NetX パケットで構成されている可能性があります。 また、パケット ヘッダーはパケットの先頭へのポインターを保持します。 プロトコルが追加されると、このポインターは単純に後方に移動されて、新しいヘッダーがデータの前に直接書き込まれます。 柔軟なパケット テクノロジを使用しない場合、スタックは別のバッファーを割り当て、新しいヘッダーを使用して新しいバッファーにデータをコピーする必要があります。これは、負荷の高い処理です。

各パケットのペイロード サイズは特定のパケット プールに対して固定されているため、ペイロード サイズを超えるアプリケーション データでは、複数のパケットが連結されている必要があります。 パケットにユーザー データを入力する場合は、アプリケーションでサービス ***nx_packet_data_append*** を使用する必要があります。 このサービスによって、アプリケーション データがパケットに移動されます。 パケットがユーザー データを保持するのに十分でない場合は、ユーザー データを格納するための追加のパケットが割り当てられます。 パケット チェーンを使用するには、ドライバーがチェーン化されたパケットとの間で送受信できる必要があります。

各 NetX パケット メモリ プールは、パブリック リソースです。 NetX では、パケット プールの使用方法に関する制約はありません。

### <a name="packet-pool-memory-area"></a>パケット プールのメモリ領域
パケット プールのメモリ領域は、作成時に指定されます。 ThreadX オブジェクトと NetX オブジェクトの他のメモリ領域と同様に、ターゲットのアドレス空間内のどこにでも配置できます。 アプリケーションに非常に高い柔軟性が提供されるため、これは重要な機能です。 たとえば、ネットワーク バッファー用に高速メモリ領域がある通信製品を考えます。 このメモリ領域を NetX パケット メモリ プール内に作成することで、この領域を簡単に利用できます。

### <a name="creating-packet-pools"></a>パケット プールの作成
パケット プールは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。 NetX アプリケーションのパケット メモリ プールの数に制限はありません。

### <a name="packet-header-nx_packet"></a>パケット ヘッダー NX_PACKET
既定では、NetX ではパケット ペイロード領域の直前にパケット ヘッダーが配置されます。 パケット メモリ プールは基本的に一連のパケットで、ヘッダーの直後にパケット ペイロードが続きます。 パケット ヘッダー (***NX_PACKET***) とパケット プールのレイアウトを図 3 に示します。

ゼロ コピー操作を実行できるネットワーク デバイス ドライバーでは、通常、パケット ペイロード領域の開始アドレスが DMA ロジックにプログラミングされます。 特定の DMA エンジンでは、ペイロード領域にアラインメントの要件があります。

> [!IMPORTANT]
> *パケットの送信が完了したときに、ネットワーク ドライバーで ***nx_packet_transmit_release** _ 関数を呼び出す必要があります。 この関数によって、パケットが使用可能なプールに実際に戻される前に、TCP 出力キューに含まれていないことが確認されます。 この関数の呼び出しに失敗すると、予期しない動作になる可能性があります。_

![パケット ヘッダーとパケット プールのレイアウト](./media/user-guide/packet-header-packet-pool-layout.png)

**図 3. パケット ヘッダーとパケット プールのレイアウト**

パケット ヘッダーのフィールドは、次の表に示すように定義されます。 この表は、*NX_PACKET* 構造のすべてのメンバーの包括的な一覧ではないことに注意してください。

| パケット ヘッダー          | 目的                                                                                                                                                                                                                                                                                                                            |
|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *nx_packet_pool_owner*   | このフィールドは、この特定のパケットを所有するパケット プールを指します。 パケットが解放されると、この特定のプールに解放されます。 各パケット内のプール所有権に基づいて、データグラムが複数のパケット プールの複数のパケットにまたがる場合があります。                                                         |
| *nx_packet_next*         | このフィールドは、同じフレーム内の次のパケットを指します。 NULL の場合、フレームに含まれる追加のパケットはありません。 |
| *nx_packet_last*         | このフィールドは、同じネットワーク パケット内の最後のパケットを指します。 NULL の場合、このパケットはネットワーク パケット全体を表します。  |
| *nx_packet_length*       | このフィールドには、ネットワーク パケット全体の合計バイト数が含まれます。これには、*nx_packet_next* メンバーによって連結されているすべてのパケットの合計バイト数が含まれます。 |
| *nx_packet_ip_interface* | このフィールドは、インターフェイス ドライバーによって、また送信パケットのために NetX によって受信されるときにパケットに割り当てられるインターフェイス制御ブロックです。 インターフェイス制御ブロックはインターフェイスを記述します。たとえば、ネットワーク アドレス、MAC アドレス、IP アドレス、インターフェイスの状態 (リンクが有効、物理マッピングが必要、など) を表します。 |
| *nx_packet_data_start*   | このフィールドは、このパケットの物理ペイロード領域の開始位置を示します。 NX_PACKET ヘッダーの直後に配置する必要はありませんが、これが ***nx_packet_pool_create*** サービスの既定の設定です。 |
| *nx_packet_data_end*     | このフィールドは、このパケットの物理ペイロード領域の最後を指しています。 このフィールドと nx_packet_data_start フィールドの差は、ペイロード サイズを表します。 |
| *nx_packet_prepend_ptr*  | このフィールドは、パケット データ (プロトコル ヘッダーまたは実際のデータ) が、パケット ペイロード領域内の既存のパケット データ (存在する場合) の前に追加される場所を指します。 *nx_packet_data_start* ポインターの位置以上で、*nx_packet_append_ptr* ポインター以下である必要があります。  *NetX では、パフォーマンス上の理由から、パケットが伝送のために NetX サービスに渡されるときに、先頭のポインターがロング ワード単位で揃えたアドレスを指していることを前提としています。* |
| *nx_packet_append_ptr*    | このフィールドは、現在パケット ペイロード領域にあるデータの末尾を指します。 これは、*nx_packet_prepend_ptr* と *nx_packet_data_end* によって示されるメモリ位置の間にある必要があります。 このフィールドと *nx_packet_prepend_ptr* フィールドの差は、このパケット内のデータの量を表します。 |
| *nx_packet_fragment_next* | このフィールドは、パケット全体を再アセンブルできるようになるまで、断片化されたパケットを保持するために使用されます。 |
| *nx_packet_pad*           | このフィールドでは、必要なアラインメント要件を達成するために、4 バイト ワードの埋め込みの長さを定義します。 *NX_PACKET_HEADER_PAD* が定義されていない場合、このフィールドは削除されます。 |
|  |  |

### <a name="packet-header-offsets"></a>パケット ヘッダーのオフセット

ヘッダーのサイズを格納するのに十分な領域を確保するために、パケット ヘッダーのサイズが定義されています。 *nx_packet_allocate* サービスは、パケットを割り当て、指定されたパケットの種類に従ってパケット内の先頭のポインターを調整するために使用されます。 パケットの種類によって、プロトコルのデータの前にプロトコル ヘッダー (UDP、TCP、ICMP など) を挿入するために必要なオフセットが NetX に示されます。

パケット内の IP ヘッダーと物理層 (イーサネット) ヘッダーを考慮するために、NetX で次の種類が定義されています。 後者の場合は、必要な 4 バイトのアラインメントを考慮して、16 バイトであると想定されます。 IP ネットワークのパケットを割り当てるために、アプリケーション向けに NetX で IP パケットが引き続き定義されています。 次の表に定義されている記号を示します。

| パケットの種類   | 値 |
|---------------|-------|
| NX_IP_PACKET  | 0x24  |
| NX_UDP_PACKET | 0x2c  |
| NX_TCP_PACKET | 0x38  |
|               |       |

### <a name="pool-capacity"></a>プールの容量
パケット プール内のパケット数は、ペイロード サイズと、パケット プール作成サービスに渡されるメモリ領域内の合計バイト数と相関しています。 プールの容量は、パケット サイズ (NX_PACKET ヘッダーのサイズ、ペイロード サイズ、適切なアラインメントなど) で、指定されたメモリ領域の合計バイト数を除算して計算されます。

### <a name="thread-suspension"></a>スレッドの中断
空のプールからのパケットを待機している間に、アプリケーション スレッドが停止する場合があります。 パケットがプールに返されると、停止されていたスレッドにこのパケットが割り当てられ、再開されます。

同じパケット プールで複数のスレッドが停止された場合、それらは停止された順序で再開されます (FIFO)。

### <a name="pool-statistics-and-errors"></a>プールの統計情報とエラー
有効にすると、NetX パケット管理ソフトウェアの **Errors** によって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計情報とエラー レポートがパケット プール向けに保持されます。

* プール内の合計パケット数
* プール内の空きパケット数
* プールの空の割り当て要求
* プールの空の割り当て保留
* 無効なパケットの解放

これらの統計情報およびエラー レポートはすべて、プール内の合計パケット数と空きパケット数を除いて、***NX_DISABLE_PACKET_INFO** _ が定義されていない限り、NetX ライブラリに組み込まれています。 このデータは、アプリケーションで _ *_nx_packet_pool_info_get_** サービスと共に使用できます。

### <a name="packet-pool-control-block-nx_packet_pool"></a>パケット プール制御ブロック NX_PACKET_POOL

各パケット メモリ プールの特性は、その制御ブロックに含まれています。 ここには、空きパケットのリンク リスト、空きパケットの数、このプール内のパケットのペイロード サイズなどの有用な情報が含まれています。 この構造体は *nx_api.h* ファイルで定義されています。

パケット プール制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。

## <a name="ip-protocol"></a>IP プロトコル

NetX のインターネット プロトコル (IP) コンポーネントは、インターネット上で IP パケットを送受信する役割を担います。 このコンポーネントは、NetX では、基盤となるネットワーク ドライバーを使用して、TCP、UDP、ICMP、および IGMP メッセージの送信および受信を最終的に担います。

NetX は IP プロトコルをサポートします (RFC 791)

### <a name="ip-addresses"></a>IP アドレス

インターネット上の各ホストには、IP アドレスと呼ばれる 32 ビットの一意の識別子があります。 図 4 に示すように、IP アドレスには 5 つのクラスがあります。 5 つの IP アドレス クラスの範囲は次のとおりです。

| クラス | Range                        |
|-------|------------------------------|
| A     | 0.0.0.0 ～ 127.255.255.255   |
| B     | 128.0.0.0 ～ 191.255.255.255 |
| C     | 192.0.0.0 ～ 223.255.255.255 |
| D     | 224.0.0.0 ～ 239.255.255.255 |
| E     | 240.0.0.0 ～ 247.255.255.255 |

**7 ビット 24 ビット**

![IP アドレスの構造](./media/user-guide/ip-address-structure.png)

**図 4. IP アドレスの構造**

アドレス指定には、"*ユニキャスト*"、"*ブロードキャスト*"、"*マルチキャスト*" の 3 つの種類があります。 ユニキャスト アドレスは、インターネット上の特定のホストを識別する IP アドレスです。 ユニキャスト アドレスには、送信元または宛先の IP アドレスを指定できます。 ブロードキャスト アドレスは、特定のネットワークまたはサブネットワーク上のすべてのホストを識別し、宛先アドレスとしてのみ使用できます。 ブロードキャスト アドレスは、アドレスのホスト ID 部分を 1 に設定することによって指定します。 マルチキャスト アドレス (クラス D) は、インターネット上のホストの動的なグループを指定します。 マルチキャスト グループのメンバーは、いつでも参加し離脱することができます。

> [!IMPORTANT]
> *UDP over IP のようなコネクションレス プロトコルでのみ、ブロードキャストと、マルチキャスト グループの制限付きブロードキャスト機能を利用できます。*

> [!IMPORTANT]
> *マクロ* IP_ADDRESS *は* ***nx_api.h** _ で定義されています。 これにより、ピリオドではなくコンマを使用して IP アドレスを簡単に指定できます。 たとえば、図 4 に示すように、IP_ADDRESS(128,0,0,0)_ では最初のクラス B アドレスが指定されます。*

### <a name="ip-gateway-address"></a>IP ゲートウェイ アドレス

ネットワーク ゲートウェイは、ネットワーク上のホストが、ローカル ドメインの外部の宛先に送信するパケットをリレーするのを支援します。 送信先が近隣ノードのいずれかなのか、または、事前にプログラミングされた静的ルーティング テーブルを使用するのか、といった、送信先となるネクスト ホップに関するいくつかの情報が各ノードにあります。 ただし、これらのアプローチが失敗した場合、ノードはパケットを既定のゲートウェイに転送する必要があります。ここには、パケットを送信先にルーティングする方法についてより詳細な情報があります。 既定のゲートウェイは、IP インスタンスに接続されている物理インターフェイスの 1 つを介して直接アクセスできる必要があることに注意してください。 アプリケーションは ***nx_ip_gateway_address_set*** を呼び出して、IP の既定のゲートウェイ アドレスを構成します。

### <a name="ip-header"></a>IP ヘッダー

インターネット上で送信されるすべての IP パケットについて、IP ヘッダーが必要です。 上位レベルのプロトコル (UDP、TCP、ICMP、または IGMP) がパケットを送信するために IP コンポーネントを呼び出すと、IP 送信モジュールによってデータの前に IP ヘッダーが配置されます。 逆に、IP パケットをネットワークから受信した場合、IP コンポーネントでは、上位レベルのプロトコルにパケットを配信する前に IP ヘッダーを削除します。 図 5 は、IP ヘッダーの形式を示しています。

![IP ヘッダーの形式](./media/user-guide/ip-header-format.png)

**図 5. IP ヘッダーの形式**

> [!IMPORTANT]
> *TCP/IP 実装のすべてのヘッダーは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに配置されます。たとえば、IP ヘッダーの 4 ビットのバージョンと 4 ビットのヘッダー長は、ヘッダーの最初のバイトに配置する必要があります。*

IP ヘッダーのフィールドは次のように定義されています。

**IP ヘッダー フィールドの目的**

"***4 ビットのバージョン***" このフィールドには、このヘッダーが表す IP のバージョンが含まれています。 NetX でサポートされている IP バージョン 4 では、このフィールドの値は 4 です。

"***4 ビットのヘッダー長***" このフィールドは、IP ヘッダー内の 32 ビット ワードの数を指定します。 オプションのワードが存在しない場合、このフィールドの値は 5 になります。

"***8 ビットのサービス タイプ (TOS)***" このフィールドは、この IP パケットに要求されるサービスの種類を指定します。 有効な要求を次に示します。

| **TOS 要求**     | **Value** |
| ------------------- | --------- |
| Normal              | 0x00      |
| 最小遅延       | 0x10      |
| 最大データ        | 0x08      |
| 最大の信頼性 | 0x04      |
| 最小コスト        | 0x02      |

"***16 ビットの合計長***" このフィールドには、IP ヘッダーを含む IP データグラムの合計長がバイト単位で表示されます。 IP データグラムは、TCP/IP インターネットで検出された情報の基本単位です。 これには、データに加えて、宛先と送信元のアドレスが含まれます。 これは 16 ビットのフィールドであるため、IP データグラムの最大サイズは 65,535 バイトです。

"***16 ビットの ID***" このフィールドは、ホストから送信された各 IP データグラムを一意に識別するために使用される番号です。 通常、この番号は IP データグラムの送信後にインクリメントされます。 これは、受信した IP パケット フラグメントをアセンブルする場合に特に便利です。

"***3 ビットのフラグ***" このフィールドには IP の断片化に関する情報が含まれています。 ビット 14 は "フラグメント禁止" ビットです。 このビットが設定されている場合、発信 IP データグラムは断片化されません。 ビット 13 は "フラグメント継続" ビットです。 このビットが設定されている場合は、断片化が継続されます。 このビットがクリアされている場合、これは IP パケットの最後のフラグメントです。

**IP ヘッダー フィールドの目的**

"***13 ビットのフラグメント オフセット***" このフィールドには、フラグメント オフセットの上位 13 ビットが含まれます。 このため、フラグメント オフセットは 8 バイト境界でのみ許可されます。 断片化された IP データグラムの最初のフラグメントには、"フラグメント継続" ビットが設定され、オフセットは 0 になります。

"***8 ビットの Time to Live (TTL)***" このフィールドには、このデータグラムが通過できるルーターの数が含まれます。これにより、データグラムの有効期間が制限されます。

"***8 ビットのプロトコル***" このフィールドでは、IP データグラムを使用しているプロトコルを指定します。 有効なプロトコルとその値の一覧を次に示します。

| Protocol | 値 |
|----------|-------|
| ICMP     | 0x01  |
| IGMP     | 0x02  |
| TCP      | 0X06  |
| UDP      | 0X11  |
|          |       |


"***16 ビットのチェックサム***" このフィールドには、IP ヘッダーのみを対象とする 16 ビットのチェックサムが含まれています。 上位レベルのプロトコルには、IP ペイロードに対応する追加のチェックサムがあります。

"***32 ビットの送信元 IP アドレス***" このフィールドには送信元の IP アドレスが含まれます。これは常にホスト アドレスです。

"***32 ビットの宛先 IP アドレス***" このフィールドには、アドレスがブロードキャストまたはマルチキャスト アドレスの場合、単一または複数の受信側の IP アドレスが含まれます。

### <a name="creating-ip-instances"></a>IP インスタンスの作成

IP インスタンスは、アプリケーション スレッドによる初期化中またはランタイムに作成されます。 内部 IP スレッドの初期 IP アドレス、ネットワーク マスク、既定のパケット プール、メディア ドライバー、およびメモリと優先順位は、*nx_ip_create* サービスによって定義されます。 IP アドレスが無効なアドレス (0.0.0.0) に設定されている IP インスタンスをアプリケーションで初期化する場合は、後で RARP や、DHCP または同様のプロトコルを使用して、インターフェイス アドレスが手動構成によって解決されることを前提としています。

複数のネットワーク インターフェイスがあるシステムでは、*nx_ip_create* を呼び出すときにプライマリ インターフェイスが指定されます。 *nx_ip_interface_attach* を呼び出すことによって、追加の各インターフェイスを同じ IP インスタンスにアタッチできます。 このサービスでは、ネットワーク インターフェイスに関する情報 (IP アドレス、ネットワーク マスクなど) をインターフェイス制御ブロックに格納し、ドライバー インスタンスを IP インスタンスのインターフェイス制御ブロックに関連付けます。 ドライバーでは、データ パケットが受信されたら、IP 受信ロジックに転送する前に、インターフェイス情報を NX_PACKET 構造体に格納する必要があります。 IP インスタンスは、インターフェイスをアタッチする前に既に作成されている必要があることに注意します。

 ### <a name="ip-send"></a>IP 送信
 NetX の IP 送信処理は非常に合理化されています。

パケット内の先頭のポインターは、IP ヘッダーを格納するために後方に移動されます。 IP ヘッダーが完了し (呼び出し元のプロトコル レイヤーで指定されたすべてのオプションが使用されます)、IP チェックサムがインラインで計算され、関連付けられているネットワーク ドライバーにパケットがディスパッチされます。 また、送信の断片化は、IP 送信処理内からも調整されます。

IP で宛先 IP アドレスに物理マッピングが必要な場合、NetX で ARP 要求が開始されます。

> [!IMPORTANT]
> *IP 接続では、キューに格納されているパケットの数が ARP キューの深さ (* *シンボル **NX_ARP_MAX_QUEUE_DEPTH** によって定義されている) を超えない限り、IP アドレス解決 (つまり、物理マッピング) を必要とするパケットは ARP キューにエンキューされます。* *キューの深さに達した場合、NetX ではキューの最も古いパケットが削除され、エンキューされた残りのアドレスの解決を待機し続けます。一方、ARP エントリが解決されない場合、ARP エントリの保留中のパケットは、ARP エントリのタイムアウト時に解放されます。*

複数のネットワーク インターフェイスがあるシステムでは、NetX は宛先 IP アドレスに基づいてインターフェイスを選択します。 選択プロセスには、次の手順が適用されます。

1. 宛先アドレスが IP ブロードキャストまたはマルチキャストで、有効な発信インターフェイスが指定されている場合は、そのインターフェイスが使用されます。 それ以外の場合は、最初の物理インターフェイスが使用されます。

2. 宛先アドレスが静的ルーティング テーブルで見つかった場合は、そのゲートウェイに関連付けられているインターフェイスが使用されます。

3. 宛先がオンリンクの場合は、オンリンク インターフェイスが使用されます。

4. 宛先アドレスがループバック アドレス 127.0.0.1 の場合、ループバック インターフェイスが使用されます。

5. 既定のゲートウェイが適切に構成されている場合は、既定のゲートウェイに関連付けられているインターフェイスを使用してパケットを転送します。

6. 上記のすべてが失敗した場合、出力パケットはドロップされます。

### <a name="ip-receive"></a>IP 受信

IP 受信処理は、ネットワーク ドライバーまたは内部 IP スレッドから呼び出されます (遅延受信パケット キューのパケットを処理するため)。 IP 受信処理では、プロトコル フィールドを調べて、適切なプロトコル コンポーネントにパケットをディスパッチしようとします。 パケットが実際にディスパッチされる前に、IP ヘッダーの前に先頭のポインターを移動することで、IP ヘッダーが削除されます。

IP 受信処理では、断片化された IP パケットも検出されて、断片化が有効になっている場合に再アセンブルするために必要な手順が実行されます。 断片化が必要でも有効になっていない場合、パケットはドロップされます。

NetX では、パケットに指定されたインターフェイスに基づいて、適切なネットワーク インターフェイスが決定されます。 パケット インターフェイスが NULL の場合、NetX では既定でプライマリ インターフェイスに設定されます。 これは、NetX のレガシ イーサネット ドライバーとの互換性を保証するために行われます。

### <a name="raw-ip-send"></a>生 IP 送信

生 IP パケットは、NetX によって直接はサポート (および処理) されない上位層プロトコル ペイロードを含む IP フレームです。 生のパケットを使用すると、開発者は独自の IP ベースのアプリケーションを定義できます。 生 IP パケット処理が _*_nx_ip_raw_packet_enabled_*_ サービスで有効になっている場合、アプリケーションでは ***nx_ip_raw_packet_send** _ サービスを使用して生 IP パケットを直接送信できます。 宛先アドレスがマルチキャストまたはブロードキャスト アドレスの場合でも、NetX では既定で最初の (プライマリ) インターフェイスが設定されます。 そのため、このようなパケットをセカンダリ インターフェイスで送信するには、アプリケーションで _ *_nx_ip_raw_packet_interface_send_** サービスを使用して、発信パケットに使用する送信元アドレスを指定する必要があります。

### <a name="raw-ip-receive"></a>生 IP 受信

生 IP パケット処理が有効になっている場合、アプリケーションは ***nx_ip_raw_packet_receive** _ サービスを通じて生 IP パケットを受信する可能性があります。 すべての受信パケットは、IP ヘッダーで指定されたプロトコルに従って処理されます。 プロトコルで UDP、TCP、IGMP、ICMP のいずれかが指定されている場合、NetX ではパケット プロトコルの種類に適したハンドラーを使用してパケットを処理します。 プロトコルがこれらのプロトコルのいずれかではなく、生 IP 受信が有効になっている場合、受信パケットは生パケット キューに格納されて、アプリケーションで _ *_nx_ip_raw_packet_receive_** サービスを介して受信されるのを待機します。 また、生 IP パケットを待機している間に、オプションのタイムアウトでアプリケーション スレッドが停止されることもあります。

### <a name="default-packet-pool"></a>既定のパケット プール

各 IP インスタンスには、作成時に既定のパケット プールが割り当てられます。 このパケット プールは、ARP、RARP、ICMP、IGMP、さまざまな TCP 制御パケット (SYN、ACK など) にパケットを割り当てるために使用されます。 NetX がパケットを割り当てる必要があるときに既定のパケット プールが空の場合、NetX で特定の操作を中止することが必要になる場合があり、可能な場合はエラー メッセージを返します。

### <a name="ip-helper-thread"></a>IP ヘルパー スレッド

各 IP インスタンスには、ヘルパー スレッドがあります。 このスレッドは、すべての遅延パケット処理とすべての周期処理を担います。 IP ヘルパー スレッドは ***nx_ip_create*** で作成されます。 ここで、スレッドのスタックと優先順位が指定されます。 IP ヘルパー スレッドでの最初の処理は、IP 作成サービスに関連付けられているネットワーク ドライバーの初期化を完了することである点に注意してください。 ネットワーク ドライバーの初期化が完了すると、ヘルパー スレッドはパケットと定期的な要求を処理するために無限ループを開始します。

> [!IMPORTANT]
> *IP ヘルパー スレッド内で予期しない動作が見られた場合、最初のデバッグ手順は、IP 作成サービス中にスタック サイズを増やすことです。スタックが小さすぎる場合に、IP ヘルパー スレッドによってメモリが上書きされている可能性があります。これにより、通常とは異なる問題が発生することがあります。*

### <a name="thread-suspension"></a>スレッドの中断

生 IP パケットを受信しようとしているときに、アプリケーション スレッドが中断されることがあります。 生のパケットを受信すると、中断された最初のスレッドに新しいパケットが渡され、そのスレッドが再開されます。 パケットを受信するためのすべての NetX サービスには、省略可能な中断タイムアウトがあります。 パケットが受信されるか、タイムアウトが経過すると、適切な完了ステータスでアプリケーション スレッドが再開されます。

### <a name="ip-statistics-and-errors"></a>IP の統計情報とエラー

有効にした場合、NetX では、アプリケーションに役立つ可能性のあるいくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP インスタンスごとに保持されます。

- 送信された IP パケットの合計数
- 送信された IP バイトの合計数
- 受信した IP パケットの合計数
- 受信した IP バイトの合計数
- 無効な IP パケットの合計数
- ドロップされた IP 受信パケットの合計数
- IP 受信チェックサム エラーの合計数
- ドロップされた IP 送信パケットの合計数
- 送信された IP フラグメントの合計数
- 受信した IP フラグメントの合計数

これらの統計およびエラー レポートはすべて、***nx_ip_info_get*** サービスを使用してアプリケーションで利用できます。

### <a name="ip-control-block-nx_ip"></a>IP 制御ブロック NX_IP

各 IP インスタンスの特性は、制御ブロックにあります。 これには、各ネットワーク デバイスの IP アドレスとネットワーク マスク、近隣 IP および物理ハードウェア アドレス マッピングのテーブルなどの有用な情報が含まれています。 この構造体は ***nx_api.h*** で定義されています。IP インスタンスの制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。

### <a name="static-ip-routing"></a>静的 IP ルーティング

静的ルーティング機能を使用すると、アプリケーションでは、特定のネットワーク外の宛先 IP アドレスに対して IP ネットワークとネクスト ホップ アドレスを指定できます。 静的ルーティングが有効になっている場合、NetX は静的ルーティング テーブルを検索し、送信するパケットの宛先アドレスと一致するエントリを検索します。 一致するものが見つからない場合、NetX は物理インターフェイスの一覧を検索し、宛先 IP アドレスとネットワーク マスクに基づいて、送信元 IP アドレスとネクスト ホップ アドレスを選択します。 IP インスタンスに接続されているネットワーク ドライバーのどの IP アドレスとも宛先が一致しない場合、NetX は、既定のゲートウェイに直接接続されているインターフェイスを選択し、送信元アドレスとしてインターフェイスの IP アドレスを使用し、ネクスト ホップとして既定のゲートウェイを使用します。

***nx_ip_static_route_add*** と ***nx_ip_static_route_delete** _ サービスをそれぞれ使用して、静的ルーティング テーブルのエントリを追加および削除できます。 静的ルーティングを使用するには、_ *_NX_ENABLE_IP_STATIC_ROUTING_** を定義して、ホスト アプリケーションでこの機能を有効にする必要があります。

> [!IMPORTANT]
> *静的ルーティング テーブルにエントリを追加するときに、NetX では、指定された宛先アドレスに一致するエントリがテーブル内に既に存在するかどうかを確認します。存在する場合は、ネットワーク マスクの中で、より小さいネットワーク (長いプレフィックス) のエントリを優先します。*

### <a name="ip-fragmentation"></a>IP の断片化

ネットワーク デバイスには、送信パケットのサイズに制限がある場合があります。 この制限は、最大転送単位 (MTU) と呼ばれます。 IP の MTU は、IP パケットを断片化せずにリンク レイヤー ドライバーで送信できる最大 IP フレーム サイズです。 デバイス ドライバーの初期化フェーズでは、ドライバー モジュールはサービス ***nx_ip_interface_mtu_set*** を介して IP の MTU サイズを構成する必要があります。

推奨されませんが、アプリケーションでは、デバイスでサポートされている基になる IP MTU よりも大きいデータグラムが生成される場合があります。 このような IP データグラムを送信する前に、IP レイヤーはこれらのパケットを断片化する必要があります。 断片化された IP フレームを受信する場合、受信側は同じ断片化 ID を持つ断片化されたすべての IP フレームを格納し、順番に再アセンブルする必要があります。 IP 受信ロジックがすべてのフラグメントを収集して元の IP フレームを時間内に復元できない場合は、すべてのフラグメントが解放されます。 このようなパケット損失を検出して回復する作業は、上位層プロトコルが担います。

IP の断片化と再アセンブリの操作をサポートするために、システム デザイナーは、***nx_ip_fragment_enable*** サービスを使用して NetX の IP の断片化機能を有効にする必要があります。 この機能が有効になっていない場合は、断片化された受信 IP パケットだけでなく、ネットワーク ドライバーの MTU を超えるパケットも破棄されます。

> [!IMPORTANT]
> *IP 断片化ロジックは、NetX ライブラリを構築するときに、*  ***NX_DISABLE_FRAGMENTATION** _ _を定義することで完全に削除できます。 これにより、NetX のコード サイズを減らすことができます。*

## <a name="address-resolution-protocol-arp-in-ip"></a>IP のアドレス解決プロトコル (ARP)

アドレス解決プロトコル (ARP) は、32 ビットの IP アドレスを、基になる物理メディアの IP アドレスに動的にマッピングする役割を担います (RFC 826)。 イーサネットは最も一般的な物理メディアであり、48 ビットのアドレスをサポートしています。 ARP の必要性は、***nx_ip_create*** サービスに提供されるネットワーク ドライバーによって決まります。 物理マッピングが必要な場合、ネットワーク ドライバーはインターフェイス構造の ***nx_interface_address_mapping_needed*** にフラグを設定する必要があります。

### <a name="arp-enable"></a>ARP 有効化
ARP を正常に機能させるには、最初に ***nx_arp_enable*** サービスを使用してアプリケーションで有効化する必要があります。 このサービスでは、ARP 有効化サービスに提供されるメモリからの ARP キャッシュ領域の作成など、ARP 処理用にさまざまなデータ構造が設定されます。

### <a name="arp-cache"></a>ARP キャッシュ
ARP キャッシュは、内部 ARP マッピング データ構造の配列として表示できます。 各内部構造によって、IP アドレスと物理ハードウェア アドレスの間の関係を維持することができます。 さらに、各データ構造にリンク ポインターがあるため、複数のリンク リストに含めることができます。

ARP テーブルにマッピングが存在する場合、アプリケーションでは、サービス ***nx_arp_ip_address_find** _ を使用してハードウェア MAC アドレスを指定することにより、ARP キャッシュから IP アドレスを検索できます。 同様に、サービス _ *_nx_arp_hardware_address_find_** では、指定された IP アドレスの MAC アドレスが返されます。


### <a name="arp-dynamic-entries"></a>ARP 動的エントリ

既定では、ARP 有効化サービスは、ARP キャッシュ内のすべてのエントリを、使用可能な動的 ARP エントリの一覧に配置します。 マップされていない IP アドレスへの送信要求が検出されると、このリストから動的 ARP エントリが NetX によって割り当てられます。 割り当てが完了すると、ARP エントリがセットアップされ、ARP 要求が物理メディアに送信されます。

動的エントリは、サービス ***nx_arp_dynamic_entry_set*** で作成することもできます。

> [!IMPORTANT]
> *すべての動的 ARP エントリが使用されている場合、最も長く使用されていない ARP エントリが新しいマッピングに置き換えられます。*

### <a name="arp-static-entries"></a>ARP 静的エントリ
アプリケーションでは、***nx_arp_static_entry_create*** サービスを使用して静的 ARP マッピングを設定することもできます。 このサービスは、動的 ARP エントリ リストから ARP エントリを割り当て、アプリケーションから提供されたマッピング情報を使用して静的リストに配置します。 静的 ARP エントリは、再利用またはエージングの対象になりません。 アプリケーションでは、サービス ***nx_arp_static_entry_delete*** を使用して静的エントリを削除できます。
ARP テーブル内のすべての静的エントリを削除するために、アプリケーションでサービス ***nx_arp_static_entries_delete*** が使用されることがあります。

### <a name="automatic-arp-entry"></a>自動 ARP 入力
NetX は、ARP 要求に対するピアの応答後に、ピアの IP/MAC マッピングを記録します。 NetX には、ネットワークからの要請されていない ARP 要求に基づいて、ピア IP/MAC アドレスのマッピングを記録する自動 ARP 入力機能も実装されています。 この機能を使用すると、ARP テーブルにピア情報が入力されるため、ARP 要求/応答サイクルを実行するために必要な遅延を減らすことができます。 ただし、自動 ARP を有効にした場合の欠点は、ローカル リンク上に多数のノードがあるビジー状態のネットワークでは、ARP テーブルがすぐにいっぱいになる傾向があることです。これが最終的には ARP エントリの置換につながります。

この機能は、既定で有効になっています。 無効にするには、定義されたシンボル ***NX_DISABLE_ARP_AUTO_ENTRY*** を使用して NetX ライブラリをコンパイルする必要があります。

### <a name="arp-messages"></a>ARP メッセージ

前に説明したように、IP アドレスにマッピングが必要であることが IP タスクによって検出されると、ARP 要求メッセージが送信されます。 ARP 要求は、対応する ARP 応答を受信するまで、(***NX_ARP_UPDATE_RATE** _ 秒ごとに) 定期的に送信されます。 ARP の試行が破棄される前に、合計で _ *_NX_ARP_MAXIMUM_RETRIES_** 回の ARP 要求が行われます。 ARP 応答を受信すると、関連付けられている物理アドレス情報がキャッシュ内の ARP エントリに格納されます。

マルチホーム システムの場合、NetX では、指定された宛先アドレスに基づいて ARP 要求と応答を送信するインターフェイスが決定されます。

> [!IMPORTANT]
> *送信 IP パケットは、NetX が ARP 応答を待機している間、キューに登録されます。キューに置かれる発信 IP* *パケットの数は、定数*  ***NX_ARP_MAX_QUEUE_DEPTH*** によって定義されます。

NetX は、ローカル IP ネットワーク上の他のノードからの ARP 要求にも応答します。 ARP 要求を受信するインターフェイスの現在の IP アドレスと一致する外部 ARP 要求が行われると、NetX は、現在の物理アドレスを含む ARP 応答メッセージを構築します。

イーサネットの ARP 要求と応答の形式を図 6 に示し、次に説明します。

| 要求/応答フィールド       | 目的    |
|------------------------------|-----------------|
| イーサネットの宛先アドレス | この 6 バイトのフィールドには、ARP 応答の宛先アドレスが格納され、ARP 要求の場合はブロードキャスト (すべて) になります。 このフィールドは、ネットワーク ドライバーによって設定されます。 |
| イーサネットの送信元アドレス      | この 6 バイトのフィールドには、ARP 要求または応答の送信者のアドレスが格納され、ネットワーク ドライバーによって設定されます。 |
| フレームの種類                   | この 2 バイトのフィールドには、存在するイーサネット フレームの種類が格納されます。ARP 要求と応答の場合、これは 0x0806 に相当します。 これは、ネットワーク ドライバーで設定される最後のフィールドです。 |
| ハードウェアの種類                | この 2 バイトのフィールドには、ハードウェアの種類が格納されます。イーサネットの場合は 0x0001 です。 |
| プロトコル タイプ                | この 2 バイトのフィールドには、プロトコルの種類が格納されます。IP アドレスの場合は 0x0800 です。 |
| ハードウェア サイズ                | この 1 バイトのフィールドには、ハードウェア アドレスのサイズが格納されます。イーサネット アドレスの場合は 6 です。 |


![ARP パケット形式](./media/user-guide/arp-packet-format.png)

**図 6. ARP パケット形式**

| 要求/応答フィールド | 目的  |
|---|---|
| プロトコル サイズ | この 1 バイトのフィールドには IP アドレスのサイズが格納されます。IP アドレスの場合は 4 です。  |
| オペレーション コード | この 2 バイトのフィールドには、この ARP パケットに対する操作が格納されます。 ARP 要求は 0x0001 の値で指定され、ARP 応答は 0x0002 の値で表されます。  |
| 送信者のイーサネット アドレス | この 6 バイトのフィールドには、送信者のイーサネット アドレスが格納されます。 |
| 送信者の IP アドレス | この 4 バイトのフィールドには、送信者の IP アドレスが格納されます。 |
| ターゲット イーサネット アドレス | この 6 バイトのフィールドには、ターゲットのイーサネット アドレスが格納されます。 |
| ターゲット IP アドレス | この 4 バイトのフィールドには、ターゲットの IP アドレスが格納されます。 |

> [!IMPORTANT]
> *ARP の要求と応答は、イーサネットレベルのパケットです。その他のすべての TCP/IP パケットは、IP パケット ヘッダーによってカプセル化されます。*

> [!IMPORTANT]
> *TCP/IP 実装のすべての ARP メッセージは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

### <a name="arp-aging"></a>ARP のエージング

NetX では、動的 ARP 入力の自動無効化がサポートされています。 ***NX_ARP_EXPIRATION_RATE** _ は、物理マッピングに対して確立された IP アドレスが有効な秒数を指定します。 有効期限が切れると、ARP キャッシュから ARP エントリが削除されます。 対応する IP アドレスへの送信を次に試行したときに、新しい ARP 要求が発生します。 _ *_NX_ARP_EXPIRATION_RATE_** を 0 に設定すると、ARP のエージングが無効になります。これは既定の構成です。

### <a name="arp-defend"></a>ARP の防御

ARP 要求または ARP 応答パケットが受信され、送信元の IP アドレスが同じで、このノードの IP アドレスと競合している場合、NetX によってそのアドレスに対する ARP 要求が防御として送信されます。 競合する ARP パケットが 10 秒以内に複数回受信された場合、NetX はそれ以上の防御パケットを送信しません。 既定の間隔は 10 秒で、***NX_ARP_DEFEND_INTERVAL** _ で再定義できます。 この動作は、RFC5227 の 2.4(c) で指定されたポリシーに従います。 Windows XP では ARP プローブの応答として ARP アナウンスが無視されるため、ユーザーは _*_NX_ARP_DEFEND_BY_REPLY_** を定義して、追加の防御として ARP 応答を送信できます。

### <a name="arp-statistics-and-errors"></a>ARP の統計情報とエラー

有効にすると、NetX ARP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP の ARP 処理ごとに保持されます。

- 送信された ARP 要求の合計数
- 受信した ARP 要求の合計数
- 送信された ARP 応答の合計数
- 受信した ARP 応答の合計数
- ARP 動的エントリの合計数
- ARP 静的エントリの合計数
- ARP 期限切れエントリの合計数
- ARP 無効メッセージの合計数

これらの統計およびエラー レポートはすべて、***nx_arp_info_get*** サービスを使用してアプリケーションで利用できます。

## <a name="reverse-address-resolution-protocol-rarp-in-ip"></a>IP の逆アドレス解決プロトコル (RARP)

逆アドレス解決プロトコル (RARP) は、ホストの 32 ビット IP アドレスのネットワーク割り当てを要求するためのプロトコルです (RFC 903)。 これは RARP 要求によって行われ、ネットワーク メンバーが RARP 応答でホスト ネットワーク インターフェイスに IP アドレスを割り当てるまで定期的に継続されます。 アプリケーションは、サービス ***nx_ip_create*** を使用して、IP インスタンスを IP アドレス 0 で作成します。 RARP がアプリケーションで有効化されている場合は、RARP プロトコルを使用して、IP アドレスが 0 のインターフェイスを介してアクセス可能なネットワーク サーバーから IP アドレスを要求できます。

### <a name="rarp-enable"></a>RARP 有効化

RARP を使用するには、アプリケーションで IP アドレスが 0 の IP インスタンスを作成してから、サービス ***nx_rarp_enable*** を使用して RARP を有効にする必要があります。 マルチホーム システムの場合は、IP インスタンスに関連付けられている少なくとも 1 つのネットワーク デバイスの IP アドレスが 0 である必要があります。 RARP の処理では、ネットワークに指定された IP アドレスを持つ有効な RARP 応答を受信するまで、IP アドレスを必要とする NetX システムの RARP 要求メッセージが定期的に送信されます。 この時点で、RARP 処理は完了します。

RARP は、有効化された後ですべてのインターフェイス アドレスが解決されると、自動的に無効になります。 アプリケーションは、サービス ***nx_rarp_disable*** を使用して、RARP を強制的に終了させることができます。

###  <a name="rarp-request"></a>RARP 要求

RARP 要求パケットの形式は、トピック「[ARP メッセージ](#arp-messages)」の図 6 に示されている ARP パケットとほぼ同じです。唯一の違いは、フレームの種類フィールドが 0x8035 で、*操作コード* フィールドが 3 で RARP 要求が指定されていることです。 前述のように、ネットワークで割り当てられた IP アドレスを持つ RARP 応答を受信するまで、RARP 要求は定期的に送信されます (***NX_RARP_UPDATE_RATE*** 秒ごと)。

> [!IMPORTANT]
> *TCP/IP 実装のすべての RARP メッセージは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

### <a name="rarp-reply"></a>RARP 応答

RARP 応答メッセージはネットワークから受信され、このホストに対するネットワーク割り当て IP アドレスが格納されています。 RARP 応答パケットの形式は、図 6 に示されている ARP パケットとほぼ同じです。 唯一の違いは、フレームの種類フィールドが 0x8035 で、*操作コード* フィールドは 4 で、RARP 応答を指定することです。 受信後に、IP アドレスが IP インスタンスで設定され、RARP の定期的な要求は無効になり、IP インスタンスで通常のネットワーク操作ができるようになります。

マルチホーム ホストでは、要求元のネットワーク インターフェイスに IP アドレスが適用されます。 まだ IP アドレスの割り当てを要求している他のネットワーク インターフェイスがある場合、すべてのインターフェイス IP アドレス要求が解決されるまで、定期的に RARP サービスが続行されます。

> [!IMPORTANT]
> *アプリケーションでは、RARP 処理が完了するまで IP インスタンスを使用しないようにします。**nx_ip_status_check** は、アプリケーションで RARP の完了を待機するために使用される場合があります。マルチホーム システムの場合、要求しているインターフェイスで RARP 処理が完了するまで、アプリケーションによってそのインターフェイスが使用されないようにします。セカンダリ デバイスの IP アドレスの状態は、**nx_ip_interface_status_check** サービスを使用して確認できます。*

### <a name="rarp-statistics-and-errors"></a>RARP の統計情報とエラー

有効にすると、NetX RARP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP の RARP 処理ごとに保持されます。

- 送信された RARP 要求の合計数
- 受信した RARP 応答の合計数
- RARP 無効メッセージの合計数

これらの統計およびエラー レポートはすべて、***nx_rarp_info_get*** サービスを使用してアプリケーションで利用できます。

## <a name="internet-control-message-protocol-icmp"></a>インターネット制御メッセージ プロトコル (ICMP)

IP のインターネット制御メッセージ プロトコル (ICMP) は、IP ネットワークのメンバー間でエラーおよび制御情報を渡すことに制限されています。

他のほとんどのアプリケーション レイヤー (TCP/IP など) メッセージと同様に、ICMP メッセージは ICMP プロトコルの指定を使用して IP ヘッダーでカプセル化されます。

### <a name="icmp-statistics-and-errors"></a>ICMP の統計情報とエラー

有効にした場合、NetX では、アプリケーションに役立つ可能性のあるいくつかの ICMP 統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP の ICMP 処理ごとに保持されます。

- 送信された ICMP ping の合計数
- ICMP ping タイムアウトの合計数
- 中断された ICMP ping スレッドの合計数
- 受信した ICMP ping 応答の合計数
- ICMP チェックサム エラーの合計数
- 未処理の ICMP メッセージの合計数

これらの統計およびエラー レポートはすべて、***nx_icmp_info_get*** サービスを使用してアプリケーションで利用できます。

### <a name="icmp-enable"></a>ICMP の有効化
NetX で ICMP メッセージを処理する前に、アプリケーションは ***nx_icmp_enable*** サービスを呼び出して ICMP 処理を有効にする必要があります。 この処理が完了すると、アプリケーションは ping 要求とフィールド受信 ping パケットを発行できるようになります。

### <a name="icmp-echo-request"></a>ICMP エコー要求
エコー要求は、通常、ホスト IP アドレスによって識別される、ネットワークにある特定ノードの存在を確認するために使用される ICMP メッセージの 1 つの種類です。 一般的な ping コマンドは、ICMP エコー要求/エコー応答メッセージを使用して実装されます。 特定のホストが存在する場合、そのネットワーク スタックは ping の要求と応答を ping 応答と共に処理します。 図 7 では、ICMP ping メッセージの形式について詳しく説明します。

![ICMP ping メッセージ](./media/user-guide/icmp-ping-message.png)

**図 7. ICMP ping メッセージ**

> [!IMPORTANT]
> *TCP/IP 実装のすべての ICMP メッセージは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

次の表に、ICMP ヘッダー形式について説明します。

| ヘッダー フィールド    | 目的 |
|-----------------|---------------------------------------------------|
| 種類            | このフィールドでは、ICMP メッセージを指定します (ビット 31-24)。 最も一般的なのは、0 のエコー応答と 8 のエコー要求です。 |
| コード            | このフィールドは、タイプ フィールドに固有のコンテキストです (ビット 23-16)。 エコー要求または応答の場合、コードは 0 に設定されます。 |
| Checksum        | このフィールドには、タイプ フィールドで始まる ICMP ヘッダー全体を含めた、ICMP メッセージの 1 の補数和の 16 ビット チェックサムが格納されます。 チェックサムを生成する前に、チェックサム フィールドはクリアされます。                 |
| 識別  | このフィールドには、ホストを識別する ID 値が格納されています。ホストは、ECHO REPLY のエコー要求から抽出された ID を使用する必要があります (ビット 31-16)。 |
| Sequence number | このフィールドには、ID 値が格納されています。ホストは、ECHO REPLY のエコー要求から抽出された ID を使用する必要があります (ビット 31-16)。 識別子フィールドとは異なり、この値は同じホストからの後続のエコー要求で変更されます (ビット 15-0)。 |


### <a name="icmp-echo-response"></a>ICMP エコー応答
ping 応答は、外部の ping 要求に応答して ICMP コンポーネントによって内部的に生成される別の種類の ICMP メッセージです。 ping 応答には、確認応答に加えて、ping 要求に指定されたユーザー データのコピーも含まれます。

## <a name="internet-group-management-protocol-igmp"></a>インターネット グループ管理プロトコル (IGMP)

インターネット グループ管理プロトコル (IGMP) は、受信または参加を意図している近隣やそのルーターと通信するデバイスに、IP マルチキャスト グループを提供します (RFC 1112 および RFC 2236)。 マルチキャスト グループは、基本的にはネットワーク メンバーの動的なコレクションであり、クラス D の IP アドレスで表されます。 マルチキャスト グループのメンバーは、いつでも離脱することができ、新しいメンバーはいつでも参加できます。 グループへの参加と離脱に関係する調整は、IGMP の役割です。

### <a name="igmp-enable"></a>IGMP の有効化

NetX でマルチキャスト アクティビティを実行する前に、アプリケーションで ***nx_igmp_enable*** サービスを呼び出す必要があります。 このサービスによって、マルチキャスト要求に対する準備の基本的な IGMP 初期化が実行されます。

### <a name="multicast-ip-addressing"></a>マルチキャスト IP アドレス指定

前述のように、マルチキャスト アドレスは、ページ 58 の図 4 に示すように、実際にはクラス D の IP アドレスです。 クラス D アドレスの下位 28 ビットは、マルチキャスト グループ ID に対応しています。 あらかじめ定義されているマルチキャスト アドレスがいくつかあります。 ただし、IGMP 処理には、"*すべてのホスト アドレス*" (244.0.0.1) が特に重要です。 "*すべてのホスト アドレス*" は、ルーターが、すべてのマルチキャスト メンバーを照会して、所属するマルチキャスト グループを報告するために使用されます。

### <a name="physical-address-mapping-in-ip"></a>IP での物理アドレスのマッピング

クラス D マルチキャスト アドレスは、01.00.5e.00.00.00 から 01.00.5e.7f.ff.ff の範囲内の物理イーサネット アドレスに直接マップされます。 IP マルチキャスト アドレスの下位 23 ビットは、イーサネット アドレスの下位 23 ビットに直接マップされます。

### <a name="multicast-group-join"></a>マルチキャスト グループへの参加

特定のマルチキャスト グループに参加する必要があるアプリケーションでは、***nx_igmp_multicast_join*** サービスを呼び出して参加することができます。 このサービスは、このマルチキャスト グループに参加する要求の数を追跡します。 これがマルチキャスト グループに参加するアプリケーションの最初の要求である場合は、このホストがグループに参加することを示す IGMP レポートがプライマリ ネットワークに送信されます。 次に、ネットワーク ドライバーを呼び出して、このマルチキャスト グループのイーサネット アドレスを持つパケットをリッスンするように設定します。

マルチホーム システムでは、特定のインターフェイスを介してマルチキャスト グループにアクセスできる場合、アプリケーションは ***nx_igmp_multicast_join*** ではなく、サービス ***nx_igmp_multicast_interface_join*** を使用します。これは、プライマリ ネットワーク上のマルチキャスト グループに限定されます。

### <a name="multicast-group-leave"></a>マルチキャスト グループからの離脱

以前に参加したマルチキャスト グループを離脱する必要があるアプリケーションでは、***nx_igmp_multicast_leave*** サービスを呼び出すことによってこれを行うことができます。 このサービスは、グループへの参加回数に関連付けられた内部カウントを減らします。 グループに対する未処理の参加要求がない場合、このマルチキャスト グループのイーサネット アドレスを持つパケットのリッスンを無効にするために、ネットワーク ドライバーが呼び出されます。

### <a name="multicast-loopback"></a>マルチキャスト ループバック

アプリケーションでは、同じノードのいずれかのソースから送信されたマルチキャスト トラフィックを受信したい場合があります。 これには、サービス ***nx_igmp_loopback_enable*** を使用して、IP マルチキャスト コンポーネントでループバックが有効になっている必要があります。

### <a name="igmp-report-message"></a>IGMP レポート メッセージ

アプリケーションがマルチキャスト グループに参加すると、IGMP レポート メッセージがネットワーク経由で送信され、ホストが特定のマルチキャスト グループに参加することが示されます。 IGMP レポート メッセージの形式を図 8 に示します。 マルチキャスト グループ アドレスは、IGMP レポート メッセージのグループ メッセージと宛先 IP アドレスの両方に使用されます。

![IGMP レポート メッセージ](./media/user-guide/igmp-report-message.png)

**図 8. IGMP レポート メッセージ**

上の図 (図 8) では、IGMP ヘッダーには、バージョン/タイプ フィールド、最大応答時間、チェックサム フィールド、およびマルチキャスト グループ アドレス フィールドが含まれています。 IGMPv1 メッセージの場合、最大応答時間フィールドは、IGMPv1 プロトコルの一部ではないため、常に 0 に設定されます。 最大応答時間フィールドは、IGMPv2 プロトコルで定義されているように、ホストがクエリ タイプとして IGMP メッセージを受信したときに設定され、ホストが別のホストのレポート タイプのメッセージを受信したときにクリアされます。

次に、IGMP ヘッダー形式について説明します。

| **ヘッダー フィールド**          | **目的** |
|-----------------------|--------------------------------------------------------------------|
| Version               | このフィールドでは、IGMP バージョンを指定します (ビット 31-28)。                                                                               |
| Type                  | このフィールドでは、IGMP メッセージのタイプを指定します (ビット 27-24)。                                                                       |
| 最大応答時間 | IGMPv1 では使用されません。 IGMPv2 では、このフィールドは最大応答時間として機能します。                                                      |
| Checksum              | このフィールドには、IGMP バージョンで始まる IGMP メッセージの 1 の補数和の 16 ビット チェックサムが格納されます (ビット 0-15)。 |
| グループ アドレス         | 32 ビット クラス D グループ IP アドレス |


IGMP レポート メッセージは、マルチキャスト ルーターによって送信される IGMP クエリ メッセージに応答して送信されます。 マルチキャスト ルーターは、クエリ メッセージを定期的に送信して、まだグループ メンバーシップが必要なホストを確認します。 クエリ メッセージの形式は、図 8 に示す IGMP レポート メッセージと同じです。 唯一の違いは、IGMP タイプが 1 で、グループ アドレス フィールドが 0 に設定されていることです。 IGMP クエリ メッセージは、マルチキャスト ルーターによって "*すべてのホスト*" の IP アドレスに送信されます。 グループ メンバーシップを引き続き維持するホストは、別の IGMP レポート メッセージを送信することによって応答します。

> [!IMPORTANT]
> *TCP/IP 実装のすべてのメッセージは、**ビッグ エンディアン** 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

### <a name="igmp-statistics-and-errors"></a>IGMP の統計情報とエラー

有効にすると、NetX IGMP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP の IGMP 処理ごとに保持されます。

- 送信された IGMP レポートの合計数
- 受信した IGMP クエリの合計数
- IGMP チェックサム エラーの合計数
- 現在参加している IGMP グループの合計数

これらの統計およびエラー レポートはすべて、***nx_igmp_info_get*** サービスを使用してアプリケーションで利用できます。

## <a name="user-datagram-protocol-udp"></a>ユーザー データグラム プロトコル (UDP)

ユーザー データグラム プロトコル (UDP) は、ネットワーク メンバー間で最も単純な形式のデータ転送を提供します (RFC 768)。 UDP データ パケットは、ベスト エフォート方式でネットワーク メンバー間で送信されます。つまり、パケット受信者による確認応答用メカニズムは組み込まれていません。 さらに、UDP パケットを送信する場合、事前に接続を確立する必要はありません。 このため、UDP パケット転送は非常に効率的です。

### <a name="udp-header"></a>UDP ヘッダー
UDP は、送信時にアプリケーションのデータの前に単純なパケット ヘッダーを配置し、受信時にパケットから同様の UDP ヘッダーを削除してから、受信した UDP パケットをアプリケーションに配信します。 UDP はパケットを送受信するために IP プロトコルを使用します。つまり、パケットがネットワーク上にあるときに UDP ヘッダーの前に IP ヘッダーが存在することを意味します。 図 9 は、UDP ヘッダーの形式を示しています。

![UDP ヘッダー](./media/user-guide/udp-header.png)

**図 9. UDP ヘッダー**

> [!IMPORTANT]
> *UDP/IP 実装のすべてのヘッダーは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

次に、UDP ヘッダー形式について説明します。

| ヘッダー フィールド                   | 目的 |
|--------------------------------|---------------------------------------------|
| 16 ビットの送信元ポート番号      | このフィールドには、UDP パケットの送信元のポートが格納されます。 有効な UDP ポートの範囲は 1 ～ 0xFFFF です。 |
| 16 ビットの宛先ポート番号 | このフィールドには、パケットの送信先の UDP ポートが格納されます。 有効な UDP ポートの範囲は 1 ～ 0xFFFF です。   |
| 16 ビットの UDP の長さ   | このフィールドには、UDP ヘッダーのサイズを含む、UDP パケットのバイト数が格納されます。                                  |
| 16 ビットの UDP チェックサム | このフィールドには、UDP ヘッダー、パケット データ領域、擬似 IP ヘッダーなど、パケットの 16 ビットのチェックサムが格納されます。 |

### <a name="udp-enable"></a>UDP 有効化

UDP パケット転送が可能になる前に、アプリケーションはまず、***nx_udp_enable*** サービスを呼び出して UDP を有効にする必要があります。 有効にすると、アプリケーションは UDP パケットを送信および受信できるようになります。

### <a name="udp-socket-create"></a>UDP ソケットの作成

UDP ソケットは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。 サービスの初期のタイプ、有効期限、および受信キューの深さは、***nx_udp_socket_create*** サービスによって定義されます。 アプリケーションの UDP ソケットの数に制限はありません。

### <a name="udp-checksum"></a>UDP チェックサム

UDP は、IP 擬似ヘッダー (送信元 IP アドレス、宛先 IP アドレス、プロトコル/長さ IP ワードで構成される)、UDP ヘッダー、および UDP パケット データを対象とする、1 の補数の 16 ビット チェックサムを指定します。 計算された UDP チェックサムが 0 の場合は、すべて 1 として格納されます (0xFFFF)。 送信ソケットの UDP チェックサム ロジックが無効になっている場合、チェックサムが計算されなかったことを示すために、UDP チェックサム フィールドに 0 が配置されます。 UDP チェックサムが受信側によって計算されたチェックサムと一致しない場合、UDP パケットは単純に破棄されます。

IP ネットワークでは、UDP チェックサムは省略可能です。 NetX を使用すると、アプリケーションは、ソケットごとに UDP チェックサムの計算を有効または無効にすることができます。 既定では、UDP ソケット チェックサム ロジックが有効になっています。 アプリケーションは、***nx_udp_socket_checksum_disable*** サービスを呼び出すことによって、特定の UDP ソケットのチェックサム ロジックを無効にすることができます。

特定のイーサネット コントローラーは、その場で UDP チェックサムを生成することができます。 システムがハードウェア チェックサム計算機能を使用できる場合、チェックサム ロジックを使用せずに NetX ライブラリを構築できます。 UDP ソフトウェア チェックサムを無効にするには、***NX_DISABLE_UDP_TX_CHECKSUM*** と ***NX_DISABLE_UDP_RX_CHECKSUM* *_ のシンボルを定義して NetX ライブラリを構築する必要があります ([第 2 章](chapter2.md)で説明)。構成オプションを使用すると、NetX から UDP チェックサム ロジックが完全に削除されますが、_* nx_udp_socket_checksum_disable*** サービスを呼び出すと、アプリケーションはソケットごとに IP UDP チェックサム処理を無効にすることができます。

### <a name="udp-ports-and-binding"></a>UDP ポートとバインド

UDP ポートは、UDP プロトコルの論理エンド ポイントです。 NetX の UDP コンポーネントには、1 ～ 0xFFFF の範囲で、65,535 の有効なポートがあります。 UDP データを送受信するには、まず、アプリケーションで UDP ソケットを作成してから、目的のポートにバインドする必要があります。 UDP ソケットをポートにバインドした後、アプリケーションはそのソケットでデータを送受信できます。

### <a name="udp-fast-pathtrade"></a>UDP Fast Path&trade;

UDP Fast Path&trade; は、NetX UDP 実装を介した低パケット オーバーヘッド パスの名前です。 UDP パケットを送信するには、***nx_udp_socket_send** _ と _*_nx_ip_packet_send_*_ の関数を呼び出して、最終的にネットワーク ドライバーを呼び出します。 _*_nx_udp_socket_send_*_ は、既存の NetX アプリケーション向けに NetX で使用でき、IP パケットにのみ使用できます。 ただし、推奨される方法は、以下で説明する _ *_nx_udp_socket_send_** サービスを使用することです。 UDP パケット受信では、UDP パケットは適切な UDP ソケット受信キューに配置されるか、ネットワーク ドライバーの受信割り込み処理からの単一の関数呼び出しで、中断されたアプリケーション スレッドに配信されます。 UDP パケットを送受信するための高度に最適化されたロジックは、UDP Fast Path テクノロジの本質です。

### <a name="udp-packet-send"></a>UDP パケット送信

IP ネットワーク経由での UDP データの送信は、***nx_udp_socket_send** _ 関数を呼び出すことによって簡単に実現できます。 呼び出し元は、_"IP アドレス"* フィールドに IP バージョンを設定する必要があります。 NetX では、送信先 IP アドレスに基づいて、送信される UDP パケットの最適な送信元アドレスが決定されます。 このサービスは、パケット データの前に UDP ヘッダーを配置し、内部 IP 送信ルーチンを使用してネットワークに送信します。 UDP パケットの送信では、すべての UDP パケット転送が直ちに処理されるため、スレッドが中断されることはありません。

マルチキャストまたはブロードキャストの宛先で、NetX デバイスに選択できる IP アドレスが複数ある場合に、アプリケーションで使用する送信元 IP アドレスを指定する必要があります。 これは、サービス ***nx_udp_socket_interface_send*** を使用して行うことができます。

> [!IMPORTANT]
> *マルチキャストまたはブロードキャスト パケットの送信に **nx_udp_socket_send** が使用されている場合、最初のインターフェイスの IP アドレスが送信元アドレスとして使用されます。*

> [!IMPORTANT]
> *このソケットに対して UDP チェックサム ロジックが有効になっている場合、チェックサム操作は、UDP または IP のデータ構造へのアクセスをブロックすることなく、呼び出し元のスレッドのコンテキストで実行されます。*

> [!NOTE]
> ***NX_PACKET** 構造に存在する UDP ペイロード データは、長いワード境界に配置する必要があります。アプリケーションでは、先頭のポインターと NetX のデータ開始ポインターの間に十分な領域を残して、UDP、IP、および物理メディアのヘッダーを配置する必要があります。*

### <a name="udp-packet-receive"></a>UDP パケット受信

アプリケーション スレッドは、***nx_udp_socket_receive*** を呼び出すことによって、特定のソケットから UDP パケットを受信する場合があります。 ソケット受信関数は、ソケットの受信キューで最も古いパケットを配信します。 受信キューにパケットがない場合、呼び出し元のスレッドは、パケットが到着するまで (オプションのタイムアウトで) 中断できます。

UDP 受信パケット処理 (通常はネットワーク ドライバーの受信割り込みハンドラーから呼び出されます) は、パケットを UDP ソケットの受信キューに配置するか、パケットを待機している最初に中断されたスレッドに配信する役割を担います。 パケットがキューに置かれている場合は、受信処理によって、ソケットに関連付けられている最大受信キューの深さも確認されます。 新しくキューに入れられたパケットがキューの深さを超えると、キュー内の最も古いパケットが破棄されます。

### <a name="udp-receive-notify"></a>UDP 受信通知

アプリケーション スレッドが複数のソケットから受信したデータを処理する必要がある場合は、***nx_udp_socket_receive_notify*** 関数を使用する必要があります。 この関数は、ソケットの受信パケット コールバック関数を登録します。 ソケットでパケットが受信されるたびに、コールバック関数が実行されます。

コールバック関数の内容は、アプリケーション固有です。 ただし、最も高い可能性として、パケットが対応するソケットで利用できるようになったことを処理スレッドに通知するロジックが含まれています。

### <a name="peer-address-and-port"></a>ピア アドレスとポート

UDP パケットを受信すると、アプリケーションでは、サービス ***nx_udp_packet_info_extract*** を使用して、送信者の IP アドレスとポート番号を見つけることができます。 正常に返された場合、このサービスは、送信者の IP アドレス、送信者のポート番号、およびパケットの受信に使用されたローカル インターフェイスに関する情報を提供します。

### <a name="thread-suspension"></a>スレッドの中断

前述のように、特定の UDP ポートで UDP パケットを受信しようとしている間に、アプリケーション スレッドが中断されることがあります。 そのポートでパケットが受信されると、最初に中断されたスレッドに渡され、そのスレッドが再開されます。 UDP 受信パケットで中断する場合は、オプションのタイムアウトを使用できます。これは、ほとんどの NetX サービスで利用可能な機能です。

### <a name="udp-socket-statistics-and-errors"></a>UDP ソケットの統計情報とエラー

有効にすると、NetX UDP ソケット ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP/UDP インスタンスごとに保持されます。

- 送信された UDP パケットの合計数
- 送信された UDP バイトの合計数
- 受信した UDP パケットの合計数
- 受信した UDP バイトの合計数
- 無効な UDP パケットの合計数
- ドロップされた UDP 受信パケットの合計数
- UDP 受信チェックサム エラーの合計数
- 送信された UDP ソケット パケット数
- 送信された UDP ソケット バイト数
- 受信した UDP ソケット パケット数
- 受信した UDP ソケット バイト数
- キューに登録された UDP ソケット パケット数
- ドロップされた UDP ソケット受信パケット数
- UDP ソケット チェックサム エラー

これらのすべての統計およびエラー レポートをアプリケーションで使用するには、すべての UDP ソケットで集められた UDP 統計は ***nx_udp_info_get*** サービスを使用し、指定された UDP ソケットの UDP 統計情報は ***nx_udp_socket_info_get*** サービスを使用します。

### <a name="udp-socket-control-block-nx_udp_socket"></a>UDP ソケット制御ブロック NX_UDP_SOCKET

各 UDP ソケットの特性は、関連付けられている **NX_UDP_SOCKET** 制御ブロックにあります。 これには、IP データ構造へのリンク、送信パスと受信パスのネットワーク インターフェイス、バインドされたポート、受信パケット キューなどの有用な情報が含まれています。 この構造体は **_nx_api.h_** ファイルで定義されています。

## <a name="transmission-control-protocol-tcp"></a>伝送制御プロトコル (TCP)

伝送制御プロトコル (TCP) は、2 つのネットワーク メンバー間で信頼性の高いストリーム データ転送を提供します (RFC 793)。 1 つのネットワーク メンバーから送信されたすべてのデータは、受信側メンバーによって検証され、確認されます。 また、この 2 つのメンバーは、データ転送の前に接続を確立している必要があります。 これにより、信頼性の高いデータ転送が行われるようになります。ただし、前述の UDP データ転送よりもかなり多くのオーバーヘッドが必要になります。

### <a name="tcp-header"></a>TCP ヘッダー

送信時には、TCP ヘッダーがユーザーが提供するデータの前に配置されます。 受信時には、TCP ヘッダーが受信パケットから削除され、アプリケーションで使用できるユーザー データだけが残ります。 TCP は IP プロトコルを使用してパケットを送受信します。これは、パケットがネットワーク上にあるときに、TCP ヘッダーの前に IP ヘッダーがあることを意味します。 図 10 は、TCP ヘッダーの形式を示しています。

![TCP ヘッダー](./media/user-guide/tcp-header.png)

**図 10. TCP ヘッダー**

次に、TCP ヘッダー形式について説明します。

| ヘッダー フィールド | 目的 |
|---|---|
| 16 ビットの送信元ポート番号 | このフィールドには、TCP パケットが送信されるポートが格納されます。 有効な TCP ポートの範囲は 1 ～ 0xFFFF です。 |
| 16 ビットの宛先ポート番号 | このフィールドには、パケット送信先の TCP ポートが格納されます。 有効な TCP ポートの範囲は 1 ～ 0xFFFF です。 |
| 32 ビットのシーケンス番号 | このフィールドには、接続のこちら側から送信されるデータのシーケンス番号が格納されます。 元のシーケンスは、2 つの TCP ノード間の最初の接続シーケンス中に確立されます。 その時点以降のすべてのデータ転送で、送信されたバイト数ずつシーケンス番号がインクリメントされます。 |
| 32 ビットの確認応答番号 | このフィールドには、接続のこちら側で受信した最後のバイトに対応するシーケンス番号が格納されます。 これは、以前に送信されたデータが、接続の反対側で正常に受信されたかどうかを判断するために使用されます。 |
| 4 ビットのヘッダー長           | このフィールドには、TCP ヘッダー内の 32 ビット ワードの数が格納されます。 TCP ヘッダーにオプションが存在しない場合、このフィールドは 5 です。 |
| 6 ビットのコード ビット               | このフィールドには、接続に関連付けられたさまざまな制御情報を示すために使用される 6 つの異なるコード ビットが含まれています。 制御ビットは次のように定義されます。 |



| 名前 | ビット | 意味                                                     |
|------|-----|-------------------------------------------------------------|
| URG  | 21  | 緊急データあり                                         |
| ACK  | 20  | 確認応答番号は有効                             |
| PSH  | 19  | このデータをすぐに処理                                |
| RST  | 18  | 接続をリセット                                        |
| SYN  | 17  | シーケンス番号を同期 (接続の確立に使用) |
| FIN  | 16  | 送信側が送信を完了 (接続終了に使用) |

**16 ビットのウィンドウ**

このフィールドはフロー制御に使用されます。 これには、ソケットが現在受信できるバイト数が格納されます。 これは基本的にフロー制御に使用されます。 送信元は、送信するデータが受信側の公開されたウィンドウに適合することを確認する責任があります。

| **ヘッダー フィールド**          | **目的** |
| ------------------------- | --- |
| **16 ビットの TCP チェックサム**   | このフィールドには、TCP ヘッダー、パケット データ領域、擬似 IP ヘッダーなど、パケットの 16 ビットのチェックサムが格納されます。                |
| **16 ビットの緊急ポインター** | このフィールドには、緊急データの最後のバイトの正のオフセットが格納されます。 このフィールドは、ヘッダーに URG コード ビットが設定されている場合にのみ有効です。 |

> [!IMPORTANT]
> *TCP/IP 実装のすべてのヘッダーは、ビッグ エンディアン形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

### <a name="tcp-enable"></a>TCP 有効化

TCP 接続とパケット転送を可能にするには、まず、アプリケーションで nx_tcp_enable サービスを呼び出して TCP を有効にする必要があります。 有効にすると、アプリケーションはすべての TCP サービスに自由にアクセスできるようになります。

### <a name="tcp-socket-create"></a>TCP ソケットの作成

TCP ソケットは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。 サービスの初期のタイプ、有効期限、およびウィンドウ サイズは、***nx_tcp_socket_create*** サービスによって定義されます。 アプリケーションの TCP ソケットの数に制限はありません。

### <a name="tcp-checksum"></a>TCP チェックサム

TCP は、IP 擬似ヘッダー (送信元 IP アドレス、宛先 IP アドレス、プロトコル/長さ IP ワードで構成される)、TCP ヘッダー、および TCP パケット データを対象とする、1 の補数の 16 ビット チェックサムを指定します。

特定のネットワーク コントローラーでは、ハードウェアで TCP チェックサムの計算と検証を実行できます。 このようなシステムでは、実行時のオーバーヘッドを減らすために、アプリケーションでは、可能な限りハードウェア チェックサム ロジックを使用することができます。 アプリケーションでは、**NX_DISABLE_TCP_TX_CHECKSUM** と **NX_DISABLE_TCP_RX_CHECKSUM** を定義することによって、NetX ライブラリからの TCP チェックサム計算ロジックをビルド時に完全に無効にすることができます。 このようにして、TCP チェックサム コードはコンパイルされません。

### <a name="tcp-port"></a>[TCP ポート]

TCP ポートは、TCP プロトコルの論理接続ポイントです。 NetX の TCP コンポーネントには、1 ～ 0xFFFF の範囲で、65,535 の有効なポートがあります。 1 つのポートのデータを任意の他の宛先ポートに送信できる UDP とは異なり、TCP ポートは特定のもう 1 つの TCP ポートに接続されており、この接続が確立されたときにのみ、接続を構成する 2 つのポート間でのみデータ転送が行われます。

> [!IMPORTANT]
> *TCP ポートは、UDP ポートと完全に分離されています。たとえば、UDP ポート番号 1 は TCP ポート番号 1 とは関係ありません。*

## <a name="client-server-model"></a>クライアントサーバー モデル

データ転送に TCP を使用するには、最初に 2 つの TCP ソケット間に接続を確立する必要があります。 接続の確立は、クライアントサーバー形式で行われます。 接続のクライアント側は接続を開始する側であり、サーバー側は、クライアント接続要求を待機してからすべての処理を実行します。

> [!IMPORTANT]
> *マルチホーム デバイスの場合、NetX は接続に使用する送信元アドレスと、接続の宛先 IP アドレスに基づいたネクスト ホップ アドレスを自動的に判定します。*

### <a name="tcp-socket-state-machine"></a>TCP ソケットの状態機械

2 つの TCP ソケット (クライアント 1 つとサーバー 1 つ) 間の接続は複雑で、状態機械方式で管理されます。 各 TCP ソケットは、CLOSED 状態で開始されます。 接続イベントを通じて、各ソケットの状態機械が ESTABLISHED 状態に移行します。この状態で、TCP でのデータ転送の大部分が行われます。 接続の一方の側がデータを送信する必要がなくなった場合、接続は切断されます。 もう一方の側が切断すると、最終的に TCP ソケットは CLOSED 状態に戻ります。 このプロセスは、TCP クライアントとサーバーが接続を確立して閉じるたびに繰り返されます。 図 11 は、TCP 状態機械のさまざまな状態を示しています。

![TCP 状態機械の状態](./media/user-guide/states-tcp-state-machine.png)

### <a name="figure-11-states-of-the-tcp-state-machine"></a>図 11. TCP 状態機械の状態

### <a name="tcp-client-connection"></a>TCP クライアント接続

前述のように、TCP 接続のクライアント側は、TCP サーバーへの接続要求を開始します。 接続要求を行う前に、クライアントの IP インスタンスで TCP を有効にする必要があります。 さらに、***nx_tcp_socket_create** _ サービスを使用して次にクライアントの TCP ソケットを作成し、_*_nx_tcp_client_socket_bind_*_ サービスを介してポートにバインドする必要があります。 クライアント ソケットをバインドした後、_ *_nx_tcp_client_socket_connect_** サービスを使用して、TCP サーバーとの接続を確立します。 接続試行を開始するには、ソケットが CLOSED 状態になっている必要があることに注意してください。 接続を確立するには、まず、NetX で SYN パケットを発行し、サーバーからの SYN ACK パケットを待機します。これは、接続要求の受け入れを示します。 SYN ACK を受信した後、NetX は ACK パケットで応答し、ESTABLISHED 状態にクライアント ソケットを昇格させます。

### <a name="tcp-client-disconnection"></a>TCP クライアント切断

接続の終了は、***nx_tcp_socket_disconnect*** の呼び出しで行われます。 中断が指定されていない場合、クライアント ソケットは RST パケットをサーバー ソケットに送信し、ソケットを CLOSED 状態にします。 それ以外の場合、中断が要求されると、次のように完全な TCP 切断プロトコルが実行されます。

- サーバーが以前に切断要求を開始した場合 (クライアント ソケットが既に FIN パケットを受信していて、ACK で応答し、CLOSE WAIT 状態にある場合)、NetX ではクライアントの TCP ソケットの状態が LAST ACK 状態に昇格され、FIN パケットが送信されます。 次に、サーバーからの ACK を待機してから切断を完了し、CLOSED 状態に入ります。

- 一方、クライアントが最初に切断要求を開始する場合 (サーバーが切断されていない状態で、ソケットがまだ ESTABLISHED 状態である場合)、NetX では FIN パケットが送信されて切断が開始し、サーバーからの FIN と ACK の受信を待機してから切断を完了してソケットが CLOSED 状態になります。

ソケットの送信キューにパケットが残っている場合、NetX は指定されたタイムアウトの間中断して、パケットが確認されるようにします。 タイムアウトが経過すると、NetX はクライアント ソケットの送信キューを空にします。

クライアント ソケットからポートのバインドを解除するために、アプリケーションは ***nx_tcp_client_socket_unbind*** を呼び出します。 ソケットは、ポートが解放される前に、CLOSED 状態であるか、切断処理中 (つまり、TIMED WAIT 状態) である必要があります。それ以外の場合は、エラーが返されます。

最後に、アプリケーションがクライアント ソケットを必要としなくなった場合は、***nx_tcp_socket_delete*** を呼び出してソケットを削除します。

### <a name="tcp-server-connection"></a>TCP サーバー接続

TCP 接続のサーバー側はパッシブです。つまり、サーバーは、クライアントが接続要求を開始するのを待機します。 クライアント接続を受け入れるには、まず、サービス ***nx_tcp_enable** _ を呼び出して、IP インスタンスで TCP を有効にする必要があります。 次に、アプリケーションは _ *_nx_tcp_socket_create_** サービスを使用して TCP ソケットを作成する必要があります。

また、サーバー ソケットを、接続要求をリッスンするように設定する必要もあります。 これは、***nx_tcp_server_socket_listen*** サービスを使用して行うことができます。 このサービスは、サーバー ソケットを LISTEN 状態にし、指定されたサーバー ポートをソケットにバインドします。

> [!IMPORTANT]
> *ソケット リッスン コールバック ルーチンを設定するには、アプリケーションで **nx_tcp_server_socket_listen** サービスの tcp_listen_callback 引数に適切なコールバック関数を指定します。このサーバー ポートで新しい接続が要求されるたびに、このアプリケーション コールバック関数が NetX によって実行されます。コールバックでの処理は、アプリケーションで制御されます。*

クライアント接続要求を受け入れるために、アプリケーションは ***nx_tcp_server_socket_accept** _ サービスを呼び出します。 受け入れサービスを呼び出すには、サーバー ソケットが LISTEN 状態または SYN RECEIVED 状態のいずれかである必要があります (つまり、サーバーが LISTEN 状態であり、接続を要求しているクライアントから SYN パケットを受信した状態)。 _ *_nx_tcp_server_socket_accept_** から返される正常の状態は、接続が設定されており、サーバー ソケットが ESTABLISHED 状態であることを示します。

サーバー ソケットに有効な接続がある状態になったら、追加のクライアント接続要求が、*listen_queue_size* によって指定された深さまでキューに登録され、***nx_tcp_server_socket_listen** _ サービスに渡されます。 サーバー ポートで以降の接続を処理するには、アプリケーションは使用可能なソケット (つまり、CLOSED 状態のソケット) を使用して _ *_nx_tcp_server_socket_relisten_** を呼び出す必要があります。 ソケットに関連付けられている以前の接続が終了し、ソケットが CLOSED 状態になっている場合は、同じサーバー ソケットを使用できることに注意します。

### <a name="tcp-server-disconnection"></a>TCP サーバー切断

接続の終了は、***nx_tcp_socket_disconnect*** の呼び出しで行われます。 中断が指定されていない場合、サーバー ソケットは RST パケットをクライアント ソケットに送信し、ソケットを CLOSED 状態にします。 それ以外の場合、中断が要求されると、次のように完全な TCP 切断プロトコルが実行されます。

- クライアントが以前に切断要求を開始した場合 (サーバー ソケットが既に FIN パケットを受信していて、ACK で応答し、CLOSE WAIT 状態にある場合)、NetX は TCP ソケット状態を LAST ACK 状態に昇格し、FIN パケットを送信します。 次に、クライアントからの ACK を待機してから切断を完了し、CLOSED 状態に入ります。

- 一方、サーバーが最初に切断要求を開始する場合 (クライアントが切断されていない状態で、ソケットがまだ ESTABLISHED 状態である場合)、NetX は FIN パケットを送信して切断を開始し、クライアントからの FIN と ACK の受信を待機してから切断を完了してソケットを CLOSED 状態にします。

ソケットの送信キューにパケットが残っている場合、NetX は指定されたタイムアウトの間中断して、それらのパケットが確認されるようにします。 タイムアウトが経過すると、NetX はサーバー ソケットの送信キューをフラッシュします。

切断処理が完了し、サーバー ソケットが CLOSED 状態になった後、このソケットとサーバー ポートの関連付けを終了するために、アプリケーションでは ***nx_tcp_server_socket_unaccept*** サービスを呼び出す必要があります。 このサービスは、***nx_tcp_socket_disconnect*** または ***nx_tcp_server_socket_accept** _ がエラー状態を返す場合でも、アプリケーションによって呼び出される必要があることに注意します。 _ *_nx_tcp_server_socket_unaccept_** が返された後、ソケットをクライアントまたはサーバー ソケットとして使用したり、不要になった場合は削除することもできます。 同じサーバー ポートで別のクライアント接続を受け入れる必要がある場合は、このソケットで ***nx_tcp_server_socket_relisten*** サービスを呼び出す必要があります。

次のコード セグメントは、一般的な TCP サーバーで使用される一連の呼び出しを示しています。

```c
/* Set up a previously created TCP socket to listen on port 12 */

nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1) {

    /* Wait for a client socket connection request for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on the port. */

    nx_tcp_server_socket_unaccept(&server_socket);

    /* Set up server socket to relisten on the same port for the next
    client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a>MSS 検証

最大セグメント サイズ (MSS) は、基になる IP レイヤーによって断片化されることなく TCP ホストが受信できる最大バイト数です。 TCP 接続の確立フェーズでは、両端でそれぞれの TCP MSS 値が交換されます。これにより、送信側は、受信側の MSS よりも大きい TCP データ セグメントを送信しません。 NetX TCP モジュールは、接続を確立する前に、必要に応じてピアの公開済み MSS 値を検証します。 既定では、NetX はこのようなチェックを有効にしません。 MSS 検証を実行するアプリケーションでは、NetX ライブラリを構築するときに ***NX_ENABLE_TCP_MSS_CHECKING** _ を定義する必要があり、最小値は _*_NX_TCP_MSS_MINIMUM_*_ で定義します。 _ *_NX_TCP_MSS_MINIMUM_** の下にある MSS 値を持つ受信 TCP 接続はドロップされます。

### <a name="stop-listening-on-a-server-port"></a>サーバー ポートでのリッスン停止

以前に ***nx_tcp_server_socket_listen** _ サービスの呼び出しで指定されたサーバー ポートでクライアント接続要求をリッスンする必要がなくなった場合、アプリケーションでは、単純に _ *_nx_tcp_server_socket_unlisten_** サービスを呼び出します。 このサービスは、接続を待機しているソケットをすべて CLOSED 状態に戻し、キューに置かれたクライアント接続要求パケットをすべて解放します。

### <a name="tcp-window-size"></a>TCP ウィンドウ サイズ

接続のセットアップ フェーズとデータ転送フェーズの両方で、各ポートは、ウィンドウ サイズと呼ばれる処理可能なデータの量を報告します。 データが受信されて処理されると、このウィンドウ サイズは動的に調整されます。 TCP では、送信側は受信側のウィンドウに収まる量のデータのみを送信できます。 基本的に、ウィンドウ サイズは、接続の各方向でのデータ転送のフロー制御を提供します。

### <a name="tcp-packet-send"></a>TCP パケット送信

TCP データの送信は、***nx_tcp_socket_send*** 関数を呼び出すことによって簡単に実現できます。 送信されるデータのサイズがソケットの MSS 値または、現在のピアの受信ウィンドウ サイズ (どちらか小さいほう) より大きい場合は、TCP 内部ロジックによって、伝送のための最小 (MSS、ピア受信ウィンドウ) に収まるデータに切り分けられます。 その後、このサービスによってパケットの前に TCP ヘッダーが作成されます (チェックサムの計算も含まれます)。 受信側のウィンドウ サイズが 0 でない場合、呼び出し元は受信側のウィンドウ サイズいっぱいまでデータを送信します。 受信ウィンドウが 0 になった場合、呼び出し元は中断し、受信側のウィンドウ サイズがこのパケットの送信に十分な大きさになるまで待機することがあります。 任意の時点で、同じソケットを介してデータを送信しようとしている間に、複数のスレッドが中断されることがあります。

> [!IMPORTANT]
> *NX_PACKET 構造に存在する TCP データは、長いワード境界に配置する必要があります。さらに、先頭のポインターとデータの開始ポインターの間に、TCP、IP、および物理メディアのヘッダーを配置するために十分な領域がある必要があります。*

### <a name="tcp-packet-retransmit"></a>TCP パケットの再送信

以前に送信された TCP パケットは、接続の相手側から ACK が返されるまで、実際には内部的に格納されていました。 転送されたデータがタイムアウト期間内に確認されない場合、保存されているパケットは再送信され、次のタイムアウト期間が設定されます。 ACK を受信すると、内部送信キューの確認応答番号によってカバーされるすべてのパケットが最終的に解放されます。

> [!IMPORTANT]
> *アプリケーションは、***nx_tcp_socket_send** _ 関数が NX_SUCCESS を返した後は、パケットを再利用したり、パケットの内容を変更したりすることはありません。 送信パケットは、データが相手側で確認された後、NetX 内部処理によって最終的に解放されます。_

### <a name="tcp-keepalive"></a>TCP Keepalive

TCP Keepalive 機能を使用すると、ピアが適切に終了せずに切断したかどうか (ピアがクラッシュした場合など) をソケットで検出したり、アイドル状態が長く、特定のネットワーク監視機能が接続を終了するのを防いだりできます。 TCP Keepalive は、データのない TCP フレームを定期的に送信し、シーケンス番号を現在のシーケンス番号よりも 1 小さい値に設定することによって機能します。 このような TCP Keepalive フレームを受け取ると、受信者は、まだ稼動している場合は、現在のシーケンス番号に対して ACK で応答します。 これで、Keepalive トランザクションが完了します。

既定では、Keepalive 機能は有効になっていません。 この機能を使用するには、NetX ライブラリを ***NX_ENABLE_TCP_KEEPALIVE** _ を定義して構築する必要があります。 シンボル _ *_NX_TCP_KEEPALIVE_INITIAL_** は、Keepalive フレームが開始されるまでの非アクティブな秒数を指定します。

### <a name="tcp-packet-receive"></a>TCP パケット受信

TCP の受信パケット処理 (IP ヘルパー スレッドから呼び出されます) は、さまざまな接続および切断アクションだけでなく、確認応答処理も送信します。 さらに、TCP 受信パケット処理は、受信データを持つパケットを適切な TCP ソケットの受信キューに格納したり、パケットを待機している最初の中断されたスレッドにパケットを配信したりする役割を担います。

### <a name="tcp-receive-notify"></a>TCP 受信通知

アプリケーション スレッドが複数のソケットから受信したデータを処理する必要がある場合は、***nx_tcp_socket_receive_notify*** 関数を使用する必要があります。 この関数は、ソケットの受信パケット コールバック関数を登録します。 ソケットでパケットが受信されるたびに、コールバック関数が実行されます。

コールバック関数の内容はアプリケーション固有です。ただし、最も高い可能性として、関数には、パケットが対応するソケットで使用可能であることを処理スレッドに通知するロジックが含まれています。

### <a name="thread-suspension"></a>スレッドの中断

前述のように、特定の TCP ポートからデータを受信しようとしている間に、アプリケーション スレッドが中断されることがあります。 そのポートでパケットが受信されると、最初に中断されたスレッドに渡され、そのスレッドが再開されます。 TCP 受信パケットで中断する場合は、オプションのタイムアウトを使用できます。これは、ほとんどの NetX サービスで利用可能な機能です。

スレッドの中断は、接続 (クライアントとサーバーの両方)、クライアント バインド、および切断サービスでも使用できます。

### <a name="tcp-socket-statistics-and-errors"></a>TCP ソケットの統計情報とエラー

有効にすると、NetX TCP ソケット ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP/TCP インスタンスごとに保持されます。

- 送信された TCP パケットの合計数
- 送信された TCP バイトの合計数
- 受信した TCP パケットの合計数
- 受信した TCP バイトの合計数
- 無効な TCP パケットの合計数
- ドロップされた TCP 受信パケットの合計数
- TCP 受信チェックサム エラーの合計数
- TCP 接続の合計数
- TCP 切断の合計数
- ドロップされた TCP 接続の合計数
- TCP パケットの再送信の合計数
- 送信された TCP ソケット パケット数
- 送信された TCP ソケット バイト数
- 受信した TCP ソケット パケット数
- 受信した TCP ソケット バイト数
- TCP ソケット パケットの再送信数
- キューに登録された TCP ソケット パケット数
- TCP ソケット チェックサム エラー
- TCP ソケットの状態
- TCP ソケット送信キューの深さ
- TCP ソケット送信ウィンドウ サイズ
- TCP ソケット受信ウィンドウ サイズ

これらのすべての統計およびエラー レポートは、合計 TCP 統計情報については ***nx_tcp_info_get** _ サービスを使用し、ソケットごとの TCP 統計情報については _ *_nx_tcp_socket_info_get_** サービスを使用すると、アプリケーションで使用可能になります。

## <a name="tcp-socket-control-block-nx_tcp_socket"></a>TCP ソケット制御ブロック NX_TCP_SOCKET

各 TCP ソケットの特性は、関連付けられている *NX_TCP_SOCKET* 制御ブロックにあります。これには、IP データ構造へのリンク、ネットワーク接続インターフェイス、バインドされたポート、受信パケット キューなどの有用な情報が格納されます。 この構造体は ***nx_api.h*** ファイルで定義されています。
