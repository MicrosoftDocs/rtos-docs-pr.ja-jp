---
title: 第 3 章 - Azure RTOS NetX Secure DTLS の機能の説明
description: この章では、Azure RTOS NetX Secure DTLS の機能について説明します。
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 468f1dc8a8334dc89064594b29dc8cfabd7d8fae
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811795"
---
# <a name="chapter-3-functional-description-of-azure-rtos-netx-secure-dtls"></a>第 3 章: Azure RTOS NetX Secure DTLS の機能の説明

## <a name="execution-overview"></a>実行の概要

この章では、Azure RTOS NetX Secure DTLS の機能について説明します。 NetX Secure DTLS アプリケーションには、初期化とアプリケーション インターフェイスの呼び出しという主に 2 種類のプログラム実行があります。 

NetX Secure では、ThreadX と NetX/NetXDuo が存在することが想定されています。 ThreadX では、スレッドの実行、中断、周期的なタイマー、相互排他の機能が必要です。 NetX/NetXDuo では、UDP と IP のネットワーク機能とドライバーが必要です。

## <a name="datagram-transport-layer-security-dtls-and-transport-layer-security-tls"></a>データグラム トランスポート層セキュリティ (DTLS) とトランスポート層セキュリティ (TLS)

NetX Secure DTLS では、RFC 6347 で定義されているデータグラム トランスポート層セキュリティ プロトコル バージョン 1.2 が実装されます。 DTLS バージョン 1.0 は、RFC 4347 に定義されており、TLS バージョン 1.1 に対応しています。 DTLS は基本的に TLS の拡張であるため、次のバージョンには対応する TLS バージョンと同じバージョン番号を使用することが決定されました。 したがって、DTLS バージョン 1.2 は TLS バージョン 1.2 に対応するため、DTLS バージョン 1.1 はありません。

> [!NOTE]
> NetX Secure では、DTLS バージョン 1.2 がサポートされています。 DTLS 1.0 (RFC 4347) は現在サポートされて **いません**。

*Secure Sockets Layer* (SSL) は、RFC 2246 で標準になる前の TLS の元の名前でしたが、多くの場合、"SSL" は TLS プロトコルの総称として使用されます。 SSL の最新バージョンは 3.0 であり、TLS 1.0 は SSL バージョン 3.1 と呼ばれることもあります。 正式な "SSL" プロトコルのすべてのバージョンは、形式が古く安全ではないと見なされています。現在 NetX Secure では SSL の実装は提供されていません。

TLS では、TLS クライアントとサーバー間の TLS "*ハンドシェイク*" 中に作成される "*セッション キー*" を生成するためのプロトコルが規定されており、それらのキーは、TLS "*セッション*" 中にアプリケーションによって送信されるデータを暗号化するために使用されます。

DTLS は TLS と密接に結び付いています。これは、基になるセキュリティ メカニズムがプロトコル間で共有されているためです。 ただし、TLS は、パケットの配信と順序が保証されるトランスポート層プロトコル (実際にはほとんど常に TCP) を介して動作するように設計されており、UDP のような信頼性の低いプロトコルでは機能しません。 これは UDP 用に DTLS が導入されたためです。DTLS は 信頼性のない性質を持つ UDP や同様のプロトコルが処理されるように設計されています。 これを行うために、TCP のような信頼性の高いプロトコルと同様に、順序付けと信頼性のロジック (破棄されたデータの再転送など) が含められています。

TLS の詳細については、『NetX Secure TLS ユーザーガイド』の第 3 章を参照してください。このドキュメントでは、TLS と DTLS の違いに焦点を当てて説明します。

### <a name="dtls-record-header"></a>DTLS レコードのヘッダー

図 1 に示すように、有効な DTLS レコードには、DTLS ヘッダーが必要です。 ヘッダーは TLS と同じですが、新しい 2 つのフィールドが追加されています。以下に示すように、16 ビットの "*エポック*" と 48 ビットの "*シーケンス番号*" です。

![DTLS レコードのヘッダーの図。](media/image2.png)

**図 1 - DTLS レコードのヘッダー**

TLS レコードのヘッダーのフィールドは、次のように定義されています。

| TLS ヘッダーのフィールド | 目的  |
| ---------------- | --------- |
| **8 ビットでのメッセージの種類** | このフィールドには、送信されている DTLS レコードの種類が含まれています。 有効な種類は次のとおりです。<br />- ChangeCipherSpec: 0x14<br />- Alert: 0x15<br />- Handshake: 0x16<br />- Application Data: 0x17<br /> |
| **16 ビットでのプロトコル バージョン** | このフィールドには、DTLS プロトコルのバージョンが含まれています。 有効な値は次のとおりです。<br />- DTLS 1.1: 0xFEFD |
|  **16 ビットのエポック** |  このフィールドには、DTLS の "エポック" が含まれています。これは、暗号化の状態が変更される (新しいセッション キーが生成されるときなど) たびに増分されるカウンターです。  |
|  **48 ビットのシーケンス番号** |  このフィールドには、この特定のレコードを識別するシーケンス番号が含まれています。 レコードの順序を維持し、再転送の必要性を確認するために、DTLS によって使用されます。 |
|  **16 ビットでの長さ** |  このフィールドには、DTLS レコードにカプセル化されたデータの長さが含まれています。  |

### <a name="dtls-handshake-record-header"></a>DTLS ハンドシェイク レコードのヘッダー

図 2 に示すように、有効な DTLS ハンドシェイク レコードには、DTLS ハンドシェイクのヘッダーが必要です。

![DTLS ハンドシェイク レコードのヘッダーの図。](media/image3.png)

**図 2 - DTLS ハンドシェイク レコードのヘッダー**

DTLS ハンドシェイク レコードのヘッダーのフィールドは、次のように定義されています。

| TLS ヘッダーのフィールド | 目的 |
| ---------------- | ------------------------------------------------ |
| **8 ビットでのメッセージの種類** | このフィールドには、送信されている DTLS レコードの種類が含まれています。 有効な種類は次のとおりです。<br />- ChangeCipherSpec: 0x14<br />- Alert: 0x15<br />- Handshake: 0x16<br />- Application Data: 0x17 |
|  **16 ビットのエポック** | このフィールドには、DTLS の "エポック" が含まれています。これは、暗号化の状態が変更される (新しいセッション キーが生成されるときなど) たびに増分されるカウンターです。 |
|  **48 ビットのシーケンス番号** | このフィールドには、この特定のレコードを識別するシーケンス番号が含まれています。 レコードの順序を維持し、再転送の必要性を確認するために、DTLS によって使用されます。 |
|  **16 ビットでのプロトコル バージョン** | このフィールドには、DTLS プロトコルのバージョンが含まれています。 有効な値は次のとおりです。<br />- DTLS 1.1: 0xFEFD |
| **16 ビットでの長さ** | このフィールドには、DTLS レコードにカプセル化されたデータの長さが含まれています。 |
| **8 ビットでのハンドシェイクの種類** | このフィールドには、ハンドシェイク メッセージの種類が含まれています。 有効な値は次のとおりです。<br />- HelloRequest: 0x00<br />- ClientHello: 0x01<br />- ServerHello: 0x02<br />- Certificate: 0x0B<br />- ServerKeyExchange: 0x0C<br />- CertificateRequest: 0x0D<br />- ServerHelloDone: 0x0E<br />- CertificateVerify: 0x0F<br />- ClientKeyExchange: 0x10<br />- 完了しました | 0x14 |
| **24 ビットでの長さ** | このフィールドには、ハンドシェイク メッセージのデータの長さが含まれています。 |
| **16 ビットのシーケンス番号** | このフィールドには、シーケンス番号が含まれています。 |

### <a name="the-dtls-handshake-and-dtls-session"></a>DTLS ハンドシェイクと DTLS セッション

一般的な DTLS ハンドシェイクを図 3 に示します。 これは一般的な TLS ハンドシェイクとほぼ同じですが、重要な違いがあります。ClientHello メッセージが最初に送信されると、サーバーでは、"cookie" が含まれている新しい DTLS 固有のメッセージ (*HelloVerifyRequest*) を使用して応答します。 DTLS Client では、ハンドシェイクを続行する前に、その cookie が含まれている 2 回目の ClientHello メッセージで応答する必要があります。 UDP はコネクションレス プロトコルであるため、特定のサービス拒否 (DoS) 攻撃を防ぐためにこのメカニズムが DTLS に追加されました (TCP には専用の接続/ポートが必要であるため、TLS では同じ問題は発生しません)。

DTLS ハンドシェイクは、クライアントが *ClientHello* メッセージを DTLS Server に送信するときに開始され、DTLS セッションの開始を求めていることを示します。 このメッセージには、クライアントでセッションに使用する暗号化に関する情報と、後でハンドシェイクでセッション キーを生成するために使用される情報が含まれています。 セッション キーが生成されるまで、DTLS ハンドシェイクのすべてのメッセージが暗号化されません。 前述のように、DTLS Server では、ClientHello に応答して HelloVerifyRequest を送信し、クライアントが 2 回目の更新された ClientHello で応答するように強制することがあります。

2 回目の ClientHello メッセージを受信すると、DTLS Server では cookie を確認し、正しい場合は、クライアントから提供された暗号化オプションからの選択を示す ServerHello メッセージで応答します。 ServerHello の後には証明書メッセージが続きます。このメッセージには、クライアントに対して ID を認証するためのデジタル証明書がサーバーによって提供されます (X.509 検証が使用されている場合)。 最後に、サーバーによって、送信するメッセージがこれ以上ないことを示す ServerHelloDone メッセージが送信されます。 サーバーによって、必要に応じて、ServerHello の後に他のメッセージが送信されることがあります。場合によっては、証明書メッセージが送信されないこともあります (事前共有キーが使用されている場合など)。そのため、ServerHelloDone メッセージが必要になります。

クライアントでサーバーのすべてのメッセージが受信されると、セッション キーを生成するための十分な情報が得られます。 TLS/DTLS では、"*プリマスター シークレット*" と呼ばれるランダムなデータの共有ビットを作成することによってこれが行われます。これは固定サイズであり、暗号化が有効にされた後に必要なすべてのキーを生成するためのシードとして使用されます。 プリマスター シークレットは、Hello メッセージに指定された公開キー アルゴリズム (RSA など) と、サーバーによって証明書で提供された公開キーを使用して暗号化されます (公開キー アルゴリズムの詳細については後述します)。 事前共有キー (PSK) と呼ばれるオプションの TLS/DTLS 機能を使用すると、証明書を使用せず、代わりにホスト間で共有されるシークレット値 (通常は物理的転送またはその他のセキュリティで保護された方法による) を使用する暗号スイートが有効になります。 PSK が有効になっている場合は、事前共有秘密キーを使用して、プリマスター シークレットが生成されます。 以下の「認証方法」の「事前共有キー」のセクションを参照してください。

通常の TLS/DTLS ハンドシェイクでは、暗号化されたプリマスター シークレットが ClientKeyExchange メッセージでサーバーに送信されます。 サーバーでは、ClientKeyExchange メッセージを受信すると、その秘密キーを使用してプリマスター シークレットの暗号化を解除し、TLS/DTLS Client と並行してセッション キーの生成に進みます。

セッション キーが生成されると、それ以降のメッセージはすべて、Hello メッセージで選択された秘密キー アルゴリズム (AES など) を使用して暗号化できます。 以後のメッセージはすべて暗号化されることを示すため、ChangeCipherSpec という暗号化されていない最後のメッセージが、クライアントとサーバーの両方によって送信されます。

クライアントとサーバーの両方によって送信される最初の暗号化されたメッセージも、Finished という最後の TLS ハンドシェイク メッセージです。 このメッセージには、送受信されたすべてのハンドシェイク メッセージのハッシュが含まれています。 このハッシュは、ハンドシェイクのどのメッセージも、改ざんされたり破損したり (セキュリティ侵害の可能性を示します) していないことを検証するために使用されます。

Finished メッセージが受信され、ハンドシェイクのハッシュが検証されると、TLS/DTLS セッションが開始され、アプリケーションでデータの送受信が開始されます。 TLS/DTLS セッション中にどちらかによって送信されたすべてのデータは、最初に Hello メッセージで選択されたハッシュ アルゴリズムを使用してハッシュされ (メッセージの整合性を提供するため)、選択された秘密キー アルゴリズムと生成されたセッション キーを使用して暗号化されます。

最後に、TLS/DTLS セッションは、クライアントまたはサーバーのいずれかが終了することを選択した場合にのみ、正常に終了することができます。 打ち切られたセッションは、セキュリティ違反と見なされます (攻撃者が、送信されているすべてのデータが受信されないようにしている可能性があるため)。そのため、どちらかがセッションを終了したいときに、CloseNotify アラートという特別な通知が送信されます。 セッションを正常に停止するには、クライアントとサーバーの両方で CloseNotify アラートを送信して処理する必要があります。

![一般的な DTLS ハンドシェイク セッションの図。](media/image4.png)

**図 3 - 一般的な DTLS ハンドシェイク**

### <a name="initialization"></a>初期化

NetX Secure DTLS を使用する前に、NetX または NetXDuo のスタックを初期化する必要があります。 UDP の操作のために TCP/IP スタックを正しく初期化する方法については、NetX または NetXDuo のユーザー ガイドを参照してください。

NetX UDP が初期化されたら、DTLS を有効にすることができます。 内部的には、DTLS ネットワークのトラフィックと処理はすべて、ユーザーの介入なしで NetX/NetXDuo のスタックによって処理されます。 ただし、DTLS には、基になるネットワーク スタックとは別に処理する必要があるいくつかの固有の要件があります。 DTLS Client の操作では、これらのパラメーターは ***NX_SECURE_DTLS_SESSION** _ という DTLS 制御ブロックに割り当てられます。 DTLS Server の操作の場合、制御ブロックは _ *_NX_SECURE_DTLS_SERVER_** と呼ばれ、1 つの UDP ポートで複数の DTLS セッションを処理するために必要なインフラストラクチャが含まれています。これは、各 TLS セッションが 1 つの TCP ポートにバインドされる TLS とは異なることに注意してください。

Server と Client の 2 つの DTLS モードは、アプリケーションで有効にすることができ (ただし、NetX ソケットごとにモードは 1 つのみ)、以下で説明するようにそれぞれに固有の要件があります。

### <a name="initialization--dtls-server"></a>初期化 – DTLS Server

NetX Secure DTLS Server モードは、基盤となるネットワーク トランスポート プロトコルに UDP が使用されるため、TLS Server モードとは異なります。 TCP では、TLS セッションの間、ポートは単一のリモート ホストにバインドされます。 UDP では、リモート ホストに関して状態の概念がないため、異なるホストからの DTLS 要求がすべて同じ UDP インターフェイスで受信されます。 そのため、DTLS では、TLS および TCP と同様に、ソケットに依存するのではなく、セッション状態を保持する必要があります。 このため、DTLS Server の制御ブロック (NX_SECURE_DTLS_SERVER) では、リモート ホスト情報 (IP アドレスとポート) と DTLS セッションのマッピングが保持されます。 DTLS Server に割り当てられた UDP ソケットへのすべての受信データは、リモート ホストに基づいて既存または新規の DTLS セッションにマップされます。 このため、DTLS Server の作成では、TLS および DTLS Client で必要とされるもの以外に、いくつかの追加パラメーターが必要となります。

DTLS Server には、DTLS Server 制御ブロック、TLS 暗号スイート、および暗号スクラッチ領域/メタデータ バッファーに加えて、DTLS セッションを保持するためのバッファーと、受信した DTLS レコードの暗号化を解除するために使用されるパケット再構築バッファーが必要です。

セッション バッファーに加えて、DTLS Server には "*デジタル証明書*" (接続している TLS クライアントに対して TLS サーバーを識別するために使用されるドキュメント) と、"*秘密キー*" に対応する証明書 (通常は RSA 暗号化アルゴリズム用) が必要となります。 国際電気通信連合の X.509 標準では、TLS/DTLS によって使用される証明書の形式が規定されています。また、X.509 デジタル証明書を作成するためのユーティリティが数多くあります。

NetX Secure DTLS の場合、X.509 証明書は、ASN.1 の Distinguished Encoding Rules (DER) 形式を使用してバイナリでエンコードされている必要があります。 DER は、証明書の標準的な TLS ネットワーク転送のバイナリ形式です。

指定された証明書に関連付けられている秘密キーは、DER でエンコードされた PKCS#1 形式である必要があります。 秘密キーはデバイスでのみ使用され、ネットワーク経由で送信されることはありません。 TLS/DTLS 通信をセキュリティで保護するため、秘密キーは安全に保管してください。

DTLS Server 証明書を初期化するには、アプリケーションで、DER でエンコードされた X.509 証明書とオプションの DER でエンコードされた PKCS#1 RSA 秘密キー データを含むバッファーへのポインターを ***nx_secure_x509_certificate_intialize*** サービスを使用して提供する必要があります。このサービスにより、TLS で使用される適切な証明書データが **NX_SECURE_X509_CERT** 構造に移入されます。

サーバー証明書が初期化されたら、***nx_secure_dtls_server_local_certificate_add*** サービスを使用して TLS 制御ブロックに追加する必要があります。

サーバーの証明書が DTLS Server の制御ブロックに追加されたら、セキュリティで保護された DTLS 通信にそのサーバーを使用できます (上記の例を参照してください)。

### <a name="initialization--dtls-client"></a>初期化 – DTLS Client

NetX Secure DTLS Client モードは、UDP ソケット経由のリモート ホストへの発信接続が 1 つだけであるため、DTLS Server と比べて操作が簡単です。

DTLS Client をセットアップするには、信頼された証明機関 (CA) からの X.509 でエンコードされたデジタル証明書のコレクションである "*信頼された証明書ストア*" が必要です。 これらの証明書は、DTLS プロトコルによって "信頼されている" と見なされ、DTLS Server のエンティティによって NetX Secure DTLS Client アプリケーションに提供される証明書を認証するための基礎として機能します。

信頼された CA 証明書は、"*自己署名*" されているか、別の CA によって署名されているかのいずれかです。後者の場合、その証明書は "*中間 CA*" (ICA) と呼ばれます。 一般的な TLS/DTLS アプリケーションでは、サーバーによって ICA 証明書とサーバー証明書が提供されますが、認証を成功させる唯一の要件は、発行者のチェーン (他の証明書の署名に使用される証明書) をサーバー証明書から信頼された証明書ストア内の信頼された CA 証明書まで追跡できることです。 このチェーンは、"*信頼のチェーン*" または "*証明書チェーン*" と呼ばれます。

信頼された CA または ICA 証明書を初期化するには、アプリケーションで、DER でエンコードされた X.509 証明書を含むバッファーへのポインターを ***nx_secure_x509_certificate_intialize** _ サービスを使用して提供する必要があります。このサービスにより、TLS で使用する適切な証明書データが、_ *NX_SECURE_X509_CERT** 構造体に格納されます。

また、DTLS Client には、割り当てられる受信サーバー証明書のための領域 (事前共有キー モードが使用されていないことを想定しています) と、暗号化を解除するためにパケットを DTLS レコードに組み立てるバッファーも必要です。 これらのバッファーは、***nx_secure_dtls_session_create*** サービスにパラメーターとして渡されます (詳細については、API リファレンスを参照してください)。

その後、初期化済みの信頼された証明書は、***nx_secure_dtls_session_trusted_certificate_add*** サービスを使用して、作成された DTLS セッションの制御ブロックに追加されます。 証明書を追加しなかった場合、DTLS Client セッションは失敗します。これは、DTLS プロトコルにリモート サーバー ホストを認証するための方法がなくなるためです。

信頼された証明書ストアが作成されたら、セッションを使用して、セキュリティで保護された TLS Client の接続を確立できます。

### <a name="application-interface-calls"></a>アプリケーション インターフェイスの呼び出し

NetX Secure DTLS アプリケーションでは、通常、ThreadX RTOS で実行されているアプリケーション スレッド内から関数呼び出しを行います。 一部の初期化、特に基盤となるネットワーク通信プロトコル (UDP や IP など) の場合は、***tx_application_define *** から呼び出すことができます。 ネットワーク通信の初期化の詳細については、NetX または NetXDuo のユーザー ガイドを参照してください。

DTLS では、プロセッサを集中的に使用する操作である暗号化ルーチンが多用されます。 一般に、これらの操作は、呼び出し元スレッドのコンテキスト内で実行されます。

### <a name="dtls-session-start"></a>DTLS セッションの開始

DTLS を機能させるには、基盤となるトランスポート層ネットワーク プロトコルが必要です。 一般的に使用されるプロトコルは TCP です。 NetX Secure の TLS セッションを確立するには、**NX_UDP_SOCKET** を作成して、DTLS Client の **_nx_secure_dtls_client_session_start_** サービスに渡す必要があります。

DTLS Server の動作は異なります。 受信 DTLS Client 要求に使用される UDP ソケットは、NX_SECURE_DTLS_SERVER 制御ブロックに含まれており、***nx_secure_dtls_server_create** _ への呼び出しで初期化されます。このサービスでは、ローカル UDP ポートをパラメーターとして受け取ります。 次に、_*_nx_secure_dtls_server_start_*_ サービスを使用して、受信要求を処理する DTLS Server を開始します。 すべての受信要求は、_nx_secure_dtls_server_create * に提供されるコールバック ルーチンで処理されます (接続用に 1 つと受信通知用に 1 つ)。接続通知を受信したとき (接続通知のコールバックが DTLS によって呼び出されます) に ***nx_secure_dtls_server_session_start**_ を呼び出すことによって DTLS セッションを開始する処理を行うのはアプリケーションの責任です。 また、アプリケーションでは、(DTLS ハンドシェイクの完了後に) 受信通知コールバックが呼び出されたときに、_*_nx_secure_dtls_session_receive_** を呼び出して、受信データを処理する必要があります。 この詳細については、上の例と、上記の各サービスの API リファレンスを参照してください。

### <a name="dtls-packet-allocation"></a>DTLS パケットの割り当て

NetX Secure DTLS では、NetX/NetXDuo TCP (***NX_PACKET** _) と同じパケット構造が使用されます。ただし、DTLS ヘッダーの領域が適切に割り当てられるように、_*_nx_packet_allocate_*_ サービスを呼び出す代わりに、_ *_nx_secure_dtls_packet_allocate_** サービスを呼び出す必要があります。

### <a name="dtls-session-send"></a>DTLS セッション送信

TLS セッションが開始されたら、アプリケーションでは ***nx_secure_dtls_session_send*** サービスを使用してデータを送信することができます。 この送信サービスは、***nx_udp_socket_send** _ サービスと同じように使用され、送信するデータ、ターゲットの IP アドレス、ターゲットの UDP ポートを含む _ *_NX_PACKET_** データ構造を受け取ります。

> [!IMPORTANT]
> nx_secure_dtls_session_send を使用してデータを送信する場合は、DTLS セッションの確立に使用したのと同じ IP アドレスとポートを使用することが重要です。ただし、セッションを新しいアドレスと UDP ポートに実行時に移行するメカニズムがある場合 (これは一般的ではありません) を除きます。

DTLS 経由で送信されるデータは、送信される前に、NX Secure DTLS のスタックおよび構成された暗号化ルーチンによって暗号化されます。

### <a name="dtls-session-receive"></a>DTLS セッション受信

DTLS セッションが開始されたら、アプリケーションでは ***nx_secure_Dtls_session_receive** _ サービスを使用してデータの受信を開始できます。 DTLS Session 送信と同様に、このサービスは _*_nx_udp_socket_receive_** と同じように使用されます。ただし、受信データは DTLS スタックで暗号化して検証されてから、パケット構造に返されます。

### <a name="tls-session-close"></a>TLS セッションの終了

DTLS セッションが完了したら、DTLS クライアントとサーバーの両方で、他方に CloseNotify アラートを送信して、セッションを停止する必要があります。 セッションが正常に停止されるようにするには、双方でアラートを受信して処理する必要があります。

リモート ホストから CloseNotify アラートが送信されると、***nx_secure_dtls_session_receive** _ サービスへの呼び出しによってそのアラートが処理され、対応するアラートがリモート ホストに送信されて、値 _*_NX_SECURE_TLS_SESSION_CLOSED_** が返されます。 セッションが終了すると、その DTLS セッションを使用した以降のデータの送信または受信の試行はすべて失敗します。

アプリケーションで TLS セッションを終了する場合は、***nx_secure_dtls_session_end** _ サービスを呼び出す必要があります。 このサービスによって CloseNotify アラートが送信され、応答の CloseNotify が処理されます。 応答が受信されない場合は、DTLS セッションが正常に停止されなかったことを示すエラー値 _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_** が返されます。これは、セキュリティ違反の可能性があります。

### <a name="tlsdtls-alerts"></a>TLS/DTLS のアラート

TLS/DTLS は最大限のセキュリティを提供するように設計されています。そのため、プロトコルでの誤った動作は、潜在的なセキュリティ違反と見なされます。 このため、メッセージの処理や暗号化と解読におけるすべてのエラーが、ハンドシェイクまたはセッションを直ちに終了させる致命的エラーと見なされます。

ローカル アプリケーションでのエラー処理は比較的簡単ですが、リモート ホストでは、状況を適切に処理し、さらなるセキュリティ違反の可能性を回避するために、エラーが発生したことを認識する必要があります。 このため、TLS/DTLS では、エラーが発生したときに "*アラート*" メッセージがリモート ホストに送信されます。

アラートは、他の TLS/DTLS メッセージと同じ方法で処理され、攻撃者が送信されたアラートの種類から情報を収集できないようにするために、セッション中に暗号化されます。 ハンドシェイク時には、潜在的な攻撃者によって取得される可能性がある情報の量を限定するため、送信されるアラートはスコープ内に制限されます。

CloseNotify アラートは、TLS/DTLS セッションを閉じるために使用されますが、これは致命的でない唯一のアラートです。 これはアラートと見なされて、アラート メッセージとして送信されますが、エラーが発生したことを示さないという点で、CloseNotify は他のアラートとは異なっています。

### <a name="tlsdtls-session-renegotiation-and-resumption"></a>TLS/DTLS セッションの再ネゴシエーションと再開

TLS では、"再ネゴシエーション" という概念がサポートされています。これは単に、既存の TLS セッションのコンテキスト内での、TLS セッション パラメーターの再ネゴシエーションです。

いくつかの類似点はありますが、TLS セッションの "*再開*" をセッションの "*再ネゴシエーション*" と混同しないようにしてください。 セッションの "*再ネゴシエーション*" では、既存の TLS セッション内で新しいハンドシェイクが開始されます。セッションの "*再開*" は、完全な TLS ハンドシェイクを実行せずに閉じられた TLS セッションの再開を伴う、純粋にオプションの機能です。

NX Secure DTLS では、リモート ホストからの受信再ネゴシエーション要求が処理されます。 セッションの再開はサポート **されていません**。 これらの機能の詳細については、『NetX Secure TLS ユーザー ガイド』の第 3 章を参照してください。

### <a name="protocol-layering"></a>プロトコルのレイヤー化

TLS プロトコルは (したがって DTLS も)、トランスポート層 (TCP、UDP など) とアプリケーション層の間のネットワーク スタックに適合します。 TLS は、トランスポート層のプロトコル (したがって、"*トランスポート層*" のセキュリティ) と見なされることがありますが、基盤となるネットワーク プロトコルに関してはアプリケーションとして機能するため、アプリケーション層にグループ化されることがあります。

TLS には、TCP などの、順番どおりで無損失の配信をサポートするトランスポート層プロトコルが必要です。 この要件のために、TLS を UDP 上で実行することはできません。UDP ではデータグラムの配信が保証されないためです。 *DTLS* は、TLS の変更されたバージョンであり、UDP などのデータグラム プロトコルで TLS のセキュリティを必要とするアプリケーションに使用されます。

![TLS プロトコルのレイヤーの図。](media/image6.png)

**図 4 - TCP/IP、UDP、TLS/DTLS プロトコルのレイヤー**

## <a name="network-communications-security-and-encryption"></a>ネットワーク通信のセキュリティと暗号化

パブリック ネットワークとインターネットを介した通信をセキュリティで保護することは、非常に重要なトピックであり、膨大な数の書籍、記事、ソリューションの対象となっています。 このテーマは信じがたいほど複雑ですが、意図したターゲットだけが情報へのアクセスや変更を行えるようにネットワーク経由でその情報を送信する、という単純な考え方にまとめることができます。 これは、機密性、整合性、認証の 3 つの重要な概念に分類されます。 TLS/DTLS プロトコルでは、3 つすべてに対応したソリューションが提供されます。

暗号化は、TLS および DTLS プロトコル内で機密性、整合性、認証を提供するためにさまざまな方法で使用されます。 暗号化は、セッションまたはサーバー インスタンスの作成時に、TLS または DTLS に提供する必要があります。TLS は、暗号化自体ではなく、暗号化を使用するための柔軟なフレームワークを提供しています。 NetX Secure DTLS では、ほとんどのアプリケーションに必要な暗号化ルーチンが提供されるため、ユーザーが適切な暗号化を見つけることを気にする必要はありません。

これらのトピックの詳細については、『NetX Secure TLS ユーザー ガイド』の第 3 章を参照してください。

## <a name="tls-and-dtls-extensions"></a>TLS と DTLS の拡張機能

TLS には (したがって DTLS にも)、特定のアプリケーションに対して追加機能を提供する多くの拡張機能が用意されています。 これらの拡張機能は、通常、ClientHello または ServerHello メッセージの一部として送信され、拡張機能の使用を望んでいることをリモート ホストに示したり、セキュリティで保護された TLS セッションの確立に使用する追加の詳細情報を提供したりします。

NetX Secure DTLS では、NetX Secure TLS に含まれるすべての拡張機能がサポートされます。それらの詳細については、『NetX Secure TLS ユーザー ガイド』の第 3 章を参照してください。

## <a name="authentication-methods"></a>認証方法

TLS と DTLS では、セキュリティで保護されていないネットワークを経由する 2 つのデバイス間で安全な接続を確立するためのフレームワークが提供されますが、問題の一部は、その接続の他方の側にあるデバイスの ID が認識されることです。 リモート ホストの ID を認証するためのメカニズムがない場合は、攻撃者が簡単に信頼されたデバイスを装うことができるようになります。

最初は、IP アドレス、ハードウェアの MAC アドレス、または DNS を使用すると、ネットワーク上のホストを識別するうえで比較的高い信頼性が得られるように思われるかもしれませんが、TCP/IP テクノロジの性質と、アドレスのなりすましや (たとえば DNS キャッシュ ポイズニングを通した) DNS エントリの破損は容易であることを考えると、TLS には不正な ID に対する追加の保護レイヤーが必要であることは明確になります。

この追加の認証レイヤーを TLS に提供できるさまざまなメカニズムがありますが、最も一般的なのは "*デジタル証明書*" です。 その他のメカニズムには、事前共有キー (PSK) とパスワードのスキームがあります。

### <a name="digital-cerificates"></a>デジタル証明書

デジタル証明書は、TLS でリモート ホストを認証するための最も一般的な方法です。 基本的にデジタル証明書は、コンピューター ネットワーク上のデバイスの ID 情報を提供する特定形式のドキュメントです。

TLS では通常、国際電気通信連合によって開発された標準である X.509 という形式が使用されますが、使用される形式について TLS ホストの同意が得られる場合は、他の形式の証明書を使用できます。 X.509 では、証明書の特定の形式と、デジタル ドキュメントの生成に使用できるさまざまなエンコードが定義されています。 TLS で使用されるほとんどの X.509 証明書は、別の通信規格である ASN.1 のバリアントを使用してエンコードされます。 ASN.1 にはさまざまなデジタル エンコードがありますが、TLS 証明書で最も一般的なエンコードは、Distinguished Encoding Rules (DER) 標準です。 DER は、あいまいさが排除されるように設計された ASN.1 基本エンコード規則 (BER) の簡略化されたサブセットであり、解析が容易になります。 通常、ネットワークでは、TLS 証明書はバイナリ DER でエンコードされます。これは NetX Secure で X.509 証明書に想定する形式です。

DER 形式のバイナリ証明書は実際の TLS プロトコルで使用されていますが、これらの証明書は、さまざまな異なるエンコードで生成し、.pem、.crt、.p12 などのファイル拡張子を付けて保存することができます。 さまざまな製造元のさまざまなアプリケーションで異なるバリアントが使用されていますが、通常は広く利用可能なツールを使用してそのすべてを DER に変換することができます。

代わりになる証明書エンコードで最も一般的なのは PEM です。 PEM (Privacy Enhanced Mail) 形式は、base-64 でエンコードされるバージョンの DER エンコードであり、エンコードの結果は、電子メールや Web ベースのプロトコルを使用して簡単に送信できる出力可能なテキストになるため、よく使用されています。

NetX Secure アプリケーション用の証明書の生成の大部分はこのマニュアルの範囲外ですが、OpenSSL コマンドライン ツール ([www.openssl.org](http://www.openssl.org)) が広く入手可能であり、ほとんどの形式間で変換を行うことができます。

アプリケーションによっては、独自の証明書を生成したり、製造元または政府機関による証明書を提示したり、商用証明機関から証明書を購入したりすることができます。

NetX Secure アプリケーションでデジタル証明書を使用するには、最初に証明書をバイナリ DER 形式に変換し、必要に応じて、関連付けられた秘密キー (RSA の場合は "プライベート指数") をバイナリ形式 (通常は PKCS#1 形式の DER でエンコードされた RSA キー) に変換する必要があります。 変換が完了したら、証明書と秘密キーのデバイスへの読み込みは、ユーザーの選択に委ねられます。 可能なオプションとしては、フラッシュベースのファイル システムの使用、データからの C 配列の生成 (Linux の "xxd" などのツールを使用)、および証明書とキーをアプリケーションに定数データとしてコンパイルする方法があります。

証明書がデバイスに読み込まれたら、DTLS API を使用して、証明書を DTLS セッションまたはサーバーに関連付けることができます。

NetX Secure DTLS での X.509 証明書の使用方法の詳細と例については、『NetX secure TLS ユーザー ガイド』の「X.509 証明書を NetX Secure にインポートする」のセクションを参照してください。

詳細については、API リファレンスの次の DTLS サービスを参照してください。

- nx_secure_x509_certificate_initialize
- nx_secure_dtls_session_local_certificate_add
- nx_secure_dtls_server_local_certificate_add
- nx_secure_dtls_session_local_certificate_remove
- nx_secure_dtls_server_local_certificate_remove
- nx_secure_dtls_session_trusted_certificate_add
- nx_secure_dtls_server_trusted_certificate_add
- nx_secure_dtls_session_trusted_certificate_remove
- nx_secure_dtls_server_trusted_certificate_remove

### <a name="tls-client-certificate-specifics"></a>TLS クライアント証明書の詳細

DTLS Client の実装では、通常、デバイスにローカル証明書を読み込む必要はありません。 ローカル証明書は、ローカル デバイスを識別する証明書です。 具体的には、ローカル証明書によって、TLS/DTLS アプリケーションが読み込まれるデバイスの ID 情報が提供されます。 ただし、クライアント証明書の認証が有効になっている場合は例外ですが、これはあまり一般的ではありません。

DTLS Client では、少なくとも 1 つの信頼された証明書を読み込み (必要に応じてさらに読み込むことができます)、リモート証明書の領域を割り当てる必要があります。 信頼された証明書は、リモート デバイスの信頼性と認証の基礎を提供する証明書であり、直接または公開キー基盤 (PKI) を介して提供されます。 信頼のチェーンのルートは、通常、証明機関または CA 証明書と呼ばれます。 リモート証明書は、TLS ハンドシェイク中にリモート ホストによって送信された証明書を指します。 そのリモート ホストの ID を提供し、ローカル デバイスの信頼された証明書と比較することによって認証されます。

信頼された証明書の追加とリモート証明書用の領域の割り当ての詳細については、nx_secure_dtls_session_create、nx_secure_dtls_session_trusted_certificate_add サービスの TLS API リファレンスを参照してください。

### <a name="tlsdtls-server-certificate-specifics"></a>TLS/DTLS Server 証明書の詳細

DTLS Server の実装では、通常、デバイスへの "信頼された" 証明書の読み込みや、リモート証明書の割り当ては必要ありません。 例外は、クライアント証明書の認証が有効になっている場合です。

TLS Server では、TLS ハンドシェイク中にクライアントに対してサーバーを認証するためにサーバーからリモート クライアントに提示できるように、"ローカル" (または "ID") の証明書を読み込む必要があります。

NetX TLS サーバー アプリケーションで使用するためのローカル証明書の読み込みの詳細については、nx_secure_dtls_server_local_certificate_add、nx_secure_dtls_server_local_certificate_remove サービスの API リファレンスを参照してください。


### <a name="pre-shared-keys-psk"></a>事前共有キー (PSK)

TLS で ID 認証を提供するための代替メカニズムは、事前共有キー (PSK) の概念です。 PSK 暗号スイートを使用すると、プロセッサが集中的に使用される公開キー暗号化の操作を行う必要がなくなり、リソースに制約がある組み込みデバイスにとっての恩恵となります。 TLS/DTLS ハンドシェイクの証明書が PSK に置き換わり、TLS/DTLS セッション キーの生成で暗号化されたプリマスター シークレットの代わりに使用されます。

PSK 暗号スイートは、TLS/DTLS セッションを確立する前に、両方のデバイスに共有シークレットが存在する必要があるという点で制限されています。 つまり、TLS PSK 接続以外のセキュリティで保護された方法を使用して、そのシークレットがデバイスに読み込まれている必要があります。PSK は、TLS PSK 接続を介した更新も可能ですが、デバイスは必ず、他の何らかのメカニズムを通じて読み込まれた PSK を使用して起動される必要があります。 たとえば、出荷前にセンサー デバイスとそのゲートウェイ デバイスに PSK を読み込むことや、標準の TLS 接続 (証明書を使用) を使用して PSK を読み込むことができます。

PSK 暗号スイートには、RFC 4279 で規定されている 2 つの形式があります。 1 つ目では RSA または Diffie-Hellman キーが使用され、これらが、標準の TLS ハンドシェイクにおいて証明書で転送される公開キーと同じ方法で使用されます。 2 番目の形式は、リソースの制約がある環境でより多く使用され、セッション キー (たとえば、AES で使用される) を直接生成するために使用される PSK を使用して、コストのかかる RSA または Diffie-Hellman 操作の使用が回避されます。

NetX Secure では、2 番目の形式の PSK 暗号スイートがサポートされるため、アプリケーションで使用されていた公開キー暗号化のためのすべてのコードとメモリが不要になります。 PSK 自体は AES キーではありませんが、実際のキーがそこから生成されるパスワードのようなものと考えることができます。 どのような PSK の値を使用できるかに関してほとんど制限はありませんが、値が長いほどセキュリティが高まります (パスワードの場合と同じ)。

NetX Secure アプリケーションで PSK を使用するには、まずグローバル マクロ **NX_SECURE_ENABLE_PSK_CIPHERSUITES** を定義する必要があります。 これは通常、コンパイラ設定を通じて行われますが、定義を nx_secure_tls.h ヘッダー ファイル内に配置することもできます。 このマクロを定義すると、PSK 暗号スイートのサポートが NetX Secure DTLS アプリケーションにコンパイルされます。

PSK のサポートを有効にすると、DTLS API を使用してアプリケーションの PSK を設定できます。 各 PSK には、PSK 値 (実際の秘密 "キー"。この値は安全に保管してください)、特定の PSK を識別するために使用される "ID" 値、および TLS サーバーで特定の PSK 値を選択するために使用される "ID ヒント" が必要です。

PSK 自体は、ネットワーク接続経由で送信されることがないため、任意のバイナリ値にすることができます。 PSK は、長さが最大 64 バイトの任意の値にすることができます。

ID とヒントは、UTF-8 を使用してフォーマットされた出力可能な文字列である必要があります。 ID とヒントの値は、最大 128 バイトの任意の長さにすることができます。

ID と PSK によって、相互に通信する必要があるネットワーク内のすべてのデバイスに読み込まれる一意の組が形成されます。

"ヒント" は主に、機能またはサービスによって PSK をグループ化する特定のアプリケーション プロファイルを定義するために使用されます。 これらの値は事前に合意されている必要があり、アプリケーションに依存します。 たとえば、OpenSSL コマンドライン サーバー アプリケーション (PSK が有効になっている) では、既定の文字列 "Client_identity" が使用されます。これは TLS ハンドシェイクを続行するために TLS クライアントによって提供される必要があります。

PSK の詳細については、nx_secure_dtls_psk_add、nx_secure_dtls_server_psk_add サービスに関する NetX Secure API リファレンスを参照してください。

## <a name="importing-x509-certificates-into-netx-secure"></a>X.509 証明書の NetX Secure へのインポート

デジタル証明書は、インターネット上のほとんどの TLS 接続に必要です。 以前は未知であったホストを、信頼できる中継点 (通常は "*証明機関*" または CA と呼ばれます) を使用することでインターネット経由で認証する手段が、証明書によって提供されます。 NetX Secure デバイスを商用クラウド サービス (アマゾン ウェブ サービスなど) に接続するには、デバイスに証明書を読み込むことによってアプリケーションに証明書をインポートする必要があります。

証明書と共に、証明書に関連付けられている "*秘密キー*" が必要になる場合もあります。 一部のアプリケーション (クライアント証明書認証が使用されない予定のときの TLS クライアントなど) では、証明書だけで十分ですが、デバイスの識別に証明書が使用される予定であれば、秘密キーが必要になります。 秘密キーは一般に、証明書を作成するときに生成され、別個のファイルに格納されます。多くの場合、パスワードで暗号化されます。

NetX Secure アプリケーションに証明書をインポートする方法の詳細については、『NetX Secure TLS ユーザー ガイド』の第 3 章を参照してください。

## <a name="client-certificate-authentication-in-netx-secure-tls"></a>NetX Secure TLS でのクライアント証明書の認証

X.509 証明書認証を使用する場合、TLS/DTLS プロトコルでは、DTLS Server インスタンスによって ID の証明書が提示される必要がありますが、既定では、DTLS Client インスタンスによって認証用の証明書が提示される必要はなく、代わりに別の形式の認証が使用されます (ユーザー名/パスワードの組み合わせなど)。 これは、インターネットでの、Web サイト向けの最も一般的な TLS の使用法に合致しています。 たとえばオンライン小売サイトでは、Web ブラウザーを使用している潜在顧客に、サーバーが正当なものであることを証明する必要がありますが、ユーザーはログインとパスワードを使用して特定のアカウントにアクセスします。

ただし、既定のケースが常に望ましいとは限らないため、TLS/DTLS では、必要に応じて DTLS Server インスタンスでリモート クライアントから証明書を要求することができます。 この機能が有効になっている場合は、DTLS Server によってハンドシェイク中に CertificateRequest メッセージが DTLS Client に送信されます。 クライアントでは、それ自身の証明書と、その証明書に関連付けられている一致する秘密キーがクライアントに所有されていることを証明する暗号化トークンが含まれる CertificateVerify メッセージで応答する必要があります。 検証が失敗した場合や、証明書がサーバー上の信頼された証明書に接続されていない場合は、TLS ハンドシェイクが失敗します。

TLS でのクライアント証明書認証には 2 つの異なるケースがあります。後続のセクションでは、両方のケースについて説明します。

### <a name="client-certificate-authentication-for-dtls-clients"></a>DTLS Client でのクライアント証明書の認証

DTLS Client では、クライアント認証のために証明書を要求するサーバーへの接続を試行する場合があります。 この場合、クライアントはサーバーに証明書を提供して、一致する秘密キーを保持していることを証明する必要があります。そうしないと、サーバーによって DTLS ハンドシェイクが終了されます。

NetX Secure DTLS では、この機能をサポートする特別な構成はありませんが、アプリケーションでは、*nx_secure_tls_session_local_certificate_add* サービスを使用して、TLS Client インスタンスのローカル ID 証明書を提供する必要があります。 アプリケーションによって証明書が提示されず、リモート サーバーでクライアント証明書の認証が使用されていて証明書が要求される場合、DTLS ハンドシェイクは失敗します。 DTLS ハンドシェイクを完了するには、*nx_secure_dtls_session_local_certificate_add* 使用して DTLS セッションに提示される証明書が、リモート サーバーによって認識される必要があります。

### <a name="client-certificate-authentication-for-tls-servers"></a>TLS サーバーでのクライアント証明書の認証

クライアント証明書の認証の DTLS Server のケースは、この機能がオプションであるため、DTLS Client の場合よりも若干複雑になります。 この場合 TLS サーバーでは、リモート TLS クライアントに証明書を要求してから CertificateVerify メッセージを処理し、リモート クライアントが一致する秘密キーを所有していることを検証する必要があります。その後サーバーで、クライアントから提供された証明書を、ローカルの信頼された証明書ストア内の証明書まで追跡できることを確認する必要があります。

NetX Secure TLS Server インスタンスでは、クライアント証明書の認証は *nx_secure_dtls_server_x509_client_verify_configure* および *nx_secure_dtls_server_x509_client_verify_disable* サービスによって制御されます。

クライアント証明書の認証を有効にするには、アプリケーションで、DTLS Server セッション インスタンスを使用して *nx_secure_dtls_server_x509_client_verify_configure* を呼び出してから、*nx_secure_dtls_server_start* を呼び出す必要があります。 検証を行うには、*nx_secure_dtls_server_x509_client_verify_configure* のパラメーターとして提供される受信クライアント証明書用に割り当てる領域が必要です。 そのバッファーは、証明書チェーンの最大サイズ ("*クライアント x DTLS Server のセッション数*") を保持するために十分な大きさにする必要があることに注意してください。 各サーバー セッションには、指定された 1 つのバッファーから割り当てられる領域が必要です。 バッファーのサイズが十分であることを確認してください。提供されたクライアント証明書チェーンが大きすぎる場合は、エラーが発生します。

クライアント証明書の認証が有効になっている場合、DTLS ハンドシェイク中に、DTLS Server ではリモート DTLS Client に証明書を要求します。 NetX Secure の DTLS Server では、クライアント証明書は、X.509 発行者チェーンをたどって *nx_secure_dtls_server_trusted_certificate_add* で作成された信頼された証明書のストアに対してチェックされます。 リモート クライアントでは、信頼されたストア内の証明書に ID 証明書を接続するチェーンを提供する必要があります。そうしないと、DTLS ハンドシェイクが失敗します。 また、CertificateVerify メッセージの処理が失敗した場合は、DTLS ハンドシェイクも失敗します。

CertificateVerify メソッドに使用される署名方法は、TLS バージョン 1.0 および TLS バージョン 1.1 では固定されており、NetX Secure DTLS のベースである TLS バージョン 1.2 では TLS Server によって指定されます。 DTLS 1.2 の場合、通常、サポートされる署名方法は、暗号化方式テーブルに提供されている関連する方法に従いますが、通常は RSA と SHA-256 が使用されます (暗号化方式を使用した TLS の初期化の詳細については、「NetX Secure TLS での暗号化」を参照してください)。

## <a name="cryptography-in-netx-secure-tls"></a>NetX Secure TLS での暗号化

TLS では、暗号化を使用してネットワーク通信をセキュリティで保護できるプロトコルが定義されています。 そのため、実際に使用される暗号化に関して TLS ユーザーには幅広い選択肢があります。 仕様では、1 つの暗号スイートを実装することのみが要求されます。TLS 1.2 の場合、その暗号スイートは TLS_RSA_WITH_AES_128_CBC_SHA であり、公開キー操作に RSA、セッションの暗号化に 128 ビットのキーを使用する CBC モードの AES、メッセージ認証のハッシュに SHA-1 が使用されることを示します。

NetX Secure は、TLS 1.2 に準拠しており、既定で必須の TLS_RSA_WITH_AES_128_CBC_SHA 暗号スイートが有効にされます。ただし、ハードウェアの機能やその他の考慮事項によって暗号化方式ごとに可能な実装が多数あるため、NetX Secure では、TLS で使用される暗号化方式をユーザーが指定できるようにする汎用の暗号化 API が提供されています。

> [!NOTE]
> 汎用暗号 API メカニズムでは、ユーザーが独自の暗号スイートを実装することもできますが、これは TLS 暗号スイートと拡張機能に精通している上級ユーザーにお勧めします。 独自の暗号スイートのサポートに関心がある場合は、Express Logic の担当者にお問い合わせください。

DTLS の暗号化方式の構成方法の詳細については、『NetX Secure TLS ユーザー ガイド』の第 3 章を参照してください。 TLS と DTLS の両方に同じプロセスが適用されます。
