---
title: 第 3 章 - Azure RTOS NetX Secure DTLS の機能の説明
description: この章では、Azure RTOS NetX Secure DTLS の機能について説明します。
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 468f1dc8a8334dc89064594b29dc8cfabd7d8fae
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811795"
---
# <a name="chapter-3-functional-description-of-azure-rtos-netx-secure-dtls"></a><span data-ttu-id="9db8c-103">第 3 章: Azure RTOS NetX Secure DTLS の機能の説明</span><span class="sxs-lookup"><span data-stu-id="9db8c-103">Chapter 3: Functional description of Azure RTOS NetX Secure DTLS</span></span>

## <a name="execution-overview"></a><span data-ttu-id="9db8c-104">実行の概要</span><span class="sxs-lookup"><span data-stu-id="9db8c-104">Execution Overview</span></span>

<span data-ttu-id="9db8c-105">この章では、Azure RTOS NetX Secure DTLS の機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-105">This chapter contains a functional description of Azure RTOS NetX Secure DTLS.</span></span> <span data-ttu-id="9db8c-106">NetX Secure DTLS アプリケーションには、初期化とアプリケーション インターフェイスの呼び出しという主に 2 種類のプログラム実行があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-106">There are two primary types of program execution in a NetX Secure DTLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="9db8c-107">NetX Secure では、ThreadX と NetX/NetXDuo が存在することが想定されています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-107">NetX Secure assumes the existence of ThreadX and NetX/NetXDuo.</span></span> <span data-ttu-id="9db8c-108">ThreadX では、スレッドの実行、中断、周期的なタイマー、相互排他の機能が必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-108">From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities.</span></span> <span data-ttu-id="9db8c-109">NetX/NetXDuo では、UDP と IP のネットワーク機能とドライバーが必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-109">From NetX/NetXDuo it requires the UDP and IP networking facilities and drivers.</span></span>

## <a name="datagram-transport-layer-security-dtls-and-transport-layer-security-tls"></a><span data-ttu-id="9db8c-110">データグラム トランスポート層セキュリティ (DTLS) とトランスポート層セキュリティ (TLS)</span><span class="sxs-lookup"><span data-stu-id="9db8c-110">Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)</span></span>

<span data-ttu-id="9db8c-111">NetX Secure DTLS では、RFC 6347 で定義されているデータグラム トランスポート層セキュリティ プロトコル バージョン 1.2 が実装されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-111">NetX Secure DTLS implements the Datagram Transport Layer Security protocol version 1.2 defined in RFC 6347.</span></span> <span data-ttu-id="9db8c-112">DTLS バージョン 1.0 は、RFC 4347 に定義されており、TLS バージョン 1.1 に対応しています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-112">DTLS version 1.0 was defined in RFC 4347 and corresponded to TLS version 1.1.</span></span> <span data-ttu-id="9db8c-113">DTLS は基本的に TLS の拡張であるため、次のバージョンには対応する TLS バージョンと同じバージョン番号を使用することが決定されました。</span><span class="sxs-lookup"><span data-stu-id="9db8c-113">Due to DTLS being essentially an extension to TLS, it was decided that the next version would use the same version number as the corresponding TLS version.</span></span> <span data-ttu-id="9db8c-114">したがって、DTLS バージョン 1.2 は TLS バージョン 1.2 に対応するため、DTLS バージョン 1.1 はありません。</span><span class="sxs-lookup"><span data-stu-id="9db8c-114">Thus, there is no DTLS version 1.1 as DTLS version 1.2 corresponds to TLS version 1.2.</span></span>

> [!NOTE]
> <span data-ttu-id="9db8c-115">NetX Secure では、DTLS バージョン 1.2 がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-115">NetX Secure supports DTLS version 1.2.</span></span> <span data-ttu-id="9db8c-116">DTLS 1.0 (RFC 4347) は現在サポートされて **いません**。</span><span class="sxs-lookup"><span data-stu-id="9db8c-116">DTLS 1.0 (RFC 4347) is **not** currently supported.</span></span>

<span data-ttu-id="9db8c-117">*Secure Sockets Layer* (SSL) は、RFC 2246 で標準になる前の TLS の元の名前でしたが、多くの場合、"SSL" は TLS プロトコルの総称として使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-117">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and “SSL” is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="9db8c-118">SSL の最新バージョンは 3.0 であり、TLS 1.0 は SSL バージョン 3.1 と呼ばれることもあります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-118">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="9db8c-119">正式な "SSL" プロトコルのすべてのバージョンは、形式が古く安全ではないと見なされています。現在 NetX Secure では SSL の実装は提供されていません。</span><span class="sxs-lookup"><span data-stu-id="9db8c-119">All versions of the official “SSL” protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="9db8c-120">TLS では、TLS クライアントとサーバー間の TLS "*ハンドシェイク*" 中に作成される "*セッション キー*" を生成するためのプロトコルが規定されており、それらのキーは、TLS "*セッション*" 中にアプリケーションによって送信されるデータを暗号化するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-120">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="9db8c-121">DTLS は TLS と密接に結び付いています。これは、基になるセキュリティ メカニズムがプロトコル間で共有されているためです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-121">DTLS is closely coupled with TLS, as the underlying security mechansims are shared between the protocols.</span></span> <span data-ttu-id="9db8c-122">ただし、TLS は、パケットの配信と順序が保証されるトランスポート層プロトコル (実際にはほとんど常に TCP) を介して動作するように設計されており、UDP のような信頼性の低いプロトコルでは機能しません。</span><span class="sxs-lookup"><span data-stu-id="9db8c-122">However, TLS is designed to work over a transport layer protocol that provides guarantees about packet delivery and order (almost always TCP in practice) and will not function over an unreliable protocol like UDP.</span></span> <span data-ttu-id="9db8c-123">これは UDP 用に DTLS が導入されたためです。DTLS は 信頼性のない性質を持つ UDP や同様のプロトコルが処理されるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-123">It is precisely because of UDP that DTLS was introduced: DTLS was designed handle the unreliable nature of UDP and similar protocols.</span></span> <span data-ttu-id="9db8c-124">これを行うために、TCP のような信頼性の高いプロトコルと同様に、順序付けと信頼性のロジック (破棄されたデータの再転送など) が含められています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-124">It does this by including ordering and reliability logic (e.g. retransmission of dropped data) similar to reliable protocols like TCP.</span></span>

<span data-ttu-id="9db8c-125">TLS の詳細については、『NetX Secure TLS ユーザーガイド』の第 3 章を参照してください。このドキュメントでは、TLS と DTLS の違いに焦点を当てて説明します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-125">A complete discussion of TLS is included in Chapter 3 of the NetX Secure TLS User’s Guide, so this document will focus on the differences between TLS and DTLS.</span></span>

### <a name="dtls-record-header"></a><span data-ttu-id="9db8c-126">DTLS レコードのヘッダー</span><span class="sxs-lookup"><span data-stu-id="9db8c-126">DTLS Record header</span></span>

<span data-ttu-id="9db8c-127">図 1 に示すように、有効な DTLS レコードには、DTLS ヘッダーが必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-127">Any valid DTLS record must have a DTLS header, as shown in Figure 1.</span></span> <span data-ttu-id="9db8c-128">ヘッダーは TLS と同じですが、新しい 2 つのフィールドが追加されています。以下に示すように、16 ビットの "*エポック*" と 48 ビットの "*シーケンス番号*" です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-128">The header is the same as TLS with the addition of two new fields: the 16-bit *epoch* and the 48-bit *sequence number*, described below.</span></span>

![DTLS レコードのヘッダーの図。](media/image2.png)

<span data-ttu-id="9db8c-130">**図 1 - DTLS レコードのヘッダー**</span><span class="sxs-lookup"><span data-stu-id="9db8c-130">**Figure 1 - DTLS record header**</span></span>

<span data-ttu-id="9db8c-131">TLS レコードのヘッダーのフィールドは、次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-131">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="9db8c-132">TLS ヘッダーのフィールド</span><span class="sxs-lookup"><span data-stu-id="9db8c-132">TLS Header Field</span></span> | <span data-ttu-id="9db8c-133">目的</span><span class="sxs-lookup"><span data-stu-id="9db8c-133">Purpose</span></span>  |
| ---------------- | --------- |
| <span data-ttu-id="9db8c-134">**8 ビットでのメッセージの種類**</span><span class="sxs-lookup"><span data-stu-id="9db8c-134">**8-bit Message Type**</span></span> | <span data-ttu-id="9db8c-135">このフィールドには、送信されている DTLS レコードの種類が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-135">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="9db8c-136">有効な種類は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-136">Valid types are as follows:</span></span><br /><span data-ttu-id="9db8c-137">- ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="9db8c-137">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="9db8c-138">- Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="9db8c-138">- Alert: 0x15</span></span><br /><span data-ttu-id="9db8c-139">- Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="9db8c-139">- Handshake: 0x16</span></span><br /><span data-ttu-id="9db8c-140">- Application Data: 0x17</span><span class="sxs-lookup"><span data-stu-id="9db8c-140">- Application Data: 0x17</span></span><br /> |
| <span data-ttu-id="9db8c-141">**16 ビットでのプロトコル バージョン**</span><span class="sxs-lookup"><span data-stu-id="9db8c-141">**16-bit Protocol Version**</span></span> | <span data-ttu-id="9db8c-142">このフィールドには、DTLS プロトコルのバージョンが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-142">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="9db8c-143">有効な値は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-143">Valid values are as follows:</span></span><br /><span data-ttu-id="9db8c-144">- DTLS 1.1: 0xFEFD</span><span class="sxs-lookup"><span data-stu-id="9db8c-144">- DTLS 1.1: 0xFEFD</span></span> |
|  <span data-ttu-id="9db8c-145">**16 ビットのエポック**</span><span class="sxs-lookup"><span data-stu-id="9db8c-145">**16-bit Epoch**</span></span> |  <span data-ttu-id="9db8c-146">このフィールドには、DTLS の "エポック" が含まれています。これは、暗号化の状態が変更される (新しいセッション キーが生成されるときなど) たびに増分されるカウンターです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-146">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span>  |
|  <span data-ttu-id="9db8c-147">**48 ビットのシーケンス番号**</span><span class="sxs-lookup"><span data-stu-id="9db8c-147">**48-bit Sequence Number**</span></span> |  <span data-ttu-id="9db8c-148">このフィールドには、この特定のレコードを識別するシーケンス番号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-148">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="9db8c-149">レコードの順序を維持し、再転送の必要性を確認するために、DTLS によって使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-149">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="9db8c-150">**16 ビットでの長さ**</span><span class="sxs-lookup"><span data-stu-id="9db8c-150">**16-bit Length**</span></span> |  <span data-ttu-id="9db8c-151">このフィールドには、DTLS レコードにカプセル化されたデータの長さが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-151">This field contains the length of the data encapsulated in the DTLS record.</span></span>  |

### <a name="dtls-handshake-record-header"></a><span data-ttu-id="9db8c-152">DTLS ハンドシェイク レコードのヘッダー</span><span class="sxs-lookup"><span data-stu-id="9db8c-152">DTLS Handshake Record header</span></span>

<span data-ttu-id="9db8c-153">図 2 に示すように、有効な DTLS ハンドシェイク レコードには、DTLS ハンドシェイクのヘッダーが必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-153">Any valid DTLS handshake record must have a DTLS Handshake header, as shown in Figure 2.</span></span>

![DTLS ハンドシェイク レコードのヘッダーの図。](media/image3.png)

<span data-ttu-id="9db8c-155">**図 2 - DTLS ハンドシェイク レコードのヘッダー**</span><span class="sxs-lookup"><span data-stu-id="9db8c-155">**Figure 2 - DTLS Handshake record header**</span></span>

<span data-ttu-id="9db8c-156">DTLS ハンドシェイク レコードのヘッダーのフィールドは、次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-156">The fields of the DTLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="9db8c-157">TLS ヘッダーのフィールド</span><span class="sxs-lookup"><span data-stu-id="9db8c-157">TLS Header Field</span></span> | <span data-ttu-id="9db8c-158">目的</span><span class="sxs-lookup"><span data-stu-id="9db8c-158">Purpose</span></span> |
| ---------------- | ------------------------------------------------ |
| <span data-ttu-id="9db8c-159">**8 ビットでのメッセージの種類**</span><span class="sxs-lookup"><span data-stu-id="9db8c-159">**8-bit Message Type**</span></span> | <span data-ttu-id="9db8c-160">このフィールドには、送信されている DTLS レコードの種類が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-160">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="9db8c-161">有効な種類は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-161">Valid types are as follows:</span></span><br /><span data-ttu-id="9db8c-162">- ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="9db8c-162">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="9db8c-163">- Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="9db8c-163">- Alert: 0x15</span></span><br /><span data-ttu-id="9db8c-164">- Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="9db8c-164">- Handshake: 0x16</span></span><br /><span data-ttu-id="9db8c-165">- Application Data: 0x17</span><span class="sxs-lookup"><span data-stu-id="9db8c-165">- Application Data: 0x17</span></span> |
|  <span data-ttu-id="9db8c-166">**16 ビットのエポック**</span><span class="sxs-lookup"><span data-stu-id="9db8c-166">**16-bit Epoch**</span></span> | <span data-ttu-id="9db8c-167">このフィールドには、DTLS の "エポック" が含まれています。これは、暗号化の状態が変更される (新しいセッション キーが生成されるときなど) たびに増分されるカウンターです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-167">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span> |
|  <span data-ttu-id="9db8c-168">**48 ビットのシーケンス番号**</span><span class="sxs-lookup"><span data-stu-id="9db8c-168">**48-bit Sequence Number**</span></span> | <span data-ttu-id="9db8c-169">このフィールドには、この特定のレコードを識別するシーケンス番号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-169">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="9db8c-170">レコードの順序を維持し、再転送の必要性を確認するために、DTLS によって使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-170">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="9db8c-171">**16 ビットでのプロトコル バージョン**</span><span class="sxs-lookup"><span data-stu-id="9db8c-171">**16-bit Protocol Version**</span></span> | <span data-ttu-id="9db8c-172">このフィールドには、DTLS プロトコルのバージョンが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-172">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="9db8c-173">有効な値は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-173">Valid values are as follows:</span></span><br /><span data-ttu-id="9db8c-174">- DTLS 1.1: 0xFEFD</span><span class="sxs-lookup"><span data-stu-id="9db8c-174">- DTLS 1.1: 0xFEFD</span></span> |
| <span data-ttu-id="9db8c-175">**16 ビットでの長さ**</span><span class="sxs-lookup"><span data-stu-id="9db8c-175">**16-bit Length**</span></span> | <span data-ttu-id="9db8c-176">このフィールドには、DTLS レコードにカプセル化されたデータの長さが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-176">This field contains the length of the data encapsulated in the DTLS record.</span></span> |
| <span data-ttu-id="9db8c-177">**8 ビットでのハンドシェイクの種類**</span><span class="sxs-lookup"><span data-stu-id="9db8c-177">**8-bit Handshake Type**</span></span> | <span data-ttu-id="9db8c-178">このフィールドには、ハンドシェイク メッセージの種類が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-178">This field contains the handshake message type.</span></span> <span data-ttu-id="9db8c-179">有効な値は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-179">Valid values are as follows:</span></span><br /><span data-ttu-id="9db8c-180">- HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="9db8c-180">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="9db8c-181">- ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="9db8c-181">- ClientHello: 0x01</span></span><br /><span data-ttu-id="9db8c-182">- ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="9db8c-182">- ServerHello: 0x02</span></span><br /><span data-ttu-id="9db8c-183">- Certificate: 0x0B</span><span class="sxs-lookup"><span data-stu-id="9db8c-183">- Certificate: 0x0B</span></span><br /><span data-ttu-id="9db8c-184">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="9db8c-184">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="9db8c-185">- CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="9db8c-185">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="9db8c-186">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="9db8c-186">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="9db8c-187">- CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="9db8c-187">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="9db8c-188">- ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="9db8c-188">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="9db8c-189">- 完了しました</span><span class="sxs-lookup"><span data-stu-id="9db8c-189">- Finished</span></span> | <span data-ttu-id="9db8c-190">0x14</span><span class="sxs-lookup"><span data-stu-id="9db8c-190">0x14</span></span> |
| <span data-ttu-id="9db8c-191">**24 ビットでの長さ**</span><span class="sxs-lookup"><span data-stu-id="9db8c-191">**24-bit Length**</span></span> | <span data-ttu-id="9db8c-192">このフィールドには、ハンドシェイク メッセージのデータの長さが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-192">This field contains the length of the handshake message data.</span></span> |
| <span data-ttu-id="9db8c-193">**16 ビットのシーケンス番号**</span><span class="sxs-lookup"><span data-stu-id="9db8c-193">**16-bit Sequence Number**</span></span> | <span data-ttu-id="9db8c-194">このフィールドには、シーケンス番号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-194">This field contains a sequence number.</span></span> |

### <a name="the-dtls-handshake-and-dtls-session"></a><span data-ttu-id="9db8c-195">DTLS ハンドシェイクと DTLS セッション</span><span class="sxs-lookup"><span data-stu-id="9db8c-195">The DTLS Handshake and DTLS Session</span></span>

<span data-ttu-id="9db8c-196">一般的な DTLS ハンドシェイクを図 3 に示します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-196">A typical DTLS handshake is shown in Figure 3.</span></span> <span data-ttu-id="9db8c-197">これは一般的な TLS ハンドシェイクとほぼ同じですが、重要な違いがあります。ClientHello メッセージが最初に送信されると、サーバーでは、"cookie" が含まれている新しい DTLS 固有のメッセージ (*HelloVerifyRequest*) を使用して応答します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-197">It is nearly identical to the typical TLS handshake with an important difference – when the ClientHello message is first sent, the server responds with a new DTLS-specific message, *HelloVerifyRequest* which contains a “cookie”.</span></span> <span data-ttu-id="9db8c-198">DTLS Client では、ハンドシェイクを続行する前に、その cookie が含まれている 2 回目の ClientHello メッセージで応答する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-198">The DTLS Client must respond with a second ClientHello message containing that cookie before the handshake can proceed.</span></span> <span data-ttu-id="9db8c-199">UDP はコネクションレス プロトコルであるため、特定のサービス拒否 (DoS) 攻撃を防ぐためにこのメカニズムが DTLS に追加されました (TCP には専用の接続/ポートが必要であるため、TLS では同じ問題は発生しません)。</span><span class="sxs-lookup"><span data-stu-id="9db8c-199">This mechanism was added to DTLS to prevent certain Denial of Service (DoS) attacks since UDP is a connectionless protocol (TCP requires a dedicated connection/port so TLS does not suffer from the same issue).</span></span>

<span data-ttu-id="9db8c-200">DTLS ハンドシェイクは、クライアントが *ClientHello* メッセージを DTLS Server に送信するときに開始され、DTLS セッションの開始を求めていることを示します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-200">A DTLS handshake begins when the Client sends a *ClientHello* message to a DTLS server, indicating its desire to start a DTLS session.</span></span> <span data-ttu-id="9db8c-201">このメッセージには、クライアントでセッションに使用する暗号化に関する情報と、後でハンドシェイクでセッション キーを生成するために使用される情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-201">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="9db8c-202">セッション キーが生成されるまで、DTLS ハンドシェイクのすべてのメッセージが暗号化されません。</span><span class="sxs-lookup"><span data-stu-id="9db8c-202">Until the session keys are generated, all messages in the DTLS handshake are not encrypted.</span></span> <span data-ttu-id="9db8c-203">前述のように、DTLS Server では、ClientHello に応答して HelloVerifyRequest を送信し、クライアントが 2 回目の更新された ClientHello で応答するように強制することがあります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-203">As mentioned above, the DTLS Server may send a HelloVerifyRequest in response to the ClientHello, forcing the client to respond with a second updated ClientHello.</span></span>

<span data-ttu-id="9db8c-204">2 回目の ClientHello メッセージを受信すると、DTLS Server では cookie を確認し、正しい場合は、クライアントから提供された暗号化オプションからの選択を示す ServerHello メッセージで応答します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-204">Upon receiving the second ClientHello message, the DTLS Server will verify the cookie and if correct will respond with a ServerHello message indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="9db8c-205">ServerHello の後には証明書メッセージが続きます。このメッセージには、クライアントに対して ID を認証するためのデジタル証明書がサーバーによって提供されます (X.509 検証が使用されている場合)。</span><span class="sxs-lookup"><span data-stu-id="9db8c-205">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client (if X.509 verification is used).</span></span> <span data-ttu-id="9db8c-206">最後に、サーバーによって、送信するメッセージがこれ以上ないことを示す ServerHelloDone メッセージが送信されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-206">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="9db8c-207">サーバーによって、必要に応じて、ServerHello の後に他のメッセージが送信されることがあります。場合によっては、証明書メッセージが送信されないこともあります (事前共有キーが使用されている場合など)。そのため、ServerHelloDone メッセージが必要になります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-207">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message (such as when Pre-Shared Keys are used), hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="9db8c-208">クライアントでサーバーのすべてのメッセージが受信されると、セッション キーを生成するための十分な情報が得られます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-208">Once the client has received all the server’s messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="9db8c-209">TLS/DTLS では、"*プリマスター シークレット*" と呼ばれるランダムなデータの共有ビットを作成することによってこれが行われます。これは固定サイズであり、暗号化が有効にされた後に必要なすべてのキーを生成するためのシードとして使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-209">TLS/DTLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="9db8c-210">プリマスター シークレットは、Hello メッセージに指定された公開キー アルゴリズム (RSA など) と、サーバーによって証明書で提供された公開キーを使用して暗号化されます (公開キー アルゴリズムの詳細については後述します)。</span><span class="sxs-lookup"><span data-stu-id="9db8c-210">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="9db8c-211">事前共有キー (PSK) と呼ばれるオプションの TLS/DTLS 機能を使用すると、証明書を使用せず、代わりにホスト間で共有されるシークレット値 (通常は物理的転送またはその他のセキュリティで保護された方法による) を使用する暗号スイートが有効になります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-211">An optional TLS/DTLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="9db8c-212">PSK が有効になっている場合は、事前共有秘密キーを使用して、プリマスター シークレットが生成されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-212">When PSK is enabled, the pre-shared secret key is used to generate the Pre-Master Secret.</span></span> <span data-ttu-id="9db8c-213">以下の「認証方法」の「事前共有キー」のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-213">See the section on Pre-Shared Keys in “Authentication Methods” below.</span></span>

<span data-ttu-id="9db8c-214">通常の TLS/DTLS ハンドシェイクでは、暗号化されたプリマスター シークレットが ClientKeyExchange メッセージでサーバーに送信されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-214">In a usual TLS/DTLS handshake, the encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="9db8c-215">サーバーでは、ClientKeyExchange メッセージを受信すると、その秘密キーを使用してプリマスター シークレットの暗号化を解除し、TLS/DTLS Client と並行してセッション キーの生成に進みます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-215">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS/DTLS client.</span></span>

<span data-ttu-id="9db8c-216">セッション キーが生成されると、それ以降のメッセージはすべて、Hello メッセージで選択された秘密キー アルゴリズム (AES など) を使用して暗号化できます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-216">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="9db8c-217">以後のメッセージはすべて暗号化されることを示すため、ChangeCipherSpec という暗号化されていない最後のメッセージが、クライアントとサーバーの両方によって送信されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-217">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="9db8c-218">クライアントとサーバーの両方によって送信される最初の暗号化されたメッセージも、Finished という最後の TLS ハンドシェイク メッセージです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-218">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="9db8c-219">このメッセージには、送受信されたすべてのハンドシェイク メッセージのハッシュが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-219">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="9db8c-220">このハッシュは、ハンドシェイクのどのメッセージも、改ざんされたり破損したり (セキュリティ侵害の可能性を示します) していないことを検証するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-220">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="9db8c-221">Finished メッセージが受信され、ハンドシェイクのハッシュが検証されると、TLS/DTLS セッションが開始され、アプリケーションでデータの送受信が開始されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-221">Once the Finished messages are received and the handshake hashes are verified, the TLS/DTLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="9db8c-222">TLS/DTLS セッション中にどちらかによって送信されたすべてのデータは、最初に Hello メッセージで選択されたハッシュ アルゴリズムを使用してハッシュされ (メッセージの整合性を提供するため)、選択された秘密キー アルゴリズムと生成されたセッション キーを使用して暗号化されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-222">All data sent by either side during the TLS/DTLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="9db8c-223">最後に、TLS/DTLS セッションは、クライアントまたはサーバーのいずれかが終了することを選択した場合にのみ、正常に終了することができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-223">Finally, a TLS/DTLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="9db8c-224">打ち切られたセッションは、セキュリティ違反と見なされます (攻撃者が、送信されているすべてのデータが受信されないようにしている可能性があるため)。そのため、どちらかがセッションを終了したいときに、CloseNotify アラートという特別な通知が送信されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-224">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="9db8c-225">セッションを正常に停止するには、クライアントとサーバーの両方で CloseNotify アラートを送信して処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-225">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![一般的な DTLS ハンドシェイク セッションの図。](media/image4.png)

<span data-ttu-id="9db8c-227">**図 3 - 一般的な DTLS ハンドシェイク**</span><span class="sxs-lookup"><span data-stu-id="9db8c-227">**Figure 3- Typical DTLS handshake**</span></span>

### <a name="initialization"></a><span data-ttu-id="9db8c-228">初期化</span><span class="sxs-lookup"><span data-stu-id="9db8c-228">Initialization</span></span>

<span data-ttu-id="9db8c-229">NetX Secure DTLS を使用する前に、NetX または NetXDuo のスタックを初期化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-229">The NetX or NetXDuo stack must be initialized prior to using NetX Secure DTLS.</span></span> <span data-ttu-id="9db8c-230">UDP の操作のために TCP/IP スタックを正しく初期化する方法については、NetX または NetXDuo のユーザー ガイドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-230">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack for UDP operation.</span></span>

<span data-ttu-id="9db8c-231">NetX UDP が初期化されたら、DTLS を有効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-231">Once NetX UDP has been initialized, DTLS can be enabled.</span></span> <span data-ttu-id="9db8c-232">内部的には、DTLS ネットワークのトラフィックと処理はすべて、ユーザーの介入なしで NetX/NetXDuo のスタックによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-232">Internally, all DTLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="9db8c-233">ただし、DTLS には、基になるネットワーク スタックとは別に処理する必要があるいくつかの固有の要件があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-233">However, DTLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="9db8c-234">DTLS Client の操作では、これらのパラメーターは \***NX_SECURE_DTLS_SESSION** _ という DTLS 制御ブロックに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-234">DTLS Client operation these parameters are assigned to the DTLS control block called \***NX_SECURE_DTLS_SESSION** _.</span></span> <span data-ttu-id="9db8c-235">DTLS Server の操作の場合、制御ブロックは _ *_NX_SECURE_DTLS_SERVER_*\* と呼ばれ、1 つの UDP ポートで複数の DTLS セッションを処理するために必要なインフラストラクチャが含まれています。これは、各 TLS セッションが 1 つの TCP ポートにバインドされる TLS とは異なることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-235">For DTLS Server operation, control block is called _ *_NX_SECURE_DTLS_SERVER_*\* and it contains the infrastructure needed to handle multiple DTLS sessions on a single UDP port – note that this is different from TLS where a each TLS session is bound to a single TCP port.</span></span>

<span data-ttu-id="9db8c-236">Server と Client の 2 つの DTLS モードは、アプリケーションで有効にすることができ (ただし、NetX ソケットごとにモードは 1 つのみ)、以下で説明するようにそれぞれに固有の要件があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-236">The two DTLS modes, Server and Client, may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

### <a name="initialization--dtls-server"></a><span data-ttu-id="9db8c-237">初期化 – DTLS Server</span><span class="sxs-lookup"><span data-stu-id="9db8c-237">Initialization – DTLS Server</span></span>

<span data-ttu-id="9db8c-238">NetX Secure DTLS Server モードは、基盤となるネットワーク トランスポート プロトコルに UDP が使用されるため、TLS Server モードとは異なります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-238">NetX Secure DTLS Server mode differs from TLS Server mode due to the use of UDP for the underlying network transport protocol.</span></span> <span data-ttu-id="9db8c-239">TCP では、TLS セッションの間、ポートは単一のリモート ホストにバインドされます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-239">With TCP, the port is bound to a single remote host for the duration of the TLS session.</span></span> <span data-ttu-id="9db8c-240">UDP では、リモート ホストに関して状態の概念がないため、異なるホストからの DTLS 要求がすべて同じ UDP インターフェイスで受信されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-240">UDP has no notion of state with regard to the remote host so DTLS requests from different hosts will all be received on the same UDP interface.</span></span> <span data-ttu-id="9db8c-241">そのため、DTLS では、TLS および TCP と同様に、ソケットに依存するのではなく、セッション状態を保持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-241">Therefore, DTLS must maintain session state rather than relying on the socket as with TLS and TCP.</span></span> <span data-ttu-id="9db8c-242">このため、DTLS Server の制御ブロック (NX_SECURE_DTLS_SERVER) では、リモート ホスト情報 (IP アドレスとポート) と DTLS セッションのマッピングが保持されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-242">For this reason, the DTLS Server control block (NX_SECURE_DTLS_SERVER) maintains a mapping of remote host information (IP address and port) to DTLS sessions.</span></span> <span data-ttu-id="9db8c-243">DTLS Server に割り当てられた UDP ソケットへのすべての受信データは、リモート ホストに基づいて既存または新規の DTLS セッションにマップされます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-243">All incoming data on the UDP socket assigned to a DTLS Server will be mapped to an existing or new DTLS session based on the remote host.</span></span> <span data-ttu-id="9db8c-244">このため、DTLS Server の作成では、TLS および DTLS Client で必要とされるもの以外に、いくつかの追加パラメーターが必要となります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-244">For this reason, the DTLS server creation requires several additional parameters beyond what TLS and DTLS Client need.</span></span>

<span data-ttu-id="9db8c-245">DTLS Server には、DTLS Server 制御ブロック、TLS 暗号スイート、および暗号スクラッチ領域/メタデータ バッファーに加えて、DTLS セッションを保持するためのバッファーと、受信した DTLS レコードの暗号化を解除するために使用されるパケット再構築バッファーが必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-245">In addition to the DTLS Server control block, TLS ciphersuites, and cipher scratchspace/metadata buffer, DTLS Servers require a buffer to maintain DTLS sessions and a packet reassembly buffer used to decrypt incoming DTLS records.</span></span>

<span data-ttu-id="9db8c-246">セッション バッファーに加えて、DTLS Server には "*デジタル証明書*" (接続している TLS クライアントに対して TLS サーバーを識別するために使用されるドキュメント) と、"*秘密キー*" に対応する証明書 (通常は RSA 暗号化アルゴリズム用) が必要となります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-246">In addition to the session buffers, DTLS Servers require a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="9db8c-247">国際電気通信連合の X.509 標準では、TLS/DTLS によって使用される証明書の形式が規定されています。また、X.509 デジタル証明書を作成するためのユーティリティが数多くあります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-247">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS/DTLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="9db8c-248">NetX Secure DTLS の場合、X.509 証明書は、ASN.1 の Distinguished Encoding Rules (DER) 形式を使用してバイナリでエンコードされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-248">For NetX Secure DTLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="9db8c-249">DER は、証明書の標準的な TLS ネットワーク転送のバイナリ形式です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-249">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="9db8c-250">指定された証明書に関連付けられている秘密キーは、DER でエンコードされた PKCS#1 形式である必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-250">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="9db8c-251">秘密キーはデバイスでのみ使用され、ネットワーク経由で送信されることはありません。</span><span class="sxs-lookup"><span data-stu-id="9db8c-251">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="9db8c-252">TLS/DTLS 通信をセキュリティで保護するため、秘密キーは安全に保管してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-252">Keep private keys safe as they provide the security for TLS/DTLS communications!</span></span>

<span data-ttu-id="9db8c-253">DTLS Server 証明書を初期化するには、アプリケーションで、DER でエンコードされた X.509 証明書とオプションの DER でエンコードされた PKCS#1 RSA 秘密キー データを含むバッファーへのポインターを ***nx_secure_x509_certificate_intialize*** サービスを使用して提供する必要があります。このサービスにより、TLS で使用される適切な証明書データが **NX_SECURE_X509_CERT** 構造に移入されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-253">To initialize the DTLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize*** service, which populates the **NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="9db8c-254">サーバー証明書が初期化されたら、***nx_secure_dtls_server_local_certificate_add*** サービスを使用して TLS 制御ブロックに追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-254">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_dtls_server_local_certificate_add*** service.</span></span>

<span data-ttu-id="9db8c-255">サーバーの証明書が DTLS Server の制御ブロックに追加されたら、セキュリティで保護された DTLS 通信にそのサーバーを使用できます (上記の例を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="9db8c-255">Once the server’s certificate has been added to the DTLS Server control block, the server can be used for secure DTLS communications (see example above).</span></span>

### <a name="initialization--dtls-client"></a><span data-ttu-id="9db8c-256">初期化 – DTLS Client</span><span class="sxs-lookup"><span data-stu-id="9db8c-256">Initialization – DTLS Client</span></span>

<span data-ttu-id="9db8c-257">NetX Secure DTLS Client モードは、UDP ソケット経由のリモート ホストへの発信接続が 1 つだけであるため、DTLS Server と比べて操作が簡単です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-257">NetX Secure DTLS Client mode is simple in operation compared to the DTLS server since there is only a single outgoing connection to the remote host over the UDP socket.</span></span>

<span data-ttu-id="9db8c-258">DTLS Client をセットアップするには、信頼された証明機関 (CA) からの X.509 でエンコードされたデジタル証明書のコレクションである "*信頼された証明書ストア*" が必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-258">To setup a DTLS Client, it requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA’s).</span></span> <span data-ttu-id="9db8c-259">これらの証明書は、DTLS プロトコルによって "信頼されている" と見なされ、DTLS Server のエンティティによって NetX Secure DTLS Client アプリケーションに提供される証明書を認証するための基礎として機能します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-259">These certificates are assumed by the DTLS protocol to be “trusted” and serve as the basis for authenticating certificates provided by DTLS server entities to the NetX Secure DTLS Client application.</span></span>

<span data-ttu-id="9db8c-260">信頼された CA 証明書は、"*自己署名*" されているか、別の CA によって署名されているかのいずれかです。後者の場合、その証明書は "*中間 CA*" (ICA) と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-260">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="9db8c-261">一般的な TLS/DTLS アプリケーションでは、サーバーによって ICA 証明書とサーバー証明書が提供されますが、認証を成功させる唯一の要件は、発行者のチェーン (他の証明書の署名に使用される証明書) をサーバー証明書から信頼された証明書ストア内の信頼された CA 証明書まで追跡できることです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-261">In a typical TLS/DTLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="9db8c-262">このチェーンは、"*信頼のチェーン*" または "*証明書チェーン*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-262">This chain is known as a *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="9db8c-263">信頼された CA または ICA 証明書を初期化するには、アプリケーションで、DER でエンコードされた X.509 証明書を含むバッファーへのポインターを ***nx_secure_x509_certificate_intialize** _ サービスを使用して提供する必要があります。このサービスにより、TLS で使用する適切な証明書データが、_ *NX_SECURE_X509_CERT** 構造体に格納されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-263">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="9db8c-264">また、DTLS Client には、割り当てられる受信サーバー証明書のための領域 (事前共有キー モードが使用されていないことを想定しています) と、暗号化を解除するためにパケットを DTLS レコードに組み立てるバッファーも必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-264">The DTLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used) and a buffer for assembling packets into DTLS records to be decrypted.</span></span> <span data-ttu-id="9db8c-265">これらのバッファーは、***nx_secure_dtls_session_create*** サービスにパラメーターとして渡されます (詳細については、API リファレンスを参照してください)。</span><span class="sxs-lookup"><span data-stu-id="9db8c-265">These buffers are passed in as parameters to the ***nx_secure_dtls_session_create*** service (see API reference for more information).</span></span>

<span data-ttu-id="9db8c-266">その後、初期化済みの信頼された証明書は、***nx_secure_dtls_session_trusted_certificate_add*** サービスを使用して、作成された DTLS セッションの制御ブロックに追加されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-266">Trusted certificates that have been initialized are then added to the created DTLS session control block using the ***nx_secure_dtls_session_trusted_certificate_add*** service.</span></span> <span data-ttu-id="9db8c-267">証明書を追加しなかった場合、DTLS Client セッションは失敗します。これは、DTLS プロトコルにリモート サーバー ホストを認証するための方法がなくなるためです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-267">Failure to add a certificate will cause the DTLS Client session to fail as there will be no way for the DTLS protocol to authenticate remote server hosts.</span></span>

<span data-ttu-id="9db8c-268">信頼された証明書ストアが作成されたら、セッションを使用して、セキュリティで保護された TLS Client の接続を確立できます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-268">Once the Trusted Certificate Store has been created the session may be used to establish a secure TLS Client connection.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="9db8c-269">アプリケーション インターフェイスの呼び出し</span><span class="sxs-lookup"><span data-stu-id="9db8c-269">Application Interface Calls</span></span>

<span data-ttu-id="9db8c-270">NetX Secure DTLS アプリケーションでは、通常、ThreadX RTOS で実行されているアプリケーション スレッド内から関数呼び出しを行います。</span><span class="sxs-lookup"><span data-stu-id="9db8c-270">NetX Secure DTLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="9db8c-271">一部の初期化、特に基盤となるネットワーク通信プロトコル (UDP や IP など) の場合は、\*\*\*tx_application_define \*\*\* から呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-271">Some initialization, particularly for the underlying network communications protocols (e.g. UDP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="9db8c-272">ネットワーク通信の初期化の詳細については、NetX または NetXDuo のユーザー ガイドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-272">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="9db8c-273">DTLS では、プロセッサを集中的に使用する操作である暗号化ルーチンが多用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-273">DTLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="9db8c-274">一般に、これらの操作は、呼び出し元スレッドのコンテキスト内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-274">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="dtls-session-start"></a><span data-ttu-id="9db8c-275">DTLS セッションの開始</span><span class="sxs-lookup"><span data-stu-id="9db8c-275">DTLS Session Start</span></span>

<span data-ttu-id="9db8c-276">DTLS を機能させるには、基盤となるトランスポート層ネットワーク プロトコルが必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-276">DTLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="9db8c-277">一般的に使用されるプロトコルは TCP です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-277">The protocol typically used is TCP.</span></span> <span data-ttu-id="9db8c-278">NetX Secure の TLS セッションを確立するには、**NX_UDP_SOCKET** を作成して、DTLS Client の **_nx_secure_dtls_client_session_start_** サービスに渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-278">In order to establish a NetX Secure TLS session an **NX_UDP_SOCKET** must be created and passed into the **_nx_secure_dtls_client_session_start_** service for DTLS Clients.</span></span>

<span data-ttu-id="9db8c-279">DTLS Server の動作は異なります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-279">DTLS Servers operate differently.</span></span> <span data-ttu-id="9db8c-280">受信 DTLS Client 要求に使用される UDP ソケットは、NX_SECURE_DTLS_SERVER 制御ブロックに含まれており、\***nx_secure_dtls_server_create** _ への呼び出しで初期化されます。このサービスでは、ローカル UDP ポートをパラメーターとして受け取ります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-280">The UDP socket used for incoming DTLS Client requests is contained within the NX_SECURE_DTLS_SERVER control block and is initialized in the call to \***nx_secure_dtls_server_create** _, which takes the local UDP port as a parameter.</span></span> <span data-ttu-id="9db8c-281">次に、_*_nx_secure_dtls_server_start_*_ サービスを使用して、受信要求を処理する DTLS Server を開始します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-281">The service _*_nx_secure_dtls_server_start_*_ is then used to start the DTLS Server to handle incoming requests.</span></span> <span data-ttu-id="9db8c-282">すべての受信要求は、_nx_secure_dtls_server_create \* に提供されるコールバック ルーチンで処理されます (接続用に 1 つと受信通知用に 1 つ)。接続通知を受信したとき (接続通知のコールバックが DTLS によって呼び出されます) に \***nx_secure_dtls_server_session_start**_ を呼び出すことによって DTLS セッションを開始する処理を行うのはアプリケーションの責任です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-282">All incoming requests are handled in callback routines provided to _nx_secure_dtls_server_create\*: one for connections and one for receive notifications. It is up to the application to handle starting the DTLS session when a connection notification is received (the connect notify callback is invoked by DTLS) by calling \***nx_secure_dtls_server_session_start**_.</span></span> <span data-ttu-id="9db8c-283">また、アプリケーションでは、(DTLS ハンドシェイクの完了後に) 受信通知コールバックが呼び出されたときに、_*_nx_secure_dtls_session_receive_*\* を呼び出して、受信データを処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-283">The application also must handle incoming data when the receive notify callback is invoked (which follows a completed DTLS handshake) by calling _\*_nx_secure_dtls_session_receive_\*\*.</span></span> <span data-ttu-id="9db8c-284">この詳細については、上の例と、上記の各サービスの API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-284">The details of this are provided in the example above and in the API reference for each of the above mentioned services.</span></span>

### <a name="dtls-packet-allocation"></a><span data-ttu-id="9db8c-285">DTLS パケットの割り当て</span><span class="sxs-lookup"><span data-stu-id="9db8c-285">DTLS Packet Allocation</span></span>

<span data-ttu-id="9db8c-286">NetX Secure DTLS では、NetX/NetXDuo TCP (***NX_PACKET** _) と同じパケット構造が使用されます。ただし、DTLS ヘッダーの領域が適切に割り当てられるように、_*_nx_packet_allocate_*_ サービスを呼び出す代わりに、_ *_nx_secure_dtls_packet_allocate_** サービスを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-286">NetX Secure DTLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_dtls_packet_allocate_** service must be called so that space for the DTLS header may be allocated properly.</span></span>

### <a name="dtls-session-send"></a><span data-ttu-id="9db8c-287">DTLS セッション送信</span><span class="sxs-lookup"><span data-stu-id="9db8c-287">DTLS Session Send</span></span>

<span data-ttu-id="9db8c-288">TLS セッションが開始されたら、アプリケーションでは ***nx_secure_dtls_session_send*** サービスを使用してデータを送信することができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-288">Once the TLS session has started, the application may send data using the ***nx_secure_dtls_session_send*** service.</span></span> <span data-ttu-id="9db8c-289">この送信サービスは、***nx_udp_socket_send** _ サービスと同じように使用され、送信するデータ、ターゲットの IP アドレス、ターゲットの UDP ポートを含む _ *_NX_PACKET_** データ構造を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-289">The send service is identical in use to the ***nx_udp_socket_send** _ service, taking an _ *_NX_PACKET_** data structure containing the data being sent, a target IP address, and a target UDP port.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9db8c-290">nx_secure_dtls_session_send を使用してデータを送信する場合は、DTLS セッションの確立に使用したのと同じ IP アドレスとポートを使用することが重要です。ただし、セッションを新しいアドレスと UDP ポートに実行時に移行するメカニズムがある場合 (これは一般的ではありません) を除きます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-290">When sending data using nx_secure_dtls_session_send, it is important to use the same IP address and port that were used to establish the DTLS session, unless there is a mechanism in place to move the session to a new address and UDP port on-the-fly (this is not common).</span></span>

<span data-ttu-id="9db8c-291">DTLS 経由で送信されるデータは、送信される前に、NX Secure DTLS のスタックおよび構成された暗号化ルーチンによって暗号化されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-291">Any data sent over DTLS will be encrypted by the NX Secure DTLS stack and the configured encryption routines before being sent.</span></span>

### <a name="dtls-session-receive"></a><span data-ttu-id="9db8c-292">DTLS セッション受信</span><span class="sxs-lookup"><span data-stu-id="9db8c-292">DTLS Session Receive</span></span>

<span data-ttu-id="9db8c-293">DTLS セッションが開始されたら、アプリケーションでは \***nx_secure_Dtls_session_receive** _ サービスを使用してデータの受信を開始できます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-293">Once the DTLS session has started, the application may begin receiving data using the \***nx_secure_Dtls_session_receive** _ service.</span></span> <span data-ttu-id="9db8c-294">DTLS Session 送信と同様に、このサービスは _*_nx_udp_socket_receive_*\* と同じように使用されます。ただし、受信データは DTLS スタックで暗号化して検証されてから、パケット構造に返されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-294">Like the DTLS Session send, this service is identical in use to _\*_nx_udp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the DTLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="9db8c-295">TLS セッションの終了</span><span class="sxs-lookup"><span data-stu-id="9db8c-295">TLS Session Close</span></span>

<span data-ttu-id="9db8c-296">DTLS セッションが完了したら、DTLS クライアントとサーバーの両方で、他方に CloseNotify アラートを送信して、セッションを停止する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-296">Once a DTLS session is complete, both the DTLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="9db8c-297">セッションが正常に停止されるようにするには、双方でアラートを受信して処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-297">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="9db8c-298">リモート ホストから CloseNotify アラートが送信されると、***nx_secure_dtls_session_receive** _ サービスへの呼び出しによってそのアラートが処理され、対応するアラートがリモート ホストに送信されて、値 _*_NX_SECURE_TLS_SESSION_CLOSED_\*\* が返されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-298">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_dtls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="9db8c-299">セッションが終了すると、その DTLS セッションを使用した以降のデータの送信または受信の試行はすべて失敗します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-299">Once the session is closed, any further attempts to send or receive data with that DTLS session will fail.</span></span>

<span data-ttu-id="9db8c-300">アプリケーションで TLS セッションを終了する場合は、\***nx_secure_dtls_session_end** _ サービスを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-300">If the application wishes to close the TLS session, the \***nx_secure_dtls_session_end** _ service must be called.</span></span> <span data-ttu-id="9db8c-301">このサービスによって CloseNotify アラートが送信され、応答の CloseNotify が処理されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-301">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="9db8c-302">応答が受信されない場合は、DTLS セッションが正常に停止されなかったことを示すエラー値 _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* が返されます。これは、セキュリティ違反の可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-302">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the DTLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tlsdtls-alerts"></a><span data-ttu-id="9db8c-303">TLS/DTLS のアラート</span><span class="sxs-lookup"><span data-stu-id="9db8c-303">TLS/DTLS Alerts</span></span>

<span data-ttu-id="9db8c-304">TLS/DTLS は最大限のセキュリティを提供するように設計されています。そのため、プロトコルでの誤った動作は、潜在的なセキュリティ違反と見なされます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-304">TLS/DTLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="9db8c-305">このため、メッセージの処理や暗号化と解読におけるすべてのエラーが、ハンドシェイクまたはセッションを直ちに終了させる致命的エラーと見なされます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-305">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="9db8c-306">ローカル アプリケーションでのエラー処理は比較的簡単ですが、リモート ホストでは、状況を適切に処理し、さらなるセキュリティ違反の可能性を回避するために、エラーが発生したことを認識する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-306">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="9db8c-307">このため、TLS/DTLS では、エラーが発生したときに "*アラート*" メッセージがリモート ホストに送信されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-307">For this reason, TLS/DTLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="9db8c-308">アラートは、他の TLS/DTLS メッセージと同じ方法で処理され、攻撃者が送信されたアラートの種類から情報を収集できないようにするために、セッション中に暗号化されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-308">Alerts are treated in the same manner as any other TLS/DTLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="9db8c-309">ハンドシェイク時には、潜在的な攻撃者によって取得される可能性がある情報の量を限定するため、送信されるアラートはスコープ内に制限されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-309">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="9db8c-310">CloseNotify アラートは、TLS/DTLS セッションを閉じるために使用されますが、これは致命的でない唯一のアラートです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-310">The CloseNotify alert, used to close the TLS/DTLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="9db8c-311">これはアラートと見なされて、アラート メッセージとして送信されますが、エラーが発生したことを示さないという点で、CloseNotify は他のアラートとは異なっています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-311">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

### <a name="tlsdtls-session-renegotiation-and-resumption"></a><span data-ttu-id="9db8c-312">TLS/DTLS セッションの再ネゴシエーションと再開</span><span class="sxs-lookup"><span data-stu-id="9db8c-312">TLS/DTLS Session Renegotiation and Resumption</span></span>

<span data-ttu-id="9db8c-313">TLS では、"再ネゴシエーション" という概念がサポートされています。これは単に、既存の TLS セッションのコンテキスト内での、TLS セッション パラメーターの再ネゴシエーションです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-313">TLS supports the notion of “renegotiation” which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span>

<span data-ttu-id="9db8c-314">いくつかの類似点はありますが、TLS セッションの "*再開*" をセッションの "*再ネゴシエーション*" と混同しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-314">TLS session *resumption* should not be confused with session *renegotiation*, despite some similarities.</span></span> <span data-ttu-id="9db8c-315">セッションの "*再ネゴシエーション*" では、既存の TLS セッション内で新しいハンドシェイクが開始されます。セッションの "*再開*" は、完全な TLS ハンドシェイクを実行せずに閉じられた TLS セッションの再開を伴う、純粋にオプションの機能です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-315">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span>

<span data-ttu-id="9db8c-316">NX Secure DTLS では、リモート ホストからの受信再ネゴシエーション要求が処理されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-316">NX Secure DTLS handles incoming renegotiation requests from remote hosts.</span></span> <span data-ttu-id="9db8c-317">セッションの再開はサポート **されていません**。</span><span class="sxs-lookup"><span data-stu-id="9db8c-317">It does **not** support session resumption.</span></span> <span data-ttu-id="9db8c-318">これらの機能の詳細については、『NetX Secure TLS ユーザー ガイド』の第 3 章を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-318">A more complete discussion of these features can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="9db8c-319">プロトコルのレイヤー化</span><span class="sxs-lookup"><span data-stu-id="9db8c-319">Protocol Layering</span></span>

<span data-ttu-id="9db8c-320">TLS プロトコルは (したがって DTLS も)、トランスポート層 (TCP、UDP など) とアプリケーション層の間のネットワーク スタックに適合します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-320">The TLS protocol (and therefore DTLS as well) fits into the networking stack between the transport layer (e.g. TCP or UDP) and the application layer.</span></span> <span data-ttu-id="9db8c-321">TLS は、トランスポート層のプロトコル (したがって、"*トランスポート層*" のセキュリティ) と見なされることがありますが、基盤となるネットワーク プロトコルに関してはアプリケーションとして機能するため、アプリケーション層にグループ化されることがあります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-321">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="9db8c-322">TLS には、TCP などの、順番どおりで無損失の配信をサポートするトランスポート層プロトコルが必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-322">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="9db8c-323">この要件のために、TLS を UDP 上で実行することはできません。UDP ではデータグラムの配信が保証されないためです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-323">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="9db8c-324">*DTLS* は、TLS の変更されたバージョンであり、UDP などのデータグラム プロトコルで TLS のセキュリティを必要とするアプリケーションに使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-324">*DTLS* is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span>

![TLS プロトコルのレイヤーの図。](media/image6.png)

<span data-ttu-id="9db8c-326">**図 4 - TCP/IP、UDP、TLS/DTLS プロトコルのレイヤー**</span><span class="sxs-lookup"><span data-stu-id="9db8c-326">**Figure 4- TCP/IP, UDP and TLS/DTLS protocol layers**</span></span>

## <a name="network-communications-security-and-encryption"></a><span data-ttu-id="9db8c-327">ネットワーク通信のセキュリティと暗号化</span><span class="sxs-lookup"><span data-stu-id="9db8c-327">Network Communications Security and Encryption</span></span>

<span data-ttu-id="9db8c-328">パブリック ネットワークとインターネットを介した通信をセキュリティで保護することは、非常に重要なトピックであり、膨大な数の書籍、記事、ソリューションの対象となっています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-328">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="9db8c-329">このテーマは信じがたいほど複雑ですが、意図したターゲットだけが情報へのアクセスや変更を行えるようにネットワーク経由でその情報を送信する、という単純な考え方にまとめることができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-329">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="9db8c-330">これは、機密性、整合性、認証の 3 つの重要な概念に分類されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-330">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="9db8c-331">TLS/DTLS プロトコルでは、3 つすべてに対応したソリューションが提供されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-331">The TLS/DTLS protocol provides solutions for all three.</span></span>

<span data-ttu-id="9db8c-332">暗号化は、TLS および DTLS プロトコル内で機密性、整合性、認証を提供するためにさまざまな方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-332">Encryption is used in different ways to provide secrecy, integrity, and authentication within the TLS and DTLS protocols.</span></span> <span data-ttu-id="9db8c-333">暗号化は、セッションまたはサーバー インスタンスの作成時に、TLS または DTLS に提供する必要があります。TLS は、暗号化自体ではなく、暗号化を使用するための柔軟なフレームワークを提供しています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-333">The encryption must be supplied to TLS or DTLS upon creation of a session or server instance as TLS provides a flexible framework for using encryption and not the encryption itself.</span></span> <span data-ttu-id="9db8c-334">NetX Secure DTLS では、ほとんどのアプリケーションに必要な暗号化ルーチンが提供されるため、ユーザーが適切な暗号化を見つけることを気にする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9db8c-334">NetX Secure DTLS provides the necessary encryption routines for most applications so you do not have to be concerned about finding appropriate encryption.</span></span>

<span data-ttu-id="9db8c-335">これらのトピックの詳細については、『NetX Secure TLS ユーザー ガイド』の第 3 章を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-335">A more detailed description of these topics can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

## <a name="tls-and-dtls-extensions"></a><span data-ttu-id="9db8c-336">TLS と DTLS の拡張機能</span><span class="sxs-lookup"><span data-stu-id="9db8c-336">TLS and DTLS Extensions</span></span>

<span data-ttu-id="9db8c-337">TLS には (したがって DTLS にも)、特定のアプリケーションに対して追加機能を提供する多くの拡張機能が用意されています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-337">TLS (and therefore DTLS) provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="9db8c-338">これらの拡張機能は、通常、ClientHello または ServerHello メッセージの一部として送信され、拡張機能の使用を望んでいることをリモート ホストに示したり、セキュリティで保護された TLS セッションの確立に使用する追加の詳細情報を提供したりします。</span><span class="sxs-lookup"><span data-stu-id="9db8c-338">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="9db8c-339">NetX Secure DTLS では、NetX Secure TLS に含まれるすべての拡張機能がサポートされます。それらの詳細については、『NetX Secure TLS ユーザー ガイド』の第 3 章を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-339">NetX Secure DTLS supports all of the extensions found in NetX Secure TLS, and a complete description of those can be found in the NetX Secure TLS User Guide, Chapter 3.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="9db8c-340">認証方法</span><span class="sxs-lookup"><span data-stu-id="9db8c-340">Authentication Methods</span></span>

<span data-ttu-id="9db8c-341">TLS と DTLS では、セキュリティで保護されていないネットワークを経由する 2 つのデバイス間で安全な接続を確立するためのフレームワークが提供されますが、問題の一部は、その接続の他方の側にあるデバイスの ID が認識されることです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-341">TLS and DTLS provide the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="9db8c-342">リモート ホストの ID を認証するためのメカニズムがない場合は、攻撃者が簡単に信頼されたデバイスを装うことができるようになります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-342">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="9db8c-343">最初は、IP アドレス、ハードウェアの MAC アドレス、または DNS を使用すると、ネットワーク上のホストを識別するうえで比較的高い信頼性が得られるように思われるかもしれませんが、TCP/IP テクノロジの性質と、アドレスのなりすましや (たとえば DNS キャッシュ ポイズニングを通した) DNS エントリの破損は容易であることを考えると、TLS には不正な ID に対する追加の保護レイヤーが必要であることは明確になります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-343">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="9db8c-344">この追加の認証レイヤーを TLS に提供できるさまざまなメカニズムがありますが、最も一般的なのは "*デジタル証明書*" です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-344">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="9db8c-345">その他のメカニズムには、事前共有キー (PSK) とパスワードのスキームがあります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-345">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="9db8c-346">デジタル証明書</span><span class="sxs-lookup"><span data-stu-id="9db8c-346">Digital Cerificates</span></span>

<span data-ttu-id="9db8c-347">デジタル証明書は、TLS でリモート ホストを認証するための最も一般的な方法です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-347">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="9db8c-348">基本的にデジタル証明書は、コンピューター ネットワーク上のデバイスの ID 情報を提供する特定形式のドキュメントです。</span><span class="sxs-lookup"><span data-stu-id="9db8c-348">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="9db8c-349">TLS では通常、国際電気通信連合によって開発された標準である X.509 という形式が使用されますが、使用される形式について TLS ホストの同意が得られる場合は、他の形式の証明書を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-349">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="9db8c-350">X.509 では、証明書の特定の形式と、デジタル ドキュメントの生成に使用できるさまざまなエンコードが定義されています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-350">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="9db8c-351">TLS で使用されるほとんどの X.509 証明書は、別の通信規格である ASN.1 のバリアントを使用してエンコードされます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-351">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="9db8c-352">ASN.1 にはさまざまなデジタル エンコードがありますが、TLS 証明書で最も一般的なエンコードは、Distinguished Encoding Rules (DER) 標準です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-352">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="9db8c-353">DER は、あいまいさが排除されるように設計された ASN.1 基本エンコード規則 (BER) の簡略化されたサブセットであり、解析が容易になります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-353">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="9db8c-354">通常、ネットワークでは、TLS 証明書はバイナリ DER でエンコードされます。これは NetX Secure で X.509 証明書に想定する形式です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-354">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="9db8c-355">DER 形式のバイナリ証明書は実際の TLS プロトコルで使用されていますが、これらの証明書は、さまざまな異なるエンコードで生成し、.pem、.crt、.p12 などのファイル拡張子を付けて保存することができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-355">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="9db8c-356">さまざまな製造元のさまざまなアプリケーションで異なるバリアントが使用されていますが、通常は広く利用可能なツールを使用してそのすべてを DER に変換することができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-356">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="9db8c-357">代わりになる証明書エンコードで最も一般的なのは PEM です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-357">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="9db8c-358">PEM (Privacy Enhanced Mail) 形式は、base-64 でエンコードされるバージョンの DER エンコードであり、エンコードの結果は、電子メールや Web ベースのプロトコルを使用して簡単に送信できる出力可能なテキストになるため、よく使用されています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-358">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="9db8c-359">NetX Secure アプリケーション用の証明書の生成の大部分はこのマニュアルの範囲外ですが、OpenSSL コマンドライン ツール ([www.openssl.org](http://www.openssl.org)) が広く入手可能であり、ほとんどの形式間で変換を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-359">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="9db8c-360">アプリケーションによっては、独自の証明書を生成したり、製造元または政府機関による証明書を提示したり、商用証明機関から証明書を購入したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-360">Depending on your application, you may generate your own certificates, be provided certificates by a manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="9db8c-361">NetX Secure アプリケーションでデジタル証明書を使用するには、最初に証明書をバイナリ DER 形式に変換し、必要に応じて、関連付けられた秘密キー (RSA の場合は "プライベート指数") をバイナリ形式 (通常は PKCS#1 形式の DER でエンコードされた RSA キー) に変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-361">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the “private exponent” for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key.</span></span> <span data-ttu-id="9db8c-362">変換が完了したら、証明書と秘密キーのデバイスへの読み込みは、ユーザーの選択に委ねられます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-362">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="9db8c-363">可能なオプションとしては、フラッシュベースのファイル システムの使用、データからの C 配列の生成 (Linux の "xxd" などのツールを使用)、および証明書とキーをアプリケーションに定数データとしてコンパイルする方法があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-363">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as “xxd” from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="9db8c-364">証明書がデバイスに読み込まれたら、DTLS API を使用して、証明書を DTLS セッションまたはサーバーに関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-364">Once your certificate is loaded onto the device, the DTLS API can be used to associate your certificate with a DTLS session or server.</span></span>

<span data-ttu-id="9db8c-365">NetX Secure DTLS での X.509 証明書の使用方法の詳細と例については、『NetX secure TLS ユーザー ガイド』の「X.509 証明書を NetX Secure にインポートする」のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-365">For details and examples on how to use X.509 certificates with NetX Secure DTLS, see the section “Importing X.509 certificates into NetX Secure” in the NetX Secure TLS User Guide.</span></span>

<span data-ttu-id="9db8c-366">詳細については、API リファレンスの次の DTLS サービスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-366">Refer to the following DTLS services in the API reference for more information:</span></span>

- <span data-ttu-id="9db8c-367">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="9db8c-367">nx_secure_x509_certificate_initialize,</span></span>
- <span data-ttu-id="9db8c-368">nx_secure_dtls_session_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="9db8c-368">nx_secure_dtls_session_local_certificate_add,</span></span>
- <span data-ttu-id="9db8c-369">nx_secure_dtls_server_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="9db8c-369">nx_secure_dtls_server_local_certificate_add,</span></span>
- <span data-ttu-id="9db8c-370">nx_secure_dtls_session_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="9db8c-370">nx_secure_dtls_session_local_certificate_remove,</span></span>
- <span data-ttu-id="9db8c-371">nx_secure_dtls_server_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="9db8c-371">nx_secure_dtls_server_local_certificate_remove,</span></span>
- <span data-ttu-id="9db8c-372">nx_secure_dtls_session_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="9db8c-372">nx_secure_dtls_session_trusted_certificate_add,</span></span>
- <span data-ttu-id="9db8c-373">nx_secure_dtls_server_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="9db8c-373">nx_secure_dtls_server_trusted_certificate_add,</span></span>
- <span data-ttu-id="9db8c-374">nx_secure_dtls_session_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="9db8c-374">nx_secure_dtls_session_trusted_certificate_remove</span></span>
- <span data-ttu-id="9db8c-375">nx_secure_dtls_server_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="9db8c-375">nx_secure_dtls_server_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="9db8c-376">TLS クライアント証明書の詳細</span><span class="sxs-lookup"><span data-stu-id="9db8c-376">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="9db8c-377">DTLS Client の実装では、通常、デバイスにローカル証明書を読み込む必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9db8c-377">DTLS Client implementations generally do not require a local certificate to be loaded onto the device.</span></span> <span data-ttu-id="9db8c-378">ローカル証明書は、ローカル デバイスを識別する証明書です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-378">A local certificate is a certificate that identifies the local device.</span></span> <span data-ttu-id="9db8c-379">具体的には、ローカル証明書によって、TLS/DTLS アプリケーションが読み込まれるデバイスの ID 情報が提供されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-379">Specifically, a local certificate provides identity information for the device upon which the TLS/DTLS application is loaded.</span></span> <span data-ttu-id="9db8c-380">ただし、クライアント証明書の認証が有効になっている場合は例外ですが、これはあまり一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="9db8c-380">The exception to this is when Client Certificate Authentication is enabled, but this is less common.</span></span>

<span data-ttu-id="9db8c-381">DTLS Client では、少なくとも 1 つの信頼された証明書を読み込み (必要に応じてさらに読み込むことができます)、リモート証明書の領域を割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-381">A DTLS Client requires at least one trusted certificate to be loaded (more may be loaded if required), and space for a remote certificate to be allocated.</span></span> <span data-ttu-id="9db8c-382">信頼された証明書は、リモート デバイスの信頼性と認証の基礎を提供する証明書であり、直接または公開キー基盤 (PKI) を介して提供されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-382">A trusted certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="9db8c-383">信頼のチェーンのルートは、通常、証明機関または CA 証明書と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-383">The root of the chain of trust is usually called a Certification Authority or CA certificate.</span></span> <span data-ttu-id="9db8c-384">リモート証明書は、TLS ハンドシェイク中にリモート ホストによって送信された証明書を指します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-384">A remote certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="9db8c-385">そのリモート ホストの ID を提供し、ローカル デバイスの信頼された証明書と比較することによって認証されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-385">It provides identity for that remote host and is authenticated by comparing it to a trusted certificate on the local device.</span></span>

<span data-ttu-id="9db8c-386">信頼された証明書の追加とリモート証明書用の領域の割り当ての詳細については、nx_secure_dtls_session_create、nx_secure_dtls_session_trusted_certificate_add サービスの TLS API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-386">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span></span>

### <a name="tlsdtls-server-certificate-specifics"></a><span data-ttu-id="9db8c-387">TLS/DTLS Server 証明書の詳細</span><span class="sxs-lookup"><span data-stu-id="9db8c-387">TLS/DTLS Server Certificate Specifics</span></span>

<span data-ttu-id="9db8c-388">DTLS Server の実装では、通常、デバイスへの "信頼された" 証明書の読み込みや、リモート証明書の割り当ては必要ありません。</span><span class="sxs-lookup"><span data-stu-id="9db8c-388">DTLS Server implementations generally do not require “trusted” certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="9db8c-389">例外は、クライアント証明書の認証が有効になっている場合です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-389">The exception to this being when Client Certificate Authentication is enabled.</span></span>

<span data-ttu-id="9db8c-390">TLS Server では、TLS ハンドシェイク中にクライアントに対してサーバーを認証するためにサーバーからリモート クライアントに提示できるように、"ローカル" (または "ID") の証明書を読み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-390">A TLS Server requires a “local” (or “identity”) certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="9db8c-391">NetX TLS サーバー アプリケーションで使用するためのローカル証明書の読み込みの詳細については、nx_secure_dtls_server_local_certificate_add、nx_secure_dtls_server_local_certificate_remove サービスの API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-391">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span></span>


### <a name="pre-shared-keys-psk"></a><span data-ttu-id="9db8c-392">事前共有キー (PSK)</span><span class="sxs-lookup"><span data-stu-id="9db8c-392">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="9db8c-393">TLS で ID 認証を提供するための代替メカニズムは、事前共有キー (PSK) の概念です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-393">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="9db8c-394">PSK 暗号スイートを使用すると、プロセッサが集中的に使用される公開キー暗号化の操作を行う必要がなくなり、リソースに制約がある組み込みデバイスにとっての恩恵となります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-394">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="9db8c-395">TLS/DTLS ハンドシェイクの証明書が PSK に置き換わり、TLS/DTLS セッション キーの生成で暗号化されたプリマスター シークレットの代わりに使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-395">The PSK replaces the certificate in the TLS/DTLS handshake and is used in place of the encrypted Pre-Master Secret for TLS/DTLS session key generation.</span></span>

<span data-ttu-id="9db8c-396">PSK 暗号スイートは、TLS/DTLS セッションを確立する前に、両方のデバイスに共有シークレットが存在する必要があるという点で制限されています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-396">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS/DTLS session can be established.</span></span> <span data-ttu-id="9db8c-397">つまり、TLS PSK 接続以外のセキュリティで保護された方法を使用して、そのシークレットがデバイスに読み込まれている必要があります。PSK は、TLS PSK 接続を介した更新も可能ですが、デバイスは必ず、他の何らかのメカニズムを通じて読み込まれた PSK を使用して起動される必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-397">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="9db8c-398">たとえば、出荷前にセンサー デバイスとそのゲートウェイ デバイスに PSK を読み込むことや、標準の TLS 接続 (証明書を使用) を使用して PSK を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-398">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="9db8c-399">PSK 暗号スイートには、RFC 4279 で規定されている 2 つの形式があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-399">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="9db8c-400">1 つ目では RSA または Diffie-Hellman キーが使用され、これらが、標準の TLS ハンドシェイクにおいて証明書で転送される公開キーと同じ方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-400">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="9db8c-401">2 番目の形式は、リソースの制約がある環境でより多く使用され、セッション キー (たとえば、AES で使用される) を直接生成するために使用される PSK を使用して、コストのかかる RSA または Diffie-Hellman 操作の使用が回避されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-401">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="9db8c-402">NetX Secure では、2 番目の形式の PSK 暗号スイートがサポートされるため、アプリケーションで使用されていた公開キー暗号化のためのすべてのコードとメモリが不要になります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-402">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="9db8c-403">PSK 自体は AES キーではありませんが、実際のキーがそこから生成されるパスワードのようなものと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-403">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="9db8c-404">どのような PSK の値を使用できるかに関してほとんど制限はありませんが、値が長いほどセキュリティが高まります (パスワードの場合と同じ)。</span><span class="sxs-lookup"><span data-stu-id="9db8c-404">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="9db8c-405">NetX Secure アプリケーションで PSK を使用するには、まずグローバル マクロ **NX_SECURE_ENABLE_PSK_CIPHERSUITES** を定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-405">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="9db8c-406">これは通常、コンパイラ設定を通じて行われますが、定義を nx_secure_tls.h ヘッダー ファイル内に配置することもできます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-406">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="9db8c-407">このマクロを定義すると、PSK 暗号スイートのサポートが NetX Secure DTLS アプリケーションにコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-407">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure DTLS application.</span></span>

<span data-ttu-id="9db8c-408">PSK のサポートを有効にすると、DTLS API を使用してアプリケーションの PSK を設定できます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-408">With PSK support enabled, you can then use the DTLS API to set up PSKs for your application.</span></span> <span data-ttu-id="9db8c-409">各 PSK には、PSK 値 (実際の秘密 "キー"。この値は安全に保管してください)、特定の PSK を識別するために使用される "ID" 値、および TLS サーバーで特定の PSK 値を選択するために使用される "ID ヒント" が必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-409">Each PSK will require a PSK value (the actual secret “key” – keep this value safe), an “identity” value used to identify the specific PSK, and an “identity hint” that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="9db8c-410">PSK 自体は、ネットワーク接続経由で送信されることがないため、任意のバイナリ値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-410">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="9db8c-411">PSK は、長さが最大 64 バイトの任意の値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-411">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="9db8c-412">ID とヒントは、UTF-8 を使用してフォーマットされた出力可能な文字列である必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-412">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="9db8c-413">ID とヒントの値は、最大 128 バイトの任意の長さにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-413">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="9db8c-414">ID と PSK によって、相互に通信する必要があるネットワーク内のすべてのデバイスに読み込まれる一意の組が形成されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-414">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="9db8c-415">"ヒント" は主に、機能またはサービスによって PSK をグループ化する特定のアプリケーション プロファイルを定義するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-415">The “hint” is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="9db8c-416">これらの値は事前に合意されている必要があり、アプリケーションに依存します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-416">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="9db8c-417">たとえば、OpenSSL コマンドライン サーバー アプリケーション (PSK が有効になっている) では、既定の文字列 "Client_identity" が使用されます。これは TLS ハンドシェイクを続行するために TLS クライアントによって提供される必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-417">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string “Client_identity”, which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="9db8c-418">PSK の詳細については、nx_secure_dtls_psk_add、nx_secure_dtls_server_psk_add サービスに関する NetX Secure API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-418">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="9db8c-419">X.509 証明書の NetX Secure へのインポート</span><span class="sxs-lookup"><span data-stu-id="9db8c-419">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="9db8c-420">デジタル証明書は、インターネット上のほとんどの TLS 接続に必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-420">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="9db8c-421">以前は未知であったホストを、信頼できる中継点 (通常は "*証明機関*" または CA と呼ばれます) を使用することでインターネット経由で認証する手段が、証明書によって提供されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-421">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="9db8c-422">NetX Secure デバイスを商用クラウド サービス (アマゾン ウェブ サービスなど) に接続するには、デバイスに証明書を読み込むことによってアプリケーションに証明書をインポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-422">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="9db8c-423">証明書と共に、証明書に関連付けられている "*秘密キー*" が必要になる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-423">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="9db8c-424">一部のアプリケーション (クライアント証明書認証が使用されない予定のときの TLS クライアントなど) では、証明書だけで十分ですが、デバイスの識別に証明書が使用される予定であれば、秘密キーが必要になります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-424">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="9db8c-425">秘密キーは一般に、証明書を作成するときに生成され、別個のファイルに格納されます。多くの場合、パスワードで暗号化されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-425">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

<span data-ttu-id="9db8c-426">NetX Secure アプリケーションに証明書をインポートする方法の詳細については、『NetX Secure TLS ユーザー ガイド』の第 3 章を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-426">For a detailed description of importing certificates into NetX Secure applications, please refer to Chapter 3 in the NetX Secure TLS User Guide.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="9db8c-427">NetX Secure TLS でのクライアント証明書の認証</span><span class="sxs-lookup"><span data-stu-id="9db8c-427">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="9db8c-428">X.509 証明書認証を使用する場合、TLS/DTLS プロトコルでは、DTLS Server インスタンスによって ID の証明書が提示される必要がありますが、既定では、DTLS Client インスタンスによって認証用の証明書が提示される必要はなく、代わりに別の形式の認証が使用されます (ユーザー名/パスワードの組み合わせなど)。</span><span class="sxs-lookup"><span data-stu-id="9db8c-428">When using X.509 certificate authentication, the TLS/DTLS protocol requires that the DTLS Server instance provide a certificate for identification, but by default the DTLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="9db8c-429">これは、インターネットでの、Web サイト向けの最も一般的な TLS の使用法に合致しています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-429">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="9db8c-430">たとえばオンライン小売サイトでは、Web ブラウザーを使用している潜在顧客に、サーバーが正当なものであることを証明する必要がありますが、ユーザーはログインとパスワードを使用して特定のアカウントにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="9db8c-430">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="9db8c-431">ただし、既定のケースが常に望ましいとは限らないため、TLS/DTLS では、必要に応じて DTLS Server インスタンスでリモート クライアントから証明書を要求することができます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-431">However, the default case is not always desirable, so TLS/DTLS optionally allows for the DTLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="9db8c-432">この機能が有効になっている場合は、DTLS Server によってハンドシェイク中に CertificateRequest メッセージが DTLS Client に送信されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-432">When this feature is enabled, the DTLS Server will send a CertificateRequest message to the DTLS Client during the handshake.</span></span> <span data-ttu-id="9db8c-433">クライアントでは、それ自身の証明書と、その証明書に関連付けられている一致する秘密キーがクライアントに所有されていることを証明する暗号化トークンが含まれる CertificateVerify メッセージで応答する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-433">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="9db8c-434">検証が失敗した場合や、証明書がサーバー上の信頼された証明書に接続されていない場合は、TLS ハンドシェイクが失敗します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-434">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="9db8c-435">TLS でのクライアント証明書認証には 2 つの異なるケースがあります。後続のセクションでは、両方のケースについて説明します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-435">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-dtls-clients"></a><span data-ttu-id="9db8c-436">DTLS Client でのクライアント証明書の認証</span><span class="sxs-lookup"><span data-stu-id="9db8c-436">Client Certificate Authentication for DTLS Clients</span></span>

<span data-ttu-id="9db8c-437">DTLS Client では、クライアント認証のために証明書を要求するサーバーへの接続を試行する場合があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-437">A DTLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="9db8c-438">この場合、クライアントはサーバーに証明書を提供して、一致する秘密キーを保持していることを証明する必要があります。そうしないと、サーバーによって DTLS ハンドシェイクが終了されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-438">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the DTLS handshake.</span></span>

<span data-ttu-id="9db8c-439">NetX Secure DTLS では、この機能をサポートする特別な構成はありませんが、アプリケーションでは、*nx_secure_tls_session_local_certificate_add* サービスを使用して、TLS Client インスタンスのローカル ID 証明書を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-439">In NetX Secure DTLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_session_local_certificate_add* service.</span></span> <span data-ttu-id="9db8c-440">アプリケーションによって証明書が提示されず、リモート サーバーでクライアント証明書の認証が使用されていて証明書が要求される場合、DTLS ハンドシェイクは失敗します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-440">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the DTLS handshake will fail.</span></span> <span data-ttu-id="9db8c-441">DTLS ハンドシェイクを完了するには、*nx_secure_dtls_session_local_certificate_add* 使用して DTLS セッションに提示される証明書が、リモート サーバーによって認識される必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-441">The certificate provided to the DTLS Session with *nx_secure_dtls_session_local_certificate_add* must be recognized by the remote server in order to complete the DTLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="9db8c-442">TLS サーバーでのクライアント証明書の認証</span><span class="sxs-lookup"><span data-stu-id="9db8c-442">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="9db8c-443">クライアント証明書の認証の DTLS Server のケースは、この機能がオプションであるため、DTLS Client の場合よりも若干複雑になります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-443">The DTLS Server case for Client Certificate Authentication is slightly more complex than the DTLS Client case due to the feature being optional.</span></span> <span data-ttu-id="9db8c-444">この場合 TLS サーバーでは、リモート TLS クライアントに証明書を要求してから CertificateVerify メッセージを処理し、リモート クライアントが一致する秘密キーを所有していることを検証する必要があります。その後サーバーで、クライアントから提供された証明書を、ローカルの信頼された証明書ストア内の証明書まで追跡できることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-444">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="9db8c-445">NetX Secure TLS Server インスタンスでは、クライアント証明書の認証は *nx_secure_dtls_server_x509_client_verify_configure* および *nx_secure_dtls_server_x509_client_verify_disable* サービスによって制御されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-445">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by the *nx_secure_dtls_server_x509_client_verify_configure* and *nx_secure_dtls_server_x509_client_verify_disable* services.</span></span>

<span data-ttu-id="9db8c-446">クライアント証明書の認証を有効にするには、アプリケーションで、DTLS Server セッション インスタンスを使用して *nx_secure_dtls_server_x509_client_verify_configure* を呼び出してから、*nx_secure_dtls_server_start* を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-446">To enable Client Certificate Authentication, an application must call *nx_secure_dtls_server_x509_client_verify_configure* with the DTLS Server session instance before calling *nx_secure_dtls_server_start*.</span></span> <span data-ttu-id="9db8c-447">検証を行うには、*nx_secure_dtls_server_x509_client_verify_configure* のパラメーターとして提供される受信クライアント証明書用に割り当てる領域が必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-447">The verification requires space to be allocated for incoming client certificates which is provided as a parameter to *nx_secure_dtls_server_x509_client_verify_configure.*</span></span> <span data-ttu-id="9db8c-448">そのバッファーは、証明書チェーンの最大サイズ ("*クライアント x DTLS Server のセッション数*") を保持するために十分な大きさにする必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-448">Note that the buffer must be large enough to hold the maximum-size certificate chain provided by a client *times the number of DTLS server sessions*.</span></span> <span data-ttu-id="9db8c-449">各サーバー セッションには、指定された 1 つのバッファーから割り当てられる領域が必要です。</span><span class="sxs-lookup"><span data-stu-id="9db8c-449">Each server session requires space which will be allocated from the single provided buffer.</span></span> <span data-ttu-id="9db8c-450">バッファーのサイズが十分であることを確認してください。提供されたクライアント証明書チェーンが大きすぎる場合は、エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-450">Make sure the buffer is large enough or an error will occur if the provided Client certificate chain is too large.</span></span>

<span data-ttu-id="9db8c-451">クライアント証明書の認証が有効になっている場合、DTLS ハンドシェイク中に、DTLS Server ではリモート DTLS Client に証明書を要求します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-451">When Client Certificate Authentication is enabled, the DTLS Server will request a certificate from the remote DTLS Client during the DTLS handshake.</span></span> <span data-ttu-id="9db8c-452">NetX Secure の DTLS Server では、クライアント証明書は、X.509 発行者チェーンをたどって *nx_secure_dtls_server_trusted_certificate_add* で作成された信頼された証明書のストアに対してチェックされます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-452">In NetX Secure DTLS Server, the Client certificate is checked against the store of trusted certificates created with *nx_secure_dtls_server_trusted_certificate_add* by following the X.509 issuer chain.</span></span> <span data-ttu-id="9db8c-453">リモート クライアントでは、信頼されたストア内の証明書に ID 証明書を接続するチェーンを提供する必要があります。そうしないと、DTLS ハンドシェイクが失敗します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-453">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the DTLS handshake will fail.</span></span> <span data-ttu-id="9db8c-454">また、CertificateVerify メッセージの処理が失敗した場合は、DTLS ハンドシェイクも失敗します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-454">Additionally, if the CertificateVerify message processing fails, the DTLS handshake will also fail.</span></span>

<span data-ttu-id="9db8c-455">CertificateVerify メソッドに使用される署名方法は、TLS バージョン 1.0 および TLS バージョン 1.1 では固定されており、NetX Secure DTLS のベースである TLS バージョン 1.2 では TLS Server によって指定されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-455">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2, upon which NetX Secure DTLS is based.</span></span> <span data-ttu-id="9db8c-456">DTLS 1.2 の場合、通常、サポートされる署名方法は、暗号化方式テーブルに提供されている関連する方法に従いますが、通常は RSA と SHA-256 が使用されます (暗号化方式を使用した TLS の初期化の詳細については、「NetX Secure TLS での暗号化」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="9db8c-456">For DTLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section “Cryptography in NetX Secure TLS” for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="9db8c-457">NetX Secure TLS での暗号化</span><span class="sxs-lookup"><span data-stu-id="9db8c-457">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="9db8c-458">TLS では、暗号化を使用してネットワーク通信をセキュリティで保護できるプロトコルが定義されています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-458">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="9db8c-459">そのため、実際に使用される暗号化に関して TLS ユーザーには幅広い選択肢があります。</span><span class="sxs-lookup"><span data-stu-id="9db8c-459">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="9db8c-460">仕様では、1 つの暗号スイートを実装することのみが要求されます。TLS 1.2 の場合、その暗号スイートは TLS_RSA_WITH_AES_128_CBC_SHA であり、公開キー操作に RSA、セッションの暗号化に 128 ビットのキーを使用する CBC モードの AES、メッセージ認証のハッシュに SHA-1 が使用されることを示します。</span><span class="sxs-lookup"><span data-stu-id="9db8c-460">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="9db8c-461">NetX Secure は、TLS 1.2 に準拠しており、既定で必須の TLS_RSA_WITH_AES_128_CBC_SHA 暗号スイートが有効にされます。ただし、ハードウェアの機能やその他の考慮事項によって暗号化方式ごとに可能な実装が多数あるため、NetX Secure では、TLS で使用される暗号化方式をユーザーが指定できるようにする汎用の暗号化 API が提供されています。</span><span class="sxs-lookup"><span data-stu-id="9db8c-461">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

> [!NOTE]
> <span data-ttu-id="9db8c-462">汎用暗号 API メカニズムでは、ユーザーが独自の暗号スイートを実装することもできますが、これは TLS 暗号スイートと拡張機能に精通している上級ユーザーにお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9db8c-462">The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="9db8c-463">独自の暗号スイートのサポートに関心がある場合は、Express Logic の担当者にお問い合わせください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-463">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

<span data-ttu-id="9db8c-464">DTLS の暗号化方式の構成方法の詳細については、『NetX Secure TLS ユーザー ガイド』の第 3 章を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9db8c-464">Please see the NetX Secure TLS User Guide, Chapter 3 for a detailed discussion about how to configure cryptographic methods for DTLS.</span></span> <span data-ttu-id="9db8c-465">TLS と DTLS の両方に同じプロセスが適用されます。</span><span class="sxs-lookup"><span data-stu-id="9db8c-465">The same process applies to both TLS and DTLS.</span></span>
