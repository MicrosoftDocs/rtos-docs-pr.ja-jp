---
title: 第 3 章 - Azure RTOS NetX Secure の機能の説明
description: この章では、NetX Secure TLS の機能について説明します。
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c28ad0255f99986a4ddfe5faefad81e70840e5e0
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104810502"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a><span data-ttu-id="b3993-103">第 3 章 - Azure RTOS NetX Secure の機能の説明</span><span class="sxs-lookup"><span data-stu-id="b3993-103">Chapter 3 - Functional description of Azure RTOS NetX Secure</span></span>

## <a name="execution-overview"></a><span data-ttu-id="b3993-104">実行の概要</span><span class="sxs-lookup"><span data-stu-id="b3993-104">Execution Overview</span></span>

<span data-ttu-id="b3993-105">この章では、Azure RTOS NetX Secure TLS の機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="b3993-105">This chapter contains a functional description of Azure RTOS NetX Secure TLS.</span></span> <span data-ttu-id="b3993-106">NetX Secure TLS アプリケーションで主に行われるプログラム実行の種類は、初期化とアプリケーション インターフェイスの呼び出しです。</span><span class="sxs-lookup"><span data-stu-id="b3993-106">There are two primary types of program execution in a NetX Secure TLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="b3993-107">*NetX Secure は、ThreadX と NetX/NetXDuo の存在を前提としています。ThreadX に求められるのは、スレッドの実行、一時停止、周期タイマー、相互排他の機能です。NetX/NetXDuo に求められるのは、TCP/IP のネットワーク機能とドライバーです。*</span><span class="sxs-lookup"><span data-stu-id="b3993-107">*NetX Secure assumes the existence of ThreadX and NetX/NetXDuo. From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities. From NetX/NetXDuo it requires the TCP/IP networking facilities and drivers.*</span></span>

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a><span data-ttu-id="b3993-108">トランスポート層セキュリティ (TLS) と Secure Sockets Layer (SSL)</span><span class="sxs-lookup"><span data-stu-id="b3993-108">Transport Layer Security (TLS) and Secure Sockets Layer (SSL)</span></span>

<span data-ttu-id="b3993-109">NetX Secure のセキュリティで保護されたネットワーク プロトコル コンポーネントは、RFC 2246 (バージョン 1.0)、4346 (バージョン 1.1)、5246 (バージョン 1.2)、8446 (バージョン 1.3) で説明されているトランスポート層セキュリティ (TLS) プロトコルの実装です。</span><span class="sxs-lookup"><span data-stu-id="b3993-109">The secure network protocol component of NetX secure is an implementation of the Transport Layer Security (TLS) protocol as described in RFCs 2246 (version 1.0), 4346 (version 1.1), 5246 (version 1.2) and 8446 (version 1.3).</span></span> <span data-ttu-id="b3993-110">また、基本的な X.509 (RFC 5280) のサポート ルーチンが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b3993-110">Also included are support routines for basic X.509 (RFC 5280).</span></span>

<span data-ttu-id="b3993-111">NetX Secure TLS は、TLS バージョン 1.2 および 1.3 をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b3993-111">NetX Secure TLS supports TLS versions 1.2 and 1.3.</span></span> <span data-ttu-id="b3993-112">現在は非推奨の TLS 1.0 と TLS 1.1 のための実装が提供されていますが、これらは明示的に初期化する必要があり、新しい製品での使用は推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="b3993-112">Implementations are provided for the now-deprecated TLS 1.0 and TLS 1.1, but they must be explicitly initialized and are not recommended for use in new products.</span></span>

<span data-ttu-id="b3993-113">*Secure Sockets Layer* (SSL) は、RFC 2246 で標準になる前の TLS の、当初の名称でした。"SSL" は多くの場合、TLS プロトコルの総称として使用されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-113">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and "SSL" is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="b3993-114">SSL の最新バージョンは 3.0 であり、TLS 1.0 は SSL バージョン 3.1 と呼ばれることもあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-114">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="b3993-115">正式な "SSL" プロトコルは、すべてのバージョンが古く安全ではないと見なされており、現在では、NetX Secure に SSL 実装は用意されていません。</span><span class="sxs-lookup"><span data-stu-id="b3993-115">All versions of the official "SSL" protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="b3993-116">TLS では、TLS クライアントとサーバー間の TLS "*ハンドシェイク*" 中に作成される "*セッション キー*" を生成するためのプロトコルが規定されており、それらのキーは、TLS "*セッション*" 中にアプリケーションによって送信されるデータを暗号化するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-116">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="b3993-117">TLS データは、TCP パケットと同等の概念である "*レコード*" に分割されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-117">TLS data is divided into *records* which are equivalent in concept to a TCP packet.</span></span> <span data-ttu-id="b3993-118">すべての TLS レコードにヘッダーがあり、TLS で暗号化されたレコードにはフッター (チェックサム ハッシュ) もあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-118">Every TLS record has a header, and TLS encrypted records also have a footer (checksum hash).</span></span> <span data-ttu-id="b3993-119">TLS ハンドシェイク レコードには、より大きな TLS レコード内にカプセル化される追加ヘッダーがあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-119">TLS handshake records have an additional header encapsulated within the larger TLS record.</span></span> <span data-ttu-id="b3993-120">TLS レコードは、TCP パケットが IP パケットによってカプセル化されるのと同じ方法で、トランスポート層のネットワーク プロトコルによってカプセル化されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-120">The TLS record is encapsulated by the  transport layer network protocol in the same manner that a TCP packet is encapsulated by an IP packet.</span></span>

### <a name="tls-13"></a><span data-ttu-id="b3993-121">TLS 1.3</span><span class="sxs-lookup"><span data-stu-id="b3993-121">TLS 1.3</span></span>

<span data-ttu-id="b3993-122">TLS 1.3 仕様は 2018 年 8 月に最終的に承認されました。</span><span class="sxs-lookup"><span data-stu-id="b3993-122">In August 2018, the TLS 1.3 specification was finalized.</span></span> <span data-ttu-id="b3993-123">この新しいバージョンのプロトコルは、TLS の基礎となっているセキュリティとパフォーマンスのいくつかの基本的側面に変更を加える、かなり大幅な更新となっています。</span><span class="sxs-lookup"><span data-stu-id="b3993-123">The new version of the protocol is a fairly significant update that changes some fundamental aspects of the underlying security and performance of TLS.</span></span> <span data-ttu-id="b3993-124">ただし、これらの変更は、主に TLS ハンドシェイクの状態機械とセッション キーの生成に適用されるため、大部分は一般的な TLS ユーザーには認識されません。</span><span class="sxs-lookup"><span data-stu-id="b3993-124">However, these changes are largely invisible to the typical TLS user since they apply primarily to the TLS handshake state machine and session key generation.</span></span> <span data-ttu-id="b3993-125">オプションの機能と拡張機能もいくつか追加されました。</span><span class="sxs-lookup"><span data-stu-id="b3993-125">A number of optional features and extensions were added as well.</span></span> <span data-ttu-id="b3993-126">以下に、変更点と、それらが TLS の機能にどのように影響を与えるかの概要を示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-126">The following is a summary of the changes and how they impact TLS functionality.</span></span>

- <span data-ttu-id="b3993-127">サーバーによるメッセージの交換全体を削除して、ハンドシェイクの状態機械が最適化されました。</span><span class="sxs-lookup"><span data-stu-id="b3993-127">The handshake state machine was optimized by removing an entire exchange of messages by the server.</span></span>
- <span data-ttu-id="b3993-128">HKDF (HMAC ベースのキー派生関数) と呼ばれる標準化されたルーチンを使用するようにキーの生成が更新されました。セッション キーは、いくつかの限られたパラメーターではなく、すべてのハンドシェイク メッセージに結び付けられます。</span><span class="sxs-lookup"><span data-stu-id="b3993-128">Key generation was updated to use a standardized routine called HKDF (HMAC-based Key Derivation Function) and ties the session keys to all of the handshake messages (instead of a few select parameters).</span></span>
- <span data-ttu-id="b3993-129">TLS 1.2 とそれ以前の暗号スイートは、すべて非推奨とされ、TLS 1.3 と互換性がありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-129">All TLS 1.2 and earlier ciphersuites are deprecated and are incompatible with TLS 1.3.</span></span> <span data-ttu-id="b3993-130">同様に、すべての TLS 1.3 暗号スイートは、以前のバージョンと共に使用することができません。</span><span class="sxs-lookup"><span data-stu-id="b3993-130">Similarly, all TLS 1.3 ciphersuites are unusable with previous versions.</span></span>
- <span data-ttu-id="b3993-131">すべての TLS 1.3 暗号スイートで、短期キー<sup>6</sup> を使用して Perfect Forward Secrecy (PFS) が提供されます</span><span class="sxs-lookup"><span data-stu-id="b3993-131">All TLS 1.3 ciphersuites provide Perfect Forward Secrecy (PFS) using ephemeral keys<sup>6</sup></span></span> 
- <span data-ttu-id="b3993-132">TLS 1.3 では、AEAD<sup>7</sup> 暗号の使用を優先させるため、各レコードの "メッセージ認証コード" (MAC) が削除されます</span><span class="sxs-lookup"><span data-stu-id="b3993-132">TLS 1.3 removes the "message authentication code" (MAC) in each record in favor of using AEAD<sup>7</sup> ciphers</span></span>
- <span data-ttu-id="b3993-133">ハンドシェイク中にアプリケーション データを送信できるようにする 0-RTT (ラウンド トリップ時間ゼロ) など、付加的なオプション機能がいくつか追加されました。</span><span class="sxs-lookup"><span data-stu-id="b3993-133">Some additional optional features were added, including 0-RTT (Zero Round Trip Time) which allows for application data to be sent during the handshake.</span></span> <span data-ttu-id="b3993-134">0-RTT は完全にオプションで、Azure RTOS TLS では現在サポートされていません。</span><span class="sxs-lookup"><span data-stu-id="b3993-134">0-RTT is purely optional and is not currently supported in Azure RTOS TLS.</span></span>

<span data-ttu-id="b3993-135">TLS 1.3 は、ユーザー アプリケーションに大きな影響を与えません。</span><span class="sxs-lookup"><span data-stu-id="b3993-135">TLS 1.3 does not significantly affect user applications.</span></span> <span data-ttu-id="b3993-136">API はバージョン間でまったく同じままになっていて、1 つの暗号スイート テーブルが使用されるように暗号スイートにマーク付けされています。</span><span class="sxs-lookup"><span data-stu-id="b3993-136">The API remains exactly the same between versions, and ciphersuites are marked so a single ciphersuite table may be used.</span></span>

<span data-ttu-id="b3993-137">TLS 1.3 を使用するには、マクロ NX_SECURE_TLS_ENABLE_TLS_1_3 がグローバルに定義される必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-137">In order to use TLS 1.3, the macro NX_SECURE_TLS_ENABLE_TLS_1_3 must be globally defined.</span></span> <span data-ttu-id="b3993-138">Azure RTOS TLS では、TLS 1.3 は既定で無効になっています。</span><span class="sxs-lookup"><span data-stu-id="b3993-138">TLS 1.3 is disabled by default in Azure RTOS TLS.</span></span>

6. <span data-ttu-id="b3993-139">"短期" キーは、TLS ハンドシェイク中に生成され、そのセッションでのみシークレット交換に使用される、非対称キーの組です。</span><span class="sxs-lookup"><span data-stu-id="b3993-139">“Ephemeral” keys are asymmetric key pairs that are generated during the TLS handshake and used for the secrets exchange for only that session.</span></span> <span data-ttu-id="b3993-140">これらのキーの組は使用後に破棄されます。これにより将来の任意の時点で証明書の秘密キーが侵害された場合でも、記録されている TLS セッション内の暗号化されたデータに、攻撃者がアクセスできなくなります。つまり、"Perfect Forward Secrecy (完璧な前方機密性)" です。</span><span class="sxs-lookup"><span data-stu-id="b3993-140">They key pair is discarded after use – this prevents an attacker from being able to access encrypted data in a recorded TLS session even if a certificate private key is compromised at any time in the future – hence “Perfect Forward Secrecy”.</span></span>

7. <span data-ttu-id="b3993-141">関連付けられたデータを使用した認証された暗号化 – AES のような暗号のためのモードで、暗号化と、単一の操作での整合性のチェックを組み合わせて、整合性チェックのためにデータのハッシュを別個に行う必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="b3993-141">Authenticated Encryption with Associated Data – a mode for ciphers like AES that combines encryption and integrity checking in a single operation, eliminating the need for a separate hash of the data for integrity checking.</span></span>

### <a name="tls-record-header"></a><span data-ttu-id="b3993-142">TLS レコードのヘッダー</span><span class="sxs-lookup"><span data-stu-id="b3993-142">TLS Record header</span></span>

<span data-ttu-id="b3993-143">有効な TLS レコードにはすべて、"エラー!</span><span class="sxs-lookup"><span data-stu-id="b3993-143">Any valid TLS record must have a TLS header, as shown in Error!</span></span> <span data-ttu-id="b3993-144">参照元が見つかりません" と表示されるように、TLS ヘッダーが必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-144">Reference source not found.</span></span>

![TLS レコードのヘッダーの図。](media/image2.png)

<span data-ttu-id="b3993-146">図 1 - TLS レコードのヘッダー</span><span class="sxs-lookup"><span data-stu-id="b3993-146">Figure 1 - TLS record header</span></span>

<span data-ttu-id="b3993-147">TLS レコードのヘッダーのフィールドは、次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-147">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="b3993-148">TLS ヘッダーのフィールド</span><span class="sxs-lookup"><span data-stu-id="b3993-148">TLS Header Field</span></span> | <span data-ttu-id="b3993-149">目的</span><span class="sxs-lookup"><span data-stu-id="b3993-149">Purpose</span></span>     |
| ---------------- | ------------- |
| <span data-ttu-id="b3993-150">**8 ビットでのメッセージの種類**</span><span class="sxs-lookup"><span data-stu-id="b3993-150">**8-bit Message Type**</span></span> | <span data-ttu-id="b3993-151">このフィールドには、送信中の DTLS レコードの種類が格納されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-151">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="b3993-152">有効な種類は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b3993-152">Valid types are as follows:</span></span><br /><span data-ttu-id="b3993-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="b3993-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span></span><br /><span data-ttu-id="b3993-154">- Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="b3993-154">- Alert: 0x15</span></span><br /><span data-ttu-id="b3993-155">- Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="b3993-155">- Handshake: 0x16</span></span><br /><span data-ttu-id="b3993-156">- Application Data: 0x17</span><span class="sxs-lookup"><span data-stu-id="b3993-156">- Application Data: 0x17</span></span> |
| <span data-ttu-id="b3993-157">**16 ビットでのプロトコル バージョン**</span><span class="sxs-lookup"><span data-stu-id="b3993-157">**16-bit Protocol Version**</span></span> | <span data-ttu-id="b3993-158">このフィールドには、TLS プロトコルのバージョンが格納されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-158">This field contains the TLS protocol version.</span></span> <span data-ttu-id="b3993-159">有効な値は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b3993-159">Valid values are as follows:</span></span><br /><span data-ttu-id="b3993-160">- SSL 3.0: 0x0300</span><span class="sxs-lookup"><span data-stu-id="b3993-160">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="b3993-161">- TLS 1.0: 0x0301</span><span class="sxs-lookup"><span data-stu-id="b3993-161">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="b3993-162">- TLS 1.1: 0x0302</span><span class="sxs-lookup"><span data-stu-id="b3993-162">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="b3993-163">- TLS 1.2: 0x0303</span><span class="sxs-lookup"><span data-stu-id="b3993-163">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="b3993-164">- **TLS 1.3 <sup>9</sup>** : **0x0303**</span><span class="sxs-lookup"><span data-stu-id="b3993-164">- **TLS 1.3 <sup>9</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="b3993-165">**16 ビットでの長さ**</span><span class="sxs-lookup"><span data-stu-id="b3993-165">**16-bit Length**</span></span> | <span data-ttu-id="b3993-166">このフィールドには、TLS レコードにカプセル化されたデータの長さが格納されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-166">This field contains the length of the data encapsulated in the TLS record.</span></span> |

8. <span data-ttu-id="b3993-167">TLS 1.3 では、ChangeCipherSpec メッセージは使用されなくなっていますが、互換性のために送信される可能性があります。この場合、メッセージは無視されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-167">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

9. <span data-ttu-id="b3993-168">このスキームが続行された場合、TLS 1.3 の値は技術的には 0x0304 になりますが、拡張機能においては、実際のプロトコル バージョンを持つようにプロトコルが変更されているため、すべての TLS 1.3 レコードでは、下位互換性のために、プロトコル バージョン フィールドで 0x0303 が使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-168">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="tls-handshake-record-header"></a><span data-ttu-id="b3993-169">TLS ハンドシェイク レコードのヘッダー</span><span class="sxs-lookup"><span data-stu-id="b3993-169">TLS Handshake Record header</span></span>

<span data-ttu-id="b3993-170">図 2 に示すように、有効な TLS ハンドシェイク レコードにはすべて、TLS ハンドシェイクのヘッダーが必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-170">Any valid TLS handshake record must have a TLS Handshake header, as shown in Figure 2.</span></span>

![TLS ハンドシェイク レコードのヘッダーの図。](media/image3.png)

<span data-ttu-id="b3993-172">図 2 - TLS ハンドシェイク レコードのヘッダー</span><span class="sxs-lookup"><span data-stu-id="b3993-172">Figure 2 - TLS Handshake record header</span></span>

<span data-ttu-id="b3993-173">TLS ハンドシェイク レコードのヘッダーのフィールドは、以下のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-173">The fields of the TLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="b3993-174">TLS ヘッダーのフィールド</span><span class="sxs-lookup"><span data-stu-id="b3993-174">TLS Header Field</span></span> | <span data-ttu-id="b3993-175">目的</span><span class="sxs-lookup"><span data-stu-id="b3993-175">Purpose</span></span> |
| ---------------- |----------------------- |
| <span data-ttu-id="b3993-176">**8 ビットでのメッセージの種類**</span><span class="sxs-lookup"><span data-stu-id="b3993-176">**8-bit Message Type**</span></span> | <span data-ttu-id="b3993-177">このフィールドには、送信中の DTLS レコードの種類が格納されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-177">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="b3993-178">有効な種類は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b3993-178">Valid types are as follows:</span></span><br /><span data-ttu-id="b3993-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="b3993-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span></span><br /><span data-ttu-id="b3993-180">- Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="b3993-180">- Alert: 0x15</span></span><br /><span data-ttu-id="b3993-181">- Handshake: 0x16</span><span class="sxs-lookup"><span data-stu-id="b3993-181">- Handshake: 0x16</span></span><br /><span data-ttu-id="b3993-182">- Application Data: 0x17</span><span class="sxs-lookup"><span data-stu-id="b3993-182">- Application Data: 0x17</span></span> |
| <span data-ttu-id="b3993-183">**16 ビットでのプロトコル バージョン**</span><span class="sxs-lookup"><span data-stu-id="b3993-183">**16-bit Protocol Version**</span></span> | <span data-ttu-id="b3993-184">このフィールドには、TLS プロトコルのバージョンが格納されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-184">This field contains the TLS protocol version.</span></span> <span data-ttu-id="b3993-185">有効な値は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b3993-185">Valid values are as follows:</span></span><br /><span data-ttu-id="b3993-186">- SSL 3.0: 0x0300</span><span class="sxs-lookup"><span data-stu-id="b3993-186">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="b3993-187">- TLS 1.0: 0x0301</span><span class="sxs-lookup"><span data-stu-id="b3993-187">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="b3993-188">- TLS 1.1: 0x0302</span><span class="sxs-lookup"><span data-stu-id="b3993-188">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="b3993-189">- TLS 1.2: 0x0303</span><span class="sxs-lookup"><span data-stu-id="b3993-189">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="b3993-190">- **TLS 1.3 <sup>11</sup>** : **0x0303**</span><span class="sxs-lookup"><span data-stu-id="b3993-190">- **TLS 1.3 <sup>11</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="b3993-191">**16 ビットでの長さ**</span><span class="sxs-lookup"><span data-stu-id="b3993-191">**16-bit Length**</span></span>    | <span data-ttu-id="b3993-192">このフィールドには、TLS レコードにカプセル化されたデータの長さが格納されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-192">This field contains the length of the data encapsulated in the TLS record.</span></span> |
| <span data-ttu-id="b3993-193">**8 ビットでのハンドシェイクの種類**</span><span class="sxs-lookup"><span data-stu-id="b3993-193">**8-bit Handshake Type**</span></span> | <span data-ttu-id="b3993-194">このフィールドには、ハンドシェイク メッセージの種類が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b3993-194">This field contains the handshake message type.</span></span> <span data-ttu-id="b3993-195">有効な値は次のとおりです (\***太字** のメッセージは TLS 1.3 で追加されました)。</span><span class="sxs-lookup"><span data-stu-id="b3993-195">Valid values are as follows (\*messages in **bold** were added in TLS 1.3):</span></span><br /><span data-ttu-id="b3993-196">- HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="b3993-196">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="b3993-197">- ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="b3993-197">- ClientHello: 0x01</span></span><br /><span data-ttu-id="b3993-198">- ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="b3993-198">- ServerHello: 0x02</span></span><br /><span data-ttu-id="b3993-199">- **HelloVerifyRequest**: **0x03**</span><span class="sxs-lookup"><span data-stu-id="b3993-199">- **HelloVerifyRequest**: **0x03**</span></span><br /><span data-ttu-id="b3993-200">- **NewSessionTicket**: **0x04**</span><span class="sxs-lookup"><span data-stu-id="b3993-200">- **NewSessionTicket**: **0x04**</span></span><br /><span data-ttu-id="b3993-201">- **EndOfEarlyData**: **0x05**</span><span class="sxs-lookup"><span data-stu-id="b3993-201">- **EndOfEarlyData**: **0x05**</span></span><br /><span data-ttu-id="b3993-202">- **EncryptedExtensions**: **0x08**</span><span class="sxs-lookup"><span data-stu-id="b3993-202">- **EncryptedExtensions**: **0x08**</span></span><br /><span data-ttu-id="b3993-203">- Certificate: 0x0B</span><span class="sxs-lookup"><span data-stu-id="b3993-203">- Certificate: 0x0B</span></span><br /><span data-ttu-id="b3993-204">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="b3993-204">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="b3993-205">- CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="b3993-205">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="b3993-206">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="b3993-206">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="b3993-207">- CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="b3993-207">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="b3993-208">- ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="b3993-208">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="b3993-209">- Finished: 0x14</span><span class="sxs-lookup"><span data-stu-id="b3993-209">- Finished: 0x14</span></span><br /><span data-ttu-id="b3993-210">- **KeyUpdate**: **0x18**</span><span class="sxs-lookup"><span data-stu-id="b3993-210">- **KeyUpdate**: **0x18**</span></span><br /><span data-ttu-id="b3993-211">- **MessageHash**: **0xFE**</span><span class="sxs-lookup"><span data-stu-id="b3993-211">- **MessageHash**: **0xFE**</span></span> |
| <span data-ttu-id="b3993-212">**24 ビットでの長さ**</span><span class="sxs-lookup"><span data-stu-id="b3993-212">**24-bit Length**</span></span>    | <span data-ttu-id="b3993-213">このフィールドには、ハンドシェイク メッセージのデータの長さが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b3993-213">This field contains the length of the handshake message data.</span></span> |

10. <span data-ttu-id="b3993-214">TLS 1.3 では、ChangeCipherSpec メッセージは使用されなくなっていますが、互換性のために送信される可能性があります。この場合、メッセージは無視されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-214">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

11. <span data-ttu-id="b3993-215">このスキームが続行された場合、TLS 1.3 の値は技術的には 0x0304 になりますが、拡張機能においては、実際のプロトコル バージョンを持つようにプロトコルが変更されているため、すべての TLS 1.3 レコードでは、下位互換性のために、プロトコル バージョン フィールドで 0x0303 が使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-215">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="the-tls-handshake-and-tls-session"></a><span data-ttu-id="b3993-216">TLS ハンドシェイクと TLS セッション</span><span class="sxs-lookup"><span data-stu-id="b3993-216">The TLS Handshake and TLS Session</span></span>

<span data-ttu-id="b3993-217">図 3 に、典型的な TLS ハンドシェイク (バージョン 1.0 ～ 1.2) を示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-217">A typical TLS handshake (versions 1.0-1.2) is shown in Figure 3.</span></span> <span data-ttu-id="b3993-218">TLS ハンドシェイクは、TLS クライアントが *ClientHello* メッセージを TLS サーバーに送信するときに開始され、クライアントが TLS セッションの開始を求めていることを示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-218">A TLS handshake begins when the TLS Client sends a *ClientHello* message to a TLS server, indicating its desire to start a TLS session.</span></span> <span data-ttu-id="b3993-219">このメッセージには、クライアントでセッションに使用する暗号化に関する情報と、後でハンドシェイクでセッション キーを生成するために使用される情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b3993-219">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="b3993-220">セッション キーが生成されるまで、TLS ハンドシェイクのメッセージはすべて暗号化されません。</span><span class="sxs-lookup"><span data-stu-id="b3993-220">Until the session keys are generated, all messages in the TLS handshake are not encrypted.</span></span> <span data-ttu-id="b3993-221">TLS 1.3 ではハンドシェイクが多少変更されており、詳細については次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="b3993-221">TLS 1.3 changes the handshake somewhat – details are presented in the next section.</span></span>

<span data-ttu-id="b3993-222">TLS サーバーは、クライアントによって提供された暗号化オプションからの選択を示す ServerHello メッセージによって ClientHello に応答します。</span><span class="sxs-lookup"><span data-stu-id="b3993-222">The TLS Server responds to the ClientHello with a ServerHello message, indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="b3993-223">ServerHello の後には証明書メッセージが続き、このメッセージではサーバーにより、クライアントに対してサーバーの ID を認証するためのデジタル証明書が提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-223">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client.</span></span> <span data-ttu-id="b3993-224">最後に、サーバーによって、送信するメッセージがこれ以上ないことを示す ServerHelloDone メッセージが送信されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-224">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="b3993-225">サーバーからは、ServerHello に続いてオプションで他のメッセージが送信されることがあり、場合によっては Certificate メッセージが送信されないこともあります。そのため、ServerHelloDone メッセージが必要になります。</span><span class="sxs-lookup"><span data-stu-id="b3993-225">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message, hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="b3993-226">クライアントでサーバーのメッセージがすべて受信されると、セッション キーを生成するのに十分な情報となります。</span><span class="sxs-lookup"><span data-stu-id="b3993-226">Once the client has received all the server's messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="b3993-227">これは TLS では、"*プリマスター シークレット*" と呼ばれるランダム データの共有ビットの作成によって行われます。これは固定サイズで、暗号化が有効になった後に必要なすべてのキーを生成するためのシードとして使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-227">TLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="b3993-228">プリマスター シークレットは、Hello メッセージで指定された公開キー アルゴリズム (RSA など) と、サーバーによって証明書で提供された公開キーを使用して暗号化されます (公開キー アルゴリズムの詳細については後述します)。</span><span class="sxs-lookup"><span data-stu-id="b3993-228">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="b3993-229">事前共有キー (PSK) と呼ばれるオプションの TLS 機能を使用すると、証明書を使用せず、代わりにホスト間で共有されるシークレット値を使用する (通常は物理的転送またはその他のセキュリティで保護された方法による) 暗号スイートが有効になります。</span><span class="sxs-lookup"><span data-stu-id="b3993-229">An optional TLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="b3993-230">共有シークレットは、暗号化されたメッセージを使用してプリマスター シークレットを送信するのではなく、プリマスター シークレットを生成するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-230">The shared secret is used to generate the Pre-Master Secret instead of using an encrypted message to send the Pre-Master Secret.</span></span> <span data-ttu-id="b3993-231">後の事前共有キーに関するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-231">See the section on Pre-Shared Keys below.</span></span>

<span data-ttu-id="b3993-232">暗号化されたプリマスター シークレットは、ClientKeyExchange メッセージでサーバーに送信されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-232">The encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="b3993-233">サーバーでは、ClientKeyExchange メッセージを受信すると、その秘密キーを使用してプリマスター シークレットが解読され、TLS クライアントと同時のセッション キーの生成に進みます。</span><span class="sxs-lookup"><span data-stu-id="b3993-233">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS client.</span></span>

<span data-ttu-id="b3993-234">セッション キーが生成されると、それ以降のメッセージはすべて、Hello メッセージで選択された秘密キー アルゴリズム (AES など) を使用して暗号化できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-234">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="b3993-235">以後のメッセージはすべて暗号化されることを示すため、ChangeCipherSpec という暗号化されていない最後のメッセージが、クライアントとサーバーの両方によって送信されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-235">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="b3993-236">クライアントとサーバーの両方によって送信される最初の暗号化されたメッセージも、Finished という最後の TLS ハンドシェイク メッセージです。</span><span class="sxs-lookup"><span data-stu-id="b3993-236">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="b3993-237">このメッセージには、送受信されたすべてのハンドシェイク メッセージのハッシュが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b3993-237">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="b3993-238">このハッシュは、ハンドシェイクのどのメッセージも、改ざんされたり破損したり (セキュリティ侵害の可能性を示します) していないことを検証するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-238">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="b3993-239">Finished メッセージが受信され、ハンドシェイクのハッシュが検証されると、TLS セッションが開始され、アプリケーションのデータの送受信が開始されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-239">Once the Finished messages are received and the handshake hashes are verified, the TLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="b3993-240">TLS セッション中に、いずれかの側から送信されたすべてのデータは、まず、Hello メッセージで選択されたハッシュ アルゴリズムを使用して (メッセージの整合性を提供するために) ハッシュされ、選択された秘密キー アルゴリズムと生成されたセッション キーを使用して暗号化されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-240">All data sent by either side during the TLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="b3993-241">最後に、TLS セッションは、クライアントまたはサーバーのいずれかが終了することを選択した場合にのみ、正常に終了することができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-241">Finally, a TLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="b3993-242">打ち切られたセッションは、セキュリティ違反と見なされます (攻撃者が、送信されているすべてのデータが受信されないようにしている可能性があるため)。そのため、どちらかがセッションを終了したいときに、CloseNotify アラートという特別な通知が送信されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-242">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="b3993-243">セッションを正常に停止するには、クライアントとサーバーの両方で CloseNotify アラートを送信して処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-243">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![典型的な TLS ハンドシェイクの図。](media/image4.png)

<span data-ttu-id="b3993-245">図 3 - 典型的な TLS ハンドシェイク</span><span class="sxs-lookup"><span data-stu-id="b3993-245">Figure 3- Typical TLS handshake</span></span>

### <a name="tls-13-handshake"></a><span data-ttu-id="b3993-246">TLS 1.3 ハンドシェイク</span><span class="sxs-lookup"><span data-stu-id="b3993-246">TLS 1.3 Handshake</span></span>

<span data-ttu-id="b3993-247">Tls 1.3 では、TLS プロトコルがかなり大幅に見直されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-247">TLS 1.3 is a fairly major overhaul of the TLS protocol.</span></span> <span data-ttu-id="b3993-248">セキュリティとパフォーマンスを向上させるため、変更の大部分はハンドシェイクに加えられました。</span><span class="sxs-lookup"><span data-stu-id="b3993-248">The vast majority of the changes were made to the handshake to increase security and performance.</span></span> <span data-ttu-id="b3993-249">図 4 に典型的な TLS 1.3 ハンドシェイクを示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-249">A typical TLS 1.3 handshake is shown in Figure 4.</span></span> <span data-ttu-id="b3993-250">主な違いは、サーバーとクライアントとの間で行われるやり取りの回数に見られます。</span><span class="sxs-lookup"><span data-stu-id="b3993-250">The primary difference can be seen in the number of exchanges between the server and client.</span></span>

<span data-ttu-id="b3993-251">TLS 1.2 以前は、ハンドシェイクを終了する暗号化された Finished メッセージの送信前に、サーバーにより、2 つのフライト<sup>12</sup> メッセージ (最初に ServerHello、次に ChangeCipherSpec メッセージ) が送信されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-251">In TLS 1.2 and earlier, the server would send two flights<sup>12</sup> of messages – first the ServerHello and then a ChangeCipherSpec message before sending the encrypted Finished message that ends the handshake.</span></span> <span data-ttu-id="b3993-252">TLS 1.3 では、最初のフライト (ServerHello、拡張機能、証明書、Finished) で、サーバーによってすべてが送信されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-252">In TLS 1.3, the server sends everything in the first flight – ServerHello, extensions, certificate, and Finished.</span></span> <span data-ttu-id="b3993-253">ChangeCipherSpec メッセージはなくなって、サーバーでは、セッション キーが生成され、ServerHello の直後にハンドシェイク メッセージの暗号化が開始されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-253">The ChangeCipherSpec message was eliminated and the server generates its session keys and starts encrypting handshake messages immediately following the ServerHello.</span></span>

<span data-ttu-id="b3993-254">新しい取り決めは、TLS ハンドシェイクのより多くの部分が暗号化によって保護され、攻撃者がアクセスできるプレーンテキスト データの量が限定されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="b3993-254">The new arrangement means that more of the TLS handshake is protected by encryption, limiting the amount of plaintext data an attacker can access.</span></span> <span data-ttu-id="b3993-255">さらに、2 番目のサーバー フライト (ChangeCipherSpec とそれに続く Finished だけでした) をなくすことは、TLS クライアントがアプリケーション データの送信開始を待つ必要がなくなることを意味します。クライアントが独自の Finished メッセージを送信するとすぐにセッションが開始されるのです。</span><span class="sxs-lookup"><span data-stu-id="b3993-255">Additionally, the removal of the second server flight (which was just a ChangeCipherSpec followed by a Finished) means that a TLS client no longer needs to wait to start transmitting application data – as soon as the client sends its own Finished message the session is started.</span></span>

12. <span data-ttu-id="b3993-256">フライトは、グループ内で同時に送信される TLS メッセージの集まりにすぎません。</span><span class="sxs-lookup"><span data-stu-id="b3993-256">A flight is simply a collection of TLS messages sent simultaneously in a group.</span></span>

![TLS 1.3 ハンドシェイクの図。](media/image5.png)

<span data-ttu-id="b3993-258">図 4 - TLS 1.3 ハンドシェイクの図。</span><span class="sxs-lookup"><span data-stu-id="b3993-258">Figure 4 - TLS 1.3 Handshake</span></span>

> [!NOTE]
> <span data-ttu-id="b3993-259">*TLS 1.3 では、"早期データ" と 0-RTT (ラウンド トリップ時間ゼロ) の概念も導入されています。つまり、一部のアプリケーション データは、メッセージの初回フライトで送信できます。このオプション機能は、主に Web ブラウザーの応答性の最適化として追加されました (例: ページのレンダリングを開始するために初期に HTTP ヘッダーを送信する)。Azure RTOS 6.0 の時点では、この機能はサポートされていません。*</span><span class="sxs-lookup"><span data-stu-id="b3993-259">*TLS 1.3 also introduced the notion of "Early data" and 0-RTT (Zero Round Trip Time), meaning that some application data can be sent in the first flight of messages. This optional feature was added primarily as an optimization for web browser responsiveness (e.g. to send early HTTP headers to start rendering a page). As of Azure RTOS 6.0 this feature is NOT supported.*</span></span>

### <a name="initialization"></a><span data-ttu-id="b3993-260">初期化</span><span class="sxs-lookup"><span data-stu-id="b3993-260">Initialization</span></span>

<span data-ttu-id="b3993-261">NetX Secure TLS を使用する前に、NetX または NetXDuo の TCP/IP スタックを初期化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-261">The NetX or NetXDuo TCP/IP stack must be initialized prior to using NetX Secure TLS.</span></span> <span data-ttu-id="b3993-262">TCP/IP スタックを正しく初期化する方法については、NetX または NetXDuo のユーザー ガイドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-262">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack.</span></span>

<span data-ttu-id="b3993-263">NetX TCP/IP スタックが初期化されると、TLS を有効にできます。</span><span class="sxs-lookup"><span data-stu-id="b3993-263">Once the NetX TCP/IP stack has been initialized, TLS can be enabled.</span></span> <span data-ttu-id="b3993-264">内部的には、TLS ネットワークのトラフィックと処理はすべて NetX/NetXDuo スタックによって処理され、ユーザーの介入は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-264">Internally, all TLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="b3993-265">ただし TLS には、基になっているネットワーク スタックとは別に処理する必要がある特定の要件がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-265">However, TLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="b3993-266">これらのパラメーターは、_ *_nx_secure_tls_session_create_*\* サービスを使用して、\***NX_SECURE_TLS_SESSION** _ という名前の TLS コントロール ブロックに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b3993-266">These parameters are assigned to the TLS control block called ***NX_SECURE_TLS_SESSION** _ using the _ *_nx_secure_tls_session_create_** service.</span></span>

<span data-ttu-id="b3993-267">TLS には、Server と Client という 2 つのモードがあり、これらはどちらもアプリケーションで有効にできます (ただし、モードは NetX ソケットごとに 1 つだけです)。後で詳しく説明するように、それぞれ特定の要件があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-267">TLS has two modes, Server and Client, either of which may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

<span data-ttu-id="b3993-268">どちらのモードでも、NetX Secure TLS を使用するには、リモート ホストとの TCP 通信のために TCP ソケット (\***NX_TCP_SOCKET** _) を作成して設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-268">In either mode, NetX Secure TLS requires a TCP socket (\***NX_TCP_SOCKET** _) to be created and set up for TCP communications with the remote host.</span></span> <span data-ttu-id="b3993-269">後で詳しく説明するように、TCP ソケットは、_ *_nx_secure_tls_session_start_*\* サービスを使用して TLS セッション インスタンスに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b3993-269">The TCP socket is assigned to a TLS session instance with the _ *_nx_secure_tls_session_start_*\* service, detailed below.</span></span>

### <a name="initialization--tls-server"></a><span data-ttu-id="b3993-270">初期化 – TLS サーバー</span><span class="sxs-lookup"><span data-stu-id="b3993-270">Initialization – TLS Server</span></span>

<span data-ttu-id="b3993-271">NetX Secure の TLS Server モードでは、TCP ソケットに加えて、"*デジタル証明書*" (接続している TLS クライアントに対して TLS サーバーを識別するために使用されるドキュメント) と、"*秘密キー*" に対応する証明書 (通常は RSA 暗号化アルゴリズム用) が必要となります。</span><span class="sxs-lookup"><span data-stu-id="b3993-271">In addition to a TCP socket, NetX Secure TLS Server mode requires a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="b3993-272">ITU (国際電気通信連合) X.509 標準では TLS によって使用される証明書の形式が規定されており、X.509 デジタル証明書を作成するためのユーティリティは多数存在します。</span><span class="sxs-lookup"><span data-stu-id="b3993-272">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="b3993-273">NetX Secure TLS の場合、X.509 証明書は、ASN.1 の Distinguished Encoding Rules (DER) 形式を使用してバイナリ エンコードされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-273">For NetX Secure TLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="b3993-274">DER は、証明書の標準的な TLS ネットワーク転送のバイナリ形式です。</span><span class="sxs-lookup"><span data-stu-id="b3993-274">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="b3993-275">指定された証明書に関連付けられている秘密キーは、DER でエンコードされた PKCS#1 形式である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-275">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="b3993-276">秘密キーはデバイスでのみ使用され、ネットワーク経由で送信されることはありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-276">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="b3993-277">秘密キーは TLS 通信にセキュリティを提供するものなので、安全に保管してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-277">Keep private keys safe as they provide the security for TLS communications!</span></span>

<span data-ttu-id="b3993-278">TLS Server 証明書を初期化するには、アプリケーションで、DER でエンコードされた X.509 証明書とオプションの DER でエンコードされた PKCS#1 RSA 秘密キー データを含むバッファーへのポインターを、***nx_secure_x509_certificate_intialize** _ サービスを使用して提供する必要があります。このサービスにより、TLS で使用する適切な証明書データが、_ *NX_SECURE_X509_CERT** 構造体に格納されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-278">To initialize the TLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="b3993-279">サーバー証明書が初期化されたら、それを TLS 制御ブロックに、***nx_secure_tls_local_certificate_add*** サービスを使用して追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-279">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_tls_local_certificate_add*** service.</span></span>

<span data-ttu-id="b3993-280">サーバーの証明書が TLS 制御ブロックに追加されたら、ソケットを使用して、セキュリティで保護された TLS サーバー接続を確立できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-280">Once the server's certificate has been added to the TLS control block, the socket may be used to establish a secure TLS Server connection.</span></span>

### <a name="initialization--tls-client"></a><span data-ttu-id="b3993-281">初期化 – TLS クライアント</span><span class="sxs-lookup"><span data-stu-id="b3993-281">Initialization – TLS Client</span></span>

<span data-ttu-id="b3993-282">NetX Secure TLS Client モードを使用するには、信頼された証明機関 (CA) からの、X.509 でエンコードされたデジタル証明書のコレクションである "*信頼された証明書ストア*" が必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-282">NetX Secure TLS Client mode requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA's).</span></span> <span data-ttu-id="b3993-283">TLS プロトコルでは、これらの証明書は "信頼されている" と想定され、TLS サーバー エンティティによって NetX Secure TLS クライアントに提供される証明書を認証するための基盤として機能します。</span><span class="sxs-lookup"><span data-stu-id="b3993-283">These certificates are assumed by the TLS protocol to be "trusted" and serve as the basis for authenticating certificates provided by TLS server entities to NetX Secure TLS Client.</span></span>

<span data-ttu-id="b3993-284">信頼された CA 証明書は、"*自己署名*" されているか、別の CA によって署名されているかのいずれかです。後者の場合、その証明書は "*中間 CA*" (ICA) と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="b3993-284">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="b3993-285">一般的な TLS アプリケーションでは、サーバーにより、サーバー証明書と一緒に ICA 証明書が提供されますが、認証成功の唯一の要件は、発行者のチェーン (他の証明書の署名に使用された証明書) を、そのサーバー証明書から、信頼された証明書ストア内の信頼された CA 証明書まで追跡できることです。</span><span class="sxs-lookup"><span data-stu-id="b3993-285">In a typical TLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="b3993-286">このチェーンは、"*信頼のチェーン*" または "*証明書チェーン*" と呼ばれています。</span><span class="sxs-lookup"><span data-stu-id="b3993-286">This chain is known as a  *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="b3993-287">信頼された CA または ICA 証明書を初期化するには、アプリケーションで、DER でエンコードされた X.509 証明書を含むバッファーへのポインターを ***nx_secure_x509_certificate_intialize** _ サービスを使用して提供する必要があります。このサービスにより、TLS で使用する適切な証明書データが、_ *NX_SECURE_X509_CERT** 構造体に格納されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-287">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="b3993-288">初期化した信頼された証明書は、次に、***nx_secure_tls_trusted_certificate_add*** サービスを使用して TLS 制御ブロックに追加されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-288">Trusted certificates that have been initialized are then added to the TLS control block using the ***nx_secure_tls_trusted_certificate_add*** service.</span></span> <span data-ttu-id="b3993-289">証明書を追加しないと、TLS プロトコルでリモートの TLS サーバー ホストを認証する手段がなくなるため、TLS クライアント セッションが失敗します。</span><span class="sxs-lookup"><span data-stu-id="b3993-289">Failure to add a certificate will cause the TLS Client session to fail as there will be no way for the TLS protocol to authenticate remote TLS server hosts.</span></span>

<span data-ttu-id="b3993-290">TLS クライアントには、受信するサーバー証明書を割り当てるための領域も必要です (事前共有キー モードが使用されていない場合)。</span><span class="sxs-lookup"><span data-stu-id="b3993-290">The TLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used).</span></span> <span data-ttu-id="b3993-291">NetX Secure TLS 5.12 以降、アプリケーションでリモート証明書の領域を割り当てる必要はなくなりました。</span><span class="sxs-lookup"><span data-stu-id="b3993-291">As of NetX Secure TLS 5.12, it is no longer necessary for the application to allocate space for remote certificate.</span></span> <span data-ttu-id="b3993-292">ただし、サーバー証明書に領域を割り当てる従来のオプションは引き続き使用可能で、ユーザーが割り当てた証明書は、内部証明書バッファー最適化 <sup>13</sup> の前に使用されます。詳細については、***nx_secure_tls_remote_certificate_allocate*** サービスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-292">However, the legacy option to allocate space for a server certificate is still available and user-allocated certificates will be used before the internal certificate buffer optimization <sup>13</sup> – see the ***nx_secure_tls_remote_certificate_allocate*** service for more information.</span></span>

<span data-ttu-id="b3993-293">信頼された証明書ストアが作成され、サーバー証明書用の領域が割り当てられたら、ソケットを使用して、セキュリティで保護された TLS クライアント接続を確立することができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-293">Once the Trusted Certificate Store has been created and space for the server certificate has been allocated, the socket may be used to establish a secure TLS Client connection.</span></span>

13. <span data-ttu-id="b3993-294">最適化では、以前のバージョンの NetX Secure TLS で使用されていたユーザー指定の構造体を使用する代わりに、*nx_secure_tls_session_packet_buffer_set* を使用してユーザー アプリケーションから tls セッションに提供される "パケット バッファー" を利用して X.509 解析構造体を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="b3993-294">The optimization utilizes the “packet buffer” supplied by the user application to the tls session using *nx_secure_tls_session_packet_buffer_set* to allocate the X.509 parsing structures instead of using the user-supplied structures used in earlier versions of NetX Secure TLS.</span></span> <span data-ttu-id="b3993-295">パケット バッファーのサイズを超える証明書チェーンが使われる可能性はほとんどありません。その場合、パケット バッファー サイズを大きくするか、*nx_secure_tls _remote_certificate_allocate* を使用して証明書チェーン用の領域を割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-295">There is an unlikely possibility of encountering a certificate chain exceeding the size of the packet buffer in which case either the packet buffer size may be increased or *nx_secure_tls _remote_certificate_allocate* may be used to allocate more space for the certificate chain.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="b3993-296">アプリケーション インターフェイスの呼び出し</span><span class="sxs-lookup"><span data-stu-id="b3993-296">Application Interface Calls</span></span>

<span data-ttu-id="b3993-297">NetX Secure TLS アプリケーションでは、通常、ThreadX RTOS で実行されているアプリケーション スレッド内から関数呼び出しを行います。</span><span class="sxs-lookup"><span data-stu-id="b3993-297">NetX Secure TLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="b3993-298">一部の初期化、特に基盤となっているネットワーク通信プロトコル (TCP や IP など) については、***tx_application_define*** から呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="b3993-298">Some initialization, particularly for the underlying network communications protocols (e.g. TCP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="b3993-299">ネットワーク通信の初期化の詳細については、NetX または NetXDuo のユーザー ガイドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-299">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="b3993-300">TLS では、プロセッサを集中的に使用する操作である暗号化ルーチンが多用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-300">TLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="b3993-301">一般に、これらの操作は、呼び出し元スレッドのコンテキスト内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-301">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="tls-session-start"></a><span data-ttu-id="b3993-302">TLS セッションの開始</span><span class="sxs-lookup"><span data-stu-id="b3993-302">TLS Session Start</span></span>

<span data-ttu-id="b3993-303">TLS には、機能させるための基になるトランスポート層ネットワーク プロトコルが必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-303">TLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="b3993-304">一般的に使用されるプロトコルは TCP です。</span><span class="sxs-lookup"><span data-stu-id="b3993-304">The protocol typically used is TCP.</span></span> <span data-ttu-id="b3993-305">NetX Secure TLS セッションを確立するには、NetX/NetXDuo TCP API を使用して TCP 接続を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-305">In order to establish a NetX Secure TLS session, a TCP connection must be established using the NetX/NetXDuo TCP API.</span></span> <span data-ttu-id="b3993-306">**NX_TCP_SOCKET** を作成し、接続の確立には、**_nx_tcp_server_socket_listen_ *_ および _* _nx_tcp_server_socket_accept_ *_ サービス (TLS サーバーの場合)、または _* _nx_tcp_client_socket_connect_** サービス (TLS クライアントの場合) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-306">An **NX_TCP_SOCKET** must be created and a connection established using the **_nx_tcp_server_socket_listen_*_ and _*_nx_tcp_server_socket_accept_*_ services (for TLS Server) or the _*_nx_tcp_client_socket_connect_** service (for TLS Client).</span></span>

<span data-ttu-id="b3993-307">TCP 接続が確立されると、次に TCP ソケットが ***nx_secure_tls_session_start*** サービスに渡されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-307">Once a TCP connection has been established, the TCP socket is then passed to the ***nx_secure_tls_session_start*** service.</span></span>

### <a name="tls-packet-allocation"></a><span data-ttu-id="b3993-308">TLS パケットの割り当て</span><span class="sxs-lookup"><span data-stu-id="b3993-308">TLS Packet Allocation</span></span>

<span data-ttu-id="b3993-309">NetX Secure TLS では、NetX/NetXDuo TCP (***NX_PACKET** _) と同じパケット構造が使用されますが、TLS ヘッダーの領域が適切に割り当てられるように、_*_nx_packet_allocate_*_ サービスを呼び出すのではなく、_ *_nx_secure_tls_packet_allocate_** サービスを呼び出す必要がある点が異なります。</span><span class="sxs-lookup"><span data-stu-id="b3993-309">NetX Secure TLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_tls_packet_allocate_** service must be called so that space for the TLS header may be allocated properly.</span></span>

### <a name="tls-session-send"></a><span data-ttu-id="b3993-310">TLS セッションでの送信</span><span class="sxs-lookup"><span data-stu-id="b3993-310">TLS Session Send</span></span>

<span data-ttu-id="b3993-311">TLS セッションが開始されたら、アプリケーションでは \***nx_secure_tls_session_send** _ サービスを使用してデータを送信することができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-311">Once the TLS session has started, the application may send data using the \***nx_secure_tls_session_send** _ service.</span></span> <span data-ttu-id="b3993-312">送信サービスは、使用の点では _*_nx_tcp_socket_send_*_ サービスと同様です。送信されるデータが格納されている _*_NX_PACKET_*_ データ構造を受け取り、そのデータだけが送信前に NX Secure TLS スタックによって暗号化されます。また、_*_nx_secure_tls_packet_allocate_*\* を使用してパケットの割り当てが行われる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-312">The send service is identical in use to the _*_nx_tcp_socket_send_*_ service, taking an _*_NX_PACKET_*_ data structure containing the data being sent, only that data will be encrypted by the NX Secure TLS stack before being sent, and the packet must be allocated using _\*_nx_secure_tls_packet_allocate_\*\*.</span></span>

### <a name="tls-session-receive"></a><span data-ttu-id="b3993-313">TLS セッションでの受信</span><span class="sxs-lookup"><span data-stu-id="b3993-313">TLS Session Receive</span></span>

<span data-ttu-id="b3993-314">TLS セッションが開始されたら、アプリケーションでは \***nx_secure_tls_session_receive** _ サービスを使用してデータの受信を開始できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-314">Once the TLS session has started, the application may begin receiving data using the \***nx_secure_tls_session_receive** _ service.</span></span> <span data-ttu-id="b3993-315">TLS セッションでの送信と同様に、このサービスは使用の点では _*_nx_tcp_socket_receive_*\* と同様ですが、受信データは、パケット構造で返される前に、TLS スタックによる解読と検証が行われる点が異なります。</span><span class="sxs-lookup"><span data-stu-id="b3993-315">Like the TLS Session send, this service is identical in use to _\*_nx_tcp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the TLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="b3993-316">TLS セッションの終了</span><span class="sxs-lookup"><span data-stu-id="b3993-316">TLS Session Close</span></span>

<span data-ttu-id="b3993-317">TLS セッションが完了したら、TLS のクライアントとサーバーの両方で他方に CloseNotify アラートを送信し、セッションを停止する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-317">Once a TLS session is complete, both the TLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="b3993-318">セッションが正常に停止されるようにするには、双方でアラートを受信して処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-318">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="b3993-319">リモート ホストから CloseNotify アラートが送信されると、そのアラートは、***nx_secure_tls_session_receive** _ サービスへの呼び出しによって処理され、対応するアラートがリモート ホストに返信され、値 _*_NX_SECURE_TLS_SESSION_CLOSED_\*\* が返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-319">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_tls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="b3993-320">セッションが終了すると、それ以降は、その TLS セッションを使用してデータの送受信を試みるとすべて失敗します。</span><span class="sxs-lookup"><span data-stu-id="b3993-320">Once the session is closed, any further attempts to send or receive data with that TLS session will fail.</span></span>

<span data-ttu-id="b3993-321">アプリケーションで TLS セッションを終了する場合は、\***nx_secure_tls_session_end** _ サービスを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-321">If the application wishes to close the TLS session, the \***nx_secure_tls_session_end** _ service must be called.</span></span> <span data-ttu-id="b3993-322">このサービスによって CloseNotify アラートが送信され、応答の CloseNotify が処理されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-322">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="b3993-323">応答が受信されない場合は、TLS セッションが正常に停止されなかったこと (セキュリティ侵害の可能性があります) を示すエラー値 _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* が返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-323">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the TLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tls-alerts"></a><span data-ttu-id="b3993-324">TLS アラート</span><span class="sxs-lookup"><span data-stu-id="b3993-324">TLS Alerts</span></span>

<span data-ttu-id="b3993-325">TLS は最大限のセキュリティを提供するように設計されています。そのため、プロトコルでの誤った動作は、潜在的なセキュリティ侵害と見なされます。</span><span class="sxs-lookup"><span data-stu-id="b3993-325">TLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="b3993-326">このため、メッセージの処理や暗号化と解読におけるすべてのエラーが、ハンドシェイクまたはセッションを直ちに終了させる致命的エラーと見なされます。</span><span class="sxs-lookup"><span data-stu-id="b3993-326">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="b3993-327">ローカル アプリケーションでのエラー処理は比較的簡単ですが、リモート ホストでは、状況を適切に処理し、さらなるセキュリティ違反の可能性を回避するために、エラーが発生したことを認識する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-327">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="b3993-328">このため TLS では、エラー発生時にはリモート ホストに、"*アラート*" メッセージが送信されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-328">For this reason, TLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="b3993-329">送信されたアラートの種類を参考にして攻撃者が情報を収集できないようにするため、アラートはセッション中に、他の TLS メッセージと同じ方法で扱われ、暗号化されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-329">Alerts are treated in the same manner as any other TLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="b3993-330">ハンドシェイク時には、潜在的な攻撃者によって取得される可能性がある情報の量を限定するため、送信されるアラートはスコープ内に制限されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-330">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="b3993-331">TLS セッションを閉じるために使用される CloseNotify アラートは、致命的ではない唯一のアラートです。</span><span class="sxs-lookup"><span data-stu-id="b3993-331">The CloseNotify alert, used to close the TLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="b3993-332">これはアラートと見なされて、アラート メッセージとして送信されますが、エラーが発生したことを示さないという点で、CloseNotify は他のアラートとは異なっています。</span><span class="sxs-lookup"><span data-stu-id="b3993-332">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

<span data-ttu-id="b3993-333">アラートの値と "レベル" は、TLS の RFC で定義されており、発生したエラーの種類を示します (レベルは "警告" と "致命的" で、ほとんどの TLS アラートは "致命的" です)。</span><span class="sxs-lookup"><span data-stu-id="b3993-333">The alert value and "level" (levels are "warning" and "fatal" – most TLS alerts are "fatal") are defined in the TLS RFCs and indicate the type of error that occurred.</span></span> <span data-ttu-id="b3993-334">CloseNotify 以外のほとんどの TLS アラートは、潜在的なセキュリティの問題を示していると考えることができ、TLS セッションやハンドシェイクは中止されることになります。</span><span class="sxs-lookup"><span data-stu-id="b3993-334">Most TLS Alerts other than CloseNotify can be considered an indication of a potential security issue and will result in the TLS session or handshake being aborted.</span></span> <span data-ttu-id="b3993-335">TLS API 呼び出しによって **NX_SECURE_TLS_ALERT_RECEIVED** (0x114) が返された場合、API サービス **_nx_secure_tls_session_alert_value_get_** (NetX Secure TLS バージョン 5.12 の新機能) を使用すると、セキュリティ問題への対処に関する決定のためにアプリケーションで利用するため、TLS のアラート値とレベルを取得できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-335">If any TLS API call returns **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), the API service **_nx_secure_tls_session_alert_value_get_** (new in NetX Secure TLS version 5.12) may be used to retrieve the TLS alert value and level for the application to use for any decisions regarding responses to security issues.</span></span> <span data-ttu-id="b3993-336">ほとんどの場合、リモート ホストから受信した CloseNotify 以外のアラートはすべて、いくつかの例外はありますが、致命的なエラーと見なす必要があります。詳細については、TLS の RFC を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-336">In most cases, any alert received from the remote host other than CloseNotify should be considered a fatal error, though there are some excptions – see the TLS RFCs for more information.</span></span>

### <a name="tls-session-renegotiation"></a><span data-ttu-id="b3993-337">TLS セッションの再ネゴシエーション</span><span class="sxs-lookup"><span data-stu-id="b3993-337">TLS Session Renegotiation</span></span>

<span data-ttu-id="b3993-338">TLS では、"再ネゴシエーション" の概念がサポートされています。これは単純に、既存の TLS セッションのコンテキスト内で TLS セッション パラメーターを再ネゴシエーションすることです。</span><span class="sxs-lookup"><span data-stu-id="b3993-338">TLS supports the notion of "renegotiation" which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span> <span data-ttu-id="b3993-339">これは、実際には、既存のセッションを使用して新しいハンドシェイク メッセージの暗号化と認証が行われることを意味します。</span><span class="sxs-lookup"><span data-stu-id="b3993-339">What this means in practice is that the new handshake messages are encrypted and authenticated using the existing session.</span></span> <span data-ttu-id="b3993-340">再ネゴシエーションは、TLS ホストで、新しいセッション パラメーターを生成したい場合に使用されます (新しい TLS セッションキーを生成するなど)。既存のセッションを完了する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-340">Renegotiation is used when a TLS host wants to generate new session parameters (e.g. generate new TLS session keys) without having to complete the existing session.</span></span> <span data-ttu-id="b3993-341">たとえば、アプリケーションのセキュリティ ポリシーで、セッション キーは限られた時間のみ使用されると規定されていても、その時間を超えて TLS セッションがアクティブな状態に留まる場合には、再ネゴシエーションが望ましい可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-341">For example, renegotiation may be desirable when security policies for an application dictate that session keys are only used for a limited time but a TLS session remains active beyond that time.</span></span>

<span data-ttu-id="b3993-342">セッションの再ネゴシエーションに関する問題の 1 つは、それによって特定の中間者攻撃に対して TLS が脆弱になることです。攻撃者がサーバーに新しいパラメーターで再ネゴシエーションを開始させることで、TLS セッションを乗っ取れるようにするといった攻撃です。</span><span class="sxs-lookup"><span data-stu-id="b3993-342">One issue with session renegotiation is that is makes TLS vulnerable to a specific Man-in-the-Middle attack where an attacker can convince a server to initiate a renegotiation with new parameters, thus allowing the attacker to hijack the TLS session.</span></span> <span data-ttu-id="b3993-343">この問題を軽減するため、Secure Renegotiation Indication 拡張機能が導入されました ("**エラー! 参照元が見つかりません**" に関する</span><span class="sxs-lookup"><span data-stu-id="b3993-343">To mitigate this issue, the Secure Renegotiation Indication extension was introduced (see section **Error! Reference source not found.**</span></span> <span data-ttu-id="b3993-344">セクションを参照)。</span><span class="sxs-lookup"><span data-stu-id="b3993-344">section).</span></span>

<span data-ttu-id="b3993-345">NetX Secure TLS では、セッションの再ネゴシエーションと、Secure Renegotiation Indication 拡張機能が完全にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b3993-345">NetX Secure TLS completely supports session renegotiation and the Secure Renegotiation Indication extension.</span></span>

<span data-ttu-id="b3993-346">リモート ホストからデータを受信すると、再ネゴシエーション (と拡張機能) は、アプリケーションとの相互作用なしで自動的に処理されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-346">When receiving data from a remote host, renegotations (and the extension) are handled automatically without application interaction.</span></span> <span data-ttu-id="b3993-347">セッションの再ネゴシエーションに関する通知が必要な場合は、*nx_secure_tls_session_renegotiate_callback_set* サービスで、再ネゴシエーションのコールバックが提供されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-347">If notification about session renegotiations is desired, a renegotiation callback may be supplied with the *nx_secure_tls_session_renegotiate_callback_set* service.</span></span> <span data-ttu-id="b3993-348">リモート ホストによって再ネゴシエーションが要求されるたびにこのコールバックが呼び出され、必要に応じてアプリケーションでアクションを起こすことができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-348">The callback will be invoked whenever a renegotiation is requested by the remote host, allowing the application to take action if desired.</span></span>

<span data-ttu-id="b3993-349">アクティブな TLS セッションから再ネゴシエーションを開始するには、目的の TLS セッションで、*nx_secure_tls_session_renegotiate* サービスを呼び出すだけです。</span><span class="sxs-lookup"><span data-stu-id="b3993-349">To initiate a renegotiation from an active TLS session, simply invoke the *nx_secure_tls_session_renegotiate* service on the desired TLS session.</span></span>

### <a name="tls-session-resumption"></a><span data-ttu-id="b3993-350">TLS セッションの再開</span><span class="sxs-lookup"><span data-stu-id="b3993-350">TLS Session Resumption</span></span>

<span data-ttu-id="b3993-351">いくつかの類似点はありますが、TLS セッションの再開を、セッションの再ネゴシエーションと混同しないでください。</span><span class="sxs-lookup"><span data-stu-id="b3993-351">TLS session resumption should not be confused with session renegotiation, despite some similarities.</span></span> <span data-ttu-id="b3993-352">セッションの "*再ネゴシエーション*" では、既存の TLS セッション内で新しいハンドシェイクが開始されます。セッションの "*再開*" は、完全な TLS ハンドシェイクを実行せずに閉じられた TLS セッションの再開を伴う、純粋にオプションの機能です。</span><span class="sxs-lookup"><span data-stu-id="b3993-352">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span> <span data-ttu-id="b3993-353">これを実現するために、TLS の実装では、セッションのパラメーターとキーをキャッシュして、それらを元のハンドシェイクで提供された一意の識別子である "*セッション ID*" に関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-353">To achieve this, a TLS implementation may cache the session parameters and keys, associating them with a *session ID,* a unique identifier supplied in the original handshake.</span></span> <span data-ttu-id="b3993-354">クライアントは、TLS サーバーに対してセッション ID を提供することによって、ホスト間の以前の TLS セッションが過去に存在し、完了したこと、また、簡略化したハンドシェイクでセッションを再確立するための状態が、まだクライアントに保持されていることを示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-354">By supplying a session ID to a TLS server, a client indicates that a previous TLS session between the hosts existed and completed some time in the past, and that the client still possesses the state to re-establish the session with a reduced handshake.</span></span> <span data-ttu-id="b3993-355">セッション キーは、理論的には依然として秘密であり、通信している 2 つのホストのみに認識されるため、サーバーは新しい TLS セッションを開始し、通常のハンドシェイクのほとんどをバイパスできます。</span><span class="sxs-lookup"><span data-stu-id="b3993-355">Since the session keys are theoretically still secret and only known by the two communicating host, the server can start a new TLS session and bypass most of the normal handshake.</span></span>

<span data-ttu-id="b3993-356">セッションの再開は、キー生成マスター シークレットを共有し、証明書の署名を検証するために使用される、コストが高い場合がある公開キー操作を回避するのに役立ちますが、セッション パラメーター、キー、暗号化の状態を、考えられるすべてのセッションについて (少なくとも構成可能な時間枠の間は) メモリ内に保持する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-356">Session resumption can be useful to avoid the potentially expensive public-key operations used to share the key generation master secret and verify certificate signatures, but it also requires that the session parameters, keys, and crypotgraphic state be maintained in memory for all possible sessions (at least for a configurable time window).</span></span>

<span data-ttu-id="b3993-357">現在のバージョンの NetX Secure TLS では、セッションの再開はサポートされていません。セッション ID は TLS サーバーによって無視されるだけで、TLS クライアントは常に NULL のセッション ID を指定します。これにより、サーバーは完全なハンドシェイクを実行するように求められます。</span><span class="sxs-lookup"><span data-stu-id="b3993-357">The current version of NetX Secure TLS does not support session resumption – the session ID is simply ignored by TLS servers and TLS clients always supply a NULL session ID which prompts the server to perform a complete handshake.</span></span> <span data-ttu-id="b3993-358">セッション再開は完全にオプション機能であり、すべての TLS 実装では、セッション ID が NULL であるか認識できない場合は既定で完全なハンドシェイクを行う必要があるため、この機能が無ければ相互運用性の問題は発生しないはずです。</span><span class="sxs-lookup"><span data-stu-id="b3993-358">The lack of session resumption should cause no inter-operability issues as it is a completely optional feature and all TLS implementations must default to a complete handshake should the session ID be NULL or unrecognized.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="b3993-359">プロトコルのレイヤー化</span><span class="sxs-lookup"><span data-stu-id="b3993-359">Protocol Layering</span></span>

<span data-ttu-id="b3993-360">TLS プロトコルは、トランスポート層 (TCP など) とアプリケーション層の間のネットワーク スタックに属します。</span><span class="sxs-lookup"><span data-stu-id="b3993-360">The TLS protocol fits into the networking stack between the transport layer (e.g. TCP) and the application layer.</span></span> <span data-ttu-id="b3993-361">TLS は、トランスポート層のプロトコル (したがって、"*トランスポート層*" のセキュリティ) と見なされることがありますが、基盤となっているネットワーク プロトコル (TCP など) に関してはアプリケーションとして機能するため、アプリケーション層にグループ化されることもあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-361">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols (such as TCP) it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="b3993-362">TLS には、TCP などの、順番どおりで無損失の配信をサポートするトランスポート層プロトコルが必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-362">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="b3993-363">この要件のために、TLS を UDP 上で実行することはできません。UDP ではデータグラムの配信が保証されないためです。</span><span class="sxs-lookup"><span data-stu-id="b3993-363">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="b3993-364">*DTLS* と呼ばれる別のプロトコルは、TLS の変更されたバージョンであり、UDP などのデータグラム プロトコル上で TLS のセキュリティを必要とするアプリケーションに使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-364">A separate protocol called *DTLS,* which is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span> <span data-ttu-id="b3993-365">NetX Secure では DTLS がサポートされていますが、DTLS のドキュメントは、このドキュメントとは別個のものです。</span><span class="sxs-lookup"><span data-stu-id="b3993-365">NetX Secure supports DTLS, but documentation for DTLS is separate from this document.</span></span>

![TCP/IP および TLS プロトコル層の図。](media/image6.png)

<span data-ttu-id="b3993-367">図 5 - TCP/IP および TLS プロトコル層の図。</span><span class="sxs-lookup"><span data-stu-id="b3993-367">Figure 5- TCP/IP and TLS protocol layers</span></span>

## <a name="network-communications-security"></a><span data-ttu-id="b3993-368">ネットワーク通信のセキュリティ</span><span class="sxs-lookup"><span data-stu-id="b3993-368">Network Communications Security</span></span>

<span data-ttu-id="b3993-369">パブリック ネットワークとインターネットを介した通信をセキュリティで保護することは、非常に重要なトピックであり、膨大な数の書籍、記事、ソリューションの対象となっています。</span><span class="sxs-lookup"><span data-stu-id="b3993-369">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="b3993-370">このテーマは信じがたいほど複雑ですが、意図したターゲットだけが情報へのアクセスや変更を行えるようにネットワーク経由でその情報を送信する、という単純な考え方にまとめることができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-370">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="b3993-371">これは、機密性、整合性、認証の 3 つの重要な概念に分類されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-371">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="b3993-372">TLS プロトコルでは、3 つすべてに対する解決策が提供されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-372">The TLS protocol provides solutions for all three.</span></span>

### <a name="secrecy"></a><span data-ttu-id="b3993-373">機密性</span><span class="sxs-lookup"><span data-stu-id="b3993-373">Secrecy</span></span>

<span data-ttu-id="b3993-374">ネットワーク経由でのデータ送信時には、多くの場合、悪意のあるエンティティがデータを取得できないことが重要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-374">When sending data over a network, it is often important that the data cannot be obtained by a malicious entity.</span></span> <span data-ttu-id="b3993-375">データが TCP/IP 接続を介して送信される場合、そのネットワークにアクセスできる誰もが、容易に入手できるネットワーク ツールを使用してそのデータを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-375">If data is sent over a TCP/IP connection, anyone with access to the network will be able to read that data using easily-available networking tools.</span></span> <span data-ttu-id="b3993-376">データが取得されないようにするには、意図したターゲット以外は読み取れないようにデータをエンコードする必要があります。これが "*機密性*" です。</span><span class="sxs-lookup"><span data-stu-id="b3993-376">To prevent that data from being obtained, it must be encoded such that it cannot be read except by the intended target – this is *secrecy.*</span></span> <span data-ttu-id="b3993-377">TLS では、RSA や AES などの暗号化アルゴリズムによって、機密性が提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-377">In TLS, encryption algorithms such as RSA and AES provide secrecy.</span></span>

### <a name="integrity"></a><span data-ttu-id="b3993-378">整合性</span><span class="sxs-lookup"><span data-stu-id="b3993-378">Integrity</span></span>

<span data-ttu-id="b3993-379">ネットワーク上を移動するデータを保護するためには、機密性では十分ではない場合があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-379">Sometimes, secrecy is not enough to protect data travelling over a network.</span></span> <span data-ttu-id="b3993-380">場合によっては、悪意のあるエンティティにより、TCP パケットの内容が変更される可能性があります。そのパケットに含まれる内容を知る必要はないのです。</span><span class="sxs-lookup"><span data-stu-id="b3993-380">In some cases, it may be possible for a malicious entity to alter the contents of a TCP packet without needing to know what that packet contains.</span></span> <span data-ttu-id="b3993-381">暗号化されたデータの変更は可能であり、解読を無効にしたり、攻撃者が実現したいと考えている何らかの結果になるようにメッセージのパラメーターを変更したりするのです。</span><span class="sxs-lookup"><span data-stu-id="b3993-381">Encrypted data can be altered, rendering the decryption invalid or changing the parameters of the message leading to whatever result the attacker may be interested in achieving.</span></span> <span data-ttu-id="b3993-382">ネットワーク上では、攻撃者が転送中のデータを変更することを防止できませんが、データが変更されたかどうかを知るためのメカニズムは提供できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-382">On the network, we cannot prevent an attacker from changing data in transit, but we can provide a mechanism to know whether or not the data has been changed.</span></span> <span data-ttu-id="b3993-383">データが転送中に変更されたら、そのことが認識されて、データを拒否することができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-383">When data is changed in transit, it will be known and the data can be rejected.</span></span> <span data-ttu-id="b3993-384">この概念が "*整合性*" です。</span><span class="sxs-lookup"><span data-stu-id="b3993-384">This concept is *integrity*.</span></span> <span data-ttu-id="b3993-385">TLS では、整合性は "*ハッシュ関数*" と呼ばれる暗号化ルーチンのクラスによって提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-385">In TLS, integrity is provided by a class of cryptographic routines known as *hash functions*.</span></span> <span data-ttu-id="b3993-386">ハッシュ関数の例としては、MD5 や SHA-1 が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="b3993-386">Some examples of hash functions are MD5 and SHA-1.</span></span>

### <a name="authentication"></a><span data-ttu-id="b3993-387">認証</span><span class="sxs-lookup"><span data-stu-id="b3993-387">Authentication</span></span>

<span data-ttu-id="b3993-388">ネットワーク通信のセキュリティにおける 3 つ目の重要な概念は、データは意図したターゲットにのみ伝達される必要があるという考え方です。</span><span class="sxs-lookup"><span data-stu-id="b3993-388">The third important concept in network communications security is the idea that data should only be communicated to the intended target.</span></span> <span data-ttu-id="b3993-389">攻撃者は、別のホストに向けたデータを受信するために、正当なエンティティに見せかけようとする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-389">An attacker may attempt to pose as a legitimate entity to receive data intended for another host.</span></span> <span data-ttu-id="b3993-390">機密性と整合性のメカニズムを使用してデータが送信されている場合であっても、攻撃者はまだ、この策略を通して、望む結果 (セキュリティで保護された通信の侵害) を実現できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-390">Even if the data is being sent with secrecy and integrity mechanisms in place, the attacker may still be able to achieve the desired result (a compromise of secure communications) through this deception.</span></span> <span data-ttu-id="b3993-391">これを防ぐには、機密データが送信される前に、リモート ホストの ID を証明するためのメカニズムが必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-391">To prevent this, a mechanism is needed to prove the identity of a remote host before any sensitive data is sent.</span></span> <span data-ttu-id="b3993-392">リモート ホストの ID を証明するプロセスが "*認証*" です。</span><span class="sxs-lookup"><span data-stu-id="b3993-392">The process of proving the identity of a remote host is *authentication.*</span></span> <span data-ttu-id="b3993-393">TLS では、デジタル証明書、ハッシュ関数、公開キー暗号化の特性を利用する "*デジタル署名*" と呼ばれるメカニズムを使用して認証が提供されます (後述)。</span><span class="sxs-lookup"><span data-stu-id="b3993-393">In TLS, authentication is provided using digital certificates, hash functions, and a mechanism called *digital signatures* which utilizes a property of public-key encryption (described below).</span></span> <span data-ttu-id="b3993-394">*事前共有キー* (PSK) を使用して、限定的であっても便利な認証の形式を提供することもできます。</span><span class="sxs-lookup"><span data-stu-id="b3993-394">A limited but useful form of authentication can also be provided with a *pre-shared key* (PSK).</span></span>

## <a name="tls-encryption"></a><span data-ttu-id="b3993-395">TLS 暗号化</span><span class="sxs-lookup"><span data-stu-id="b3993-395">TLS Encryption</span></span>

<span data-ttu-id="b3993-396">TLS プロトコルは、暗号化を利用してインターネット上で、セキュリティで保護されたネットワーク通信を提供するためのフレームワークです。</span><span class="sxs-lookup"><span data-stu-id="b3993-396">The TLS protocol is a framework for providing secure network communications over the Internet utilizing encryption.</span></span> <span data-ttu-id="b3993-397">暗号化は、一般に、元のデータ (またはそのデータに関する情報) を入手することが、"*キー*" なしでは極めて困難であるような方法でデータをエンコードするプロセスとして定義されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-397">Encryption is generally defined as the process of encoding data in such a way that obtaining the original data (or information about that data) is exceedingly difficult without a *key*.</span></span> <span data-ttu-id="b3993-398">コンピューター システムの暗号化は、有限フィールドなどの複雑な数学に基づいており、"*秘密キー*" (または "*対称暗号化*") と "*公開キー*" ("*非対称暗号化*") の 2 種類に分類できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-398">In computer systems encryption is based on complex mathematics such as finite fields and can be classified into two types: *private key* (or *symmetric encryption*) and *public key* (or *asymmetric encryption*).</span></span> <span data-ttu-id="b3993-399">秘密キーの暗号化の例には、AES (Advanced Encryption Standard) や RC4 (Rivest Cipher 4) があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-399">Examples of private key encryption are AES (Advanced Encryption Standard) and RC4 (Rivest Cipher 4).</span></span> <span data-ttu-id="b3993-400">公開キーの暗号化の例には、RSA (Rivest、Shamir、Adleson) 暗号や Diffie-Hellman 暗号があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-400">Examples of public-key encryption are the RSA (Rivest, Shamir, Adleson) and Diffie-Hellman ciphers.</span></span>

<span data-ttu-id="b3993-401">TLS プロトコルは、秘密キーと公開キーの両方の暗号化ルーチンを利用して、パフォーマンス、セキュリティ、柔軟性のバランスを実現しています。</span><span class="sxs-lookup"><span data-stu-id="b3993-401">The TLS protocol makes use of both private key and public key encryption routines to provide a balance of performance, security, and flexibility.</span></span>

### <a name="private-key-encryption"></a><span data-ttu-id="b3993-402">秘密キーの暗号化</span><span class="sxs-lookup"><span data-stu-id="b3993-402">Private-Key Encryption</span></span>

<span data-ttu-id="b3993-403">秘密キーの暗号化は、長年にわたって使用されてきました。</span><span class="sxs-lookup"><span data-stu-id="b3993-403">Private-key encryption has been in use for thousands of years.</span></span> <span data-ttu-id="b3993-404">基本的な換字暗号 (文字または単語が別の無関係な文字または単語に置き換えられる) は、最も昔から知られている暗号化の例ですが、情報時代の到来により、秘密キーの暗号化は大幅な機能強化を果たしてきました。</span><span class="sxs-lookup"><span data-stu-id="b3993-404">Basic substitution ciphers (where a letter or word is replaced by another unrelated letter or word) are the earliest known examples of encryption, but with the advent of the information age private key encryption has significantly improved.</span></span>

<span data-ttu-id="b3993-405">秘密キー暗号では "キー" が使用されます。これは、そのキーにアクセスできるエンティティのみが意味をなす方法でデータをデコードできるように、何らかの方法で何かのデータをエンコードするために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-405">A private key cipher uses a "key" which is simply a value (which could be a word, phrase, or number in the general case) that is used to somehow encode some data so that only an entity that had access to that key could decode the data in a meaningful way.</span></span> <span data-ttu-id="b3993-406">キーは、データの暗号化と解読の両方に使用されます。そのため、"*対称暗号化*" という他の名前があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-406">The key is used for both encryption and decryption of the data, hence the other name *symmetric encryption*.</span></span>

<span data-ttu-id="b3993-407">秘密キー暗号は、関連する数学が極めて複雑であっても、一般に高速であり、実装することがかなり容易です。</span><span class="sxs-lookup"><span data-stu-id="b3993-407">Private key ciphers are generally fast and fairly simple to implement, even if the mathematics involved are exceedingly complex.</span></span> <span data-ttu-id="b3993-408">このため TLS では、セキュリティで保護された通信のほとんどに対して秘密キー暗号を使用します。</span><span class="sxs-lookup"><span data-stu-id="b3993-408">For this reason, TLS uses private key ciphers for the bulk of secure communications.</span></span>

<span data-ttu-id="b3993-409">ただし、秘密キーの暗号化は、一般的なコンピューターのネットワーク通信に適用しようとすると問題があります。キーは、通信を試みる両方のコンピューター間で共有する必要があるのです。</span><span class="sxs-lookup"><span data-stu-id="b3993-409">However, private key encryption has a problem when we try to apply it to general computer network communications: the key must be shared between both machines trying to communicate.</span></span> <span data-ttu-id="b3993-410">一般的な場合、インターネット上の 2 台のコンピューター間で秘密キーを安全に伝達することは、非現実的であったり、場合によっては不可能であったりします。ネットワーク トラフィックは、インターネットを通ってルーティングされるときにデータが経由するさまざまなホップで、任意の数のエンティティによって取得可能であると想定できるためです。</span><span class="sxs-lookup"><span data-stu-id="b3993-410">In the general case, it is impractical and often impossible to communicate a private key securely between two machines on the Internet, as it can be assumed that the network traffic can be obtained by any number of entities in the various hops that data takes when being routed through the Internet.</span></span> <span data-ttu-id="b3993-411">キーが悪意のあるエンティティによって取得された場合、そのキーを使用して暗号化されたすべてのデータが侵害されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-411">If the key is obtained by a malicious entity, all data encrypted using that key is compromised.</span></span> <span data-ttu-id="b3993-412">インターネット上のほとんどのコンピューターには、ネットワーク接続しかなく、セキュリティで保護された別の通信用チャネルはないため、ネットワーク経由でキーを送信することは、暗号化されていないデータを送信することと同等で、セキュリティは備わっていません。</span><span class="sxs-lookup"><span data-stu-id="b3993-412">As most machines on the Internet have only a network connection and not another secure channel for communications, sending keys over the network is tantamount to sending the data unencrypted – it provides no security.</span></span>

<span data-ttu-id="b3993-413">このため、汎用のネットワーク通信セキュリティ プロトコルを実装するには、秘密キーの暗号化では不十分です。</span><span class="sxs-lookup"><span data-stu-id="b3993-413">For this reason, private key encryption is not sufficient to implement a general-purpose network communications security protocol.</span></span> <span data-ttu-id="b3993-414">ここで役立つのが公開キーの暗号化です。</span><span class="sxs-lookup"><span data-stu-id="b3993-414">This is where Public Key encryption can help.</span></span>

<span data-ttu-id="b3993-415">NetX Secure TLS では、AES による秘密キーの暗号化がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b3993-415">NetX Secure TLS supports AES private-key encryption.</span></span>

### <a name="public-key-encryption"></a><span data-ttu-id="b3993-416">公開キー暗号方式</span><span class="sxs-lookup"><span data-stu-id="b3993-416">Public-Key Encryption</span></span>

<span data-ttu-id="b3993-417">秘密キーの暗号化とは異なり、公開キーの暗号化は、1970 年代に表れた比較的非常に新しい概念です。</span><span class="sxs-lookup"><span data-stu-id="b3993-417">Unlike private key encryption, public key encryption is a fairly new concept, having been developed in the 1970's.</span></span> <span data-ttu-id="b3993-418">数学で "トラップドア関数" として知られている概念を利用すると、暗号化されたデータのセキュリティを損なうことなく、ネットワーク経由でキーを共有する方法があることが発見されました。</span><span class="sxs-lookup"><span data-stu-id="b3993-418">Using a concept known as "trap-door functions" in mathematics, it was discovered that there was a way to share a key over a network without compromising the security of then encrypted data.</span></span>

<span data-ttu-id="b3993-419">公開キーの暗号化は、キーが (前述した秘密キーの暗号化の意味で) 2 つの部分である "*秘密キー*" と "*公開キー*" に分割されることで機能しますが、そこから公開キーの暗号化の名前が付けられています。</span><span class="sxs-lookup"><span data-stu-id="b3993-419">The way public key encryption works is that the key (in the private-key encryption sense described above) is split into two parts, a *private key* and a *public key*, from where public key encryption gets its name.</span></span> <span data-ttu-id="b3993-420">これらのキーのいずれか (通常は公開キー) を暗号化のために使用し、もう一方を解読に使用する、という考えです。</span><span class="sxs-lookup"><span data-stu-id="b3993-420">The concept is that one of these keys (typically the public key) is used for encryption, while the other is used for decryption.</span></span> <span data-ttu-id="b3993-421">このキーの非対称性が、公開キー暗号化の別の名前である "*非対称暗号化*" の理由となっています。</span><span class="sxs-lookup"><span data-stu-id="b3993-421">This asymmetry of keys is the reason for the other name for public key encryption: *asymmetric encryption*.</span></span>

<span data-ttu-id="b3993-422">公開キー暗号化の背後にある数学はかなり複雑ですが、公開キーは暗号化に "*のみ*" 使用することができ、そのキーを取得しても暗号化されたデータは入手できないという考え方です。</span><span class="sxs-lookup"><span data-stu-id="b3993-422">The mathematics behind public key encryption are fairly complex, but the idea is that the public key can *only* be used for encryption, and obtaining that key does not allow encrypted data to be obtained.</span></span> <span data-ttu-id="b3993-423">次に秘密キーは、公開キーを使用して暗号化されたデータを解読する唯一の方法です。</span><span class="sxs-lookup"><span data-stu-id="b3993-423">The private key, in turn, is the only way to decrypt data encrypted using the public key.</span></span> <span data-ttu-id="b3993-424">したがって、秘密キーを秘密のままにしておくことで、その秘密キーの所有者と安全に通信することを望む人はだれでも、その秘密キーを所有している人だけがセキュリティで保護されたデータを取得できると知ったうえで、対応する公開キーでデータを暗号化するだけで済みます。</span><span class="sxs-lookup"><span data-stu-id="b3993-424">Thus, by keeping the private key secret, anyone wishing to communicate securely with the owner of that private key need only encrypt their data with the corresponding public key with the knowledge that only someone in possession of that private key can obtain the secure data.</span></span>

<span data-ttu-id="b3993-425">NetX Secure TLS では RSA 公開キー暗号化がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b3993-425">NetX Secure TLS supports RSA public-key encryption.</span></span>

> [!IMPORTANT] 
> <span data-ttu-id="b3993-426">*RSA は、ソフトウェアの RSA 実装が使用されている場合にはプロセッサを集中的に使用する操作です。キー サイズを大きくすると、必要な処理能力は 2 乗で増加します。つまり、キー サイズを 2 倍に増加すると 4 倍低速になります。*</span><span class="sxs-lookup"><span data-stu-id="b3993-426">*RSA is a very processor-intensive operation if the software RSA implementation is used. Larger key sizes increase the processing power required by a square factor – 4X slower for a 2X increase in key size.*</span></span>

### <a name="public-key-authentication"></a><span data-ttu-id="b3993-427">公開キー認証</span><span class="sxs-lookup"><span data-stu-id="b3993-427">Public-Key Authentication</span></span>

<span data-ttu-id="b3993-428">公開キー暗号化の概念には、これを使用して逆の操作を行うことで、暗号化に加えて認証を提供できるという興味深い副次的効果があります。"*秘密*" キーを使用して暗号化し、"*公開*" キーを使用して解読するのです。</span><span class="sxs-lookup"><span data-stu-id="b3993-428">An interesting side-effect of the public-key encryption concept is that it can be used to provide authentication as well as encryption by doing the operation in reverse: encrypting using the *private* key and decrypting using the *public* key.</span></span> <span data-ttu-id="b3993-429">これを行うための実際のメカニズムは、使用される公開キー アルゴリズムによって異なりますが、考え方は同じです。</span><span class="sxs-lookup"><span data-stu-id="b3993-429">The actual mechanism for doing this depends on the public key algorithm being used, but the concept is the same.</span></span>

<span data-ttu-id="b3993-430">公開キー認証を使用して認証するためには、秘密キーの所有者が、その秘密キーを使用して一部のデータ (一般には認証対象のデータの暗号化ハッシュ) を暗号化します。</span><span class="sxs-lookup"><span data-stu-id="b3993-430">To authenticate using public key authentication, the owner of a private key encrypts some piece of data (typically a cryptographic hash of the data to be authenticated) using that private key.</span></span> <span data-ttu-id="b3993-431">次に、データが秘密キーの所有者から来たことを認証したいユーザーは、関連付けられている公開キーを使用してそのデータを解読します。解読に成功する場合は、ユーザーがその公開キーの有効性を信頼している前提であれば、そのデータは秘密キーの所有者から来たものであることを確認できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-431">Then, someone wishing to authenticate that the data came from the owner of the private key uses the associated public key to decrypt the data – if the decryption is successful, and assuming the user trusted the validity of that public key, then the user can be certain that the data came from the owner of the private key.</span></span>

<span data-ttu-id="b3993-432">TLS では、信頼された証明書ストアの公開キーを使用して TLS サーバー (やオプションでの TLS クライアント) によって提供されたデジタル証明書の有効性を、公開キー認証を使用して検証します。</span><span class="sxs-lookup"><span data-stu-id="b3993-432">In TLS, public key authentication is used to verify the validity of a digital certificate provided by a TLS server (and optionally the TLS client) using public keys from the trusted certificate store.</span></span> <span data-ttu-id="b3993-433">証明書はストアの公開キーに対してチェックされ、証明書内のデータは、サーバーの ID を確認するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-433">The certificate is checked against a public key in the store and the data in the certificate is used to check the identity of the server.</span></span>

<span data-ttu-id="b3993-434">NetX Secure TLS では RSA 認証がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b3993-434">NetX Secure TLS supports RSA authentication.</span></span>

### <a name="cryptographic-hashing"></a><span data-ttu-id="b3993-435">暗号化ハッシュ</span><span class="sxs-lookup"><span data-stu-id="b3993-435">Cryptographic Hashing</span></span>

<span data-ttu-id="b3993-436">暗号化は、TLS で使用される唯一の暗号化操作ではありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-436">Encryption is not the only cryptographic operation used in TLS.</span></span> <span data-ttu-id="b3993-437">TLS セッション中にメッセージの整合性を提供するには、メッセージの内容が改ざんされていないことを確認するためのチェックサムが必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-437">In order to provide message integrity during a TLS session, a checksum is needed to ensure that the message contents have not been tampered with.</span></span> <span data-ttu-id="b3993-438">ただし (TCP で使用されるような) 簡単なチェックサムでは、知識のある攻撃者が簡単に突破できるため、受け入れ可能な整合性のレベルを保証するには不十分です。</span><span class="sxs-lookup"><span data-stu-id="b3993-438">However, a simple checksum (as is used in TCP) is insufficient to guarantee an acceptable level of integrity as it can be easily subverted by a knowledgeable attacker.</span></span> <span data-ttu-id="b3993-439">メッセージの整合性を提供するために TLS によって使用されるメカニズムは、"*暗号化ハッシュ*" と呼ばれています。</span><span class="sxs-lookup"><span data-stu-id="b3993-439">The mechanism used by TLS to provide message integrity is known as a *cryptographic hash*.</span></span>

<span data-ttu-id="b3993-440">暗号化は 1 対 1 のエンコードです。つまり、暗号化されたデータから元のデータ全体を取得できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-440">Encryption is a 1:1 encoding – that is, the entirety of the original data can be obtained from the encrypted data.</span></span> <span data-ttu-id="b3993-441">ただし、ハッシュでは、チェックサムと同様に、任意の量のデータを固定サイズの値にマップします。</span><span class="sxs-lookup"><span data-stu-id="b3993-441">However, a hash maps an arbitrary amount of data into a fixed size value, just like a checksum.</span></span> <span data-ttu-id="b3993-442">単純なチェックサムとは異なり、ハッシュは、異なる入力データが同じ出力になるような "*競合*" を減らすために特に設計されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-442">Unlike a simple checksum, a hash is specifically designed to reduce *collisions*, where different input data result in the same output.</span></span> <span data-ttu-id="b3993-443">単純なチェックサムでは、ビットが 1 から 0 に反転され、別のビットが 0 から 1 に反転されている場合、チェックサムは同じになります。</span><span class="sxs-lookup"><span data-stu-id="b3993-443">In a simple checksum, if a bit is flipped from 1 to 0 and another bit from 0 to 1, the checksum is the same.</span></span> <span data-ttu-id="b3993-444">暗号化ハッシュの使用時には出力に大きな違いが生じるため、攻撃者がハッシュされたデータを変更し、変更されたデータに対してハッシュ操作を行っても同じ値になるようにする (そうして、そのデータの整合性の検証を誤らせる) のは困難になります。</span><span class="sxs-lookup"><span data-stu-id="b3993-444">With a cryptographic hash, the output would differ significantly, making it difficult for an attacker to change the hashed data and have the hash operation on the changed data still result in the same value (and thus falsely verifying the integrity of that data).</span></span>

<span data-ttu-id="b3993-445">TLS では、いくつかの異なるハッシュ アルゴリズムを使用して、アプリケーション メッセージと TLS 制御メッセージの両方のメッセージに整合性を提供します。</span><span class="sxs-lookup"><span data-stu-id="b3993-445">TLS uses a number of different hash algorithms to provide integrity for messages, both application messages and TLS control messages.</span></span> <span data-ttu-id="b3993-446">これには MD5、SHA-1、SHA-256 が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b3993-446">These include MD5, SHA-1 and SHA-256.</span></span>

<span data-ttu-id="b3993-447">NetX Secure TLS では、MD5、SHA-1、SHA-256 のハッシュがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b3993-447">NetX Secure TLS supports MD5, SHA-1, and SHA-256 hashing.</span></span>

## <a name="tls-extensions"></a><span data-ttu-id="b3993-448">TLS 拡張機能</span><span class="sxs-lookup"><span data-stu-id="b3993-448">TLS Extensions</span></span>

<span data-ttu-id="b3993-449">TLS には、特定のアプリケーションに追加の機能を提供する拡張機能が多数用意されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-449">TLS provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="b3993-450">これらの拡張機能は、通常、ClientHello または ServerHello メッセージの一部として送信され、拡張機能の使用を望んでいることをリモート ホストに示したり、セキュリティで保護された TLS セッションの確立に使用する追加の詳細情報を提供したりします。</span><span class="sxs-lookup"><span data-stu-id="b3993-450">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="b3993-451">一般に、拡張機能では、ハンドシェイクの開始時に、進行中の操作をガイドするオプションのパラメーターを TLS に対して指定します。</span><span class="sxs-lookup"><span data-stu-id="b3993-451">In general, extensions provide optional parameters to TLS at the beginning of the handshake that guide the proceeding operations.</span></span> <span data-ttu-id="b3993-452">一部の拡張機能には、アプリケーションによる入力や意思決定が必要ですが、一方、他の拡張機能では自動的に処理されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-452">Some extensions require application input or decision making, while others are handled automatically.</span></span>

<span data-ttu-id="b3993-453">次の表で、NetX Secure TLS で現在サポートされている、TLS の拡張機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="b3993-453">The following table describes the TLS extensions currently supported by NetX Secure TLS:</span></span>

| <span data-ttu-id="b3993-454">**Extension Name**</span><span class="sxs-lookup"><span data-stu-id="b3993-454">**Extension Name**</span></span>              | <span data-ttu-id="b3993-455">**説明**</span><span class="sxs-lookup"><span data-stu-id="b3993-455">**Description**</span></span>              |
| ------------------------------- |----------------------------- |
| <span data-ttu-id="b3993-456">Secure Renegotiation Indication</span><span class="sxs-lookup"><span data-stu-id="b3993-456">Secure Renegotiation Indication</span></span> | <span data-ttu-id="b3993-457">この拡張機能により、再ネゴシエーションのハンドシェイク中に発生する可能性がある中間者攻撃の脆弱性が軽減されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-457">This extension mitigates a Man-in-the-Middle attack vulnerability that could occur during a renegotiation handshake.</span></span>|
| <span data-ttu-id="b3993-458">Server Name Indication</span><span class="sxs-lookup"><span data-stu-id="b3993-458">Server Name Indication</span></span>          | <span data-ttu-id="b3993-459">この拡張機能により、TLS クライアントは特定の DNS 名を TLS サーバーに提供できるようになり、サーバーが正しい資格情報を選択できるようになります (サーバーに複数の ID 証明書とネットワーク エントリポイントがあることが前提)。</span><span class="sxs-lookup"><span data-stu-id="b3993-459">This extension allows a TLS Client to supply a specific DNS name to a TLS Server, allowing the server to select the correct credentials (assumes the server has multiple identity certificates and network entrypoints).</span></span> |
| <span data-ttu-id="b3993-460">Signature Algorithms</span><span class="sxs-lookup"><span data-stu-id="b3993-460">Signature Algorithms</span></span>            | <span data-ttu-id="b3993-461">この拡張機能により、TLS クライアントは、使用可能な署名アルゴリズムとハッシュ アルゴリズムのリストを TLS サーバーに提供できるようになります。</span><span class="sxs-lookup"><span data-stu-id="b3993-461">This extension enables a TLS Client to provide a list of acceptable signature and hash algorithms to a TLS Server.</span></span> |

<span data-ttu-id="b3993-462">サポートされている TLS 拡張機能の概要</span><span class="sxs-lookup"><span data-stu-id="b3993-462">Overview of supported TLS Extensions</span></span>

### <a name="secure-renegotiation-indication"></a><span data-ttu-id="b3993-463">Secure Renegotiation Indication</span><span class="sxs-lookup"><span data-stu-id="b3993-463">Secure Renegotiation Indication</span></span>

<span data-ttu-id="b3993-464">TLS では、既存の TLS セッション内でハンドシェイクを実行し、それにより、確立されたセッションを使用してハンドシェイク メッセージを暗号化するという概念がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b3993-464">TLS supports the notion of performing a handshake within an existing TLS session, thereby using the established session to encrypt the handshake messages.</span></span> <span data-ttu-id="b3993-465">このプロセスにより、TLS セッションを終了せずに暗号化セッション キーを再確立することができます (「TLS セッションの再ネゴシエーション」セクションを参照)。</span><span class="sxs-lookup"><span data-stu-id="b3993-465">This process allows the cryptographic session keys to be re-established without ending the TLS session (see section "TLS Session Renegotiation").</span></span>

<span data-ttu-id="b3993-466">残念ながら、しばらくの間 TLS で再ネゴシエーションが使用された後、再ネゴシエーション機能を悪用する中間者攻撃に対して脆弱性が存在していたことが検出されました。</span><span class="sxs-lookup"><span data-stu-id="b3993-466">Unfortunately, after TLS had been using renegotiation for some time, it was discovered that there was a vulnerability to a Man-in-the-Middle attack that exploited the renegotiation feature.</span></span> <span data-ttu-id="b3993-467">脆弱性を解消するため、Secure Renegotiation Indication 拡張機能が導入されました。</span><span class="sxs-lookup"><span data-stu-id="b3993-467">To close the vulnerability, the Secure Renegotiation Indication extension was introduced.</span></span> <span data-ttu-id="b3993-468">Secure Renegotiation 拡張機能では、基本的に、確立された接続からの Finished メッセージのハッシュを使用して、元のホストが再ネゴシエーション ハンドシェイクに参加していることを確認します。基本的にハッシュは、攻撃者はハッシュを偽造できないであろうという前提のもとで、検証トークンとして使用されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-468">Essentially, the Secure Renegotiation extension uses the Finished message hash from the established connection to verify that the original hosts are participating in the renegotiation handshake – essentially the hash is used as a verification token under the assumption that an attacker would not be able to forge the hash (which would require access to the session keys).</span></span>

<span data-ttu-id="b3993-469">NetX Secure TLS では再ネゴシエーションは自動的に処理され、Secure Renegotiation Extension は既定で使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-469">NetX Secure TLS handles renegotiation automatically and uses the Secure Renegotiation Extension by default.</span></span> <span data-ttu-id="b3993-470">アプリケーションの操作は不要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-470">No application interaction is required.</span></span>

### <a name="server-name-indication"></a><span data-ttu-id="b3993-471">Server Name Indication</span><span class="sxs-lookup"><span data-stu-id="b3993-471">Server Name Indication</span></span>

<span data-ttu-id="b3993-472">TLS クライアントでは、TLS ハンドシェイク中にクライアントでサーバーを認証できるように、リモート サーバーから ID 証明書が提供されると予期しています。</span><span class="sxs-lookup"><span data-stu-id="b3993-472">During the TLS handshake, a TLS Client expects a remote server to provide an identity certificate so the client can authenticate the server.</span></span> <span data-ttu-id="b3993-473">ただし、1 つのサーバーが、それぞれ一意の ID を持つ異なる "仮想" サーバーを使用して複数の異なるサービスを提供する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-473">However, there may be some cases where a server will provide multiple different services with different "virtual" servers each having unique identities.</span></span> <span data-ttu-id="b3993-474">複数の ID を持つ単一サーバーの場合、TLS クライアントでは、サーバーが適切な資格情報を選択するために使用する特定の DNS 名を指定できます。この名前を指定するメカニズムが、Server Name Indication (SNI) 拡張機能です。</span><span class="sxs-lookup"><span data-stu-id="b3993-474">In the case of a single server with multiple identities, a TLS client can supply a specific DNS name that the server will use to select the proper credentials – the mechanism for supplying this name is the Server Name Indication (SNI) extension.</span></span>

<span data-ttu-id="b3993-475">SNI 拡張機能を使用するアプリケーションのためには、何らかの操作が必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-475">For an application using the SNI extension, some interaction is required.</span></span> <span data-ttu-id="b3993-476">TLS クライアントの場合、アプリケーションでは、リモート サーバーに送信される DNS 名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-476">For TLS Clients, the application must supply a DNS name to be sent to the remote server.</span></span> <span data-ttu-id="b3993-477">TLS サーバーの場合、アプリケーションでは、拡張機能から DNS 名を読み取り、クライアントに送り返す適切な証明書を選択する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-477">For TLS Servers, the application must read the DNS name from the extension and select an appropriate certificate to send back to the client.</span></span>

<span data-ttu-id="b3993-478">以降のセクションでは、NetX Secure TLS で SNI 拡張機能を使用する方法について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="b3993-478">The following sections provide more detail on how to use the SNI extension in NetX Secure TLS.</span></span>

### <a name="sni-extension--tls-client"></a><span data-ttu-id="b3993-479">SNI 拡張機能 – TLS クライアント</span><span class="sxs-lookup"><span data-stu-id="b3993-479">SNI Extension – TLS Client</span></span>

<span data-ttu-id="b3993-480">SNI 拡張機能を使用する予定の NetX Secure TLS クライアントでは、ハンドシェイク中に指定される DNS 名を TLS に提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-480">A NetX Secure TLS Client wishing to use the SNI extension must provide a DNS name to TLS to be supplied during the handshake.</span></span> <span data-ttu-id="b3993-481">拡張機能はハンドシェイク プロセスを開始する ClientHello メッセージの中で送信されるため、TLS セッションを開始する前に、この名前の初期化と指定を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-481">This name must be initialized and supplied prior to starting a TLS session since the extension is sent in the ClientHello message which starts the handshake process.</span></span>

<span data-ttu-id="b3993-482">次のコード スニペットは、拡張機能の使い方を示しています。</span><span class="sxs-lookup"><span data-stu-id="b3993-482">The following code snippet illustrates the use of the extension.</span></span> <span data-ttu-id="b3993-483">まず、目的のサーバー名を使用して、NX_SECURE_X509_DNS_NAME オブジェクトが初期化されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-483">First, a NX_SECURE_X509_DNS_NAME object is initialized with the desired server name.</span></span> <span data-ttu-id="b3993-484">次に、TLS セッションの開始前に、SNI 拡張機能 API を使用して TLS に名前が指定されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-484">Then, prior to starting the TLS session, the name is provided to TLS using the SNI extension API.</span></span> <span data-ttu-id="b3993-485">名前が設定されたら、以後の操作は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-485">Once the name is set, no further action is required.</span></span> <span data-ttu-id="b3993-486">個々の関数の詳細については、第 4 章の</span><span class="sxs-lookup"><span data-stu-id="b3993-486">See the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="b3993-487">NetX Secure サービスに関する説明のページで API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-487">Description of NetX Secure Services for more information on the individual functions.</span></span>

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a><span data-ttu-id="b3993-488">SNI 拡張機能 – TLS サーバー</span><span class="sxs-lookup"><span data-stu-id="b3993-488">SNI Extension – TLS Server</span></span>

<span data-ttu-id="b3993-489">TLS サーバー側では、ハンドシェイク中にリモート クライアントに提供する適切な資格情報 (証明書など) を選択するため、アプリケーションで SNI 拡張機能の処理が行われる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-489">On the TLS Server side, the SNI extension may be processed by the application in order to select proper credentials (e.g. certificate) to provide to the remote client during the handshake.</span></span> <span data-ttu-id="b3993-490">これを行うには、アプリケーションで、ClientHello メッセージの受信に続いて呼び出されるセッション コールバックを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-490">To do this, the application must supply a session callback which is invoked following the receipt of a ClientHello message.</span></span>

<span data-ttu-id="b3993-491">nx_secure_tls_session_server_callback_set API のコード例 (122 ページを参照) は、サーバー コールバックを使用した受信 SNI 拡張機能の解析を示しています。</span><span class="sxs-lookup"><span data-stu-id="b3993-491">The example code for the nx_secure_tls_session_server_callback_set API  (see page 122) illustrates the parsing of an incoming SNI extension using a server callback.</span></span> <span data-ttu-id="b3993-492">基本的に、TLS サーバーで ClientHello を受信してコールバックを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b3993-492">Essentially, the TLS Server receives a ClientHello and invokes the callback.</span></span> <span data-ttu-id="b3993-493">次に、アプリケーションで *nx_secure_tls_session_sni_extension_parse* API を使用して、コールバックに提供された拡張機能データを解析して SNI 拡張機能を見つけ、指定された DNS 名を返します (この拡張機能では、1 つの DNS 名のみがサポートされていることに注意してください)。</span><span class="sxs-lookup"><span data-stu-id="b3993-493">Then the application uses the *nx_secure_tls_session_sni_extension_parse* API to parse the extension data provided to the callback to find the SNI extension and return the supplied DNS name (note that the extension only supports a single DNS name).</span></span> <span data-ttu-id="b3993-494">名前が取得されたら、アプリケーションでそれを使用し、適切なサーバー ID 証明書 (および該当する場合は発行者チェーン) を見つけ、それを送信します。</span><span class="sxs-lookup"><span data-stu-id="b3993-494">Once the name is obtained, the application uses it to find and send the appropriate server identity certificate (and issuer chain if applicable).</span></span>

### <a name="signature-algorithms-extension"></a><span data-ttu-id="b3993-495">Signature Algorithms 拡張機能</span><span class="sxs-lookup"><span data-stu-id="b3993-495">Signature Algorithms Extension</span></span>

<span data-ttu-id="b3993-496">この拡張機能は TLS 1.2 に固有のもので、TLS クライアントで、デジタル署名の生成と検証に使用するための、受け入れ可能な署名とハッシュ アルゴリズムの組のリストを提供できるようになります。</span><span class="sxs-lookup"><span data-stu-id="b3993-496">This extension is specific to TLS 1.2 and allows a TLS Client to provide a list of acceptable signature and hash algorithm pairs that are acceptable for use in generating and verifying digital signatures.</span></span> <span data-ttu-id="b3993-497">このリストは、*nx_secure_tls_session_create* に提供された暗号テーブルを使用して、TLS クライアント用の NetX Secure TLS によって自動的に生成されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-497">The list is generated automatically by NetX Secure TLS for TLS Clients using the cipher table supplied to *nx_secure_tls_session_create*.</span></span> <span data-ttu-id="b3993-498">アプリケーションの操作は不要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-498">No application interaction is required.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="b3993-499">認証方法</span><span class="sxs-lookup"><span data-stu-id="b3993-499">Authentication Methods</span></span>

<span data-ttu-id="b3993-500">TLS には、セキュリティで保護されていないネットワーク上で 2 つのデバイス間にセキュリティで保護された接続を確立するためのフレームワークが用意されていますが、その接続の他方の末端にあるデバイスの ID を認識することが、問題の一部となっています。</span><span class="sxs-lookup"><span data-stu-id="b3993-500">TLS provides the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="b3993-501">リモート ホストの ID を認証するためのメカニズムがない場合は、攻撃者が簡単に信頼されたデバイスを装うことができるようになります。</span><span class="sxs-lookup"><span data-stu-id="b3993-501">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="b3993-502">最初は、IP アドレス、ハードウェアの MAC アドレス、または DNS を使用すると、ネットワーク上のホストを識別するうえで比較的高い信頼性が得られるように思われるかもしれませんが、TCP/IP テクノロジの性質と、アドレスのなりすましや (たとえば DNS キャッシュ ポイズニングを通した) DNS エントリの破損は容易であることを考えると、TLS には不正な ID に対する追加の保護レイヤーが必要であることは明確になります。</span><span class="sxs-lookup"><span data-stu-id="b3993-502">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="b3993-503">この追加の認証レイヤーを TLS に提供できるさまざまなメカニズムがありますが、最も一般的なのは "*デジタル証明書*" です。</span><span class="sxs-lookup"><span data-stu-id="b3993-503">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="b3993-504">その他のメカニズムには、事前共有キー (PSK) とパスワードのスキームがあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-504">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="b3993-505">デジタル証明書</span><span class="sxs-lookup"><span data-stu-id="b3993-505">Digital Cerificates</span></span>

<span data-ttu-id="b3993-506">デジタル証明書は、TLS でリモート ホストを認証するための最も一般的な方法です。</span><span class="sxs-lookup"><span data-stu-id="b3993-506">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="b3993-507">基本的にデジタル証明書は、コンピューター ネットワーク上のデバイスの ID 情報を提供する特定形式のドキュメントです。</span><span class="sxs-lookup"><span data-stu-id="b3993-507">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="b3993-508">TLS では通常、国際電気通信連合によって開発された標準である X.509 という形式が使用されますが、使用される形式について TLS ホストの同意が得られる場合は、他の形式の証明書を使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-508">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="b3993-509">X.509 では、証明書の特定の形式と、デジタル ドキュメントの生成に使用できるさまざまなエンコードが定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-509">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="b3993-510">TLS で使用されるほとんどの X.509 証明書は、別の通信規格である ASN.1 のバリアントを使用してエンコードされます。</span><span class="sxs-lookup"><span data-stu-id="b3993-510">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="b3993-511">ASN.1 にはさまざまなデジタル エンコードがありますが、TLS 証明書で最も一般的なエンコードは、Distinguished Encoding Rules (DER) 標準です。</span><span class="sxs-lookup"><span data-stu-id="b3993-511">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="b3993-512">DER は、あいまいさが排除されるように設計された ASN.1 基本エンコード規則 (BER) の簡略化されたサブセットであり、解析が容易になります。</span><span class="sxs-lookup"><span data-stu-id="b3993-512">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="b3993-513">通常、ネットワークでは、TLS 証明書はバイナリ DER でエンコードされます。これは NetX Secure で X.509 証明書に想定する形式です。</span><span class="sxs-lookup"><span data-stu-id="b3993-513">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="b3993-514">DER 形式のバイナリ証明書は実際の TLS プロトコルで使用されていますが、これらの証明書は、さまざまな異なるエンコードで生成し、.pem、.crt、.p12 などのファイル拡張子を付けて保存することができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-514">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="b3993-515">さまざまな製造元のさまざまなアプリケーションで異なるバリアントが使用されていますが、通常は広く利用可能なツールを使用してそのすべてを DER に変換することができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-515">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="b3993-516">代わりになる証明書エンコードで最も一般的なのは PEM です。</span><span class="sxs-lookup"><span data-stu-id="b3993-516">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="b3993-517">PEM (Privacy Enhanced Mail) 形式は、base-64 でエンコードされるバージョンの DER エンコードであり、エンコードの結果は、電子メールや Web ベースのプロトコルを使用して簡単に送信できる出力可能なテキストになるため、よく使用されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-517">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="b3993-518">NetX Secure アプリケーション用の証明書の生成の大部分はこのマニュアルの範囲外ですが、OpenSSL コマンドライン ツール ([www.openssl.org](http://www.openssl.org)) が広く入手可能であり、ほとんどの形式間で変換を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-518">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="b3993-519">アプリケーションによって、独自の証明書を生成することも、製造元や政府機関から証明書の提供を受けることも、商用の証明機関から証明書を購入することもあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-519">Depending on your application, you may generate your own certificates, be provided certificates by a  manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="b3993-520">NetX Secure アプリケーションでデジタル証明書を使用するには、最初に証明書をバイナリ DER 形式に変換し、必要に応じて、関連付けられた秘密キー (RSA の場合は "秘密指数") をバイナリ形式 (一般には、PKCS#1 形式の DER でエンコードされた RSA キーまたは DER でエンコードされた ECC キー) に変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-520">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the "private exponent" for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key or a DER-encoded ECC key.</span></span> <span data-ttu-id="b3993-521">変換が完了したら、証明書と秘密キーのデバイスへの読み込みは、ユーザーの選択に委ねられます。</span><span class="sxs-lookup"><span data-stu-id="b3993-521">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="b3993-522">選択可能なオプションとしては、フラッシュベースのファイル システムの使用、データからの C 配列の生成 (Linux の "xxd" などのツールを使用)、証明書とキーを定数データとしてアプリケーション内へコンパイルする方法などがあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-522">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as "xxd" from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="b3993-523">証明書がデバイスに読み込まれたら、TLS API を使用して、証明書を TLS セッションに関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-523">Once your certificate is loaded onto the device, the TLS API can be used to associate your certificate with a TLS session.</span></span>

<span data-ttu-id="b3993-524">NetX Secure TLS での X.509 証明書の使用方法の詳細と例については、「X.509 証明書の NetX Secure へのインポート」のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-524">For details and examples on how to use X.509 certificates with NetX Secure TLS, see the section "Importing X.509 certificates into NetX Secure".</span></span>

<span data-ttu-id="b3993-525">詳細については、API リファレンスで、以下の TLS サービスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-525">Refer to the following TLS services in the API reference for more information:</span></span>

- <span data-ttu-id="b3993-526">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="b3993-526">nx_secure_x509_certificate_initialize</span></span>
- <span data-ttu-id="b3993-527">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="b3993-527">nx_secure_tls_local_certificate_add</span></span>
- <span data-ttu-id="b3993-528">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="b3993-528">nx_secure_tls_local_certificate_remove</span></span>
- <span data-ttu-id="b3993-529">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="b3993-529">nx_secure_tls_remote_certificate_allocate</span></span>
- <span data-ttu-id="b3993-530">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="b3993-530">nx_secure_tls_trusted_certificate_add</span></span>
- <span data-ttu-id="b3993-531">nx_secure_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="b3993-531">nx_secure_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="b3993-532">TLS クライアント証明書の詳細</span><span class="sxs-lookup"><span data-stu-id="b3993-532">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="b3993-533">TLS クライアントの実装では、一般に、デバイスに "ローカルの" 証明書<sup>14</sup> を読み込む必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-533">TLS Client implementations generally do not require a "local" certificate<sup>14</sup> to be loaded onto the device.</span></span> <span data-ttu-id="b3993-534">これに該当しないのは、クライアント証明書認証が有効になっている場合ですが、これはまったく一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-534">The exception to this is when Client Certificate Authentication is enabled, but this is far less common.</span></span>

<span data-ttu-id="b3993-535">TLS Client では、"信頼された"証明書<sup>15</sup> を少なくとも 1 つ読み込み (必要な場合はさらに読み込む場合があります)、"リモート" 証明書<sup>16</sup> 用の領域を割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-535">A TLS Client requires at least one "trusted" certificate<sup>15</sup> to be loaded (more may be loaded if required), and space for a "remote" certificate<sup>16</sup> to be allocated.</span></span>

<span data-ttu-id="b3993-536">信頼された証明書の追加とリモート証明書用の領域の割り当ての詳細については、TLS API リファレンスで、nx_secure_tls_remote_certificate_allocate サービスと nx_secure_tls_trusted_certificate_add サービスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-536">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span></span>

14. <span data-ttu-id="b3993-537">"ローカル" 証明書は、ローカル デバイスを識別する証明書です。つまり、TLS アプリケーションが読み込まれるデバイスの ID 情報を提供するものです。</span><span class="sxs-lookup"><span data-stu-id="b3993-537">A “local” certificate is a certificate that identifies the local device – that is, it provides identity information for the device upon which the TLS application is loaded.</span></span>

15. <span data-ttu-id="b3993-538">"信頼された" 証明書は、リモート デバイスの信頼性と認証の基礎を提供する証明書であり、直接、または公開キー基盤 (PKI) を介して提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-538">A “trusted” certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="b3993-539">信頼のチェーンのルートは、通常、"証明機関" または CA 証明書と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="b3993-539">The root of the chain of trust is usually called a “Certification Authority” or CA certificate.</span></span>

16. <span data-ttu-id="b3993-540">"リモート" 証明書は、TLS ハンドシェイク中にリモート ホストによって送信される証明書を指します。</span><span class="sxs-lookup"><span data-stu-id="b3993-540">A “remote” certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="b3993-541">これが、そのリモート ホストの ID を提供し、ローカル デバイス上の "信頼された" 証明書と比較されることで、認証が行われます。</span><span class="sxs-lookup"><span data-stu-id="b3993-541">It provides identity for that remote host and is authenticated by comparing it to a “trusted” certificate on the local device.</span></span>

### <a name="tls-server-certificate-specifics"></a><span data-ttu-id="b3993-542">TLS サーバー証明書の詳細</span><span class="sxs-lookup"><span data-stu-id="b3993-542">TLS Server Certificate Specifics</span></span>

<span data-ttu-id="b3993-543">TLS サーバーの実装では、一般に、"信頼された" 証明書をデバイスに読み込んだり、リモート証明書を割り当てたりする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-543">TLS Server implementations generally do not require "trusted" certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="b3993-544">これに該当しないのは、クライアント証明書認証が有効になっている場合です (これはあまり一般的ではありません)。</span><span class="sxs-lookup"><span data-stu-id="b3993-544">The exception to this being when Client Certificate Authentication is enabled (this is less common).</span></span>

<span data-ttu-id="b3993-545">TLS サーバーでは、クライアントに対してそのサーバーを認証するため、"ローカル" (または "ID") の証明書を読み込んで、それを TLS ハンドシェイク中にサーバーからリモート クライアントに提供できるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-545">A TLS Server requires a "local" certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="b3993-546">NetX TLS サーバー アプリケーションで使用するためにローカル証明書を読み込むことの詳細については、以下のサービスについて API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-546">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services:</span></span> 
- <span data-ttu-id="b3993-547">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="b3993-547">nx_secure_tls_local_certificate_add,</span></span> 
- <span data-ttu-id="b3993-548">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="b3993-548">nx_secure_tls_local_certificate_remove.</span></span>

### <a name="pre-shared-keys-psk"></a><span data-ttu-id="b3993-549">事前共有キー (PSK)</span><span class="sxs-lookup"><span data-stu-id="b3993-549">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="b3993-550">TLS で ID 認証を提供するための代替メカニズムは、事前共有キー (PSK) の概念です。</span><span class="sxs-lookup"><span data-stu-id="b3993-550">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="b3993-551">PSK 暗号スイートを使用すると、プロセッサが集中的に使用される公開キー暗号化の操作を行う必要がなくなり、リソースに制約がある組み込みデバイスにとっての恩恵となります。</span><span class="sxs-lookup"><span data-stu-id="b3993-551">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="b3993-552">TLS ハンドシェイクの証明書が PSK に置き換えられて、TLS セッション キーの生成で、暗号化されたプリマスター シークレットの代わりに使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-552">The PSK replaces the certificate in the TLS handshake and is used in place of the encrypted Pre-Master Secret for TLS session key generation.</span></span>

<span data-ttu-id="b3993-553">PSK 暗号スイートは、TLS セッションを確立する前に、両方のデバイスに共有シークレットが存在する必要があるという意味では制約があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-553">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS session can be established.</span></span> <span data-ttu-id="b3993-554">つまり、TLS PSK 接続以外のセキュリティで保護された方法を使用して、そのシークレットがデバイスに読み込まれている必要があります。PSK は、TLS PSK 接続を介した更新も可能ですが、デバイスは必ず、他の何らかのメカニズムを通じて読み込まれた PSK を使用して起動される必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-554">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="b3993-555">たとえば、出荷前にセンサー デバイスとそのゲートウェイ デバイスに PSK を読み込むことや、標準の TLS 接続 (証明書を使用) を使用して PSK を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-555">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="b3993-556">PSK 暗号スイートには、RFC 4279 で規定されている 2 つの形式があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-556">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="b3993-557">1 つ目では RSA または Diffie-Hellman キーが使用され、これらが、標準の TLS ハンドシェイクにおいて証明書で転送される公開キーと同じ方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-557">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="b3993-558">2 番目の形式は、リソースの制約がある環境でより多く使用され、セッション キー (たとえば、AES で使用される) を直接生成するために使用される PSK を使用して、コストのかかる RSA または Diffie-Hellman 操作の使用が回避されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-558">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="b3993-559">NetX Secure では、2 番目の形式の PSK 暗号スイートがサポートされるため、アプリケーションで使用されていた公開キー暗号化のためのすべてのコードとメモリが不要になります。</span><span class="sxs-lookup"><span data-stu-id="b3993-559">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="b3993-560">PSK 自体は AES キーではありませんが、実際のキーがそこから生成されるパスワードのようなものと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-560">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="b3993-561">どのような PSK の値を使用できるかに関してほとんど制限はありませんが、値が長いほどセキュリティが高まります (パスワードの場合と同じ)。</span><span class="sxs-lookup"><span data-stu-id="b3993-561">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="b3993-562">NetX Secure アプリケーションで PSK を使用するには、まずグローバル マクロ **NX_SECURE_ENABLE_PSK_CIPHERSUITES** を定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-562">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="b3993-563">これは通常、コンパイラ設定を通じて行われますが、定義を nx_secure_tls.h ヘッダー ファイル内に配置することもできます。</span><span class="sxs-lookup"><span data-stu-id="b3993-563">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="b3993-564">このマクロを定義すると、PSK 暗号スイートのサポートが NetX Secure TLS アプリケーション内にコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="b3993-564">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure TLS application.</span></span>

<span data-ttu-id="b3993-565">PSK のサポートが有効であれば、TLS API を使用してアプリケーションのために PSK を設定できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-565">With PSK support enabled, you can then use the TLS API to set up PSKs for your application.</span></span> <span data-ttu-id="b3993-566">各 PSK には、PSK 値 (実際の秘密 "キー"。この値は安全に保管してください)、特定の PSK を識別するために使用される "ID" 値、特定の PSK 値を選択するために TLS サーバーで使用される "ID ヒント" が必要となります。</span><span class="sxs-lookup"><span data-stu-id="b3993-566">Each PSK will require a PSK value (the actual secret "key" – keep this value safe), an "identity" value used to identify the specific PSK, and an "identity hint" that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="b3993-567">PSK 自体は、ネットワーク接続経由で送信されることがないため、任意のバイナリ値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-567">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="b3993-568">PSK は、長さが最大 64 バイトの任意の値にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-568">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="b3993-569">ID とヒントは、UTF-8 を使用してフォーマットされた出力可能な文字列である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-569">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="b3993-570">ID とヒントの値は、最大 128 バイトの任意の長さにすることができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-570">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="b3993-571">ID と PSK によって、相互に通信する必要があるネットワーク内のすべてのデバイスに読み込まれる一意の組が形成されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-571">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="b3993-572">"ヒント" は主に、機能またはサービスによって PSK をグループ化する特定のアプリケーション プロファイルを定義するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-572">The "hint" is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="b3993-573">これらの値は事前に合意されている必要があり、アプリケーションに依存します。</span><span class="sxs-lookup"><span data-stu-id="b3993-573">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="b3993-574">たとえば、(PSK が有効になっている) OpenSSL コマンドライン サーバー アプリケーションでは、既定の文字列 "Client_identity" が使用されます。これは、TLS ハンドシェイクを続行するために TLS クライアントによって提供される必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-574">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string "Client_identity", which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="b3993-575">PSK の詳細については、NetX Secure API リファレンスで、nx_secure_tls_client_psk_set サービスと nx_secure_tls_psk_add サービスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-575">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="b3993-576">X.509 証明書の NetX Secure へのインポート</span><span class="sxs-lookup"><span data-stu-id="b3993-576">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="b3993-577">デジタル証明書は、インターネット上のほとんどの TLS 接続に必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-577">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="b3993-578">以前は未知であったホストを、信頼できる中継点 (通常は "*証明機関*" または CA と呼ばれます) を使用することでインターネット経由で認証する手段が、証明書によって提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-578">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="b3993-579">NetX Secure デバイスを商用クラウド サービス (アマゾン ウェブ サービスなど) に接続するには、デバイスに証明書を読み込むことによってアプリケーションに証明書をインポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-579">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="b3993-580">証明書と共に、証明書に関連付けられている "*秘密キー*" が必要になる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-580">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="b3993-581">一部のアプリケーション (クライアント証明書認証が使用されない予定のときの TLS クライアントなど) では、証明書だけで十分ですが、デバイスの識別に証明書が使用される予定であれば、秘密キーが必要になります。</span><span class="sxs-lookup"><span data-stu-id="b3993-581">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="b3993-582">秘密キーは一般に、証明書を作成するときに生成され、別個のファイルに格納されます。多くの場合、パスワードで暗号化されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-582">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

### <a name="certificate-types"></a><span data-ttu-id="b3993-583">証明書の種類</span><span class="sxs-lookup"><span data-stu-id="b3993-583">Certificate Types</span></span>

<span data-ttu-id="b3993-584">デジタル証明書は、一般に、ネットワーク上のエンティティを識別するために使用されますが、それらのアプリケーションによっては、それらの特性が少し異なってきます。</span><span class="sxs-lookup"><span data-stu-id="b3993-584">Digital certificates are generally used to identify entities on a network, but depending on what their application they will have slightly different properties.</span></span>

### <a name="local-certificates"></a><span data-ttu-id="b3993-585">ローカル証明書</span><span class="sxs-lookup"><span data-stu-id="b3993-585">Local Certificates</span></span>

<span data-ttu-id="b3993-586">このドキュメントでは、ローカル デバイスの ID を提供する証明書として "ローカル証明書" に言及します (その他に使用できる名前は "デバイス証明書" です)。</span><span class="sxs-lookup"><span data-stu-id="b3993-586">For the purposes of this documentation, we will refer to "local certificates" as those certificates which provide an identity for our local device (another possible name could be "device certificate").</span></span> <span data-ttu-id="b3993-587">これらの証明書は、リモート ホストでローカル デバイスを認証する必要があるときに、リモート ホストに提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-587">These certificates will be provided to a remote host when the remote host desires to authenticate the local device.</span></span>

### <a name="remote-certificates"></a><span data-ttu-id="b3993-588">リモート証明書</span><span class="sxs-lookup"><span data-stu-id="b3993-588">Remote Certificates</span></span>

<span data-ttu-id="b3993-589">このドキュメントでは、"リモート証明書" は、該当する場合に TLS ハンドシェイク中にリモート ホストによって提供される証明書を指します。</span><span class="sxs-lookup"><span data-stu-id="b3993-589">In this documentation, "remote certificates" refers to those certificates provided by a remote host during the TLS handshake when applicable.</span></span> <span data-ttu-id="b3993-590">これらの証明書のために、領域が割り当てられている必要があり、そうでないと NetX Secure でそれらを解析できず、TLS ハンドシェイクを完了することができなくなります。</span><span class="sxs-lookup"><span data-stu-id="b3993-590">Space for these certificates must be allocated or NetX Secure will not be able to parse them and complete the TLS handshake.</span></span>

### <a name="signing-certificates"></a><span data-ttu-id="b3993-591">署名証明書</span><span class="sxs-lookup"><span data-stu-id="b3993-591">Signing Certificates</span></span>

<span data-ttu-id="b3993-592">"署名証明書" は、認証の目的で、その他の証明書またはデータにデジタル署名するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-592">A "signing certificate" is used to digitally sign other certificates or data for the purpose of authentication.</span></span> <span data-ttu-id="b3993-593">これらの証明書は、公開キー基盤 (PKI) 内の中間証明書またはルート証明書のいずれかである可能性があり、通常は、個々のデバイスやホストの識別には使用されません。</span><span class="sxs-lookup"><span data-stu-id="b3993-593">These certificates may be either intermediate or root certificates within a Public Key Infrastructure (PKI) and are generally not used to identify individual devices or hosts.</span></span>

### <a name="root-ca-certificates"></a><span data-ttu-id="b3993-594">［ルート CA 証明書］</span><span class="sxs-lookup"><span data-stu-id="b3993-594">Root CA Certificates</span></span>

<span data-ttu-id="b3993-595">"ルート CA 証明書" は、PKI の基盤を提供する署名する側の証明書であり、別の署名証明書によって署名されるのではなく、自己署名されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-595">"Root CA certificates" are signing certificates that provide the basis of a PKI and are self-signed, rather than being signed by another signing certificate.</span></span> <span data-ttu-id="b3993-596">TLS クライアントでリモート サーバーを検証するためには、一般に、少なくとも 1 つのルート CA 証明書が必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-596">At least one Root CA certificate is typically required for a TLS Client to verify remote servers.</span></span>

### <a name="certificate-formats"></a><span data-ttu-id="b3993-597">証明書の形式</span><span class="sxs-lookup"><span data-stu-id="b3993-597">Certificate formats</span></span>

<span data-ttu-id="b3993-598">デジタル証明書は、単純に、ASN.1 構文を使用してエンコードされた構造化データが含まれるファイルです。</span><span class="sxs-lookup"><span data-stu-id="b3993-598">Digital certificates are simply files containing structured data encoded using the ASN.1 syntax.</span></span> <span data-ttu-id="b3993-599">ただし、証明書を格納できるさまざまな形式が存在するため、証明書を NetX Secure アプリケーションに読み込む前に適切な形式にすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-599">However, there are various formats in which certificates may be stored and it is important to have the right format before loading a certificate into a NetX Secure application.</span></span>

<span data-ttu-id="b3993-600">証明書の最も一般的な形式は、DER と PEM です。</span><span class="sxs-lookup"><span data-stu-id="b3993-600">The most common formats for certificates are DER and PEM.</span></span> <span data-ttu-id="b3993-601">DER (ANS.1 形式の 1 つである *Distinguished Encoding Rules*) は、初期ハンドシェイクを実行するときに TLS によって使用されるバイナリ形式です。</span><span class="sxs-lookup"><span data-stu-id="b3993-601">DER (for *Distinguished Encoding Rules*, an ASN.1 format) is the binary format used by TLS when performing the initial handshake.</span></span> <span data-ttu-id="b3993-602">PEM (*Privacy Enhanced Mail* に由来) は、Web でのメール送信や HTTP 経由の送信に適した、DER 形式の base 64 エンコード バージョンです。</span><span class="sxs-lookup"><span data-stu-id="b3993-602">PEM (from *Privacy Enhanced Mail*) is a base-64 encoded version of the DER format which is suitable for emailing or sending over HTTP on the web.</span></span> <span data-ttu-id="b3993-603">ベンダーが異なると、PEM 証明書の場合は ".pem" や ".crt" などの異なるファイル名拡張子が使用され、DER 証明書の場合は "der" が使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-603">Different vendors use different filename extensions for certificates, such as ".pem" or ".crt" for PEM certificates, and ".der" for DER certificates.</span></span> <span data-ttu-id="b3993-604">証明書があり、どの形式が使用されているかが明確でない場合は、このファイルをテキスト エディターで開くと、種類を確認することができます。DER ファイルはエンコードされたバイナリ形式で、PEM ファイルは、"-----BEGIN CERTIFICATE-----" というヘッダーで始まる標準の ASCII テキストであるためです。</span><span class="sxs-lookup"><span data-stu-id="b3993-604">If you have a certificate and it is not clear what format is used, opening the file in a text editor will allow you to determine the type since DER files are encoded  binary, and PEM files are regular ASCII text that start with the header "-----BEGIN CERTIFICATE-----".</span></span>

<span data-ttu-id="b3993-605">NetX Secure では、証明書はバイナリ DER 形式である必要があるため、インポートする前に証明書を DER 形式に変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-605">NetX Secure requires that your certificate be in binary DER format, so you will need to convert your certificate into DER format before importing.</span></span> <span data-ttu-id="b3993-606">これは、すぐに入手できる OpenSSL などのツールで行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-606">This can be done with readily available tools such as OpenSSL.</span></span>

<span data-ttu-id="b3993-607">アプリケーションの秘密キーが必要な場合、キー ファイルは、PEM または DER を使用して、特定の形式 (RSA の場合は PKCS # 1、ECC の場合は RFC 5915) でエンコードされます。</span><span class="sxs-lookup"><span data-stu-id="b3993-607">If you need a private key for your application, the key file will be encoded using PEM or DER in a specific format (PKCS#1 for RSA, RFC 5915 for ECC).</span></span> <span data-ttu-id="b3993-608">秘密キーファイルは、インポートする前に DER に変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-608">The private key file will need to be converted into DER before being imported.</span></span>

<span data-ttu-id="b3993-609">以下の OpenSSL コマンドは、証明書と RSA キー ファイルを、NetX Secure で必要な DER 形式に変換する例として示されています (ECC も似ています。OpenSSL のドキュメントを参照してください)。</span><span class="sxs-lookup"><span data-stu-id="b3993-609">The following OpenSSL commands are given as an example for converting certificates and RSA key files into the DER format required by NetX Secure (ECC is similar – refer to the OpenSSL documentation).</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a><span data-ttu-id="b3993-610">秘密キーと証明書</span><span class="sxs-lookup"><span data-stu-id="b3993-610">Private Keys and Certificates</span></span>

<span data-ttu-id="b3993-611">デバイスを識別する証明書については、関連付けられている秘密キーを証明書と一緒に読み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-611">For certificates that identify a device, the associated private key must be loaded along with the certificate.</span></span> <span data-ttu-id="b3993-612">TLS サーバーでは、秘密キー (RSA、Diffie-Hellman、楕円曲線暗号化など、いずれかの公開キー アルゴリズム用である可能性があります) を使用して、TLS クライアントから受信するキー マテリアル ("事前マスター シークレット") を解読し、それによってクライアントに対して自身を認証します。</span><span class="sxs-lookup"><span data-stu-id="b3993-612">The private key (which may be for one of the public-key algorithms such as RSA, Diffie-Hellman, or Elliptic-Curve Cryptography) is used by a TLS server to decrypt the incoming key material (the "pre-master secret") from a TLS client, thereby authenticating itself to the client.</span></span> <span data-ttu-id="b3993-613">TLS クライアントについては、ID 証明書 (関連付けられている秘密キーがある証明書) が提供され、サーバーがクライアント証明書を要求すると、秘密キーを使用してクライアントの認証が行われます。RSA の場合、クライアントにより、秘密キーを使用してトークンが暗号化されます。次にサーバーにより、クライアント証明書で提供されたクライアントの公開キーを使用してトークンが解読されます (Diffie-Hellman と ECC の認証は同様の方法で行われますが、詳細は少し異なります)。</span><span class="sxs-lookup"><span data-stu-id="b3993-613">For a TLS Client, if an identity certificate (a certificate with its associated private key) is provided and a server requests a client certificate, the private key is used to authenticate the client – in the case of RSA the client  encrypts a token using the private key which the server then decrypts using the client's public key, provided in the client certificate (Diffie-Hellman and ECC authentication happens in a similar fashion but the details are a bit different).</span></span>

<span data-ttu-id="b3993-614">NetX Secure では、サービス *nx_secure_x509_certificate_initialize* を使用して、X.509 証明書が初期化されます (詳細については、「デバイスへの証明書の読み込み」を参照)。また、オプションで、秘密キーをその証明書に関連付けます。</span><span class="sxs-lookup"><span data-stu-id="b3993-614">In NetX secure, the service *nx_secure_x509_certificate_initialize* is used to initialize an X.509 certificate (see section "Loading certificates onto your device" for more information) and optionally associate a private key with that certificate.</span></span>

<span data-ttu-id="b3993-615">秘密キーが指定されている場合、その証明書は、デバイスを識別するために使用される "ID" 証明書であるとマークされます。</span><span class="sxs-lookup"><span data-stu-id="b3993-615">If a private key is supplied, the certificate is marked as being the "identity" certificate used to identify the device.</span></span> <span data-ttu-id="b3993-616">キーは、関連付けられたキーの種類がある、連続するバイナリ BLOB および長さとして渡されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-616">The key is passed as a contiguous binary blob and a length, with an associated key type.</span></span> <span data-ttu-id="b3993-617">キーの種類は、キーの種類 (例: RSA、ECC など) と形式 (例: PKCS # 1 DER など) によって異なります。</span><span class="sxs-lookup"><span data-stu-id="b3993-617">The key type depends on the type of key (e.g. RSA, ECC, etc.) and the format (e.g. PKCS#1 DER).</span></span> <span data-ttu-id="b3993-618">キーが指定されていない場合は、値 NX_SECURE_X509_KEY_TYPE_NONE (値 0x0) を渡して、キーが指定されていないことを示すことができます (データ パラメーターに長さ 0 の NX_NULL ポインターを指定すると同じ効果が得られます)。</span><span class="sxs-lookup"><span data-stu-id="b3993-618">If no key is supplied, the value NX_SECURE_X509_KEY_TYPE_NONE (value 0x0) can be passed to indicate no key is being supplied (a length of 0 and a NX_NULL pointer for the data parameter will achieve the same effect).</span></span>

<span data-ttu-id="b3993-619">次の表に、NetX Secure で認識されるキーの種類と、*nx_secure_x509_certificate_initialize* に渡される、関連付けられている種類の識別子を示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-619">The following table shows the key types known to NetX Secure and the associated type identifier to be passed into *nx_secure_x509_certificate_initialize*.</span></span> <span data-ttu-id="b3993-620">NetX Secure に追加される暗号化アルゴリズムが増えるにつれて、その他のキーの種類が追加されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-620">Additional key types will be added as more encryption algorithms are added to NetX Secure.</span></span>

| <span data-ttu-id="b3993-621">識別子</span><span class="sxs-lookup"><span data-stu-id="b3993-621">Identifier</span></span>                              | <span data-ttu-id="b3993-622">アルゴリズム</span><span class="sxs-lookup"><span data-stu-id="b3993-622">Algorithm</span></span> | <span data-ttu-id="b3993-623">Format</span><span class="sxs-lookup"><span data-stu-id="b3993-623">Format</span></span>   | <span data-ttu-id="b3993-624">Encoding</span><span class="sxs-lookup"><span data-stu-id="b3993-624">Encoding</span></span> | <span data-ttu-id="b3993-625">値</span><span class="sxs-lookup"><span data-stu-id="b3993-625">Value</span></span> |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| <span data-ttu-id="b3993-626">NX_SECURE_X509_KEY_TYPE_NONE</span><span class="sxs-lookup"><span data-stu-id="b3993-626">NX_SECURE_X509_KEY_TYPE_NONE</span></span>            | <span data-ttu-id="b3993-627">None</span><span class="sxs-lookup"><span data-stu-id="b3993-627">None</span></span>      | <span data-ttu-id="b3993-628">該当なし</span><span class="sxs-lookup"><span data-stu-id="b3993-628">N/A</span></span>      | <span data-ttu-id="b3993-629">該当なし</span><span class="sxs-lookup"><span data-stu-id="b3993-629">N/A</span></span>      | <span data-ttu-id="b3993-630">0x0</span><span class="sxs-lookup"><span data-stu-id="b3993-630">0x0</span></span>   |
| <span data-ttu-id="b3993-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span><span class="sxs-lookup"><span data-stu-id="b3993-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span></span>   | <span data-ttu-id="b3993-632">RSA</span><span class="sxs-lookup"><span data-stu-id="b3993-632">RSA</span></span>       | <span data-ttu-id="b3993-633">PKCS#1</span><span class="sxs-lookup"><span data-stu-id="b3993-633">PKCS#1</span></span>   | <span data-ttu-id="b3993-634">DER</span><span class="sxs-lookup"><span data-stu-id="b3993-634">DER</span></span>      | <span data-ttu-id="b3993-635">0x1</span><span class="sxs-lookup"><span data-stu-id="b3993-635">0x1</span></span>   |
| <span data-ttu-id="b3993-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span><span class="sxs-lookup"><span data-stu-id="b3993-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span></span>          | <span data-ttu-id="b3993-637">ECDSA</span><span class="sxs-lookup"><span data-stu-id="b3993-637">ECDSA</span></span>     | <span data-ttu-id="b3993-638">RFC 5915</span><span class="sxs-lookup"><span data-stu-id="b3993-638">RFC 5915</span></span> | <span data-ttu-id="b3993-639">DER</span><span class="sxs-lookup"><span data-stu-id="b3993-639">DER</span></span>      | <span data-ttu-id="b3993-640">0x2</span><span class="sxs-lookup"><span data-stu-id="b3993-640">0x2</span></span>   |

### <a name="user-defined-private-key-types"></a><span data-ttu-id="b3993-641">ユーザー定義の秘密キーの種類</span><span class="sxs-lookup"><span data-stu-id="b3993-641">User-defined private key types</span></span>

<span data-ttu-id="b3993-642">*nx_secure_x509_certificate_initialize* サービスのキーの種類の識別子の値によって、キーが指定されたときに実行されるアクションが制御されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-642">The values of the key type identifiers for the *nx_secure_x509_certificate_initialize* service govern the actions taken when the private key is supplied.</span></span> <span data-ttu-id="b3993-643">既知の種類の場合、値の範囲は 0x0000 0000 ～ 0x0000 FFFF (32 ビット符号なし整数の下位 16 ビット) です。</span><span class="sxs-lookup"><span data-stu-id="b3993-643">For known types, the values are in the range 0x0000 0000 – 0x0000 FFFF (bottom 16 bits of a 32-bit unsigned integer).</span></span> <span data-ttu-id="b3993-644">カスタム キーの種類<sup>17</sup> があるプラットフォームの場合 (一部のハードウェアベースの暗号化エンジンの場合と同様に)、範囲 0x0000 1000 ～ 0xFFFF FFFF (0 以外の上位 16 ビット) のユーザー定義のキーの種類を、キーの種類として渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-644">For platforms with custom key types<sup>17</sup> (as is the case for some hardware-based encryption engines), a user-defined key type in the range 0x0000 1000-0xFFFF FFFF (top 16 bits non-zero) may be passed as the key type.</span></span> <span data-ttu-id="b3993-645">キーの種類の上位 16 ビットのいずれかが設定されている場合、秘密キーのデータは、TLS 暗号スイート テーブルで指定されている適切な暗号化ルーチン (RSA など) に直接渡されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-645">If any of the top 16 bits of the key type are set, then the private key data is passed directly to the appropriate cryptographic routine (e.g. RSA) supplied in the TLS ciphersuite table.</span></span> <span data-ttu-id="b3993-646">ユーザー定義のキーの種類は、暗号化ルーチンに渡される前に、解析されたり他の方法で処理されたりすることはありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-646">User-defined key types are not parsed or otherwise processed before being passed to the cryptographic routine.</span></span> <span data-ttu-id="b3993-647">さらに、どのような適切な処理でもそのレベルで処理できるように、ユーザー定義のキーの種類も暗号化ルーチンに渡されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-647">In addition, the user-defined key type will also be passed to the cryptographic routine so that any appropriate processing can be handled at that level.</span></span>

<span data-ttu-id="b3993-648">ユーザー定義のキーの種類は、一般に、(おそらく暗号化された) カスタム キー データを利用する特定のハードウェア プラットフォームのために使用されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-648">Note that user-defined key types are generally used for specific hardware platforms that utilize custom (possibly encrypted) key data.</span></span> <span data-ttu-id="b3993-649">一般にこれは、そのハードウェア ベンダー (または、PKCS#11 のような標準の場合は 1 つの特定の標準) に固有のメカニズムを使用して、キー データの生成またはエンコードが行われることを意味します。</span><span class="sxs-lookup"><span data-stu-id="b3993-649">Generally this implies that the key data is generated or encoded using a mechanism specific to that hardware vendor (or in the case of a standard like PKCS#11, a specific standard).</span></span> <span data-ttu-id="b3993-650">詳細については、お使いのハードウェア プラットフォームのドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-650">Consult your hardware platform documentation for more information.</span></span>

17. <span data-ttu-id="b3993-651">ユーザー定義のキーの種類を使用するには、カスタム キーの形式を処理するために、対応するカスタム暗号化ルーチンが必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-651">User-defined key types require a corresponding custom cryptographic routine to handle the custom key format.</span></span> <span data-ttu-id="b3993-652">暗号化ルーチンには対応するアルゴリズム (RSA など) が備わっていて、暗号スイート テーブルで TLS に渡される必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-652">The cryptographic routine must have a matching algorithm (e.g. RSA) and be passed into TLS in the ciphersuite table.</span></span> 

### <a name="loading-certificates-onto-your-device"></a><span data-ttu-id="b3993-653">デバイスへの証明書の読み込み</span><span class="sxs-lookup"><span data-stu-id="b3993-653">Loading certificates onto your device</span></span>

<span data-ttu-id="b3993-654">証明書をインポートするのは、デバイスにファイルを読み込むどの方法でもかまいません。</span><span class="sxs-lookup"><span data-stu-id="b3993-654">Any method for loading a file onto your device will be sufficient to import your certificates.</span></span>

<span data-ttu-id="b3993-655">証明書を読み込む最も簡単な方法は、バイナリ DER でエンコードされたデータを C 配列に変換し、それを定数としてアプリケーション内にコンパイルすることです。</span><span class="sxs-lookup"><span data-stu-id="b3993-655">The simplest method for loading a certificate is to convert the binary DER-encoded data into a C array and compile it into your application as a constant.</span></span> <span data-ttu-id="b3993-656">これは、Linux の "xxd" などのツールで簡単に行うことができます ("-i" オプションを使用します)。</span><span class="sxs-lookup"><span data-stu-id="b3993-656">This can be easily done with tools such as "xxd" in Linux (with the "-i" option).</span></span>

<span data-ttu-id="b3993-657">または、証明書データへのポインターを NetX Secure API に渡すことができる限り、フラッシュ ファイル システムまたはその他のストレージ オプションに証明書を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-657">Alternatively, you can load your certificate into a flash filesystem or other storage options as long as you can pass a pointer to the certificate data into the NetX Secure API.</span></span>

### <a name="certificate-files-needed-for-netx-secure"></a><span data-ttu-id="b3993-658">NetX Secure に必要な証明書ファイル</span><span class="sxs-lookup"><span data-stu-id="b3993-658">Certificate files needed for NetX Secure</span></span>

<span data-ttu-id="b3993-659">インポートする必要がある証明書ファイルは、お使いのアプリケーションによって異なります。</span><span class="sxs-lookup"><span data-stu-id="b3993-659">The certificate files you will need to import depends on your application.</span></span> <span data-ttu-id="b3993-660">一般に、TLS サーバーにはデバイスを識別するための証明書が必要で、TLS クライアントには、リモート サーバーを認証するための "*信頼された証明書*" が 1 つ以上必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-660">In general, TLS Servers require a certificate to identify the device, and TLS Clients require one or more *Trusted Certificates* to authenticate remote servers.</span></span> <span data-ttu-id="b3993-661">次の表に、いくつかの異なる TLS アプリケーションに必要な証明書を示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-661">The following table illustrates certificates needed for some different TLS applications.</span></span>

| <span data-ttu-id="b3993-662">**TLS の機能/オプション**</span><span class="sxs-lookup"><span data-stu-id="b3993-662">**TLS functionality/options**</span></span>                     | <span data-ttu-id="b3993-663">**必要な証明書/キー (最小限)**</span><span class="sxs-lookup"><span data-stu-id="b3993-663">**Certificates/keys needed (minimum)**</span></span>              |
| ------------------------------------------------- | --------------------------------------------------- |
| <span data-ttu-id="b3993-664">TLS クライアント</span><span class="sxs-lookup"><span data-stu-id="b3993-664">TLS Client</span></span>                                        | <span data-ttu-id="b3993-665">ルート CA 証明書</span><span class="sxs-lookup"><span data-stu-id="b3993-665">Root CA certificate</span></span>                                 |
| <span data-ttu-id="b3993-666">TLS サーバー</span><span class="sxs-lookup"><span data-stu-id="b3993-666">TLS Server</span></span>                                        | <span data-ttu-id="b3993-667">ローカル証明書、その証明書の秘密キー</span><span class="sxs-lookup"><span data-stu-id="b3993-667">Local certificate, private key for that certificate</span></span> |
| <span data-ttu-id="b3993-668">クライアント証明書認証を行う TLS サーバー</span><span class="sxs-lookup"><span data-stu-id="b3993-668">TLS Server with Client Certificate Authentication</span></span> | <span data-ttu-id="b3993-669">ローカル証明書、秘密キー、ルート CA</span><span class="sxs-lookup"><span data-stu-id="b3993-669">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="b3993-670">クライアント証明書認証を行う TLS クライアント</span><span class="sxs-lookup"><span data-stu-id="b3993-670">TLS Client with Client Certificate Authentication</span></span> | <span data-ttu-id="b3993-671">ローカル証明書、秘密キー、ルート CA</span><span class="sxs-lookup"><span data-stu-id="b3993-671">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="b3993-672">事前共有キーのみを使用する TLS クライアントまたはサーバー</span><span class="sxs-lookup"><span data-stu-id="b3993-672">TLS Client or Server with Pre-Shared Keys only</span></span>    | <span data-ttu-id="b3993-673">なし (証明書の代わりに PSK が使用される)</span><span class="sxs-lookup"><span data-stu-id="b3993-673">None (PSK used instead of certificates)</span></span>             |

<span data-ttu-id="b3993-674">証明書の読み込みに関連するサービスは以下のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b3993-674">The relevant services for loading certificates are as follows:</span></span>

| <span data-ttu-id="b3993-675">**[API Name]\(アプリ名\)**</span><span class="sxs-lookup"><span data-stu-id="b3993-675">**API Name**</span></span>                                   | <span data-ttu-id="b3993-676">**目的**</span><span class="sxs-lookup"><span data-stu-id="b3993-676">**Purpose**</span></span>                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| <span data-ttu-id="b3993-677">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="b3993-677">nx_secure_x509_certificate_initialize</span></span>      | <span data-ttu-id="b3993-678">証明書データと秘密キーを使用して NX_SECURE_X509_CERT 構造体にデータを格納するため、すべての証明書に対してを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-678">Must be called for all certificates to populate the NX_SECURE_X509_CERT structure with your certificate data and private key.</span></span> |
| <span data-ttu-id="b3993-679">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="b3993-679">nx_secure_tls_local_certificate_add</span></span>       | <span data-ttu-id="b3993-680">デバイスを識別するためにローカル証明書を TLS セッションに追加します。</span><span class="sxs-lookup"><span data-stu-id="b3993-680">Add a local certificate to a TLS session to identify your device.</span></span>                                                                |
| <span data-ttu-id="b3993-681">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="b3993-681">nx_secure_tls_local_certificate_remove</span></span>    | <span data-ttu-id="b3993-682">TLS セッションからローカル証明書を削除します。</span><span class="sxs-lookup"><span data-stu-id="b3993-682">Remove a local certificate from a TLS session.</span></span>                                                                                   |
| <span data-ttu-id="b3993-683">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="b3993-683">nx_secure_tls_remote_certificate_allocate</span></span> | <span data-ttu-id="b3993-684">(初期化されていない NX_SECURE_X509_CERT を使用して呼び出される) リモート証明書用の領域を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="b3993-684">Allocate space for a remote certificate (called with an uninitialized NX_SECURE_X509_CERT).</span></span>                                   |
| <span data-ttu-id="b3993-685">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="b3993-685">nx_secure_tls_trusted_certificate_add</span></span>     | <span data-ttu-id="b3993-686">リモート ホストを認証するための信頼された証明書として、TLS セッションに証明書を追加します。</span><span class="sxs-lookup"><span data-stu-id="b3993-686">Add a certificate to a TLS Session as a Trusted Certificate for authenticating remote hosts.</span></span>                                     |
| <span data-ttu-id="b3993-687">nx_secure_tls_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="b3993-687">nx_secure_tls_trusted_certificate_remove</span></span>  | <span data-ttu-id="b3993-688">TLS セッションから信頼された証明書を削除します。</span><span class="sxs-lookup"><span data-stu-id="b3993-688">Remove a trusted certificate from a TLS Session.</span></span>                                                                                 |

### <a name="working-with-aws-iot-certificates"></a><span data-ttu-id="b3993-689">AWS IoT 証明書の操作</span><span class="sxs-lookup"><span data-stu-id="b3993-689">Working with AWS IoT Certificates</span></span>

<span data-ttu-id="b3993-690">アマゾン ウェブ サービスの IoT インターフェイスで、サイドバー メニューから [セキュリティ] を選択し、[証明書] を選択します。</span><span class="sxs-lookup"><span data-stu-id="b3993-690">In the Amazon Web Services IoT interface, select "Security" from the sidebar menu and select "Certificates".</span></span> <span data-ttu-id="b3993-691">新しい証明書を作成し、指示に従って新しいデバイス証明書をダウンロードします。</span><span class="sxs-lookup"><span data-stu-id="b3993-691">Create a new certificate and follow the instructions to download your new device certificate.</span></span>

<span data-ttu-id="b3993-692">証明書をダウンロードしたら、OpenSSL または同様のユーティリティを使用して、それらを DER 形式に変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-692">Once you have downloaded your certificates, you will need to convert them into DER format using OpenSSL or a similar utility.</span></span>

<span data-ttu-id="b3993-693">注: AWS では公開キー ファイルも提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-693">NOTE: AWS will also provide a public key file.</span></span> <span data-ttu-id="b3993-694">公開キーは、ローカル デバイス証明書に含まれているので、アプリケーションにインポートする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-694">The public key is contained within the local device certificate so it does not need to be imported into your application.</span></span>

<span data-ttu-id="b3993-695">例として、NetX Secure で使用するために、ローカル デバイス証明書とその秘密キーを DER 形式に変換するコマンドを次に示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-695">As an example, here are the commands to convert the local device certificate and its private key into DER format for use with NetX Secure:</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
<span data-ttu-id="b3993-696">変換されたファイルは、上の手順に従ってアプリケーションにインポートできます。</span><span class="sxs-lookup"><span data-stu-id="b3993-696">The converted files can be imported into your application following the above instructions.</span></span>

## <a name="x509-certificate-validation-in-netx-secure"></a><span data-ttu-id="b3993-697">NetX Secure での X.509 証明書の検証</span><span class="sxs-lookup"><span data-stu-id="b3993-697">X.509 Certificate Validation in NetX Secure</span></span> 

<span data-ttu-id="b3993-698">ホストの識別と検証のために X.509 証明書と TLS を使用する場合、それらの証明書が実際にどのように検証されるかを理解しておくことが重要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-698">When using TLS with X.509 certificates for host identification and verification, it is important to understand how those certificates are actually validated.</span></span> <span data-ttu-id="b3993-699">TLS 仕様には、証明書の検証方法に関する詳細な手順は記載されていませんが、X.509 仕様 (RFC 5280) が参照されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-699">While the TLS specification does not provide detailed instructions on how to validate a certificate, it does refer to the X.509 specification (RFC 5280).</span></span> <span data-ttu-id="b3993-700">一般に、TLS では、受信する証明書 (TLS ハンドシェイク中にリモート ホストによって提供される証明書) に対して少なくとも基本的な検証を実行することが予期されていて、それは NetX Secure TLS でも同様です。</span><span class="sxs-lookup"><span data-stu-id="b3993-700">In general, it is expected that TLS will perform at least basic validation on incoming certificates (those certificates supplied by the remote host during the TLS handshake), and NetX Secure TLS is no different.</span></span>

### <a name="basic-x509-validation"></a><span data-ttu-id="b3993-701">基本的な X.509 検証</span><span class="sxs-lookup"><span data-stu-id="b3993-701">Basic X.509 Validation</span></span>

<span data-ttu-id="b3993-702">受信するすべての証明書について、NetX Secure TLS では基本的な X.509 パス検証が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-702">For any incoming certificate, NetX Secure TLS will perform basic X.509 path validation.</span></span> <span data-ttu-id="b3993-703">このプロセスでは、各証明書のデジタル署名の確認が、リモート ホストによって提供されたか、信頼された証明書ストアに置かれている可能性がある、発行者の証明書に対して行われます (信頼された証明書をインポートすることの詳細については、「X.509 証明書の NetX Secure へのインポート」のセクションを参照)。</span><span class="sxs-lookup"><span data-stu-id="b3993-703">The process involves checking each certificate's digital signature against its issuer certificate, which may be provided by the remote host or be located in the trusted certificate store (see the section "Importing X.509 certificates into NetX Secure" for more information on importing trusted certificates).</span></span> <span data-ttu-id="b3993-704">検証プロセスは、信頼された証明書に到達するか、チェーンが終了する (自己署名証明書があるか、発行者証明書がない状態) まで、発行者の証明書に対して再帰的に繰り返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-704">The validation process is recursively repeated on the issuer certificates until a trusted certificate is reached or the chain ends (with a self-signed certificate or a missing issuer certificate).</span></span> <span data-ttu-id="b3993-705">信頼された証明書に到達した場合、証明書は検証されますが、それ以外の場合は拒否されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-705">If a trusted certificate is reached, the certificate is verified, otherwise it is rejected.</span></span> <span data-ttu-id="b3993-706">さらに、検証プロセスの各段階で、アプリケーションのタイムスタンプ関数によって提供された時間に対して、各証明書の有効期限日がチェックされます (詳細についてはサービス "nx_secure_tls_session_time_function_set" を参照)。</span><span class="sxs-lookup"><span data-stu-id="b3993-706">Additionally, at each stage in the verification process the expiration date of each certificate is checked against the time provided by the application timestamp function (see the service "nx_secure_tls_session_time_function_set" for more information).</span></span>

<span data-ttu-id="b3993-707">X.509 仕様には、"ポリシー" をサポートするためのアルゴリズムも用意されています。これは、パスの検証中にチェックすることができる、X.509 拡張機能に存在する識別子です。</span><span class="sxs-lookup"><span data-stu-id="b3993-707">The X.509 specification also provides an algorithm for supporting "policies", which are identifiers that are present in an X.509 extension that can be checked during path validation.</span></span> <span data-ttu-id="b3993-708">NetX Secure では、現在のところ、"anyPolicy" オプションが定義されているかのように X.509 証明書を処理します。つまり、すべてのポリシーが受け入れられ、オプションのポリシー チェックは実行されません。</span><span class="sxs-lookup"><span data-stu-id="b3993-708">NetX Secure currently treats X.509 certificates as though the "anyPolicy" option is defined – that is, all policies are acceptable and the optional policy checking is not performed.</span></span> <span data-ttu-id="b3993-709">NetX Secure X.509 の実装は、今後のリリースでこの機能が導入されて強化される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-709">The NetX Secure X.509 implementation may be augmented with this feature in a future release.</span></span> <span data-ttu-id="b3993-710">現時点では、ポリシー拡張機能は *nx_secure_x509_extension_find* API を使用して証明書から取得することができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-710">For now, the policy extension may be obtained from a certificate using the *nx_secure_x509_extension_find* API.</span></span>

<span data-ttu-id="b3993-711">基本パスの検証が完了すると、TLS では、*nx_secure_tls_session_certificate_callback_set* API を使用して、アプリケーションによって提供される証明書の検証コールバックが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-711">Once the basic path validation is complete, TLS will invoke the certificate verification callback supplied by the application using the *nx_secure_tls_session_certificate_callback_set* API.</span></span> <span data-ttu-id="b3993-712">コールバックが指定されていない場合、パスの検証に成功した後の証明書は、信頼されていると見なされます。</span><span class="sxs-lookup"><span data-stu-id="b3993-712">If no callback is supplied, the certificate is considered to be trusted following successful path validation.</span></span> <span data-ttu-id="b3993-713">コールバックが指定されている場合は、アプリケーションに要求されている追加の証明書の検証があれば、コールバックによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-713">If a callback is supplied, the callback will perform any additional validation of the certificate required by the application.</span></span> <span data-ttu-id="b3993-714">コールバックからの戻り値は、TLS ハンドシェイクを続行するか、検証エラーが原因でハンドシェイクを中止するかを決めるために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-714">The return value from the callback is used to determine whether to continue with the TLS handshake or to abort the handshake due to a validation failure.</span></span>

<span data-ttu-id="b3993-715">コールバックは、関連する TLS セッションへのポインターと、検証する証明書への NX_SECURE_X509_CERT ポインターを使用して呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-715">The callback is invoked with a pointer to the relevant TLS session and an NX_SECURE_X509_CERT pointer to the certificate to be validated.</span></span> <span data-ttu-id="b3993-716">追加の検証チェックを実行するために必要な TLS からのすべてのデータは、TLS セッションと証明書の間のアプリケーションに置かれています。</span><span class="sxs-lookup"><span data-stu-id="b3993-716">Between the TLS session and the certificate, the application has all of the data it needs from TLS to perform additional verification checks.</span></span>

<span data-ttu-id="b3993-717">NetX Secure では、追加の検証の助けになるように、DNS の検証や証明書失効リストのチェックなど、いくつかの一般的な検証操作のための X.509 ルーチンが提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-717">To help with the additional validation, NetX Secure provides X.509 routines for some common validation operations, including DNS validation and Certificate Revocation List checking.</span></span> <span data-ttu-id="b3993-718">これらのルーチンはすべて、証明書の検証コールバック内での使用に適していますが、X.509 証明書のオフライン チェックを実行するためにも使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-718">All of these routines are suitable for use within the certificate verification callback but may also be used to perform off-line checking of X.509 certificates.</span></span>

<span data-ttu-id="b3993-719">次の表は、X.509 証明書の処理に使用できるヘルパー関数をまとめたものです。</span><span class="sxs-lookup"><span data-stu-id="b3993-719">The following table summarizes the available helper functions for X.509 certificate processing.</span></span> <span data-ttu-id="b3993-720">操作に関する詳細な説明については、後続のセクションと、第 4 章の API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-720">More detailed explanations for the operations can be found in the following sections and the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="b3993-721">NetX Secure サービスの説明に、特定のルーチンに関する追加の詳細が記載されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-721">Description of NetX Secure Services provides additional details on the specific routines.</span></span>

| <span data-ttu-id="b3993-722">**[API Name]\(アプリ名\)**</span><span class="sxs-lookup"><span data-stu-id="b3993-722">**API Name**</span></span>                             | <span data-ttu-id="b3993-723">**説明**</span><span class="sxs-lookup"><span data-stu-id="b3993-723">**Description**</span></span>                               |
| ---------------------------------------- | -------------------------------------- |
| <span data-ttu-id="b3993-724">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="b3993-724">nx_secure_x509_common_name_dns_check</span></span>               | <span data-ttu-id="b3993-725">X.509 サブジェクトの共通名と SubjectAltName を、必要な DNS 名に対して確認します</span><span class="sxs-lookup"><span data-stu-id="b3993-725">Check the X.509 subject Common Name and SubjectAltName against an expected DNS name</span></span> |
| <span data-ttu-id="b3993-726">nx_secure_x509_crl_revocation_check</span><span class="sxs-lookup"><span data-stu-id="b3993-726">nx_secure_x509_crl_revocation_check</span></span>                 | <span data-ttu-id="b3993-727">X.509 証明書失効リスト (CRL) に失効した証明書があるかどうかを確認します</span><span class="sxs-lookup"><span data-stu-id="b3993-727">Check for a revoked certificate in an X.509 Certificate Revocation List (CRL)</span></span>       |
| <span data-ttu-id="b3993-728">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="b3993-728">nx_secure_x509_extended_key_usage_extension_parse</span></span> | <span data-ttu-id="b3993-729">証明書内の特定の拡張キー使用法 OID を解析し、見つけます</span><span class="sxs-lookup"><span data-stu-id="b3993-729">Parse and find a specific extended key usage OID in a certificate</span></span>                   |
| <span data-ttu-id="b3993-730">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="b3993-730">nx_secure_x509_key_usage_extension_parse</span></span>           | <span data-ttu-id="b3993-731">証明書内のキー使用法のビットフィールドを解析して返します</span><span class="sxs-lookup"><span data-stu-id="b3993-731">Parse and return the key usage bitfield in a certificate</span></span>                            |
| <span data-ttu-id="b3993-732">nx_secure_x509_extension_find</span><span class="sxs-lookup"><span data-stu-id="b3993-732">nx_secure_x509_extension_find</span></span>                        | <span data-ttu-id="b3993-733">特定の拡張機能の、DER でエンコードされた ASN.1 RAW データを見つけて返します。</span><span class="sxs-lookup"><span data-stu-id="b3993-733">Find and return the raw DER-encoded ASN.1 data for a specific extension.</span></span>            |

<span data-ttu-id="b3993-734">証明書の検証コールバックで使用するための X.509 ヘルパー関数</span><span class="sxs-lookup"><span data-stu-id="b3993-734">X.509 helper functions for use in the certificate verification callback</span></span>

### <a name="x509-extensions"></a><span data-ttu-id="b3993-735">X.509 の拡張機能</span><span class="sxs-lookup"><span data-stu-id="b3993-735">X.509 Extensions</span></span>

<span data-ttu-id="b3993-736">X.509 仕様では、証明書の検証で利用できる追加情報を提供するために使用できる、いくつかの "拡張機能" について説明しています。</span><span class="sxs-lookup"><span data-stu-id="b3993-736">The X.509 specification describes a number of "extensions" that can be used to supply additional information that can be utilized in the verification of certificates.</span></span> <span data-ttu-id="b3993-737">ほとんどの場合、これらの拡張機能は省略可能であり、信頼されたルート証明書に対して、デジタル証明書のセキュリティで保護された検証を行うために要求なものではありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-737">For the most part, these extensions are optional and are not required for secure validation of a digital certificate against a trusted root certificate.</span></span> <span data-ttu-id="b3993-738">ただし、NetX Secure で実際に、いくつかの基本的な拡張機能がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b3993-738">However, NetX Secure does support some basic extensions.</span></span> <span data-ttu-id="b3993-739">今後のリリースで、その他の拡張機能のサポートが追加される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-739">Support for additional extensions may be added in future releases.</span></span>

<span data-ttu-id="b3993-740">次の表に、現在サポートされている拡張機能の一覧を示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-740">The currently supported extensions are listed in the following table:</span></span>

| <span data-ttu-id="b3993-741">拡張機能の名前</span><span class="sxs-lookup"><span data-stu-id="b3993-741">Extension Name</span></span>           | <span data-ttu-id="b3993-742">説明</span><span class="sxs-lookup"><span data-stu-id="b3993-742">Description</span></span>                                                                   | <span data-ttu-id="b3993-743">関連 API</span><span class="sxs-lookup"><span data-stu-id="b3993-743">Relevant API</span></span>                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| <span data-ttu-id="b3993-744">キー使用法</span><span class="sxs-lookup"><span data-stu-id="b3993-744">Key Usage</span></span>                | <span data-ttu-id="b3993-745">ビットフィールドの証明書の公開キーに対して許容される使用法を提供します</span><span class="sxs-lookup"><span data-stu-id="b3993-745">Provides acceptable uses for a certificate's public key in a bitfield</span></span>         | <span data-ttu-id="b3993-746">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="b3993-746">nx_secure_x509_key_usage_extension_parse</span></span>           |
| <span data-ttu-id="b3993-747">拡張キー使用法</span><span class="sxs-lookup"><span data-stu-id="b3993-747">Extended Key Usage</span></span>       | <span data-ttu-id="b3993-748">OID を使用した証明書の公開キーのための、許容される追加の使用法を提供します</span><span class="sxs-lookup"><span data-stu-id="b3993-748">Provides additional acceptable uses for a certificate's public key using OIDs</span></span> | <span data-ttu-id="b3993-749">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="b3993-749">nx_secure_x509_extended_key_usage_extension_parse</span></span> |
| <span data-ttu-id="b3993-750">サブジェクト代替名</span><span class="sxs-lookup"><span data-stu-id="b3993-750">Subject Alternative Name</span></span> | <span data-ttu-id="b3993-751">証明書によっても表現される代替 DNS 名を提供します</span><span class="sxs-lookup"><span data-stu-id="b3993-751">Provides alternative DNS names that are also represented by the certificate</span></span>   | <span data-ttu-id="b3993-752">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="b3993-752">nx_secure_x509_common_name_dns_check</span></span>               |

### <a name="unsupported-x509-extensions"></a><span data-ttu-id="b3993-753">サポートされていない X.509 拡張機能</span><span class="sxs-lookup"><span data-stu-id="b3993-753">Unsupported X.509 Extensions</span></span>

<span data-ttu-id="b3993-754">NetX Secure の X.509 実装では、サポートされていない拡張機能を抽出するサービスに加えて、*nx_secure_x509_extension_find* が提供されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-754">NetX Secure's X.509 implemenation does provide a service to extract unsupported extensions as well: *nx_secure_x509_extension_find*.</span></span> <span data-ttu-id="b3993-755">この API は、返されたデータを解析するために、DER でエンコードされた ASN.1 の知識が必要なため、上級ユーザーを対象としています。</span><span class="sxs-lookup"><span data-stu-id="b3993-755">This API is intended for advanced users as it requires knowledge of DER-encoded ASN.1 in order to parse the data returned.</span></span> <span data-ttu-id="b3993-756">これは、サポートされている拡張機能を抽出するために内部的に使用されますが、X.509 拡張機能のカスタマイズしたサポートを開発する際に便利なように提供されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-756">It it used internally to extract supported extensions but is supplied for convenience in developing customized support for X.509 extensions.</span></span>

<span data-ttu-id="b3993-757">nx_secure_x509_extension_find を使用するために、証明書や拡張機能 ID と一緒に、NX_SECURE_X509_EXTENSION が渡されます。これは、既知の拡張機能の種類を表す可変長の OID 文字列を整数で表したものです。</span><span class="sxs-lookup"><span data-stu-id="b3993-757">To use nx_secure_x509_extension_find, a NX_SECURE_X509_EXTENSION is passed in, along with the certificate and an extension ID, which is an integer representation of the variable-length OID string for a known extension type.</span></span> <span data-ttu-id="b3993-758">X.509 拡張機能でサポートされている OID の完全な一覧は、API リファレンスの 178 ページ、nx_secure_x509_extension_find に記載されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-758">A complete list of supported OIDs for X.509 extensions is provided in the API reference for nx_secure_x509_extension_find on page 178.</span></span>

<span data-ttu-id="b3993-759">NX_SECURE_X509_EXTENSION 構造体は次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-759">The NX_SECURE_X509_EXTENSION structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
<span data-ttu-id="b3993-760">サービスが正常に返されると、証明書の関連データが構造体に格納されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-760">When the service returns successfully, the structure will be populated with the relevant data from the certificate.</span></span> <span data-ttu-id="b3993-761">nx_secure_x509_extension_id フィールドは、一般に内部的な目的で使用されますが、関連する OID 整数表現が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-761">The nx_secure_x509_extension_id field is generally used for internal purposes but will be populated with the relevant OID integer representation.</span></span> <span data-ttu-id="b3993-762">nx_secure_x509_extension_critical フィールドでは、X.509 拡張機能の重要性を示すフラグ値 (ブール値) が公開されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-762">The nx_secure_x509_extension_critical field exposes the X.509 critical extension flag value (Boolean).</span></span> <span data-ttu-id="b3993-763">nx_secure_x509_extension_data および nx_secure_x509_extension_data_length の各フィールドには、それぞれ、DER でエンコードされた拡張機能用の ASN.1 データへのポインターと、そのデータの長さが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-763">The nx_secure_x509_extension_data and nx_secure_x509_extension_data_length fields contain a pointer to the DER-encoded ASN.1 data for the extension, and the length of that data, respectively.</span></span>

<span data-ttu-id="b3993-764">拡張機能の ASN.1 データの実際の解析は、このドキュメントの範囲を超えていますが、NetX Secure TLS ソースにアクセスできる場合は、サポートされている拡張機能に対して nx_secure_x509_extension_find が呼び出されるすべての場所で、解析がどのように行われるかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-764">Actual parsing of the extension ASN.1 data is beyond the scope of this document, but if you have access to the NetX Secure TLS source you can see how the parsing is done wherever nx_secure_x509_extension_find is called for supported extensions.</span></span>

### <a name="x509-dns-validation"></a><span data-ttu-id="b3993-765">X.509 の DNS 検証</span><span class="sxs-lookup"><span data-stu-id="b3993-765">X.509 DNS Validation</span></span>

<span data-ttu-id="b3993-766">TLS での一般的な証明書の検証操作では、TLS ハンドシェイク中に、そのホストによって提供された X.509 証明書に対して、リモート ホストのトップレベル ドメイン (TLD) 名を確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-766">A common certificate validation operation in TLS involves checking the Top-Level Domain (TLD) name of a remote host against the X.509 certificate provided by that host during the TLS handshake.</span></span> <span data-ttu-id="b3993-767">この操作は、DNS 参照が信頼できるという前提で、証明書が、それを提供したホスト サーバーと確かに一致していることを確認するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="b3993-767">This operation helps to ensure that the certificate does indeed match the host server that provided it, assuming the DNS lookup can be trusted.</span></span> <span data-ttu-id="b3993-768">NetX Secure TLS では、この機能はサービス **nx_secure_x509_common_name_dns_check** によって提供されます。これは、証明書と、ホストへのアクセスに使用される URL の TLD の部分を含む文字列を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="b3993-768">In NetX Secure TLS, this functionality is provided by the service **nx_secure_x509_common_name_dns_check**, which takes the certificate and a string containing the TLD portion of the URL used to access the host.</span></span> <span data-ttu-id="b3993-769">TLD は証明書の共通名フィールドと比較されて、一致する場合は NX_SUCCESS が返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-769">The TLD is compared to the certificate's Common Name field and if it matches, NX_SUCCESS is returned.</span></span> <span data-ttu-id="b3993-770">共通名が一致しない場合、ルーチンでは、X.509 証明書拡張機能 *subjectAltName* が存在するかどうかの確認も行われます。</span><span class="sxs-lookup"><span data-stu-id="b3993-770">If the Common Name does not match, the routine will also check for the existence of the X.509 certificate extension *subjectAltName*.</span></span> <span data-ttu-id="b3993-771">subjectAltName が存在する場合は、指定された TLD に対して、拡張機能内のすべての DNSName エントリも確認されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-771">If a subjectAltName is present, any DNSName entries in the extension are also checked against the provided TLD.</span></span> <span data-ttu-id="b3993-772">この場合も、一致する場合は NX_SUCCESS が返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-772">Again, if any match, NX_SUCCESS is returned.</span></span> <span data-ttu-id="b3993-773">一致するものが見つからない場合は、証明書検証コールバックから返すのに適したエラーが返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-773">If no match is found, an error suitable for returning from the certificate validation callback is returned.</span></span>

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a><span data-ttu-id="b3993-774">X.509 キー使用法拡張機能と拡張キー使用法拡張機能</span><span class="sxs-lookup"><span data-stu-id="b3993-774">X.509 Key Usage and Extended Key Usage Extensions</span></span>

<span data-ttu-id="b3993-775">X.509 キー使用法拡張機能と拡張キー使用法拡張機能では、証明書の認証時に証明書の公開キーを使用可能にする方法についての情報が提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-775">The X.509 Key Usage and Extended Key Usage extensions provide information on how a certificate's public key may be used when authenticating that certificate.</span></span> <span data-ttu-id="b3993-776">キー使用法は、証明書の署名と発行が行われるときに証明書の発行者によって提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-776">The key usage is supplied by the certificate's issuer when the certificate is signed and issued.</span></span> <span data-ttu-id="b3993-777">キー使用法を TLS ホストで使用すると、リモート TLS ホストを認証してその他の操作を実行するために、その証明書の利用が認められていることを確認できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-777">The key usage may be used by a TLS host to check that the certificate is authorized to be used to authenticate a remote TLS host and perform other operations.</span></span>

<span data-ttu-id="b3993-778">キー使用法拡張機能は、各ビットが特定のキーの使用法を表す単純なビットフィールドで構成されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-778">The Key Usage extension consists of a simple bitfield where each of the bits represents a specific key usage.</span></span> <span data-ttu-id="b3993-779">これらの値の完全な一覧は、API リファレンスの 183 ページ、*nx_secure_x509_key_usage_extension_parse* に記載されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-779">A complete list of these values is provided in the API reference for *nx_secure_x509_key_usage_extension_parse* on page 183.</span></span> <span data-ttu-id="b3993-780">キー使用法におけるビットとそれらの意味のより完全な説明については、RFC 5280 のセクション 4.2.1.3 を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-780">For a more complete description of the key usage bits and their meanings, refer to RFC 5280, section 4.2.1.3.</span></span>

<span data-ttu-id="b3993-781">キー使用法拡張機能と同様に、拡張キー使用拡張機能では、許容されるキーの使用に関する情報が提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-781">The Extended Key Usage extension, like the Key Usage extension, provides acceptable key use information.</span></span> <span data-ttu-id="b3993-782">ただし、任意の使用法をサポートするために、拡張キー使用法拡張機能では、ビットフィールドではなく OID が利用されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-782">However, in order to support arbitrary usages, the Extended Key Usage extension utilizes OIDs instead of a bitfield.</span></span> <span data-ttu-id="b3993-783">NetX Secure X.509 の拡張キー使用法拡張機能を解析するときには、OID を表す整数がアプリケーションから提供されます。その後、*nx_secure_x509_extended_key_usage_extension_parse* サービスから、その OID が存在するかどうかが返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-783">When parsing an Extended Key Usage extension in NetX Secure X.509, an integer representing the OID is supplied by the application – the *nx_secure_x509_extended_key_usage_extension_parse* service will then return whether that OID is present.</span></span> <span data-ttu-id="b3993-784">拡張キー使用法でサポートされている OID の完全な一覧は、API リファレンス 175 ページの *nx_secure_x509_extended_key_usage_extension_parse* に記載されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-784">A complete list of supported OIDs for Extended Key usage is provided in the API reference for *nx_secure_x509_extended_key_usage_extension_parse* on page 175.</span></span> <span data-ttu-id="b3993-785">OID とそれらの意味のより完全な説明については、RFC 5280 のセクション 4.2.1.12 を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-785">For a more complete description of the OIDs and their meanings, refer to RFC 5280, section 4.2.1.12.</span></span>

### <a name="x509-crl-revocation-status-checking"></a><span data-ttu-id="b3993-786">X.509 CRL 失効状態チェック</span><span class="sxs-lookup"><span data-stu-id="b3993-786">X.509 CRL Revocation Status Checking</span></span>

<span data-ttu-id="b3993-787">X.509 では、デジタル証明書署名機関が、署名した証明書の有効性を失効させることを可能にする、"*証明書失効リスト*" (CRL) と呼ばれるメカニズムが提供されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-787">X.509 provides a mechanism called the *Certificate Revocation List* (CRL) that allows a digital certificate signing authority to revoke the validity of certificates it has signed.</span></span> <span data-ttu-id="b3993-788">署名機関からの証明書を検証する必要があるどのアプリケーションでも、CRL を取得し、その機関 (発行者) によって署名された任意の証明書を CRL に対して比較して、何らかの理由 (秘密キーが侵害されたなど) で証明書の状態が失効しているかどうかを確認することができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-788">Any application that needs to verify certificates from a signing authority can obtain a CRL and compare any certificates signed by that authority (issuer) against the CRL to see if they have had their status revoked for some reason (such as compromised private key).</span></span> <span data-ttu-id="b3993-789">アプリケーションでは、このようにして、証明書の他の検証チェックに合格するおそれがある危険な証明書の使用を回避できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-789">In this way, the application can avoid using potentially dangerous certificates that pass other certificate validation checks.</span></span>

<span data-ttu-id="b3993-790">DER でエンコードされたリストを、事前に定義されたサーバーから、または他の何からの方法を通してダウンロードすることによって、アプリケーションで CRL の取得が行われます。</span><span class="sxs-lookup"><span data-stu-id="b3993-790">Obtaining a CRL is done by an application by downloading the DER-encoded list from a pre-defined server or through some other means.</span></span> <span data-ttu-id="b3993-791">実際の設定は発行者によって異なるため、NetX Secure には CRL 取得用のメカニズムは用意されていませんが、CRL に対して証明書をチェックするルーチン **nx_secure_x509_crl_revocation_check** が用意されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-791">The actual setup varies from issuer to issuer so NetX Secure does not provide a mechanism for obtaining CRLs, but it does provide a routine to check a certificate against a CRL, **nx_secure_x509_crl_revocation_check**.</span></span>

<span data-ttu-id="b3993-792">この API は、DER でエンコードされた CRL、チェックの基準となる証明書ストア (TLS セッション内のものなど)、確認する証明書を取ります。</span><span class="sxs-lookup"><span data-stu-id="b3993-792">The API takes a DER-encoded CRL, a certificate store (such as the one in a TLS session) to check against, and the certificate to be checked.</span></span> <span data-ttu-id="b3993-793">ルーチンでは、まず、信頼されたストア (アプリケーションによって提供された証明書ストアの一部) に対して CRL を検証します。</span><span class="sxs-lookup"><span data-stu-id="b3993-793">The routine first validates the CRL itself against the trusted store (part of the certificate store provided by the application).</span></span> <span data-ttu-id="b3993-794">これが重要なのは、サービス拒否攻撃に使用されている不正な CRL からの保護を行い、その CRL が実際に適切な発行者からのものであることを確証するためです。</span><span class="sxs-lookup"><span data-stu-id="b3993-794">This is important to protect against fraudulent CRLs being used for Denial-of-Service attacks and establishes that the CRL is actually from the proper issuer.</span></span> <span data-ttu-id="b3993-795">CRL の検証に続き、発行者がチェックされます。CRL の発行者が証明書の発行者と一致しない場合、CRL はその証明書に対して無効であり、エラーが返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-795">Following the CRL validation, the issuer is checked – if the issuer of the CRL does not match the issuer of the certificate, then the CRL is not valid for that certificate and an error is returned.</span></span> <span data-ttu-id="b3993-796">この時点で TLS ハンドシェイクを続行できるかどうかの決定は、アプリケーションで行います。</span><span class="sxs-lookup"><span data-stu-id="b3993-796">It is up to the application to determine whether the TLS handshake can continue at this point.</span></span> <span data-ttu-id="b3993-797">発行者が確かに一致する場合は、その CRL で、検証対象の証明書のシリアル番号が検索されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-797">If the issuers do match, then the CRL is searched for the serial number of the certificate being validated.</span></span> <span data-ttu-id="b3993-798">そのシリアル番号がリストにある場合は、証明書が失効したことを示すエラーが返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-798">If the serial number is present in the list, an error indicating that the certificate has been revoked is returned.</span></span> <span data-ttu-id="b3993-799">一致が見つからない場合は、NX_SUCCESS が返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-799">If no match is found, NX_SUCCESS is returned.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="b3993-800">NetX Secure TLS でのクライアント証明書の認証</span><span class="sxs-lookup"><span data-stu-id="b3993-800">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="b3993-801">X.509 証明書認証を使用する場合、TLS プロトコルでは、TLS サーバー インスタンスから ID の証明書が提供される必要がありますが、既定では、TLS クライアント インスタンスから認証用の証明書を提供する必要はありません。その代わりに、別の形式の認証 (ユーザー名とパスワードの組み合わせなど) が使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-801">When using X.509 certificate authentication, the TLS protocol requires that the TLS Server instance provide a certificate for identification, but by default the TLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="b3993-802">これは、インターネットでの、Web サイト向けの最も一般的な TLS の使用法に合致しています。</span><span class="sxs-lookup"><span data-stu-id="b3993-802">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="b3993-803">たとえばオンライン小売サイトでは、Web ブラウザーを使用している潜在顧客に、サーバーが正当なものであることを証明する必要がありますが、ユーザーはログインとパスワードを使用して特定のアカウントにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="b3993-803">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="b3993-804">ただし、既定のケースが常に望ましいとは限らないため、TLS では必要に応じて、TLS サーバー インスタンスからリモート クライアントに証明書を要求することができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-804">However, the default case is not always desirable, so TLS optionally allows for the TLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="b3993-805">この機能が有効になっているときには、ハンドシェイク中に、TLS サーバーから TLS クライアントに CertificateRequest メッセージが送信されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-805">When this feature is enabled, the TLS Server will send a CertificateRequest message to the TLS Client during the handshake.</span></span> <span data-ttu-id="b3993-806">クライアントでは、それ自身の証明書と、その証明書に関連付けられている一致する秘密キーがクライアントに所有されていることを証明する暗号化トークンが含まれる CertificateVerify メッセージで応答する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-806">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="b3993-807">検証が失敗した場合や、証明書がサーバー上の信頼された証明書に接続されていない場合は、TLS ハンドシェイクが失敗します。</span><span class="sxs-lookup"><span data-stu-id="b3993-807">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="b3993-808">TLS でのクライアント証明書認証には 2 つの異なるケースがあります。後続のセクションでは、両方のケースについて説明します。</span><span class="sxs-lookup"><span data-stu-id="b3993-808">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-tls-clients"></a><span data-ttu-id="b3993-809">TLS クライアントでのクライアント証明書認証</span><span class="sxs-lookup"><span data-stu-id="b3993-809">Client Certificate Authentication for TLS Clients</span></span>

<span data-ttu-id="b3993-810">TLS クライアントは、クライアント認証のために証明書を要求するサーバーへの接続を試みることがあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-810">A TLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="b3993-811">この場合、クライアントはサーバーに証明書を提供し、一致する秘密キーを所有していることを立証する必要があります。そうしないと、サーバーによって TLS ハンドシェイクが終了されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-811">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the TLS handshake.</span></span>

<span data-ttu-id="b3993-812">NetX Secure TLS に、この機能をサポートするための特別な構成はありませんが、アプリケーションで *nx_secure_tls_session_local_certificate_add* サービスを使用して、TLS クライアント インスタンスのローカル ID 証明書を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-812">In NetX Secure TLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_local_certificate_add* service.</span></span> <span data-ttu-id="b3993-813">アプリケーションによって証明書が提示されず、リモート サーバーでクライアント証明書認証が使用されていて証明書が要求される場合、その TLS ハンドシェイクは失敗します。</span><span class="sxs-lookup"><span data-stu-id="b3993-813">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the TLS handshake will fail.</span></span> <span data-ttu-id="b3993-814">TLS ハンドシェイクを完了するためには、*nx_secure_tls_local_certificate_add* を使用して TLS セッションに提供される証明書が、リモート サーバーによって認識される必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-814">The certificate provided to the TLS Session with *nx_secure_tls_local_certificate_add* must be recognized by the remote server in order to complete the TLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="b3993-815">TLS サーバーでのクライアント証明書の認証</span><span class="sxs-lookup"><span data-stu-id="b3993-815">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="b3993-816">クライアント証明書認証の TLS サーバーでのケースは、この機能がオプションであるため、TLS クライアントのケースより少し複雑です。</span><span class="sxs-lookup"><span data-stu-id="b3993-816">The TLS Server case for Client Certificate Authentication is slightly more complex than the TLS Client case due to the feature being optional.</span></span> <span data-ttu-id="b3993-817">この場合 TLS サーバーでは、リモート TLS クライアントに証明書を要求してから CertificateVerify メッセージを処理し、リモート クライアントが一致する秘密キーを所有していることを検証する必要があります。その後サーバーで、クライアントから提供された証明書を、ローカルの信頼された証明書ストア内の証明書まで追跡できることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-817">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="b3993-818">NetX Secure TLS サーバー インスタンスでは、クライアント証明書認証は</span><span class="sxs-lookup"><span data-stu-id="b3993-818">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by</span></span> <br>
<span data-ttu-id="b3993-819">*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>enable* サービスと</span><span class="sxs-lookup"><span data-stu-id="b3993-819">the *nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>enable* and</span></span><br>
<span data-ttu-id="b3993-820">*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>disable* サービスによって制御されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-820">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>disable* services.</span></span>

<span data-ttu-id="b3993-821">クライアント証明書認証を有効にするには、アプリケーションで、</span><span class="sxs-lookup"><span data-stu-id="b3993-821">To enable Client Certificate Authentication, an application must call</span></span><br>
<span data-ttu-id="b3993-822">*nx_secure_tls_session_start* を呼び出す前に TLS サーバー セッションを使用して、*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>enable* を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-822">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify <span class="underline">_</span>enable* with the TLS Server session instance before calling *nx_secure_tls_session_start*.</span></span> <span data-ttu-id="b3993-823">TLS クライアント接続に使用される TLS セッションでこのサービスを呼び出しても何の影響もないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-823">Note that calling this service on a TLS Session that is used for TLS Client connections will have no effect.</span></span>

<span data-ttu-id="b3993-824">クライアント証明書認証が有効になっているときには、TLS ハンドシェイク中に、TLS サーバーからリモート TLS クライアントに証明書が要求されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-824">When Client Certificate Authentication is enabled, the TLS Server will request a certificate from the remote TLS Client during the TLS handshake.</span></span> <span data-ttu-id="b3993-825">NetX Secure TLS サーバーでは、X.509 発行者チェーンをたどり、*nx <span class="underline"> _</span>secure_tls <span class="underline">_</span>trusted <span class="underline"> _</span>certificate<span class="underline">_</span>add* を使用して作成された、信頼された証明書のストアに対して、クライアント証明書がチェックされます。</span><span class="sxs-lookup"><span data-stu-id="b3993-825">In NetX Secure TLS Server, the Client certificate is checked against the store of trusted certificates created with *nx <span class="underline">_</span>secure_tls <span class="underline">_</span>trusted <span class="underline">_</span>certificate<span class="underline">_</span>add* following the X.509 issuer chain.</span></span> <span data-ttu-id="b3993-826">リモート クライアントでは、その ID 証明書が、信頼されたストア内の証明書につながるチェーンを提供する必要があります。そうしないと TLS ハンドシェイクが失敗します。</span><span class="sxs-lookup"><span data-stu-id="b3993-826">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the TLS handshake will fail.</span></span> <span data-ttu-id="b3993-827">さらに、CertificateVerify メッセージの処理が失敗した場合、TLS ハンドシェイクも失敗します。</span><span class="sxs-lookup"><span data-stu-id="b3993-827">Additionally, if the CertificateVerify message processing fails, the TLS handshake will also fail.</span></span>

<span data-ttu-id="b3993-828">CertificateVerify メソッドに使用される署名方法は、TLS バージョン 1.0 および TLS バージョン 1.1 では固定されており、TLS バージョン 1.2 では、TLS サーバーによって指定されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-828">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2.</span></span> <span data-ttu-id="b3993-829">TLS 1.2 の場合、サポートされる署名方法は、一般に、暗号化方式のテーブルで指定されている関連方式に従っていますが、通常は RSA が SHA-256 と共に使用されます (暗号化方式を使用した TLS の初期化の詳細については、「NetX Secure TLS での暗号化」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="b3993-829">For TLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section "Cryptography in NetX Secure TLS" for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="b3993-830">NetX Secure TLS での暗号化</span><span class="sxs-lookup"><span data-stu-id="b3993-830">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="b3993-831">TLS では、暗号化を使用してネットワーク通信をセキュリティで保護できるプロトコルが定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-831">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="b3993-832">そのため、実際に使用される暗号化に関して TLS ユーザーには幅広い選択肢があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-832">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="b3993-833">仕様では、1 つの暗号スイートを実装することのみが要求されます。TLS 1.2 の場合、その暗号スイートは TLS_RSA_WITH_AES_128_CBC_SHA であり、公開キー操作に RSA、セッションの暗号化に 128 ビットのキーを使用する CBC モードの AES、メッセージ認証のハッシュに SHA-1 が使用されることを示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-833">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="b3993-834">NetX Secure は、TLS 1.2 に準拠しており、既定で必須の TLS_RSA_WITH_AES_128_CBC_SHA 暗号スイートが有効にされます。ただし、ハードウェアの機能やその他の考慮事項によって暗号化方式ごとに可能な実装が多数あるため、NetX Secure では、TLS で使用される暗号化方式をユーザーが指定できるようにする汎用の暗号化 API が提供されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-834">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

<span data-ttu-id="b3993-835">注: 汎用の暗号化 API メカニズムを使用すると、ユーザーが独自の暗号スイートを実装することもできますが、これは、TLS の暗号スイートや拡張機能に精通している上級ユーザーにお勧めします。</span><span class="sxs-lookup"><span data-stu-id="b3993-835">NOTE: The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="b3993-836">独自の暗号スイートのサポートに関心がある場合は、Express Logic の担当者にお問い合わせください。</span><span class="sxs-lookup"><span data-stu-id="b3993-836">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

### <a name="cryptographic-methods"></a><span data-ttu-id="b3993-837">暗号化方式</span><span class="sxs-lookup"><span data-stu-id="b3993-837">Cryptographic Methods</span></span>

<span data-ttu-id="b3993-838">NetX Secure TLS では、特定のハードウェア プラットフォーム用のハードウェア ドライバーを備えたソフトウェアに、DES、3DES、AES、MD5、HMAC-MD5、SHA-1、HMAC-SHA1、SHA-256、HMAC-SHA256、RSA、ECC (選択曲線) が実装されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-838">NetX Secure TLS implements DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA, and ECC (selected curves) in software with hardware drivers for certain hardware platforms.</span></span> <span data-ttu-id="b3993-839">アプリケーションでは、NetX Secure に用意されている暗号化ルーチンを使用することも、エンド ユーザーまたはサード パーティが提供するカスタム ルーチンを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="b3993-839">An application may use the cryptographic routines provided with NetX Secure, or use custom routines provided by the end user or third parties.</span></span>

<span data-ttu-id="b3993-840">*NX_CRYPTO_METHOD* は、アプリケーションで、NetX Secure TLS で使用される暗号アルゴリズムの特定の実装を記述するために設計された制御ブロックです。</span><span class="sxs-lookup"><span data-stu-id="b3993-840">The *NX_CRYPTO_METHOD* is a control block designed for an application to describe a particular implementation of a cryptographic algorithm to be used with NetX Secure TLS.</span></span> <span data-ttu-id="b3993-841">*NX_CRYPTO_METHOD* を使用すると、アプリケーション独自の暗号化実装を、NetX Secure に簡単に統合できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-841">With the *NX_CRYPTO_METHOD,* an application can easily integrate their own crypto implementation into NetX Secure.</span></span> <span data-ttu-id="b3993-842">*NX_CRYPTO_METHOD* 構造体は次のように宣言されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-842">The *NX_CRYPTO_METHOD* structure is declared as:</span></span>

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

<span data-ttu-id="b3993-843">以下に、*NX_CRYPTO_METHOD* 構造体の各要素の説明を示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-843">Below is the description of each element in the *NX_CRYPTO_METHOD* structure:</span></span>

- <span data-ttu-id="b3993-844">nx_crypto_algorithm: このフィールドで、変数 *method* に記述されているアルゴリズムを識別します。NetX Secure TLS で有効な値の一部は以下のとおりです (特定の値については nx_crypto_const.h を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="b3993-844">nx_crypto_algorithm: This field identifies the algorithm described in the variable *method* Some valid values for NetX Secure TLS are as follows (refer to nx_crypto_const.h for specific values):</span></span>
    
  - <span data-ttu-id="b3993-845">NX_CRYPTO_NONE</span><span class="sxs-lookup"><span data-stu-id="b3993-845">NX_CRYPTO_NONE</span></span>    
  - <span data-ttu-id="b3993-846">NX_CRYPTO_ENCRYPTION_NULL</span><span class="sxs-lookup"><span data-stu-id="b3993-846">NX_CRYPTO_ENCRYPTION_NULL</span></span>    
  - <span data-ttu-id="b3993-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span><span class="sxs-lookup"><span data-stu-id="b3993-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span></span>    
  - <span data-ttu-id="b3993-848">NX_CRYPTO_AUTHENTICATION_NONE</span><span class="sxs-lookup"><span data-stu-id="b3993-848">NX_CRYPTO_AUTHENTICATION_NONE</span></span>    
  - <span data-ttu-id="b3993-849">TLS_HASH_SHA_1</span><span class="sxs-lookup"><span data-stu-id="b3993-849">TLS_HASH_SHA_1</span></span>    
  - <span data-ttu-id="b3993-850">TLS_HASH_SHA_256</span><span class="sxs-lookup"><span data-stu-id="b3993-850">TLS_HASH_SHA_256</span></span>    
  - <span data-ttu-id="b3993-851">TLS_HASH_MD5</span><span class="sxs-lookup"><span data-stu-id="b3993-851">TLS_HASH_MD5</span></span>    
  - <span data-ttu-id="b3993-852">TLS_CIPHER_RSA</span><span class="sxs-lookup"><span data-stu-id="b3993-852">TLS_CIPHER_RSA</span></span>    
  - <span data-ttu-id="b3993-853">TLS_CIPHER_NULL</span><span class="sxs-lookup"><span data-stu-id="b3993-853">TLS_CIPHER_NULL</span></span>

- <span data-ttu-id="b3993-854">nx_crypto_key_size_in_bits: このフィールドでは、その方式で使用される秘密キーのサイズを指定します。</span><span class="sxs-lookup"><span data-stu-id="b3993-854">nx_crypto_key_size_in_bits: this field specifies the size of the secret key used by the method.</span></span>

- <span data-ttu-id="b3993-855">nx_crypto_IV_size_in_bits: このフィールドでは、初期化ベクトル (IV) のサイズを指定します。</span><span class="sxs-lookup"><span data-stu-id="b3993-855">nx_crypto_IV_size_in_bits: this field specifies the size of the Initialization Vector (IV).</span></span> <span data-ttu-id="b3993-856">ほとんどの場合、IV ブロックは暗号化/解読アルゴリズムについてのみ使用されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-856">Note that in most cases the IV block is only used for encryption/decryption algorithms.</span></span> <span data-ttu-id="b3993-857">このフィールドは、認証や検証のアルゴリズムではめったに使用されません。</span><span class="sxs-lookup"><span data-stu-id="b3993-857">Authentication and verification algorithms rarely use this field.</span></span>

- <span data-ttu-id="b3993-858">nx_crypto_ICV_size_in_bits: このフィールドでは、整合性チェック値 (ICV) ブロックのサイズを指定します。</span><span class="sxs-lookup"><span data-stu-id="b3993-858">nx_crypto_ICV_size_in_bits: this field specifies the size of the Integrity Check Value (ICV) block.</span></span> <span data-ttu-id="b3993-859">注: このブロックは IPsec での使用を目的としており、TLS では使用されません。</span><span class="sxs-lookup"><span data-stu-id="b3993-859">NOTE: This block is for IPsec usage and is unused in TLS.</span></span> <span data-ttu-id="b3993-860">詳細については、NetX Duo IPsec に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-860">See NetX Duo IPsec for more information.</span></span>

- <span data-ttu-id="b3993-861">nx_crypto_block_size_in_bytes: このフィールドでは、ブロックベースの暗号の暗号アルゴリズム ブロックのサイズをバイト単位で指定します。</span><span class="sxs-lookup"><span data-stu-id="b3993-861">nx_crypto_block_size_in_bytes: this field specifies the size of the cryptographic algorithm block for block-based ciphers, in bytes.</span></span> <span data-ttu-id="b3993-862">ほとんどの場合、これは暗号化ルーチンによって使用され、認証ルーチンによって使用されることはほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-862">In most cases this is used by encryption routines and rarely by authentication routines.</span></span>

- <span data-ttu-id="b3993-863">nx_crypto_metadata_area_size: このフィールドでは、このメソッドが必要とするメタデータ領域のサイズを指定します。</span><span class="sxs-lookup"><span data-stu-id="b3993-863">nx_crypto_metadata_area_size: this field specifies the size of the metadata area this method requires.</span></span> <span data-ttu-id="b3993-864">各実装では、状態情報を格納するため、中間データ (キー変換マテリアルなど) を格納するため、またはスクラッチ領域として使用するために、一定のメモリが必要とされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-864">Each implementation may require certain memory to store its state information, or to store intermediate data (such as key transformation material), or to use as a scratch area.</span></span> <span data-ttu-id="b3993-865">実装に必要な領域のサイズを、このフィールドで指定します。</span><span class="sxs-lookup"><span data-stu-id="b3993-865">The amount of space required by an implementation is specified in this field.</span></span> <span data-ttu-id="b3993-866">アプリケーションからは、TLS セッションの作成時にメモリ領域が提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-866">The application provides the memory space when creating a TLS session.</span></span> <span data-ttu-id="b3993-867">このメタデータ領域を管理する必要があるのは、暗号化機能です。</span><span class="sxs-lookup"><span data-stu-id="b3993-867">The cryptographic function is responsible for managing this metadata area.</span></span>

- <span data-ttu-id="b3993-868">nx_crypto_init: これは、暗号アルゴリズムの初期化関数です。</span><span class="sxs-lookup"><span data-stu-id="b3993-868">nx_crypto_init: This is the initialization function for the cryptographic algorithm.</span></span> <span data-ttu-id="b3993-869">初期化ルーチンを必要としない実装では、このフィールドを NX_NULL に設定してもかまいません。</span><span class="sxs-lookup"><span data-stu-id="b3993-869">For an implementation that does not need an initialization routine, this field may be set to NX_NULL.</span></span> <span data-ttu-id="b3993-870">初期化関数の典型的な使い方は、アルゴリズムのために内部データ構造を初期化することです。</span><span class="sxs-lookup"><span data-stu-id="b3993-870">A typical use of an initialization function is to initialize the internal data structure for the algorithm.</span></span> <span data-ttu-id="b3993-871">NetX Secure TLS では、内部でこの関数を呼び出すことによって、暗号化ルーチンの初期化を処理します。</span><span class="sxs-lookup"><span data-stu-id="b3993-871">NetX Secure TLS will handle initialization of the cryptographic routine by calling this function internally.</span></span>

<span data-ttu-id="b3993-872">初期化関数のプロトタイプは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b3993-872">The prototype for the initialization function is:</span></span>

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - <span data-ttu-id="b3993-873">method は、その暗号化方式の制御ブロックへのポインターです。</span><span class="sxs-lookup"><span data-stu-id="b3993-873">method is a pointer to the crypto method control block.</span></span>

  - <span data-ttu-id="b3993-874">key は、データ パケットを処理するための秘密キー文字列です。</span><span class="sxs-lookup"><span data-stu-id="b3993-874">key is the secret key string for processing the data packets.</span></span>

  - <span data-ttu-id="b3993-875">key_size_in_bits では、秘密キーのサイズをビット単位で定義します。</span><span class="sxs-lookup"><span data-stu-id="b3993-875">key_size_in_bits defines the size of the secret key, in bits.</span></span>

  - <span data-ttu-id="b3993-876">handle は、特定の暗号化セッションを識別する、実装で定義されている項目です。</span><span class="sxs-lookup"><span data-stu-id="b3993-876">handle is an implementation-defined item that identifies a particular crypto session.</span></span> <span data-ttu-id="b3993-877">値は初期化ルーチンによって生成されて、呼び出し元に戻されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-877">The value is generated by the initialization routine, and is passed back to the caller.</span></span> <span data-ttu-id="b3993-878">後続の暗号化操作やクリーンアップ ルーチンでは、このハンドルを使用してセッションを識別します。</span><span class="sxs-lookup"><span data-stu-id="b3993-878">The subsequent crypto operation or clean up routine use this handle to identify the session.</span></span>

  - <span data-ttu-id="b3993-879">crypto_metadata は、このアルゴリズムの実装で必要とされているメタデータ領域へのポインターです。</span><span class="sxs-lookup"><span data-stu-id="b3993-879">crypto_metadata is a pointer to the metadata area required by the implementation of this algorithm.</span></span> <span data-ttu-id="b3993-880">メタデータ領域を必要としないアルゴリズムの場合、このフィールドは NX_NULL に設定されます。また、初期化ルーチンでメタデータ領域にアクセスしてはいけません。</span><span class="sxs-lookup"><span data-stu-id="b3993-880">For algorithms that do not need a metadata area this field is set to NX_NULL and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="b3993-881">crypto_metadata_size では、メタデータ領域のサイズを指定します。</span><span class="sxs-lookup"><span data-stu-id="b3993-881">crypto_metadata_size specifies the size of the metadata area.</span></span> <span data-ttu-id="b3993-882">メタデータ領域なしで作成された SA の場合、このフィールドは 0 に設定されます。また、初期化ルーチンでメタデータ領域にアクセスしてはいけません。</span><span class="sxs-lookup"><span data-stu-id="b3993-882">For SAs created without metadata area, this field is set to zero, and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="b3993-883">初期化プロセスが成功した場合は、このルーチンから *NX_SUCCESS* が返されるはずです。</span><span class="sxs-lookup"><span data-stu-id="b3993-883">This routine shall return *NX_SUCCESS* if the initialization process is successful.</span></span> <span data-ttu-id="b3993-884">呼び出し元は、その他の戻り値をすべてエラーとして扱います。</span><span class="sxs-lookup"><span data-stu-id="b3993-884">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="b3993-885">nx_crypto_cleanup: これは、暗号アルゴリズムの実装に対して定義されたクリーンアップ ルーチンです。</span><span class="sxs-lookup"><span data-stu-id="b3993-885">nx_crypto_cleanup: This is the cleanup routine defined for the implementation of a crypto algorithm.</span></span> <span data-ttu-id="b3993-886">これは、TLS セッションが削除または再起動されたときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-886">It is invoked when a TLS session is deleted or restarted.</span></span>

<span data-ttu-id="b3993-887">クリーンアップ関数のプロトタイプは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b3993-887">The prototype for the cleanup function is:</span></span>

```C
UINT crypto_cleanup_function(VOID *handle);
```
- <span data-ttu-id="b3993-888">handle は、呼び出し元によってクリーンアップ関数に渡されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-888">handle is passed to the cleanup function by the caller.</span></span> <span data-ttu-id="b3993-889">ハンドルは、暗号化の初期化ルーチンによって初期化されて、暗号アルゴリズムの状態を識別するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-889">The handle is initialized by the crypto initialization routine and used to identify cryptographic algorithm state.</span></span>

- <span data-ttu-id="b3993-890">クリーンアップ プロセスが成功した場合は、このルーチンから *NX_SUCCESS* が返されるはずです。</span><span class="sxs-lookup"><span data-stu-id="b3993-890">This routine shall return *NX_SUCCESS* if the cleanup process is successful.</span></span> <span data-ttu-id="b3993-891">呼び出し元は、その他の戻り値をすべてエラーとして扱います。</span><span class="sxs-lookup"><span data-stu-id="b3993-891">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="b3993-892">nx_crypto_operation: これは、実際の暗号化、解読、認証のサービスを実行するルーチンです。</span><span class="sxs-lookup"><span data-stu-id="b3993-892">nx_crypto_operation: This is the routine that performs the actual encryption, decryption, and authentication services.</span></span> <span data-ttu-id="b3993-893">操作ルーチンの関数プロトタイプは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b3993-893">The function prototype of the operation routine is:</span></span>

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- <span data-ttu-id="b3993-894">op は、このルーチンで実行する必要がある操作の種類を示します。有効な値は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b3993-894">op indicates the type of operation this routine is expected to carry out. Valid values are:</span></span>
    
    - <span data-ttu-id="b3993-895">NX_CRYPTO_ENCRYPT</span><span class="sxs-lookup"><span data-stu-id="b3993-895">NX_CRYPTO_ENCRYPT</span></span>
    - <span data-ttu-id="b3993-896">NX_CRYPTO_DECRYPT</span><span class="sxs-lookup"><span data-stu-id="b3993-896">NX_CRYPTO_DECRYPT</span></span>
    - <span data-ttu-id="b3993-897">NX_CRYPTO_AUTHENTICATE</span><span class="sxs-lookup"><span data-stu-id="b3993-897">NX_CRYPTO_AUTHENTICATE</span></span>
    - <span data-ttu-id="b3993-898">NX_CRYPTO_VERIFY</span><span class="sxs-lookup"><span data-stu-id="b3993-898">NX_CRYPTO_VERIFY</span></span>

- <span data-ttu-id="b3993-899">handle は、呼び出し元によって操作関数に渡されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-899">handle is passed to the operation function by the caller.</span></span> <span data-ttu-id="b3993-900">これは、暗号化初期化ルーチンによって生成されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-900">It is generated by the crypto initialization routine.</span></span>
- <span data-ttu-id="b3993-901">method は、その暗号化方式の制御ブロックを指し示します</span><span class="sxs-lookup"><span data-stu-id="b3993-901">method points to the crypto method control block</span></span>
- <span data-ttu-id="b3993-902">key は、この操作に使用される秘密キーを指し示します</span><span class="sxs-lookup"><span data-stu-id="b3993-902">key points to the secret key used for this operation</span></span>
- <span data-ttu-id="b3993-903">key_size_in_bits は秘密キーのサイズです (ビット単位)</span><span class="sxs-lookup"><span data-stu-id="b3993-903">key_size_in_bits is the size of the secret key in bits</span></span>
- <span data-ttu-id="b3993-904">input は、操作対象メッセージの先頭へのポインターです。</span><span class="sxs-lookup"><span data-stu-id="b3993-904">input is a pointer to the beginning of the message to be operated on.</span></span>
- <span data-ttu-id="b3993-905">input_length_in_byte は、操作対象のメッセージのサイズを示すために呼び出し元によって渡されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-905">input_length_in_byte is passed by the caller to indicate the size of the message to be operated on.</span></span>
- <span data-ttu-id="b3993-906">iv_ptr は、IV ブロックの先頭を指し示すために呼び出し元によって設定されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-906">iv_ptr is setup by the caller to point to the beginning of an IV block.</span></span> <span data-ttu-id="b3993-907">IV ブロック用のメモリは、呼び出し元によって提供されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-907">Note that the memory for the IV block is provided by the caller.</span></span> <span data-ttu-id="b3993-908">暗号化では、操作関数によって IV の情報をこのメモリ ブロックに書き込む必要があります。解読では、操作関数によって、このメモリ ブロックから IV 情報を取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-908">For encryption, the operation function should write the IV information into this memory block; for decryption, the operation function should retrieve the IV information from this memory block.</span></span> <span data-ttu-id="b3993-909">認証および検証の操作のためのアルゴリズムでは、一般に、初期化ベクトルは使用されません。</span><span class="sxs-lookup"><span data-stu-id="b3993-909">Algorithms for authentication and verification operation typically do not use the initialization vector.</span></span>
- <span data-ttu-id="b3993-910">output は、出力バッファーを指し示すために呼び出し元によって設定されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-910">output is setup by the caller to point to an output buffer.</span></span> <span data-ttu-id="b3993-911">出力バッファー用のメモリは、呼び出し元によって提供されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-911">Note that the memory for the output buffer is provided by the caller.</span></span> <span data-ttu-id="b3993-912">暗号化では、操作関数によって出力バッファーに暗号テキストを書き込む必要があります。解読では、解読されたテキスト (クリア テキスト) を出力バッファーに書き込む必要があります。認証では、出力バッファーにハッシュ値を書き込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-912">For encryption, the operation function should write the cipher text to the output buffer; for decryption, the operation should write the deciphered text (clear text) to the output buffer; for authentication, the hash value shall be written to the output buffer.</span></span> <span data-ttu-id="b3993-913">検証では、ハッシュ情報を格納するために出力バッファーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-913">For verification, the output buffer is used to store hash information.</span></span>
- <span data-ttu-id="b3993-914">output_length_in_byte では、出力バッファーのサイズを指定します。</span><span class="sxs-lookup"><span data-stu-id="b3993-914">output_length_in_byte indicates the size of the output buffer</span></span>
- <span data-ttu-id="b3993-915">crypto_metadata は、この暗号化操作によって使用されるメタデータ領域を指し示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-915">crypto_metadata points to the metadata area to be used by this crypto operation.</span></span> <span data-ttu-id="b3993-916">暗号化メタデータ領域は、一般に、crypto_init_function によって初期化されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-916">The crypto metadata area is typically initialized by crypto_init_function.</span></span>
- <span data-ttu-id="b3993-917">crypto_metadata_size では、メタデータ領域のサイズを指定します。</span><span class="sxs-lookup"><span data-stu-id="b3993-917">crypto_metadata_size indicates the size of the metadata area.</span></span>
- <span data-ttu-id="b3993-918">操作プロセスが成功した場合は、このルーチンから *NX_SUCCESS* が返されるはずです。</span><span class="sxs-lookup"><span data-stu-id="b3993-918">This routine shall return *NX_SUCCESS* if the operation process is successful.</span></span> <span data-ttu-id="b3993-919">呼び出し元は、その他の戻り値をすべてエラーとして扱います。</span><span class="sxs-lookup"><span data-stu-id="b3993-919">The caller treats any other return value as failure.</span></span>
- <span data-ttu-id="b3993-920">packet_ptr: 処理されるデータが含まれるパケット。</span><span class="sxs-lookup"><span data-stu-id="b3993-920">packet_ptr: The packet that contains the data being processed.</span></span> <span data-ttu-id="b3993-921">注: このパラメーターは TLS では使用されておらず、NX_NULL に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-921">NOTE: This parameter is unused by TLS and should be set to NX_NULL.</span></span>
- <span data-ttu-id="b3993-922">nx_crypto_hw_process_callback: その暗号化方式で提供されているコールバック関数。</span><span class="sxs-lookup"><span data-stu-id="b3993-922">nx_crypto_hw_process_callback: A callback function provided by the encryption method.</span></span> <span data-ttu-id="b3993-923">これは、暗号化関数がハードウェアによって提供されていて、コールバック ルーチンが必要な場合に使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-923">This is used if the crypto function is provided by hardware and requires a callback routine.</span></span>

<span data-ttu-id="b3993-924">NetX Secure TLS には、以下の暗号化方式が用意されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-924">NetX Secure TLS provides the following encryption methods:</span></span>

- <span data-ttu-id="b3993-925">*AES*</span><span class="sxs-lookup"><span data-stu-id="b3993-925">*AES*</span></span>  
- <span data-ttu-id="b3993-926">*RSA*</span><span class="sxs-lookup"><span data-stu-id="b3993-926">*RSA*</span></span>  
- <span data-ttu-id="b3993-927">*NULL*</span><span class="sxs-lookup"><span data-stu-id="b3993-927">*NULL*</span></span>

<span data-ttu-id="b3993-928">NetX Secure TLS には、以下の認証方法が用意されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-928">NetX Secure TLS provides the following authentication methods:</span></span>

- <span data-ttu-id="b3993-929">*HMAC-MD5*</span><span class="sxs-lookup"><span data-stu-id="b3993-929">*HMAC-MD5*</span></span>  
- <span data-ttu-id="b3993-930">*HMAC-SHA1*</span><span class="sxs-lookup"><span data-stu-id="b3993-930">*HMAC-SHA1*</span></span>  
- <span data-ttu-id="b3993-931">*HMAC-SHA256*</span><span class="sxs-lookup"><span data-stu-id="b3993-931">*HMAC-SHA256*</span></span>

<span data-ttu-id="b3993-932">以下の例では、NetX Duo IPsec によって提供される暗号化と認証のメソッドを使用するように *NX_CRYPTO_METHOD* 構造体を構成する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="b3993-932">The following examples illustrate how to configure the *NX_CRYPTO_METHOD* structure to use the encryption and authentication methods provided by NetX Duo IPsec.</span></span>

<span data-ttu-id="b3993-933">***AES:***</span><span class="sxs-lookup"><span data-stu-id="b3993-933">***AES:***</span></span>

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
<span data-ttu-id="b3993-934">***NULL***</span><span class="sxs-lookup"><span data-stu-id="b3993-934">***NULL***</span></span>

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
<span data-ttu-id="b3993-935">***HMAC-SHA1***</span><span class="sxs-lookup"><span data-stu-id="b3993-935">***HMAC-SHA1***</span></span>
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
<span data-ttu-id="b3993-936">***NONE***</span><span class="sxs-lookup"><span data-stu-id="b3993-936">***NONE***</span></span>

<span data-ttu-id="b3993-937">特殊なメソッドの **NX_CRYPTO_NONE** は、暗号化または認証のサービスが不要であることを IPsec モジュールに通知するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-937">A special method **NX_CRYPTO_NONE** is used to signal the IPsec module that the encryption or the authentication service is not required.</span></span> <span data-ttu-id="b3993-938">これは以下のように構成されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-938">It is configured as follows:</span></span>

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a><span data-ttu-id="b3993-939">暗号化方式を使用した TLS の初期化</span><span class="sxs-lookup"><span data-stu-id="b3993-939">Initializing TLS with Cryptographic Methods</span></span>

<span data-ttu-id="b3993-940">前のセクションで説明した暗号化方式の署名に準拠した暗号化ルーチンを作成したら、NX_SECURE_TLS_SESSION 制御ブロックを初期化するときに、それらを TLS に渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-940">Once you have created your cryptographic routines conforming to the cryptographic method signatures described in the previous section, you will need to pass them into TLS when you initialize an NX_SECURE_TLS_SESSION control block.</span></span> <span data-ttu-id="b3993-941">これは、TLS サービスの nx_secure_tls_session_create で実行します。</span><span class="sxs-lookup"><span data-stu-id="b3993-941">This is done in the TLS service nx_secure_tls_session_create:</span></span>

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- <span data-ttu-id="b3993-942">session_pointer は、NX_SECURE_TLS_SESSION 制御ブロックへのポインターです。</span><span class="sxs-lookup"><span data-stu-id="b3993-942">session_pointer is a pointer to your NX_SECURE_TLS_SESSION control block.</span></span>
- <span data-ttu-id="b3993-943">tls_cipher_table は、後述する NX_SECURE_TLS_CRYPTO 制御ブロックへのポインターです。</span><span class="sxs-lookup"><span data-stu-id="b3993-943">tls_cipher_table is a pointer to an NX_SECURE_TLS_CRYPTO control block, described below.</span></span>
- <span data-ttu-id="b3993-944">encryption_metadata_area は、TLS で暗号化ルーチンによって使用される領域を指し示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-944">encryption_metadata_area points to space used by cryptographic routines in TLS.</span></span>
- <span data-ttu-id="b3993-945">encryption_metadata_size は、メタデータ領域のサイズです (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="b3993-945">encryption_metadata_size is the size of the metadata area in bytes.</span></span>

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a><span data-ttu-id="b3993-946">NetX Secure TLS での楕円曲線暗号 (ECC)</span><span class="sxs-lookup"><span data-stu-id="b3993-946">Elliptic Curve Cryptography (ECC) in NetX Secure TLS</span></span>

<span data-ttu-id="b3993-947">楕円曲線暗号 (ECC) は、RSA の代わりに使用できる公開キー暗号化スキームです。</span><span class="sxs-lookup"><span data-stu-id="b3993-947">Elliptic Curve Cryptography (ECC) provides a public-key cryptography scheme that can be used instead of RSA.</span></span> <span data-ttu-id="b3993-948">ECC は一般的により高速であり、RSA よりも小さなキーを使用するので、組み込まれる TLS では有益なオプションとなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-948">ECC is typically faster and uses smaller keys than RSA so it can be a valuable option for embedded TLS.</span></span> <span data-ttu-id="b3993-949">Azure RTOS 6.0 より前のバージョンの X-Ware では、ECC はアドオンとして出荷されており、プロジェクトに ECC ソース コードをインストールする必要がありました。</span><span class="sxs-lookup"><span data-stu-id="b3993-949">In X-Ware versions prior to Azure RTOS 6.0, ECC was shipped as an add-on, requiring installation of the ECC source code into your project.</span></span> <span data-ttu-id="b3993-950">Azure RTOS 6.0 では、ECC はメインライン コードベースに統合されたため、ECC ファイルのインストールは不要になっています。</span><span class="sxs-lookup"><span data-stu-id="b3993-950">Azure RTOS 6.0 integrated ECC into the mainline codebase so installation of the ECC files is no longer necessary.</span></span> <span data-ttu-id="b3993-951">ただし、ECC では引き続き、以前のバージョンと同様の初期化が必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-951">However, ECC still requires the same initialization as those previous versions.</span></span>

### <a name="supported-ecc-curves"></a><span data-ttu-id="b3993-952">サポートされている ECC 曲線</span><span class="sxs-lookup"><span data-stu-id="b3993-952">Supported ECC curves</span></span>

<span data-ttu-id="b3993-953">NetX Secure では、<http://www.secg.org/sec2-v2.pdf> に従って曲線のパーツが実装されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-953">NetX Secure implements parts of the curves as per <http://www.secg.org/sec2-v2.pdf>.</span></span> <span data-ttu-id="b3993-954">以下の曲線がサポートされています<sup>18</sup>:</span><span class="sxs-lookup"><span data-stu-id="b3993-954">Thefollowing curves are supported<sup>18</sup>:</span></span>

  - <span data-ttu-id="b3993-955">secp256r1</span><span class="sxs-lookup"><span data-stu-id="b3993-955">secp256r1</span></span> 
  - <span data-ttu-id="b3993-956">secp384r1</span><span class="sxs-lookup"><span data-stu-id="b3993-956">secp384r1</span></span> 
  - <span data-ttu-id="b3993-957">secp521r1</span><span class="sxs-lookup"><span data-stu-id="b3993-957">secp521r1</span></span> 

<span data-ttu-id="b3993-958">その他の ECC 曲線が使用されている場合、*nx_secure_tls_session_start ()* ルーチンから、サポートされていない曲線が使用されたことを示すエラー NX_SECURE_TLS_NO_SUPPORTED_CIPHERS が返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-958">If other ECC curves are used, the *nx_secure_tls_session_start()* routine will return the error NX_SECURE_TLS_NO_SUPPORTED_CIPHERS indicating that unsupported curves were used.</span></span>

<span data-ttu-id="b3993-959">ECC アルゴリズムによって TLS 証明書チェーンも暗号化される場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-959">Note that TLS certificate chain may be encrypted by ECC-algorithms as well.</span></span> <span data-ttu-id="b3993-960">TLS クライアントによって提供される曲線はサポートされていますが、証明書チェーンで使用される ECC 曲線はサポートされていない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-960">Even though the curves provided by the TLS Client are supported, it is possible that the ECC curve used in the certificate chain is not supported.</span></span> <span data-ttu-id="b3993-961">この場合、*nx_secure_tls_session_start* ルーチンから、NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER が返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-961">In this case, *nx_secure_tls_session_start* routine returns NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span></span>

<span data-ttu-id="b3993-962">ECC の既定の暗号スイート テーブルの例が、nx_crypto_generic_ciphersuites.c で提供されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-962">A default ciphersuite table example for ECC is provided in nx_crypto_generic_ciphersuites.c.</span></span> <span data-ttu-id="b3993-963">暗号スイート テーブルの詳細については、「TLS 暗号化暗号テーブル」のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-963">See section "TLS Cryptographic Cipher Table" for more information on ciphersuite tables.</span></span>

18. <span data-ttu-id="b3993-964">曲線 secp192r1 と secp224r1are の実装も、レガシ アプリケーション用に提供されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-964">Note that implementations for the curves secp192r1 and secp224r1are also provided for legacy applications.</span></span> <span data-ttu-id="b3993-965">ただし、これらの曲線は今では脆弱であると見なされており、新しいアプリケーションの開発には使用すべきではありません。</span><span class="sxs-lookup"><span data-stu-id="b3993-965">However these curves are now considered weak and SHOULD NOT be used for new application development.</span></span>

### <a name="crypto-methods-for-ecc"></a><span data-ttu-id="b3993-966">ECC の暗号化メソッド</span><span class="sxs-lookup"><span data-stu-id="b3993-966">Crypto Methods for ECC</span></span>

<span data-ttu-id="b3993-967">楕円曲線グループの暗号化メソッド:</span><span class="sxs-lookup"><span data-stu-id="b3993-967">Crypto methods for Elliptic Curve groups:</span></span>

- <span data-ttu-id="b3993-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup></span><span class="sxs-lookup"><span data-stu-id="b3993-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span></span>  
- <span data-ttu-id="b3993-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup></span><span class="sxs-lookup"><span data-stu-id="b3993-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span></span>  
- <span data-ttu-id="b3993-970">NX_CRYPTO_METHOD crypto_method_ec_secp256</span><span class="sxs-lookup"><span data-stu-id="b3993-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span></span>  
- <span data-ttu-id="b3993-971">NX_CRYPTO_METHOD crypto_method_ec_secp384</span><span class="sxs-lookup"><span data-stu-id="b3993-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span></span>  
- <span data-ttu-id="b3993-972">NX_CRYPTO_METHOD crypto_method_ec_secp521</span><span class="sxs-lookup"><span data-stu-id="b3993-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span></span>

<span data-ttu-id="b3993-973">ECC 曲線の暗号化メソッドは nx_crypto_generic_ciphersuites.c で定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-973">The crypto methods for ECC curves are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="b3993-974">ECDHE の暗号化メソッド:</span><span class="sxs-lookup"><span data-stu-id="b3993-974">Crypto method for ECDHE:</span></span>

- <span data-ttu-id="b3993-975">NX_CRYPTO_METHOD crypto_method_ecdhe</span><span class="sxs-lookup"><span data-stu-id="b3993-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span></span>

<span data-ttu-id="b3993-976">ECDSA の暗号化メソッド:</span><span class="sxs-lookup"><span data-stu-id="b3993-976">Crypto method for ECDSA:</span></span>

- <span data-ttu-id="b3993-977">NX_CRYPTO_METHOD crypto_method_ecdsa</span><span class="sxs-lookup"><span data-stu-id="b3993-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span></span>

<span data-ttu-id="b3993-978">ECDSA および ECDHE の暗号化メソッドは nx_crypto_generic_ciphersuites.c で定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-978">ECDSA and ECDHE crypto methods are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="b3993-979">これらは、RSA、SHA、AES などの他の暗号化方式と組み合わせて、暗号スイート ルックアップ テーブルの構成要素として使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-979">Combined with other crypto methods such as RSA, SHA, AES, they can be used as building blocks for the ciphersuite lookup table.</span></span>

### <a name="enabling-ecc-support-for-tls"></a><span data-ttu-id="b3993-980">TLS での ECC サポートの有効化</span><span class="sxs-lookup"><span data-stu-id="b3993-980">Enabling ECC Support for TLS</span></span>

<span data-ttu-id="b3993-981">ECC は、TLS で既定で有効になっています。</span><span class="sxs-lookup"><span data-stu-id="b3993-981">ECC is enabled by default for TLS.</span></span> <span data-ttu-id="b3993-982">ECC のサポートを無効にするには、シンボル NX_SECURE_DISABLE_ECC_CIPHERSUITE を定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-982">To disable ECC support, the symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE must be defined.</span></span>

<span data-ttu-id="b3993-983">変更を有効にするには、NetX Secure ライブラリと、そのライブラリを使用するすべてのアプリケーションをリビルドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-983">For the change to take effect, you will need to rebuild the NetX Secure Library and all applications that use that library.</span></span>

<span data-ttu-id="b3993-984">アプリケーション コードでは、TLS セッションの作成後に API n *x_secure_tls_ecc_initialize ()* を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-984">In the application code, the API n *x_secure_tls_ecc_initialize()* must be called after the TLS session is created.</span></span> <span data-ttu-id="b3993-985">この API により、TLS セッションに、TLS のキー交換操作および証明書の検証に使用される曲線の種類が通知されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-985">This API notifies the TLS session of the type of curves to be used for TLS key exchange operations and certificate verification.</span></span> <span data-ttu-id="b3993-986">ECC アルゴリズムが選択されている場合は、TLS ハンドシェイク フェーズの間にクライアントとサーバーが ECC 曲線関連のパラメーターを交換して、どの曲線を使用するかが決定されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-986">During the TLS handshake phase, if an ECC algorithm is selected the client and server exchange ECC curve-related parameters to decide which curve to use.</span></span>

<span data-ttu-id="b3993-987">次のコード セグメントで、この API の使用方法を示します。</span><span class="sxs-lookup"><span data-stu-id="b3993-987">The following code segment illustrates how to use the API.</span></span> <span data-ttu-id="b3993-988">引数 (*nx_crypto_ecc_supported_groups、nx_crypto_ecc_supported_groups_size、nx_crypto_ecc_curves)* はすべて、*nx_crypto_generic_ciphersuites.c* で定義されていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-988">Note that the arguments (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, and nx_crypto_ecc_curves)* are all defined in *nx_crypto_generic_ciphersuites.c*.</span></span> <span data-ttu-id="b3993-989">そのため、これらのシンボルは直接使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-989">Therefore these symbols can be used directly.</span></span>

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
<span data-ttu-id="b3993-990">nx_crypto_generic_ciphersuites.c の構成例には、ECC が有効になっているときに使用される ECC 暗号スイート ルックアップ テーブルが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b3993-990">The example configuration in nx_crypto_generic_ciphersuites.c contains an ECC ciphersuite lookup table that is used when ECC is enabled.</span></span> <span data-ttu-id="b3993-991">ECC を使用するには、nx_secure_tls_session_create を使用して TLS セッションを作成するときに、単純に暗号スイート テーブルのパラメーターとして nx_crypto_tls_ciphers_ecc を渡します。</span><span class="sxs-lookup"><span data-stu-id="b3993-991">To use ECC, simply pass nx_crypto_tls_ciphers_ecc as the ciphersuite table parameter when creating TLS sessions with nx_secure_tls_session_create.</span></span> <span data-ttu-id="b3993-992">このテーブル例には、ECC 用と非 ECC 用の両方の暗号スイートが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b3993-992">The example table contains both ECC and non-ECC ciphersuites.</span></span>

### <a name="tls-cryptographic-cipher-table"></a><span data-ttu-id="b3993-993">TLS 暗号化暗号テーブル</span><span class="sxs-lookup"><span data-stu-id="b3993-993">TLS Cryptographic Cipher Table</span></span>

<span data-ttu-id="b3993-994">The NX_SECURE_TLS_CRYPTO 構造体は以下のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-994">The NX_SECURE_TLS_CRYPTO structure is defined as:</span></span>

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
<span data-ttu-id="b3993-995">このテーブルは、NetX Secure TLS プロジェクト内にある静的定数にこの構造体のエントリを格納することによって作成されます。この定数は通常、暗号化のルーチンおよびモジュールと共に配置されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-995">The table is created by filling in the entries for this structure in a static constant located within the NetX Secure TLS project, usually located with the cryptographic routines and modules.</span></span>

<span data-ttu-id="b3993-996">例として、NetX Secure で提供されるソフトウェア専用の ("汎用") 暗号化ライブラリには、以下のテーブル定義が含まれています (ECC 以外の暗号スイートのサポート用<sup>19</sup>)。</span><span class="sxs-lookup"><span data-stu-id="b3993-996">As an example, the software-only ("generic") cryptographic library provided with NetX Secure contains the following table definition (for non-ECC ciphersuite support<sup>19</sup>):</span></span>

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
<span data-ttu-id="b3993-997">この構造体では、最初のエントリが TLS 暗号スイート テーブルです。</span><span class="sxs-lookup"><span data-stu-id="b3993-997">In the structure, the first entry is the TLS ciphersuite table.</span></span> <span data-ttu-id="b3993-998">NX_SECURE_TLS_CIPHERSUITE_INFO 構造体では、暗号化ルーチン (NX_CRYPTO_METHOD ポインターの形式になっています) が、TLS 仕様で定義されている特定の暗号スイートにマップされています。</span><span class="sxs-lookup"><span data-stu-id="b3993-998">The NX_SECURE_TLS_CIPHERSUITE_INFO structure maps cryptographic routines (in the form of NX_CRYPTO_METHOD pointers) to specific ciphersuites as defined in the TLS specifications.</span></span> <span data-ttu-id="b3993-999">2 番目の値は、最初のフィールドが指し示すテーブル内のエントリの数です。</span><span class="sxs-lookup"><span data-stu-id="b3993-999">The second value is the number of entries in the table pointed to by the first field.</span></span>

<span data-ttu-id="b3993-1000">次のフィールドは、デジタル証明書の処理時に X.509 によって使用されるルーチンのテーブルを指し示しており、構造体 NX_SECURE_X509_CRYPTO は、形式が NX_SECURE_TLS_CIPHERSUITE_INFO に類似しています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1000">The next field points to a table of routines used by X.509 when processing digital certificates and the structure NX_SECURE_X509_CRYPTO is similar in form to NX_SECURE_TLS_CIPHERSUITE_INFO.</span></span> <span data-ttu-id="b3993-1001">次のフィールドは、テーブル内のエントリの数です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1001">The following field is the number of entries in the table.</span></span>

<span data-ttu-id="b3993-1002">ルックアップ テーブルに続くのは、特定のバージョンの TLS に必要ないくつかのルーチンです。</span><span class="sxs-lookup"><span data-stu-id="b3993-1002">Following the lookup table are a number of routines needed for specific versions of TLS.</span></span> <span data-ttu-id="b3993-1003">たとえば、TLS バージョン 1.2 より前は、キー生成とハンドシェイク ハッシュのルーチンは、SHA-1 と MD5 の組み合わせを使用するように固定されていました。これらのルーチンのメソッドは、特定の暗号スイートに関連付けられていないため、この暗号構造体の中で明示的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1003">For example, prior to TLS version 1.2, the key generation and handshake hashing routines were fixed to use a combination of SHA-1 and MD5 – the methods for these routines are called out specifically in the cipher structure since they are not tied to specific ciphersuites.</span></span> <span data-ttu-id="b3993-1004">TLS バージョン 1.2 では、キー生成とハッシュのルーチンは暗号スイートによって選択されますが、使用するルーチンが指定されていない暗号スイートでは、SHA-256 ハッシュ方式が使用され、この暗号構造体によってそのルーチンが明示的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1004">In TLS version 1.2, the key generation and hashing routines are chosen by the ciphersuite, but for ciphersuites which do not specify the routines to use, the SHA-256 hash method is used, and the cipher structure calls out that routine specifically.</span></span>

<span data-ttu-id="b3993-1005">TLS 1.3 では、さまざまな操作に対していくつかの特定の暗号が追加で必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1005">TLS 1.3 requires a few extra specific ciphers for various operations.</span></span>

19. <span data-ttu-id="b3993-1006">TLS 1.3 が有効になっている場合は、TLS 1.3 のサポートのために ECC が必要であることに注意します。nx_crypto_tls_ciphers_ecc を使用してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-1006">Note that TLS 1.3 support requires ECC – use nx_crypto_tls_ciphers_ecc if TLS 1.3 is enabled.</span></span>

### <a name="tls-ciphersuite-lookup-table"></a><span data-ttu-id="b3993-1007">TLS 暗号スイート ルックアップ テーブル</span><span class="sxs-lookup"><span data-stu-id="b3993-1007">TLS Ciphersuite Lookup Table</span></span>

<span data-ttu-id="b3993-1008">TLS の暗号テーブルを入力するには、暗号化ルーチンを特定の暗号スイート識別子にマップする暗号スイート ルックアップ テーブルも作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-1008">To fill in the cipher table for TLS, you will also need to create a ciphersuite lookup table that maps cryptographic routines to specific ciphersuite identifiers.</span></span> <span data-ttu-id="b3993-1009">これらの識別子は、IANA で登録されている世界共通の値です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1009">The identifiers are IANA-registered values that are universal.</span></span> <span data-ttu-id="b3993-1010">詳細については、TLS の RFC を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-1010">See the TLS RFCs for more information.</span></span> <span data-ttu-id="b3993-1011">これらのルーチンは、各暗号スイートで使用される 5 つの別個の方法である、パブリック暗号、公開キー認証、セッション暗号、セッション ハッシュ ルーチン、TLS 擬似ランダム関数 (PRF) を表しています (一部の暗号スイートでは 5 つすべては使用されないことがあります)。</span><span class="sxs-lookup"><span data-stu-id="b3993-1011">The routines represent the 5 separate methods used in each ciphersuite (some ciphersuites may not use all 5): public cipher, public-key authentication, session cipher, session hash routine, and TLS Pseudo-Random Function (PRF).</span></span> <span data-ttu-id="b3993-1012">次の表で、5 つの方法それぞれについて説明します。</span><span class="sxs-lookup"><span data-stu-id="b3993-1012">The following table explains each of the 5 methods:</span></span>

| <span data-ttu-id="b3993-1013">**ルーチンのカテゴリ**</span><span class="sxs-lookup"><span data-stu-id="b3993-1013">**Routine category**</span></span>      | <span data-ttu-id="b3993-1014">**説明**</span><span class="sxs-lookup"><span data-stu-id="b3993-1014">**Description**</span></span>                                                                                       | <span data-ttu-id="b3993-1015">**アルゴリズムの例**</span><span class="sxs-lookup"><span data-stu-id="b3993-1015">**Example algorithms**</span></span>                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| <span data-ttu-id="b3993-1016">パブリック暗号</span><span class="sxs-lookup"><span data-stu-id="b3993-1016">Public cipher</span></span>             | <span data-ttu-id="b3993-1017">TLS ハンドシェイク中にキーを交換するために使用されます</span><span class="sxs-lookup"><span data-stu-id="b3993-1017">Used to exchange keys during the TLS handshake</span></span>                                                        | <span data-ttu-id="b3993-1018">RSA、Diffie-Hellman、ECC</span><span class="sxs-lookup"><span data-stu-id="b3993-1018">RSA, Diffie-Hellman, ECC</span></span>                                          |
| <span data-ttu-id="b3993-1019">公開キー認証</span><span class="sxs-lookup"><span data-stu-id="b3993-1019">Public-key authentication</span></span> | <span data-ttu-id="b3993-1020">TLS ハンドシェイク中にデータの認証や署名を行うために使用されます</span><span class="sxs-lookup"><span data-stu-id="b3993-1020">Used to authenticate or sign data during the TLS handshake</span></span>                                            | <span data-ttu-id="b3993-1021">RSA、DSS</span><span class="sxs-lookup"><span data-stu-id="b3993-1021">RSA, DSS</span></span>                                                          |
| <span data-ttu-id="b3993-1022">セッション暗号</span><span class="sxs-lookup"><span data-stu-id="b3993-1022">Session cipher</span></span>            | <span data-ttu-id="b3993-1023">TLS セッション中にアプリケーション データを暗号化するために使用される対称キー アルゴリズム</span><span class="sxs-lookup"><span data-stu-id="b3993-1023">Symmetric-key algorithm used to encrypt application data during the TLS session</span></span>                       | <span data-ttu-id="b3993-1024">AES、RC4</span><span class="sxs-lookup"><span data-stu-id="b3993-1024">AES, RC4</span></span>                                                          |
| <span data-ttu-id="b3993-1025">セッション ハッシュ</span><span class="sxs-lookup"><span data-stu-id="b3993-1025">Session hash</span></span>              | <span data-ttu-id="b3993-1026">TLS セッション中に、メッセージの整合性を維持するために使用されます (データが変更されていないことを保証します)</span><span class="sxs-lookup"><span data-stu-id="b3993-1026">Used to preserve the integrity of messages during the TLS session (assures that data has not changed)</span></span> | <span data-ttu-id="b3993-1027">SHA-1、SHA-256</span><span class="sxs-lookup"><span data-stu-id="b3993-1027">SHA-1, SHA-256</span></span>                                                    |
| <span data-ttu-id="b3993-1028">TLS PRF</span><span class="sxs-lookup"><span data-stu-id="b3993-1028">TLS PRF</span></span>                   | <span data-ttu-id="b3993-1029">TLS ハンドシェイクで、キー マテリアルとハンドシェイク ハッシュを生成するために使用されます</span><span class="sxs-lookup"><span data-stu-id="b3993-1029">Used to generate key material and in the handshake hash in the TLS handshake</span></span>                          | <span data-ttu-id="b3993-1030">PRF はハッシュ ルーチン (SHA-1 と MD5、SHA-256、SHA-512) に基づいています</span><span class="sxs-lookup"><span data-stu-id="b3993-1030">The PRF is based on hash routines – SHA-1 + MD5, SHA-256, SHA-512</span></span> |

<span data-ttu-id="b3993-1031">NX_SECURE_X509_EXTENSION 構造体は、以下のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1031">The NX_SECURE_TLS_CIPHERSUITE_INFO structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
<span data-ttu-id="b3993-1032">nx_secure_tls_ciphersuite フィールドには IANA の暗号スイートの値が格納されており、NX_CRYPTO_METHOD ポインターは、その暗号スイートによって使用される 5 つの方法を表しています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1032">The nx_secure_tls_ciphersuite field contains the IANA ciphersuite value, and the NX_CRYPTO_METHOD pointers represent the 5 methods used by that ciphersuite.</span></span> <span data-ttu-id="b3993-1033">スカラー値 (nx_secure_tls_iv_size、nx_secure_tls_key_size、nx_secure_tls_hash_size) は情報提供用で、NX_CRYPTO_METHOD エントリでは取得できない可能性がある情報が提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1033">The scalar values (nx_secure_tls_iv_size, nx_secure_tls_key_size, and nx_secure_tls_hash_size) are informational, providing information that might not be available in the NX_CRYPTO_METHOD entries.</span></span>

<span data-ttu-id="b3993-1034">例として、TLS の既定の暗号スイートである TLS_RSA_WITH_AES_128_CBC_SHA を見てみましょう。これにより、RSA、128 ビット キーを使用する AES-CBC、セッション ハッシュ用の SHA-1 を使用することが指定されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1034">As an example, we will look at the default ciphersuite for TLS, TLS_RSA_WITH_AES_128_CBC_SHA, which specifies the use of RSA, AES-CBC with 128-bit keys, and SHA-1 for session hashing.</span></span> <span data-ttu-id="b3993-1035">この暗号スイートに対しては TLS PRF が指定されていないので、TLSv1.2 モードでは、既定の SHA-256 PRF が使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1035">No TLS PRF is specified for this ciphersuite, so in TLSv1.2 mode, it will use the default SHA-256 PRF.</span></span> <span data-ttu-id="b3993-1036">表で指定されている PRF に関わらず、TLS 1.0 および 1.1 では、すべての暗号スイートで SHA-1 と MD5 による PRF が使用されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-1036">Note that all ciphersuites use the SHA-1+MD5 PRF in TLS 1.0 and 1.1, regardless of the PRF specified in the table.</span></span>

<span data-ttu-id="b3993-1037">汎用暗号化ライブラリの NX_SECURE_TLS_CIPHERSUITE_INFO テーブル内のエントリでは、以下のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1037">The entry in the NX_SECURE_TLS_CIPHERSUITE_INFO table in the generic cryptographic library is defined as follows:</span></span>

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

<span data-ttu-id="b3993-1038">セッション暗号については、キー サイズは暗号スイートによって決定されるますが、公開キーの方法では、ハンドシェイク中に交換されるデジタル証明書に公開キーが含まれているため、TLS ハンドシェイクの進行中はキー サイズが不明です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1038">Note that for the session cipher the key size is determined by the ciphersuite, but for the public-key methods the key size is not known until the TLS handshake is underway since the public keys are contained in the digital certificates exchanged during the handshake.</span></span>

### <a name="x509-cipher-lookup-table"></a><span data-ttu-id="b3993-1039">X.509 暗号ルックアップ テーブル</span><span class="sxs-lookup"><span data-stu-id="b3993-1039">X.509 Cipher Lookup Table</span></span>

<span data-ttu-id="b3993-1040">NX_SECURE_TLS_CIPHERSUITE_INFO テーブルと同様に、NX_SECURE_X509_CRYPTO 構造体では、暗号化ルーチンが既知の値にマップされています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1040">Like the NX_SECURE_TLS_CIPHERSUITE_INFO table, the NX_SECURE_X509_CRYPTO structure maps cryptographic routines to known values.</span></span> <span data-ttu-id="b3993-1041">X.509 の場合、識別子は実際には X.509 によって定義されており、標準化団体の ISO および ITU に登録されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1041">In the case of X.509, the identifiers are actually OIDs defined by X.509 and registered with the ISO and ITU standards bodies.</span></span> <span data-ttu-id="b3993-1042">OID は、デジタル証明書で使用される暗号化ルーチンなど、さまざまな通信規格において多様な情報を一意に識別するために設計された、可変長のマルチバイト値です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1042">OIDs are variable-length multi-byte values designed to uniquely identify various information in various telecommunication standards, including cryptographic routines used in digital certificates.</span></span> <span data-ttu-id="b3993-1043">OID は可変長であるため、NetX Secure TLS では、公式の OID 値を、内部で使用されている固定長の定数にマップしています (nx_secure_x509.h を参照)。</span><span class="sxs-lookup"><span data-stu-id="b3993-1043">Due to the fact that OIDs are variable length, NetX Secure TLS maps the official OID values to fixed-length constants that are used internally (see nx_secure_x509.h).</span></span> <span data-ttu-id="b3993-1044">これらの定数は、NX_SECURE_X509_CRYPTO 構造体で使用されており、この構造体は以下のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1044">These constants are used in the NX_SECURE_X509_CRYPTO structure, which is defined as follows:</span></span>

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

<span data-ttu-id="b3993-1045">最初のフィールド *nx_secure_x509_crypto_identifier* は、NetX Secure で使用されている内部的な OID 表現です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1045">The first field, *nx_secure_x509_crypto_identifier*, is the internal OID representation used by NetX Secure.</span></span>

<span data-ttu-id="b3993-1046">2 番目と 3 番目のフィールドは、OID によって識別される暗号化の方法を表す NX_CRYPTO_METHOD オブジェクトを指し示しています。これは、ハッシュ ルーチンと組みにされた公開キー操作です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1046">The second and third fields point to NX_CRYPTO_METHOD objects that represent the cryptographic methods identified by the OID, a public-key operation paired with a hash routine.</span></span> <span data-ttu-id="b3993-1047">各デジタル証明書には、暗号化ルーチンに対して複数の OID が含まれている場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-1047">Note that each digital certificate may have more than one OID for cryptographic routines.</span></span>

<span data-ttu-id="b3993-1048">X.509 用の方法のテーブルは、暗号スイート ルックアップ テーブルと同じ方法で作成されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1048">The method table for X.509 is constructed in the same manner as the ciphersuite lookup table.</span></span> <span data-ttu-id="b3993-1049">例として、RSA_SHA1 の OID を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="b3993-1049">As an example, we will look at the OID for RSA_SHA1.</span></span> <span data-ttu-id="b3993-1050">RSA_SHA1 の実際の OID は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b3993-1050">The actual OID for RSA_SHA1 is as follows:</span></span>

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
<span data-ttu-id="b3993-1051">OID は、ASN.1 構文で表現されていて、1.2.840.113549.1.1.5 という数値になっています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1051">The OID is represented in ASN.1 syntax and has a numeric value of 1.2.840.113549.1.1.5.</span></span> <span data-ttu-id="b3993-1052">この値は次に、バイナリ形式でエンコードされ、次のバイトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1052">This value is then encoded in binary format, creating the following bytes:</span></span>

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
<span data-ttu-id="b3993-1053">ASN.1 からバイナリ形式への実際の変換については、このドキュメントの範囲外となっています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1053">The actual conversion from ASN.1 to the binary format is beyond the scope of this document.</span></span> <span data-ttu-id="b3993-1054">詳細については、"OID のための ASN.1 エンコード" を検索してください。</span><span class="sxs-lookup"><span data-stu-id="b3993-1054">Search for ASN.1 encodings for OIDs for more information.</span></span> <span data-ttu-id="b3993-1055">NetX Secure でサポートされている OID のバイナリ表現は、ファイル *nx_secure_x509.c* に記載されています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1055">The binary representation of the OIDs supported by NetX Secure can be found in the file *nx_secure_x509.c*.</span></span>

<span data-ttu-id="b3993-1056">実際の OID から内部で認識される定数へのマッピングが用意できたら、NX_SECURE_X509_CRYPTO テーブル内に RSA_SHA1 のためのエントリを作成できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1056">Once we have a mapping of the actual OID to an internally-recognized constant, we can create an entry for RSA_SHA1 in the NX_SECURE_X509_CRYPTO table:</span></span>

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a><span data-ttu-id="b3993-1057">既定の TLS ルーチン</span><span class="sxs-lookup"><span data-stu-id="b3993-1057">Default TLS Routines</span></span>

<span data-ttu-id="b3993-1058">前述のように、TLS では、ハンドシェイク中にキーの生成とメッセージの検証を行うため、既定のルーチンがいくつか必要です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1058">As mentioned above, TLS requires some default routines for key generation and message verification during the handshake.</span></span> <span data-ttu-id="b3993-1059">プライマリ ルーチンは、TLS 擬似ランダム関数 (PRF) です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1059">The primary routine is the TLS Pseudo-Random Function, or PRF.</span></span> <span data-ttu-id="b3993-1060">PRF はハッシュ ルーチンに基づいており、キー生成やその他の目的で、任意の量の擬似ランダム データ<sup>20</sup> を生成するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1060">The PRF is based on hash routines and can be used to generate an arbitrary amount of pseudo-random data<sup>20</sup> for key generation or other purposes.</span></span>

<span data-ttu-id="b3993-1061">PRF に加えて、各バージョンの TLS で、既定のハッシュ ルーチンが利用されます。このルーチンも提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-1061">In addition to the PRF, each version of TLS utilizes default hash routines that also need to be provided.</span></span> <span data-ttu-id="b3993-1062">TLS バージョン 1.0 および 1.1 では、MD5 と SHA-1 がそれらのハッシュ ルーチンです。</span><span class="sxs-lookup"><span data-stu-id="b3993-1062">For TLS versions 1.0 and 1.1, those hash routines are MD5 and SHA-1.</span></span> <span data-ttu-id="b3993-1063">TLS バージョン 1.2 に必要なのは SHA-256 だけです。</span><span class="sxs-lookup"><span data-stu-id="b3993-1063">TLS version 1.2 requires only SHA-256.</span></span>

<span data-ttu-id="b3993-1064">NX_SECURE_TLS_CRYPTO 構造体には、MD5、SHA-1、SHA-256、TLS バージョン 1.0/1.1 の PRF、既定の TLS 1.2 のための PRF を表す NX_CRYPTO_METHOD ポインターがあります。</span><span class="sxs-lookup"><span data-stu-id="b3993-1064">In the NX_SECURE_TLS_CRYPTO structure, there are NX_CRYPTO_METHOD pointers for MD5, SHA-1, SHA-256, the TLS version 1.0/1.1 PRF, and the default TLS 1.2 PRF.</span></span>

<span data-ttu-id="b3993-1065">TLS 1.3 をサポートすると、HKDF (キーの生成)、HMAC (ハンドシェイク中に使用される特定のハッシュ操作用)、ECDHE (TLS 1.3 の機能に必要) のフィールドが追加されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1065">TLS 1.3 support adds fields for HKDF (key generation), HMAC (for specific hashing operations used during the handshake) and ECDHE (required for TLS 1.3 functionality).</span></span>

<span data-ttu-id="b3993-1066">汎用ソフトウェア暗号化ライブラリで提供されるのは、ソフトウェア バージョンの TLS PRF です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1066">Provided in the generic software cryptography library are software versions of the TLS PRF.</span></span> <span data-ttu-id="b3993-1067">TLS 1.0/1.1 の場合、この関数は *nx_crypto_tls_prf_1* という名称です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1067">For TLS 1.0/1.1, this function is called *nx_crypto_tls_prf_1*.</span></span> <span data-ttu-id="b3993-1068">TLS 1.2 の場合、関数は *nx_secure_tls_prf_sha256* という名前です。</span><span class="sxs-lookup"><span data-stu-id="b3993-1068">For TLS 1.2, the function is called *nx_secure_tls_prf_sha256*.</span></span> <span data-ttu-id="b3993-1069">サフィックス "1" は、従来の TLS 1.0 PRF を表していて、"sha256" サフィックスは、TLS 1.2 の既定の PRF は SHA-256 に基づいているという事実に触れています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1069">The suffix "1" represents the legacy TLS 1.0 PRF, and the "sha256" suffix refers to the fact that the TLS 1.2 default PRF is based on SHA-256.</span></span> <span data-ttu-id="b3993-1070">その他の PRF ルーチンのサポートが必要な場合は、それらのルーチンのサフィックスに、使用されるハッシュ方式が反映されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1070">When support for other PRF routines is needed, the suffix for those routines will reflect the hash method used.</span></span> <span data-ttu-id="b3993-1071">PRF ルーチンはハッシュ方式に基づくため、基になるハッシュ ルーチンに対しては、さまざまなターゲット プラットフォームで独立してハードウェア アクセラレータを使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1071">Since the PRF routines are based on hash methods, the underlying hash routines may be hardware-accelerated independently on different target platforms.</span></span>

<span data-ttu-id="b3993-1072">TLS 暗号スイートと X.509 ルックアップ テーブルに加えて、NX_SECURE_TLS_CRYPTO 構造体には既定の PRF とハッシュ ルーチンを格納することができ、TLS セッションの初期化に使用することができます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1072">In addition to the TLS ciphersuite and X.509 lookup tables, with the default PRF and hash routines filled in the NX_SECURE_TLS_CRYPTO structure can be populated and used to initialize a TLS session.</span></span>

20. <span data-ttu-id="b3993-1073">"擬似ランダム" とは、PRF が決定論的であるという事実を指していて、同じ入力であれば常に同じ出力が生成されることを意味します。しかし、出力が予測不能であるという事実に関してはランダムです。</span><span class="sxs-lookup"><span data-stu-id="b3993-1073">“Pseudo-random” refers to the fact that the PRF is deterministic, meaning it will always produce the same output given the same input, but random in the fact that the output is not predictable.</span></span> <span data-ttu-id="b3993-1074">TLS では、PRF のこの特性を利用して、ハンドシェイク中に RSA のような公開キー暗号を使用して交換されたマスター シークレットと組み合わせたさまざまなパブリック データから、セッション キーを生成しています。</span><span class="sxs-lookup"><span data-stu-id="b3993-1074">TLS uses this property of the PRF to generate the session keys from various public data combined with the master secret exchanged during the handshake using a public-key cipher like RSA.</span></span>

### <a name="cryptographic-metadata"></a><span data-ttu-id="b3993-1075">暗号化メタデータ</span><span class="sxs-lookup"><span data-stu-id="b3993-1075">Cryptographic Metadata</span></span>

<span data-ttu-id="b3993-1076">NX_SECURE_TLS_CRYPTO テーブルを使用して TLS セッションを初期化する前に、暗号化ルーチン メタデータ用のバッファー領域を割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-1076">Before we can initialize the TLS session with the NX_SECURE_TLS_CRYPTO table, we need to allocate buffer space for the cryptographic routine metadata.</span></span> <span data-ttu-id="b3993-1077">メタデータは、その制御ブロックによって表される特定のルーチンに関連付けられている、すべての状態を格納するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1077">The metadata is used to store all the state associated with a particular routine, represented by its control block.</span></span> <span data-ttu-id="b3993-1078">それぞれの NX_CRYPTO_METHOD の *nx_crypto_metadata_area_size* フィールドは、そのルーチンに関連付けられている制御構造のサイズに設定する必要があります。そうしないと、TLS の初期化で、必要な領域が適切に計算されないため、バッファー オーバーランの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-1078">The *nx_crypto_metadata_area_size* field of each NX_CRYPTO_METHOD must be set to the size of the control structure associated with that routine or the TLS initialization will fail to properly account for the space needed, possibly causing buffer overrun issues.</span></span>

<span data-ttu-id="b3993-1079">TLS セッションが作成される前に、メタデータ バッファーを割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3993-1079">Before the TLS session is created, the metadata buffer must be allocated.</span></span> <span data-ttu-id="b3993-1080">このバッファーは、nx_secure_tls_session_create によって自動的に分割されて、暗号化方式の表に示した各ルーチンのために領域が予約されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1080">The buffer is automatically divided up by nx_secure_tls_session_create and space is reserved for each of the routines that are provided in the cryptographic method table.</span></span> <span data-ttu-id="b3993-1081">1 つの TLS セッションで一度にアクティブになる暗号スイートは 1 つだけであるため、サポートされる暗号化スイートの数は、必要とされるメタデータ領域には影響しません。暗号スイート ルックアップ テーブルでの、そのカテゴリに対する最大制御ブロック サイズを使用して、5 つの暗号スイート ルーチンごとに領域が予約されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1081">Note that since only one ciphersuite is active at a time in a TLS session, the number of supported ciphersuites does not affect the needed metadata space – space is reserved for each of the 5 ciphersuite routines using the maximum control block size for that category in the ciphersuite lookup table.</span></span>

<span data-ttu-id="b3993-1082">メタデータ バッファー サイズの計算を簡単にするため、サービス *nx_secure_metadata_size_calculate* では nx_secure_tls_session_create と同じ計算が実行されますが、単純に、必要なメタデータ バッファーの合計サイズがバイト単位で返されます。</span><span class="sxs-lookup"><span data-stu-id="b3993-1082">In order to make calculating the metadata buffer size easy, the service *nx_secure_metadata_size_calculate* performs the same calculations as nx_secure_tls_session_create but simply returns the total required metadata buffer size in bytes.</span></span>

### <a name="initializing-the-tls-session"></a><span data-ttu-id="b3993-1083">TLS セッションの初期化</span><span class="sxs-lookup"><span data-stu-id="b3993-1083">Initializing the TLS session</span></span>

<span data-ttu-id="b3993-1084">NX_CRYPTO_METHOD オブジェクトと NX_SECURE_TLS_CRYPTO オブジェクトが作成され、メタデータ領域が予約されたら、以下のように TLS セッションを初期化できます (上記の例の値を使用)。</span><span class="sxs-lookup"><span data-stu-id="b3993-1084">Once the NX_CRYPTO_METHOD and NX_SECURE_TLS_CRYPTO objects are created and the metadata area reserved, we can initialize a TLS session as follows (values taken from the above examples):</span></span>

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
