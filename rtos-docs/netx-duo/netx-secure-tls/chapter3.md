---
title: 第 3 章 - Azure RTOS NetX Secure の機能の説明
description: この章では、NetX Secure TLS の機能について説明します。
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 711195e60771ebd467c69df49ef7665f32e13a17c21ca839404e829449cf1401
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/07/2021
ms.locfileid: "116797983"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a>第 3 章 - Azure RTOS NetX Secure の機能の説明

## <a name="execution-overview"></a>実行の概要

この章では、Azure RTOS NetX Secure TLS の機能について説明します。 NetX Secure TLS アプリケーションで主に行われるプログラム実行の種類は、初期化とアプリケーション インターフェイスの呼び出しです。 

*NetX Secure は、ThreadX と NetX/NetXDuo の存在を前提としています。ThreadX に求められるのは、スレッドの実行、一時停止、周期タイマー、相互排他の機能です。NetX/NetXDuo に求められるのは、TCP/IP のネットワーク機能とドライバーです。*

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a>トランスポート層セキュリティ (TLS) と Secure Sockets Layer (SSL)

NetX Secure のセキュリティで保護されたネットワーク プロトコル コンポーネントは、RFC 2246 (バージョン 1.0)、4346 (バージョン 1.1)、5246 (バージョン 1.2)、8446 (バージョン 1.3) で説明されているトランスポート層セキュリティ (TLS) プロトコルの実装です。 また、基本的な X.509 (RFC 5280) のサポート ルーチンが含まれています。

NetX Secure TLS は、TLS バージョン 1.2 および 1.3 をサポートしています。 現在は非推奨の TLS 1.0 と TLS 1.1 のための実装が提供されていますが、これらは明示的に初期化する必要があり、新しい製品での使用は推奨されていません。

*Secure Sockets Layer* (SSL) は、RFC 2246 で標準になる前の TLS の、当初の名称でした。"SSL" は多くの場合、TLS プロトコルの総称として使用されています。 SSL の最新バージョンは 3.0 であり、TLS 1.0 は SSL バージョン 3.1 と呼ばれることもあります。 正式な "SSL" プロトコルは、すべてのバージョンが古く安全ではないと見なされており、現在では、NetX Secure に SSL 実装は用意されていません。

TLS では、TLS クライアントとサーバー間の TLS "*ハンドシェイク*" 中に作成される "*セッション キー*" を生成するためのプロトコルが規定されており、それらのキーは、TLS "*セッション*" 中にアプリケーションによって送信されるデータを暗号化するために使用されます。

TLS データは、TCP パケットと同等の概念である "*レコード*" に分割されます。 すべての TLS レコードにヘッダーがあり、TLS で暗号化されたレコードにはフッター (チェックサム ハッシュ) もあります。 TLS ハンドシェイク レコードには、より大きな TLS レコード内にカプセル化される追加ヘッダーがあります。 TLS レコードは、TCP パケットが IP パケットによってカプセル化されるのと同じ方法で、トランスポート層のネットワーク プロトコルによってカプセル化されます。

### <a name="tls-13"></a>TLS 1.3

TLS 1.3 仕様は 2018 年 8 月に最終的に承認されました。 この新しいバージョンのプロトコルは、TLS の基礎となっているセキュリティとパフォーマンスのいくつかの基本的側面に変更を加える、かなり大幅な更新となっています。 ただし、これらの変更は、主に TLS ハンドシェイクの状態機械とセッション キーの生成に適用されるため、大部分は一般的な TLS ユーザーには認識されません。 オプションの機能と拡張機能もいくつか追加されました。 以下に、変更点と、それらが TLS の機能にどのように影響を与えるかの概要を示します。

- サーバーによるメッセージの交換全体を削除して、ハンドシェイクの状態機械が最適化されました。
- HKDF (HMAC ベースのキー派生関数) と呼ばれる標準化されたルーチンを使用するようにキーの生成が更新されました。セッション キーは、いくつかの限られたパラメーターではなく、すべてのハンドシェイク メッセージに結び付けられます。
- TLS 1.2 とそれ以前の暗号スイートは、すべて非推奨とされ、TLS 1.3 と互換性がありません。 同様に、すべての TLS 1.3 暗号スイートは、以前のバージョンと共に使用することができません。
- すべての TLS 1.3 暗号スイートで、短期キー<sup>6</sup> を使用して Perfect Forward Secrecy (PFS) が提供されます 
- TLS 1.3 では、AEAD<sup>7</sup> 暗号の使用を優先させるため、各レコードの "メッセージ認証コード" (MAC) が削除されます
- ハンドシェイク中にアプリケーション データを送信できるようにする 0-RTT (ラウンド トリップ時間ゼロ) など、付加的なオプション機能がいくつか追加されました。 0-RTT は完全にオプションで、Azure RTOS TLS では現在サポートされていません。

TLS 1.3 は、ユーザー アプリケーションに大きな影響を与えません。 API はバージョン間でまったく同じままになっていて、1 つの暗号スイート テーブルが使用されるように暗号スイートにマーク付けされています。

TLS 1.3 を使用するには、マクロ NX_SECURE_TLS_ENABLE_TLS_1_3 がグローバルに定義される必要があります。 Azure RTOS TLS では、TLS 1.3 は既定で無効になっています。

6. "短期" キーは、TLS ハンドシェイク中に生成され、そのセッションでのみシークレット交換に使用される、非対称キーの組です。 これらのキーの組は使用後に破棄されます。これにより将来の任意の時点で証明書の秘密キーが侵害された場合でも、記録されている TLS セッション内の暗号化されたデータに、攻撃者がアクセスできなくなります。つまり、"Perfect Forward Secrecy (完璧な前方機密性)" です。

7. 関連付けられたデータを使用した認証された暗号化 – AES のような暗号のためのモードで、暗号化と、単一の操作での整合性のチェックを組み合わせて、整合性チェックのためにデータのハッシュを別個に行う必要がなくなります。

### <a name="tls-record-header"></a>TLS レコードのヘッダー

有効な TLS レコードにはすべて、"エラー! 参照元が見つかりません" と表示されるように、TLS ヘッダーが必要です。

![TLS レコードのヘッダーの図。](media/image2.png)

図 1 - TLS レコードのヘッダー

TLS レコードのヘッダーのフィールドは、次のように定義されています。

| TLS ヘッダーのフィールド | 目的     |
| ---------------- | ------------- |
| **8 ビットでのメッセージの種類** | このフィールドには、送信中の DTLS レコードの種類が格納されています。 有効な種類は次のとおりです。<br />- ChangeCipherSpec<sup>8</sup>: 0x14<br />- Alert: 0x15<br />- Handshake: 0x16<br />- Application Data: 0x17 |
| **16 ビットでのプロトコル バージョン** | このフィールドには、TLS プロトコルのバージョンが格納されています。 有効な値は次のとおりです。<br />- SSL 3.0: 0x0300<br />- TLS 1.0: 0x0301<br />- TLS 1.1: 0x0302<br />- TLS 1.2: 0x0303<br />- **TLS 1.3 <sup>9</sup>** : **0x0303** |
| **16 ビットでの長さ** | このフィールドには、TLS レコードにカプセル化されたデータの長さが格納されています。 |

8. TLS 1.3 では、ChangeCipherSpec メッセージは使用されなくなっていますが、互換性のために送信される可能性があります。この場合、メッセージは無視されます。

9. このスキームが続行された場合、TLS 1.3 の値は技術的には 0x0304 になりますが、拡張機能においては、実際のプロトコル バージョンを持つようにプロトコルが変更されているため、すべての TLS 1.3 レコードでは、下位互換性のために、プロトコル バージョン フィールドで 0x0303 が使用されます。

### <a name="tls-handshake-record-header"></a>TLS ハンドシェイク レコードのヘッダー

図 2 に示すように、有効な TLS ハンドシェイク レコードにはすべて、TLS ハンドシェイクのヘッダーが必要です。

![TLS ハンドシェイク レコードのヘッダーの図。](media/image3.png)

図 2 - TLS ハンドシェイク レコードのヘッダー

TLS ハンドシェイク レコードのヘッダーのフィールドは、以下のように定義されています。

| TLS ヘッダーのフィールド | 目的 |
| ---------------- |----------------------- |
| **8 ビットでのメッセージの種類** | このフィールドには、送信中の DTLS レコードの種類が格納されています。 有効な種類は次のとおりです。<br />- ChangeCipherSpec<sup>10</sup>: 0x14<br />- Alert: 0x15<br />- Handshake: 0x16<br />- Application Data: 0x17 |
| **16 ビットでのプロトコル バージョン** | このフィールドには、TLS プロトコルのバージョンが格納されています。 有効な値は次のとおりです。<br />- SSL 3.0: 0x0300<br />- TLS 1.0: 0x0301<br />- TLS 1.1: 0x0302<br />- TLS 1.2: 0x0303<br />- **TLS 1.3 <sup>11</sup>** : **0x0303** |
| **16 ビットでの長さ**    | このフィールドには、TLS レコードにカプセル化されたデータの長さが格納されています。 |
| **8 ビットでのハンドシェイクの種類** | このフィールドには、ハンドシェイク メッセージの種類が含まれています。 有効な値は次のとおりです (***太字** のメッセージは TLS 1.3 で追加されました)。<br />- HelloRequest: 0x00<br />- ClientHello: 0x01<br />- ServerHello: 0x02<br />- **HelloVerifyRequest**: **0x03**<br />- **NewSessionTicket**: **0x04**<br />- **EndOfEarlyData**: **0x05**<br />- **EncryptedExtensions**: **0x08**<br />- Certificate: 0x0B<br />- ServerKeyExchange: 0x0C<br />- CertificateRequest: 0x0D<br />- ServerHelloDone: 0x0E<br />- CertificateVerify: 0x0F<br />- ClientKeyExchange: 0x10<br />- Finished: 0x14<br />- **KeyUpdate**: **0x18**<br />- **MessageHash**: **0xFE** |
| **24 ビットでの長さ**    | このフィールドには、ハンドシェイク メッセージのデータの長さが含まれています。 |

10. TLS 1.3 では、ChangeCipherSpec メッセージは使用されなくなっていますが、互換性のために送信される可能性があります。この場合、メッセージは無視されます。

11. このスキームが続行された場合、TLS 1.3 の値は技術的には 0x0304 になりますが、拡張機能においては、実際のプロトコル バージョンを持つようにプロトコルが変更されているため、すべての TLS 1.3 レコードでは、下位互換性のために、プロトコル バージョン フィールドで 0x0303 が使用されます。

### <a name="the-tls-handshake-and-tls-session"></a>TLS ハンドシェイクと TLS セッション

図 3 に、典型的な TLS ハンドシェイク (バージョン 1.0 ～ 1.2) を示します。 TLS ハンドシェイクは、TLS クライアントが *ClientHello* メッセージを TLS サーバーに送信するときに開始され、クライアントが TLS セッションの開始を求めていることを示します。 このメッセージには、クライアントでセッションに使用する暗号化に関する情報と、後でハンドシェイクでセッション キーを生成するために使用される情報が含まれています。 セッション キーが生成されるまで、TLS ハンドシェイクのメッセージはすべて暗号化されません。 TLS 1.3 ではハンドシェイクが多少変更されており、詳細については次のセクションで説明します。

TLS サーバーは、クライアントによって提供された暗号化オプションからの選択を示す ServerHello メッセージによって ClientHello に応答します。 ServerHello の後には証明書メッセージが続き、このメッセージではサーバーにより、クライアントに対してサーバーの ID を認証するためのデジタル証明書が提供されます。 最後に、サーバーによって、送信するメッセージがこれ以上ないことを示す ServerHelloDone メッセージが送信されます。 サーバーからは、ServerHello に続いてオプションで他のメッセージが送信されることがあり、場合によっては Certificate メッセージが送信されないこともあります。そのため、ServerHelloDone メッセージが必要になります。

クライアントでサーバーのメッセージがすべて受信されると、セッション キーを生成するのに十分な情報となります。 これは TLS では、"*プリマスター シークレット*" と呼ばれるランダム データの共有ビットの作成によって行われます。これは固定サイズで、暗号化が有効になった後に必要なすべてのキーを生成するためのシードとして使用されます。 プリマスター シークレットは、Hello メッセージで指定された公開キー アルゴリズム (RSA など) と、サーバーによって証明書で提供された公開キーを使用して暗号化されます (公開キー アルゴリズムの詳細については後述します)。 事前共有キー (PSK) と呼ばれるオプションの TLS 機能を使用すると、証明書を使用せず、代わりにホスト間で共有されるシークレット値を使用する (通常は物理的転送またはその他のセキュリティで保護された方法による) 暗号スイートが有効になります。 共有シークレットは、暗号化されたメッセージを使用してプリマスター シークレットを送信するのではなく、プリマスター シークレットを生成するために使用されます。 後の事前共有キーに関するセクションを参照してください。

暗号化されたプリマスター シークレットは、ClientKeyExchange メッセージでサーバーに送信されます。 サーバーでは、ClientKeyExchange メッセージを受信すると、その秘密キーを使用してプリマスター シークレットが解読され、TLS クライアントと同時のセッション キーの生成に進みます。

セッション キーが生成されると、それ以降のメッセージはすべて、Hello メッセージで選択された秘密キー アルゴリズム (AES など) を使用して暗号化できます。 以後のメッセージはすべて暗号化されることを示すため、ChangeCipherSpec という暗号化されていない最後のメッセージが、クライアントとサーバーの両方によって送信されます。

クライアントとサーバーの両方によって送信される最初の暗号化されたメッセージも、Finished という最後の TLS ハンドシェイク メッセージです。 このメッセージには、送受信されたすべてのハンドシェイク メッセージのハッシュが含まれています。 このハッシュは、ハンドシェイクのどのメッセージも、改ざんされたり破損したり (セキュリティ侵害の可能性を示します) していないことを検証するために使用されます。

Finished メッセージが受信され、ハンドシェイクのハッシュが検証されると、TLS セッションが開始され、アプリケーションのデータの送受信が開始されます。 TLS セッション中に、いずれかの側から送信されたすべてのデータは、まず、Hello メッセージで選択されたハッシュ アルゴリズムを使用して (メッセージの整合性を提供するために) ハッシュされ、選択された秘密キー アルゴリズムと生成されたセッション キーを使用して暗号化されます。

最後に、TLS セッションは、クライアントまたはサーバーのいずれかが終了することを選択した場合にのみ、正常に終了することができます。 打ち切られたセッションは、セキュリティ違反と見なされます (攻撃者が、送信されているすべてのデータが受信されないようにしている可能性があるため)。そのため、どちらかがセッションを終了したいときに、CloseNotify アラートという特別な通知が送信されます。 セッションを正常に停止するには、クライアントとサーバーの両方で CloseNotify アラートを送信して処理する必要があります。

![典型的な TLS ハンドシェイクの図。](media/image4.png)

図 3 - 典型的な TLS ハンドシェイク

### <a name="tls-13-handshake"></a>TLS 1.3 ハンドシェイク

Tls 1.3 では、TLS プロトコルがかなり大幅に見直されています。 セキュリティとパフォーマンスを向上させるため、変更の大部分はハンドシェイクに加えられました。 図 4 に典型的な TLS 1.3 ハンドシェイクを示します。 主な違いは、サーバーとクライアントとの間で行われるやり取りの回数に見られます。

TLS 1.2 以前は、ハンドシェイクを終了する暗号化された Finished メッセージの送信前に、サーバーにより、2 つのフライト<sup>12</sup> メッセージ (最初に ServerHello、次に ChangeCipherSpec メッセージ) が送信されます。 TLS 1.3 では、最初のフライト (ServerHello、拡張機能、証明書、Finished) で、サーバーによってすべてが送信されます。 ChangeCipherSpec メッセージはなくなって、サーバーでは、セッション キーが生成され、ServerHello の直後にハンドシェイク メッセージの暗号化が開始されます。

新しい取り決めは、TLS ハンドシェイクのより多くの部分が暗号化によって保護され、攻撃者がアクセスできるプレーンテキスト データの量が限定されることを意味します。 さらに、2 番目のサーバー フライト (ChangeCipherSpec とそれに続く Finished だけでした) をなくすことは、TLS クライアントがアプリケーション データの送信開始を待つ必要がなくなることを意味します。クライアントが独自の Finished メッセージを送信するとすぐにセッションが開始されるのです。

12. フライトは、グループ内で同時に送信される TLS メッセージの集まりにすぎません。

![TLS 1.3 ハンドシェイクの図。](media/image5.png)

図 4 - TLS 1.3 ハンドシェイクの図。

> [!NOTE]
> *TLS 1.3 では、"早期データ" と 0-RTT (ラウンド トリップ時間ゼロ) の概念も導入されています。つまり、一部のアプリケーション データは、メッセージの初回フライトで送信できます。このオプション機能は、主に Web ブラウザーの応答性の最適化として追加されました (例: ページのレンダリングを開始するために初期に HTTP ヘッダーを送信する)。Azure RTOS 6.0 の時点では、この機能はサポートされていません。*

### <a name="initialization"></a>初期化

NetX Secure TLS を使用する前に、NetX または NetXDuo の TCP/IP スタックを初期化する必要があります。 TCP/IP スタックを正しく初期化する方法については、NetX または NetXDuo のユーザー ガイドを参照してください。

NetX TCP/IP スタックが初期化されると、TLS を有効にできます。 内部的には、TLS ネットワークのトラフィックと処理はすべて NetX/NetXDuo スタックによって処理され、ユーザーの介入は必要ありません。 ただし TLS には、基になっているネットワーク スタックとは別に処理する必要がある特定の要件がいくつかあります。 これらのパラメーターは、_ *_nx_secure_tls_session_create_** サービスを使用して、***NX_SECURE_TLS_SESSION** _ という名前の TLS コントロール ブロックに割り当てられます。

TLS には、Server と Client という 2 つのモードがあり、これらはどちらもアプリケーションで有効にできます (ただし、モードは NetX ソケットごとに 1 つだけです)。後で詳しく説明するように、それぞれ特定の要件があります。

どちらのモードでも、NetX Secure TLS を使用するには、リモート ホストとの TCP 通信のために TCP ソケット (***NX_TCP_SOCKET** _) を作成して設定する必要があります。 後で詳しく説明するように、TCP ソケットは、_ *_nx_secure_tls_session_start_** サービスを使用して TLS セッション インスタンスに割り当てられます。

### <a name="initialization--tls-server"></a>初期化 – TLS サーバー

NetX Secure の TLS Server モードでは、TCP ソケットに加えて、"*デジタル証明書*" (接続している TLS クライアントに対して TLS サーバーを識別するために使用されるドキュメント) と、"*秘密キー*" に対応する証明書 (通常は RSA 暗号化アルゴリズム用) が必要となります。 ITU (国際電気通信連合) X.509 標準では TLS によって使用される証明書の形式が規定されており、X.509 デジタル証明書を作成するためのユーティリティは多数存在します。

NetX Secure TLS の場合、X.509 証明書は、ASN.1 の Distinguished Encoding Rules (DER) 形式を使用してバイナリ エンコードされている必要があります。 DER は、証明書の標準的な TLS ネットワーク転送のバイナリ形式です。

指定された証明書に関連付けられている秘密キーは、DER でエンコードされた PKCS#1 形式である必要があります。 秘密キーはデバイスでのみ使用され、ネットワーク経由で送信されることはありません。 秘密キーは TLS 通信にセキュリティを提供するものなので、安全に保管してください。

TLS Server 証明書を初期化するには、アプリケーションで、DER でエンコードされた X.509 証明書とオプションの DER でエンコードされた PKCS#1 RSA 秘密キー データを含むバッファーへのポインターを、***nx_secure_x509_certificate_intialize** _ サービスを使用して提供する必要があります。このサービスにより、TLS で使用する適切な証明書データが、_ *NX_SECURE_X509_CERT** 構造体に格納されます。

サーバー証明書が初期化されたら、それを TLS 制御ブロックに、***nx_secure_tls_local_certificate_add*** サービスを使用して追加する必要があります。

サーバーの証明書が TLS 制御ブロックに追加されたら、ソケットを使用して、セキュリティで保護された TLS サーバー接続を確立できます。

### <a name="initialization--tls-client"></a>初期化 – TLS クライアント

NetX Secure TLS Client モードを使用するには、信頼された証明機関 (CA) からの、X.509 でエンコードされたデジタル証明書のコレクションである "*信頼された証明書ストア*" が必要です。 TLS プロトコルでは、これらの証明書は "信頼されている" と想定され、TLS サーバー エンティティによって NetX Secure TLS クライアントに提供される証明書を認証するための基盤として機能します。

信頼された CA 証明書は、"*自己署名*" されているか、別の CA によって署名されているかのいずれかです。後者の場合、その証明書は "*中間 CA*" (ICA) と呼ばれます。 一般的な TLS アプリケーションでは、サーバーにより、サーバー証明書と一緒に ICA 証明書が提供されますが、認証成功の唯一の要件は、発行者のチェーン (他の証明書の署名に使用された証明書) を、そのサーバー証明書から、信頼された証明書ストア内の信頼された CA 証明書まで追跡できることです。 このチェーンは、"*信頼のチェーン*" または "*証明書チェーン*" と呼ばれています。

信頼された CA または ICA 証明書を初期化するには、アプリケーションで、DER でエンコードされた X.509 証明書を含むバッファーへのポインターを ***nx_secure_x509_certificate_intialize** _ サービスを使用して提供する必要があります。このサービスにより、TLS で使用する適切な証明書データが、_ *NX_SECURE_X509_CERT** 構造体に格納されます。

初期化した信頼された証明書は、次に、***nx_secure_tls_trusted_certificate_add*** サービスを使用して TLS 制御ブロックに追加されます。 証明書を追加しないと、TLS プロトコルでリモートの TLS サーバー ホストを認証する手段がなくなるため、TLS クライアント セッションが失敗します。

TLS クライアントには、受信するサーバー証明書を割り当てるための領域も必要です (事前共有キー モードが使用されていない場合)。 NetX Secure TLS 5.12 以降、アプリケーションでリモート証明書の領域を割り当てる必要はなくなりました。 ただし、サーバー証明書に領域を割り当てる従来のオプションは引き続き使用可能で、ユーザーが割り当てた証明書は、内部証明書バッファー最適化 <sup>13</sup> の前に使用されます。詳細については、***nx_secure_tls_remote_certificate_allocate*** サービスを参照してください。

信頼された証明書ストアが作成され、サーバー証明書用の領域が割り当てられたら、ソケットを使用して、セキュリティで保護された TLS クライアント接続を確立することができます。

13. 最適化では、以前のバージョンの NetX Secure TLS で使用されていたユーザー指定の構造体を使用する代わりに、*nx_secure_tls_session_packet_buffer_set* を使用してユーザー アプリケーションから tls セッションに提供される "パケット バッファー" を利用して X.509 解析構造体を割り当てます。 パケット バッファーのサイズを超える証明書チェーンが使われる可能性はほとんどありません。その場合、パケット バッファー サイズを大きくするか、*nx_secure_tls _remote_certificate_allocate* を使用して証明書チェーン用の領域を割り当てることができます。

### <a name="application-interface-calls"></a>アプリケーション インターフェイスの呼び出し

NetX Secure TLS アプリケーションでは、通常、ThreadX RTOS で実行されているアプリケーション スレッド内から関数呼び出しを行います。 一部の初期化、特に基盤となっているネットワーク通信プロトコル (TCP や IP など) については、***tx_application_define*** から呼び出すこともできます。 ネットワーク通信の初期化の詳細については、NetX または NetXDuo のユーザー ガイドを参照してください。

TLS では、プロセッサを集中的に使用する操作である暗号化ルーチンが多用されます。 一般に、これらの操作は、呼び出し元スレッドのコンテキスト内で実行されます。

### <a name="tls-session-start"></a>TLS セッションの開始

TLS には、機能させるための基になるトランスポート層ネットワーク プロトコルが必要です。 一般的に使用されるプロトコルは TCP です。 NetX Secure TLS セッションを確立するには、NetX/NetXDuo TCP API を使用して TCP 接続を確立する必要があります。 **NX_TCP_SOCKET** を作成し、接続の確立には、**_nx_tcp_server_socket_listen_ *_ および _* _nx_tcp_server_socket_accept_ *_ サービス (TLS サーバーの場合)、または _* _nx_tcp_client_socket_connect_** サービス (TLS クライアントの場合) を使用する必要があります。

TCP 接続が確立されると、次に TCP ソケットが ***nx_secure_tls_session_start*** サービスに渡されます。

### <a name="tls-packet-allocation"></a>TLS パケットの割り当て

NetX Secure TLS では、NetX/NetXDuo TCP (***NX_PACKET** _) と同じパケット構造が使用されますが、TLS ヘッダーの領域が適切に割り当てられるように、_*_nx_packet_allocate_*_ サービスを呼び出すのではなく、_ *_nx_secure_tls_packet_allocate_** サービスを呼び出す必要がある点が異なります。

### <a name="tls-session-send"></a>TLS セッションでの送信

TLS セッションが開始されたら、アプリケーションでは ***nx_secure_tls_session_send** _ サービスを使用してデータを送信することができます。 送信サービスは、使用の点では _*_nx_tcp_socket_send_*_ サービスと同様です。送信されるデータが格納されている _*_NX_PACKET_*_ データ構造を受け取り、そのデータだけが送信前に NX Secure TLS スタックによって暗号化されます。また、_*_nx_secure_tls_packet_allocate_** を使用してパケットの割り当てが行われる必要があります。

### <a name="tls-session-receive"></a>TLS セッションでの受信

TLS セッションが開始されたら、アプリケーションでは ***nx_secure_tls_session_receive** _ サービスを使用してデータの受信を開始できます。 TLS セッションでの送信と同様に、このサービスは使用の点では _*_nx_tcp_socket_receive_** と同様ですが、受信データは、パケット構造で返される前に、TLS スタックによる解読と検証が行われる点が異なります。

### <a name="tls-session-close"></a>TLS セッションの終了

TLS セッションが完了したら、TLS のクライアントとサーバーの両方で他方に CloseNotify アラートを送信し、セッションを停止する必要があります。 セッションが正常に停止されるようにするには、双方でアラートを受信して処理する必要があります。

リモート ホストから CloseNotify アラートが送信されると、そのアラートは、***nx_secure_tls_session_receive** _ サービスへの呼び出しによって処理され、対応するアラートがリモート ホストに返信され、値 _*_NX_SECURE_TLS_SESSION_CLOSED_** が返されます。 セッションが終了すると、それ以降は、その TLS セッションを使用してデータの送受信を試みるとすべて失敗します。

アプリケーションで TLS セッションを終了する場合は、***nx_secure_tls_session_end** _ サービスを呼び出す必要があります。 このサービスによって CloseNotify アラートが送信され、応答の CloseNotify が処理されます。 応答が受信されない場合は、TLS セッションが正常に停止されなかったこと (セキュリティ侵害の可能性があります) を示すエラー値 _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_** が返されます。

### <a name="tls-alerts"></a>TLS アラート

TLS は最大限のセキュリティを提供するように設計されています。そのため、プロトコルでの誤った動作は、潜在的なセキュリティ侵害と見なされます。 このため、メッセージの処理や暗号化と解読におけるすべてのエラーが、ハンドシェイクまたはセッションを直ちに終了させる致命的エラーと見なされます。

ローカル アプリケーションでのエラー処理は比較的簡単ですが、リモート ホストでは、状況を適切に処理し、さらなるセキュリティ違反の可能性を回避するために、エラーが発生したことを認識する必要があります。 このため TLS では、エラー発生時にはリモート ホストに、"*アラート*" メッセージが送信されます。

送信されたアラートの種類を参考にして攻撃者が情報を収集できないようにするため、アラートはセッション中に、他の TLS メッセージと同じ方法で扱われ、暗号化されます。 ハンドシェイク時には、潜在的な攻撃者によって取得される可能性がある情報の量を限定するため、送信されるアラートはスコープ内に制限されます。

TLS セッションを閉じるために使用される CloseNotify アラートは、致命的ではない唯一のアラートです。 これはアラートと見なされて、アラート メッセージとして送信されますが、エラーが発生したことを示さないという点で、CloseNotify は他のアラートとは異なっています。

アラートの値と "レベル" は、TLS の RFC で定義されており、発生したエラーの種類を示します (レベルは "警告" と "致命的" で、ほとんどの TLS アラートは "致命的" です)。 CloseNotify 以外のほとんどの TLS アラートは、潜在的なセキュリティの問題を示していると考えることができ、TLS セッションやハンドシェイクは中止されることになります。 TLS API 呼び出しによって **NX_SECURE_TLS_ALERT_RECEIVED** (0x114) が返された場合、API サービス **_nx_secure_tls_session_alert_value_get_** (NetX Secure TLS バージョン 5.12 の新機能) を使用すると、セキュリティ問題への対処に関する決定のためにアプリケーションで利用するため、TLS のアラート値とレベルを取得できます。 ほとんどの場合、リモート ホストから受信した CloseNotify 以外のアラートはすべて、いくつかの例外はありますが、致命的なエラーと見なす必要があります。詳細については、TLS の RFC を参照してください。

### <a name="tls-session-renegotiation"></a>TLS セッションの再ネゴシエーション

TLS では、"再ネゴシエーション" の概念がサポートされています。これは単純に、既存の TLS セッションのコンテキスト内で TLS セッション パラメーターを再ネゴシエーションすることです。 これは、実際には、既存のセッションを使用して新しいハンドシェイク メッセージの暗号化と認証が行われることを意味します。 再ネゴシエーションは、TLS ホストで、新しいセッション パラメーターを生成したい場合に使用されます (新しい TLS セッションキーを生成するなど)。既存のセッションを完了する必要はありません。 たとえば、アプリケーションのセキュリティ ポリシーで、セッション キーは限られた時間のみ使用されると規定されていても、その時間を超えて TLS セッションがアクティブな状態に留まる場合には、再ネゴシエーションが望ましい可能性があります。

セッションの再ネゴシエーションに関する問題の 1 つは、それによって特定の中間者攻撃に対して TLS が脆弱になることです。攻撃者がサーバーに新しいパラメーターで再ネゴシエーションを開始させることで、TLS セッションを乗っ取れるようにするといった攻撃です。 この問題を軽減するため、Secure Renegotiation Indication 拡張機能が導入されました ("**エラー! 参照元が見つかりません**" に関する セクションを参照)。

NetX Secure TLS では、セッションの再ネゴシエーションと、Secure Renegotiation Indication 拡張機能が完全にサポートされています。

リモート ホストからデータを受信すると、再ネゴシエーション (と拡張機能) は、アプリケーションとの相互作用なしで自動的に処理されます。 セッションの再ネゴシエーションに関する通知が必要な場合は、*nx_secure_tls_session_renegotiate_callback_set* サービスで、再ネゴシエーションのコールバックが提供されることがあります。 リモート ホストによって再ネゴシエーションが要求されるたびにこのコールバックが呼び出され、必要に応じてアプリケーションでアクションを起こすことができます。

アクティブな TLS セッションから再ネゴシエーションを開始するには、目的の TLS セッションで、*nx_secure_tls_session_renegotiate* サービスを呼び出すだけです。

### <a name="tls-session-resumption"></a>TLS セッションの再開

いくつかの類似点はありますが、TLS セッションの再開を、セッションの再ネゴシエーションと混同しないでください。 セッションの "*再ネゴシエーション*" では、既存の TLS セッション内で新しいハンドシェイクが開始されます。セッションの "*再開*" は、完全な TLS ハンドシェイクを実行せずに閉じられた TLS セッションの再開を伴う、純粋にオプションの機能です。 これを実現するために、TLS の実装では、セッションのパラメーターとキーをキャッシュして、それらを元のハンドシェイクで提供された一意の識別子である "*セッション ID*" に関連付けることができます。 クライアントは、TLS サーバーに対してセッション ID を提供することによって、ホスト間の以前の TLS セッションが過去に存在し、完了したこと、また、簡略化したハンドシェイクでセッションを再確立するための状態が、まだクライアントに保持されていることを示します。 セッション キーは、理論的には依然として秘密であり、通信している 2 つのホストのみに認識されるため、サーバーは新しい TLS セッションを開始し、通常のハンドシェイクのほとんどをバイパスできます。

セッションの再開は、キー生成マスター シークレットを共有し、証明書の署名を検証するために使用される、コストが高い場合がある公開キー操作を回避するのに役立ちますが、セッション パラメーター、キー、暗号化の状態を、考えられるすべてのセッションについて (少なくとも構成可能な時間枠の間は) メモリ内に保持する必要もあります。

現在のバージョンの NetX Secure TLS では、セッションの再開はサポートされていません。セッション ID は TLS サーバーによって無視されるだけで、TLS クライアントは常に NULL のセッション ID を指定します。これにより、サーバーは完全なハンドシェイクを実行するように求められます。 セッション再開は完全にオプション機能であり、すべての TLS 実装では、セッション ID が NULL であるか認識できない場合は既定で完全なハンドシェイクを行う必要があるため、この機能が無ければ相互運用性の問題は発生しないはずです。

### <a name="protocol-layering"></a>プロトコルのレイヤー化

TLS プロトコルは、トランスポート層 (TCP など) とアプリケーション層の間のネットワーク スタックに属します。 TLS は、トランスポート層のプロトコル (したがって、"*トランスポート層*" のセキュリティ) と見なされることがありますが、基盤となっているネットワーク プロトコル (TCP など) に関してはアプリケーションとして機能するため、アプリケーション層にグループ化されることもあります。

TLS には、TCP などの、順番どおりで無損失の配信をサポートするトランスポート層プロトコルが必要です。 この要件のために、TLS を UDP 上で実行することはできません。UDP ではデータグラムの配信が保証されないためです。 *DTLS* と呼ばれる別のプロトコルは、TLS の変更されたバージョンであり、UDP などのデータグラム プロトコル上で TLS のセキュリティを必要とするアプリケーションに使用されます。 NetX Secure では DTLS がサポートされていますが、DTLS のドキュメントは、このドキュメントとは別個のものです。

![TCP/IP および TLS プロトコル層の図。](media/image6.png)

図 5 - TCP/IP および TLS プロトコル層の図。

## <a name="network-communications-security"></a>ネットワーク通信のセキュリティ

パブリック ネットワークとインターネットを介した通信をセキュリティで保護することは、非常に重要なトピックであり、膨大な数の書籍、記事、ソリューションの対象となっています。 このテーマは信じがたいほど複雑ですが、意図したターゲットだけが情報へのアクセスや変更を行えるようにネットワーク経由でその情報を送信する、という単純な考え方にまとめることができます。 これは、機密性、整合性、認証の 3 つの重要な概念に分類されます。 TLS プロトコルでは、3 つすべてに対する解決策が提供されています。

### <a name="secrecy"></a>機密性

ネットワーク経由でのデータ送信時には、多くの場合、悪意のあるエンティティがデータを取得できないことが重要です。 データが TCP/IP 接続を介して送信される場合、そのネットワークにアクセスできる誰もが、容易に入手できるネットワーク ツールを使用してそのデータを読み取ることができます。 データが取得されないようにするには、意図したターゲット以外は読み取れないようにデータをエンコードする必要があります。これが "*機密性*" です。 TLS では、RSA や AES などの暗号化アルゴリズムによって、機密性が提供されます。

### <a name="integrity"></a>整合性

ネットワーク上を移動するデータを保護するためには、機密性では十分ではない場合があります。 場合によっては、悪意のあるエンティティにより、TCP パケットの内容が変更される可能性があります。そのパケットに含まれる内容を知る必要はないのです。 暗号化されたデータの変更は可能であり、解読を無効にしたり、攻撃者が実現したいと考えている何らかの結果になるようにメッセージのパラメーターを変更したりするのです。 ネットワーク上では、攻撃者が転送中のデータを変更することを防止できませんが、データが変更されたかどうかを知るためのメカニズムは提供できます。 データが転送中に変更されたら、そのことが認識されて、データを拒否することができます。 この概念が "*整合性*" です。 TLS では、整合性は "*ハッシュ関数*" と呼ばれる暗号化ルーチンのクラスによって提供されます。 ハッシュ関数の例としては、MD5 や SHA-1 が挙げられます。

### <a name="authentication"></a>認証

ネットワーク通信のセキュリティにおける 3 つ目の重要な概念は、データは意図したターゲットにのみ伝達される必要があるという考え方です。 攻撃者は、別のホストに向けたデータを受信するために、正当なエンティティに見せかけようとする可能性があります。 機密性と整合性のメカニズムを使用してデータが送信されている場合であっても、攻撃者はまだ、この策略を通して、望む結果 (セキュリティで保護された通信の侵害) を実現できる可能性があります。 これを防ぐには、機密データが送信される前に、リモート ホストの ID を証明するためのメカニズムが必要です。 リモート ホストの ID を証明するプロセスが "*認証*" です。 TLS では、デジタル証明書、ハッシュ関数、公開キー暗号化の特性を利用する "*デジタル署名*" と呼ばれるメカニズムを使用して認証が提供されます (後述)。 *事前共有キー* (PSK) を使用して、限定的であっても便利な認証の形式を提供することもできます。

## <a name="tls-encryption"></a>TLS 暗号化

TLS プロトコルは、暗号化を利用してインターネット上で、セキュリティで保護されたネットワーク通信を提供するためのフレームワークです。 暗号化は、一般に、元のデータ (またはそのデータに関する情報) を入手することが、"*キー*" なしでは極めて困難であるような方法でデータをエンコードするプロセスとして定義されます。 コンピューター システムの暗号化は、有限フィールドなどの複雑な数学に基づいており、"*秘密キー*" (または "*対称暗号化*") と "*公開キー*" ("*非対称暗号化*") の 2 種類に分類できます。 秘密キーの暗号化の例には、AES (Advanced Encryption Standard) や RC4 (Rivest Cipher 4) があります。 公開キーの暗号化の例には、RSA (Rivest、Shamir、Adleson) 暗号や Diffie-Hellman 暗号があります。

TLS プロトコルは、秘密キーと公開キーの両方の暗号化ルーチンを利用して、パフォーマンス、セキュリティ、柔軟性のバランスを実現しています。

### <a name="private-key-encryption"></a>秘密キーの暗号化

秘密キーの暗号化は、長年にわたって使用されてきました。 基本的な換字暗号 (文字または単語が別の無関係な文字または単語に置き換えられる) は、最も昔から知られている暗号化の例ですが、情報時代の到来により、秘密キーの暗号化は大幅な機能強化を果たしてきました。

秘密キー暗号では "キー" が使用されます。これは、そのキーにアクセスできるエンティティのみが意味をなす方法でデータをデコードできるように、何らかの方法で何かのデータをエンコードするために使用されます。 キーは、データの暗号化と解読の両方に使用されます。そのため、"*対称暗号化*" という他の名前があります。

秘密キー暗号は、関連する数学が極めて複雑であっても、一般に高速であり、実装することがかなり容易です。 このため TLS では、セキュリティで保護された通信のほとんどに対して秘密キー暗号を使用します。

ただし、秘密キーの暗号化は、一般的なコンピューターのネットワーク通信に適用しようとすると問題があります。キーは、通信を試みる両方のコンピューター間で共有する必要があるのです。 一般的な場合、インターネット上の 2 台のコンピューター間で秘密キーを安全に伝達することは、非現実的であったり、場合によっては不可能であったりします。ネットワーク トラフィックは、インターネットを通ってルーティングされるときにデータが経由するさまざまなホップで、任意の数のエンティティによって取得可能であると想定できるためです。 キーが悪意のあるエンティティによって取得された場合、そのキーを使用して暗号化されたすべてのデータが侵害されます。 インターネット上のほとんどのコンピューターには、ネットワーク接続しかなく、セキュリティで保護された別の通信用チャネルはないため、ネットワーク経由でキーを送信することは、暗号化されていないデータを送信することと同等で、セキュリティは備わっていません。

このため、汎用のネットワーク通信セキュリティ プロトコルを実装するには、秘密キーの暗号化では不十分です。 ここで役立つのが公開キーの暗号化です。

NetX Secure TLS では、AES による秘密キーの暗号化がサポートされています。

### <a name="public-key-encryption"></a>公開キー暗号方式

秘密キーの暗号化とは異なり、公開キーの暗号化は、1970 年代に表れた比較的非常に新しい概念です。 数学で "トラップドア関数" として知られている概念を利用すると、暗号化されたデータのセキュリティを損なうことなく、ネットワーク経由でキーを共有する方法があることが発見されました。

公開キーの暗号化は、キーが (前述した秘密キーの暗号化の意味で) 2 つの部分である "*秘密キー*" と "*公開キー*" に分割されることで機能しますが、そこから公開キーの暗号化の名前が付けられています。 これらのキーのいずれか (通常は公開キー) を暗号化のために使用し、もう一方を解読に使用する、という考えです。 このキーの非対称性が、公開キー暗号化の別の名前である "*非対称暗号化*" の理由となっています。

公開キー暗号化の背後にある数学はかなり複雑ですが、公開キーは暗号化に "*のみ*" 使用することができ、そのキーを取得しても暗号化されたデータは入手できないという考え方です。 次に秘密キーは、公開キーを使用して暗号化されたデータを解読する唯一の方法です。 したがって、秘密キーを秘密のままにしておくことで、その秘密キーの所有者と安全に通信することを望む人はだれでも、その秘密キーを所有している人だけがセキュリティで保護されたデータを取得できると知ったうえで、対応する公開キーでデータを暗号化するだけで済みます。

NetX Secure TLS では RSA 公開キー暗号化がサポートされています。

> [!IMPORTANT] 
> *RSA は、ソフトウェアの RSA 実装が使用されている場合にはプロセッサを集中的に使用する操作です。キー サイズを大きくすると、必要な処理能力は 2 乗で増加します。つまり、キー サイズを 2 倍に増加すると 4 倍低速になります。*

### <a name="public-key-authentication"></a>公開キー認証

公開キー暗号化の概念には、これを使用して逆の操作を行うことで、暗号化に加えて認証を提供できるという興味深い副次的効果があります。"*秘密*" キーを使用して暗号化し、"*公開*" キーを使用して解読するのです。 これを行うための実際のメカニズムは、使用される公開キー アルゴリズムによって異なりますが、考え方は同じです。

公開キー認証を使用して認証するためには、秘密キーの所有者が、その秘密キーを使用して一部のデータ (一般には認証対象のデータの暗号化ハッシュ) を暗号化します。 次に、データが秘密キーの所有者から来たことを認証したいユーザーは、関連付けられている公開キーを使用してそのデータを解読します。解読に成功する場合は、ユーザーがその公開キーの有効性を信頼している前提であれば、そのデータは秘密キーの所有者から来たものであることを確認できます。

TLS では、信頼された証明書ストアの公開キーを使用して TLS サーバー (やオプションでの TLS クライアント) によって提供されたデジタル証明書の有効性を、公開キー認証を使用して検証します。 証明書はストアの公開キーに対してチェックされ、証明書内のデータは、サーバーの ID を確認するために使用されます。

NetX Secure TLS では RSA 認証がサポートされています。

### <a name="cryptographic-hashing"></a>暗号化ハッシュ

暗号化は、TLS で使用される唯一の暗号化操作ではありません。 TLS セッション中にメッセージの整合性を提供するには、メッセージの内容が改ざんされていないことを確認するためのチェックサムが必要です。 ただし (TCP で使用されるような) 簡単なチェックサムでは、知識のある攻撃者が簡単に突破できるため、受け入れ可能な整合性のレベルを保証するには不十分です。 メッセージの整合性を提供するために TLS によって使用されるメカニズムは、"*暗号化ハッシュ*" と呼ばれています。

暗号化は 1 対 1 のエンコードです。つまり、暗号化されたデータから元のデータ全体を取得できます。 ただし、ハッシュでは、チェックサムと同様に、任意の量のデータを固定サイズの値にマップします。 単純なチェックサムとは異なり、ハッシュは、異なる入力データが同じ出力になるような "*競合*" を減らすために特に設計されています。 単純なチェックサムでは、ビットが 1 から 0 に反転され、別のビットが 0 から 1 に反転されている場合、チェックサムは同じになります。 暗号化ハッシュの使用時には出力に大きな違いが生じるため、攻撃者がハッシュされたデータを変更し、変更されたデータに対してハッシュ操作を行っても同じ値になるようにする (そうして、そのデータの整合性の検証を誤らせる) のは困難になります。

TLS では、いくつかの異なるハッシュ アルゴリズムを使用して、アプリケーション メッセージと TLS 制御メッセージの両方のメッセージに整合性を提供します。 これには MD5、SHA-1、SHA-256 が含まれます。

NetX Secure TLS では、MD5、SHA-1、SHA-256 のハッシュがサポートされています。

## <a name="tls-extensions"></a>TLS 拡張機能

TLS には、特定のアプリケーションに追加の機能を提供する拡張機能が多数用意されています。 これらの拡張機能は、通常、ClientHello または ServerHello メッセージの一部として送信され、拡張機能の使用を望んでいることをリモート ホストに示したり、セキュリティで保護された TLS セッションの確立に使用する追加の詳細情報を提供したりします。

一般に、拡張機能では、ハンドシェイクの開始時に、進行中の操作をガイドするオプションのパラメーターを TLS に対して指定します。 一部の拡張機能には、アプリケーションによる入力や意思決定が必要ですが、一方、他の拡張機能では自動的に処理されます。

次の表で、NetX Secure TLS で現在サポートされている、TLS の拡張機能について説明します。

| **Extension Name**              | **説明**              |
| ------------------------------- |----------------------------- |
| Secure Renegotiation Indication | この拡張機能により、再ネゴシエーションのハンドシェイク中に発生する可能性がある中間者攻撃の脆弱性が軽減されます。|
| Server Name Indication          | この拡張機能により、TLS クライアントは特定の DNS 名を TLS サーバーに提供できるようになり、サーバーが正しい資格情報を選択できるようになります (サーバーに複数の ID 証明書とネットワーク エントリポイントがあることが前提)。 |
| Signature Algorithms            | この拡張機能により、TLS クライアントは、使用可能な署名アルゴリズムとハッシュ アルゴリズムのリストを TLS サーバーに提供できるようになります。 |

サポートされている TLS 拡張機能の概要

### <a name="secure-renegotiation-indication"></a>Secure Renegotiation Indication

TLS では、既存の TLS セッション内でハンドシェイクを実行し、それにより、確立されたセッションを使用してハンドシェイク メッセージを暗号化するという概念がサポートされています。 このプロセスにより、TLS セッションを終了せずに暗号化セッション キーを再確立することができます (「TLS セッションの再ネゴシエーション」セクションを参照)。

残念ながら、しばらくの間 TLS で再ネゴシエーションが使用された後、再ネゴシエーション機能を悪用する中間者攻撃に対して脆弱性が存在していたことが検出されました。 脆弱性を解消するため、Secure Renegotiation Indication 拡張機能が導入されました。 Secure Renegotiation 拡張機能では、基本的に、確立された接続からの Finished メッセージのハッシュを使用して、元のホストが再ネゴシエーション ハンドシェイクに参加していることを確認します。基本的にハッシュは、攻撃者はハッシュを偽造できないであろうという前提のもとで、検証トークンとして使用されています。

NetX Secure TLS では再ネゴシエーションは自動的に処理され、Secure Renegotiation Extension は既定で使用されます。 アプリケーションの操作は不要です。

### <a name="server-name-indication"></a>Server Name Indication

TLS クライアントでは、TLS ハンドシェイク中にクライアントでサーバーを認証できるように、リモート サーバーから ID 証明書が提供されると予期しています。 ただし、1 つのサーバーが、それぞれ一意の ID を持つ異なる "仮想" サーバーを使用して複数の異なるサービスを提供する場合もあります。 複数の ID を持つ単一サーバーの場合、TLS クライアントでは、サーバーが適切な資格情報を選択するために使用する特定の DNS 名を指定できます。この名前を指定するメカニズムが、Server Name Indication (SNI) 拡張機能です。

SNI 拡張機能を使用するアプリケーションのためには、何らかの操作が必要です。 TLS クライアントの場合、アプリケーションでは、リモート サーバーに送信される DNS 名を指定する必要があります。 TLS サーバーの場合、アプリケーションでは、拡張機能から DNS 名を読み取り、クライアントに送り返す適切な証明書を選択する必要があります。

以降のセクションでは、NetX Secure TLS で SNI 拡張機能を使用する方法について詳しく説明します。

### <a name="sni-extension--tls-client"></a>SNI 拡張機能 – TLS クライアント

SNI 拡張機能を使用する予定の NetX Secure TLS クライアントでは、ハンドシェイク中に指定される DNS 名を TLS に提供する必要があります。 拡張機能はハンドシェイク プロセスを開始する ClientHello メッセージの中で送信されるため、TLS セッションを開始する前に、この名前の初期化と指定を行う必要があります。

次のコード スニペットは、拡張機能の使い方を示しています。 まず、目的のサーバー名を使用して、NX_SECURE_X509_DNS_NAME オブジェクトが初期化されます。 次に、TLS セッションの開始前に、SNI 拡張機能 API を使用して TLS に名前が指定されます。 名前が設定されたら、以後の操作は必要ありません。 個々の関数の詳細については、第 4 章の  
  
NetX Secure サービスに関する説明のページで API リファレンスを参照してください。

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a>SNI 拡張機能 – TLS サーバー

TLS サーバー側では、ハンドシェイク中にリモート クライアントに提供する適切な資格情報 (証明書など) を選択するため、アプリケーションで SNI 拡張機能の処理が行われる場合があります。 これを行うには、アプリケーションで、ClientHello メッセージの受信に続いて呼び出されるセッション コールバックを提供する必要があります。

nx_secure_tls_session_server_callback_set API のコード例 (122 ページを参照) は、サーバー コールバックを使用した受信 SNI 拡張機能の解析を示しています。 基本的に、TLS サーバーで ClientHello を受信してコールバックを呼び出します。 次に、アプリケーションで *nx_secure_tls_session_sni_extension_parse* API を使用して、コールバックに提供された拡張機能データを解析して SNI 拡張機能を見つけ、指定された DNS 名を返します (この拡張機能では、1 つの DNS 名のみがサポートされていることに注意してください)。 名前が取得されたら、アプリケーションでそれを使用し、適切なサーバー ID 証明書 (および該当する場合は発行者チェーン) を見つけ、それを送信します。

### <a name="signature-algorithms-extension"></a>Signature Algorithms 拡張機能

この拡張機能は TLS 1.2 に固有のもので、TLS クライアントで、デジタル署名の生成と検証に使用するための、受け入れ可能な署名とハッシュ アルゴリズムの組のリストを提供できるようになります。 このリストは、*nx_secure_tls_session_create* に提供された暗号テーブルを使用して、TLS クライアント用の NetX Secure TLS によって自動的に生成されます。 アプリケーションの操作は不要です。

## <a name="authentication-methods"></a>認証方法

TLS には、セキュリティで保護されていないネットワーク上で 2 つのデバイス間にセキュリティで保護された接続を確立するためのフレームワークが用意されていますが、その接続の他方の末端にあるデバイスの ID を認識することが、問題の一部となっています。 リモート ホストの ID を認証するためのメカニズムがない場合は、攻撃者が簡単に信頼されたデバイスを装うことができるようになります。

最初は、IP アドレス、ハードウェアの MAC アドレス、または DNS を使用すると、ネットワーク上のホストを識別するうえで比較的高い信頼性が得られるように思われるかもしれませんが、TCP/IP テクノロジの性質と、アドレスのなりすましや (たとえば DNS キャッシュ ポイズニングを通した) DNS エントリの破損は容易であることを考えると、TLS には不正な ID に対する追加の保護レイヤーが必要であることは明確になります。

この追加の認証レイヤーを TLS に提供できるさまざまなメカニズムがありますが、最も一般的なのは "*デジタル証明書*" です。 その他のメカニズムには、事前共有キー (PSK) とパスワードのスキームがあります。

### <a name="digital-cerificates"></a>デジタル証明書

デジタル証明書は、TLS でリモート ホストを認証するための最も一般的な方法です。 基本的にデジタル証明書は、コンピューター ネットワーク上のデバイスの ID 情報を提供する特定形式のドキュメントです。

TLS では通常、国際電気通信連合によって開発された標準である X.509 という形式が使用されますが、使用される形式について TLS ホストの同意が得られる場合は、他の形式の証明書を使用できます。 X.509 では、証明書の特定の形式と、デジタル ドキュメントの生成に使用できるさまざまなエンコードが定義されています。 TLS で使用されるほとんどの X.509 証明書は、別の通信規格である ASN.1 のバリアントを使用してエンコードされます。 ASN.1 にはさまざまなデジタル エンコードがありますが、TLS 証明書で最も一般的なエンコードは、Distinguished Encoding Rules (DER) 標準です。 DER は、あいまいさが排除されるように設計された ASN.1 基本エンコード規則 (BER) の簡略化されたサブセットであり、解析が容易になります。 通常、ネットワークでは、TLS 証明書はバイナリ DER でエンコードされます。これは NetX Secure で X.509 証明書に想定する形式です。

DER 形式のバイナリ証明書は実際の TLS プロトコルで使用されていますが、これらの証明書は、さまざまな異なるエンコードで生成し、.pem、.crt、.p12 などのファイル拡張子を付けて保存することができます。 さまざまな製造元のさまざまなアプリケーションで異なるバリアントが使用されていますが、通常は広く利用可能なツールを使用してそのすべてを DER に変換することができます。

代わりになる証明書エンコードで最も一般的なのは PEM です。 PEM (Privacy Enhanced Mail) 形式は、base-64 でエンコードされるバージョンの DER エンコードであり、エンコードの結果は、電子メールや Web ベースのプロトコルを使用して簡単に送信できる出力可能なテキストになるため、よく使用されています。

NetX Secure アプリケーション用の証明書の生成の大部分はこのマニュアルの範囲外ですが、OpenSSL コマンドライン ツール ([www.openssl.org](http://www.openssl.org)) が広く入手可能であり、ほとんどの形式間で変換を行うことができます。

アプリケーションによって、独自の証明書を生成することも、製造元や政府機関から証明書の提供を受けることも、商用の証明機関から証明書を購入することもあります。

NetX Secure アプリケーションでデジタル証明書を使用するには、最初に証明書をバイナリ DER 形式に変換し、必要に応じて、関連付けられた秘密キー (RSA の場合は "秘密指数") をバイナリ形式 (一般には、PKCS#1 形式の DER でエンコードされた RSA キーまたは DER でエンコードされた ECC キー) に変換する必要があります。 変換が完了したら、証明書と秘密キーのデバイスへの読み込みは、ユーザーの選択に委ねられます。 選択可能なオプションとしては、フラッシュベースのファイル システムの使用、データからの C 配列の生成 (Linux の "xxd" などのツールを使用)、証明書とキーを定数データとしてアプリケーション内へコンパイルする方法などがあります。

証明書がデバイスに読み込まれたら、TLS API を使用して、証明書を TLS セッションに関連付けることができます。

NetX Secure TLS での X.509 証明書の使用方法の詳細と例については、「X.509 証明書の NetX Secure へのインポート」のセクションを参照してください。

詳細については、API リファレンスで、以下の TLS サービスを参照してください。

- nx_secure_x509_certificate_initialize
- nx_secure_tls_local_certificate_add
- nx_secure_tls_local_certificate_remove
- nx_secure_tls_remote_certificate_allocate
- nx_secure_tls_trusted_certificate_add
- nx_secure_trusted_certificate_remove

### <a name="tls-client-certificate-specifics"></a>TLS クライアント証明書の詳細

TLS クライアントの実装では、一般に、デバイスに "ローカルの" 証明書<sup>14</sup> を読み込む必要はありません。 これに該当しないのは、クライアント証明書認証が有効になっている場合ですが、これはまったく一般的ではありません。

TLS Client では、"信頼された"証明書<sup>15</sup> を少なくとも 1 つ読み込み (必要な場合はさらに読み込む場合があります)、"リモート" 証明書<sup>16</sup> 用の領域を割り当てる必要があります。

信頼された証明書の追加とリモート証明書用の領域の割り当ての詳細については、TLS API リファレンスで、nx_secure_tls_remote_certificate_allocate サービスと nx_secure_tls_trusted_certificate_add サービスを参照してください。

14. "ローカル" 証明書は、ローカル デバイスを識別する証明書です。つまり、TLS アプリケーションが読み込まれるデバイスの ID 情報を提供するものです。

15. "信頼された" 証明書は、リモート デバイスの信頼性と認証の基礎を提供する証明書であり、直接、または公開キー基盤 (PKI) を介して提供されます。 信頼のチェーンのルートは、通常、"証明機関" または CA 証明書と呼ばれます。

16. "リモート" 証明書は、TLS ハンドシェイク中にリモート ホストによって送信される証明書を指します。 これが、そのリモート ホストの ID を提供し、ローカル デバイス上の "信頼された" 証明書と比較されることで、認証が行われます。

### <a name="tls-server-certificate-specifics"></a>TLS サーバー証明書の詳細

TLS サーバーの実装では、一般に、"信頼された" 証明書をデバイスに読み込んだり、リモート証明書を割り当てたりする必要はありません。 これに該当しないのは、クライアント証明書認証が有効になっている場合です (これはあまり一般的ではありません)。

TLS サーバーでは、クライアントに対してそのサーバーを認証するため、"ローカル" (または "ID") の証明書を読み込んで、それを TLS ハンドシェイク中にサーバーからリモート クライアントに提供できるようにする必要があります。

NetX TLS サーバー アプリケーションで使用するためにローカル証明書を読み込むことの詳細については、以下のサービスについて API リファレンスを参照してください。 
- nx_secure_tls_local_certificate_add 
- nx_secure_tls_local_certificate_remove

### <a name="pre-shared-keys-psk"></a>事前共有キー (PSK)

TLS で ID 認証を提供するための代替メカニズムは、事前共有キー (PSK) の概念です。 PSK 暗号スイートを使用すると、プロセッサが集中的に使用される公開キー暗号化の操作を行う必要がなくなり、リソースに制約がある組み込みデバイスにとっての恩恵となります。 TLS ハンドシェイクの証明書が PSK に置き換えられて、TLS セッション キーの生成で、暗号化されたプリマスター シークレットの代わりに使用されます。

PSK 暗号スイートは、TLS セッションを確立する前に、両方のデバイスに共有シークレットが存在する必要があるという意味では制約があります。 つまり、TLS PSK 接続以外のセキュリティで保護された方法を使用して、そのシークレットがデバイスに読み込まれている必要があります。PSK は、TLS PSK 接続を介した更新も可能ですが、デバイスは必ず、他の何らかのメカニズムを通じて読み込まれた PSK を使用して起動される必要があります。 たとえば、出荷前にセンサー デバイスとそのゲートウェイ デバイスに PSK を読み込むことや、標準の TLS 接続 (証明書を使用) を使用して PSK を読み込むことができます。

PSK 暗号スイートには、RFC 4279 で規定されている 2 つの形式があります。 1 つ目では RSA または Diffie-Hellman キーが使用され、これらが、標準の TLS ハンドシェイクにおいて証明書で転送される公開キーと同じ方法で使用されます。 2 番目の形式は、リソースの制約がある環境でより多く使用され、セッション キー (たとえば、AES で使用される) を直接生成するために使用される PSK を使用して、コストのかかる RSA または Diffie-Hellman 操作の使用が回避されます。

NetX Secure では、2 番目の形式の PSK 暗号スイートがサポートされるため、アプリケーションで使用されていた公開キー暗号化のためのすべてのコードとメモリが不要になります。 PSK 自体は AES キーではありませんが、実際のキーがそこから生成されるパスワードのようなものと考えることができます。 どのような PSK の値を使用できるかに関してほとんど制限はありませんが、値が長いほどセキュリティが高まります (パスワードの場合と同じ)。

NetX Secure アプリケーションで PSK を使用するには、まずグローバル マクロ **NX_SECURE_ENABLE_PSK_CIPHERSUITES** を定義する必要があります。 これは通常、コンパイラ設定を通じて行われますが、定義を nx_secure_tls.h ヘッダー ファイル内に配置することもできます。 このマクロを定義すると、PSK 暗号スイートのサポートが NetX Secure TLS アプリケーション内にコンパイルされます。

PSK のサポートが有効であれば、TLS API を使用してアプリケーションのために PSK を設定できます。 各 PSK には、PSK 値 (実際の秘密 "キー"。この値は安全に保管してください)、特定の PSK を識別するために使用される "ID" 値、特定の PSK 値を選択するために TLS サーバーで使用される "ID ヒント" が必要となります。

PSK 自体は、ネットワーク接続経由で送信されることがないため、任意のバイナリ値にすることができます。 PSK は、長さが最大 64 バイトの任意の値にすることができます。

ID とヒントは、UTF-8 を使用してフォーマットされた出力可能な文字列である必要があります。 ID とヒントの値は、最大 128 バイトの任意の長さにすることができます。

ID と PSK によって、相互に通信する必要があるネットワーク内のすべてのデバイスに読み込まれる一意の組が形成されます。

"ヒント" は主に、機能またはサービスによって PSK をグループ化する特定のアプリケーション プロファイルを定義するために使用されます。 これらの値は事前に合意されている必要があり、アプリケーションに依存します。 たとえば、(PSK が有効になっている) OpenSSL コマンドライン サーバー アプリケーションでは、既定の文字列 "Client_identity" が使用されます。これは、TLS ハンドシェイクを続行するために TLS クライアントによって提供される必要があります。

PSK の詳細については、NetX Secure API リファレンスで、nx_secure_tls_client_psk_set サービスと nx_secure_tls_psk_add サービスを参照してください。

## <a name="importing-x509-certificates-into-netx-secure"></a>X.509 証明書の NetX Secure へのインポート

デジタル証明書は、インターネット上のほとんどの TLS 接続に必要です。 以前は未知であったホストを、信頼できる中継点 (通常は "*証明機関*" または CA と呼ばれます) を使用することでインターネット経由で認証する手段が、証明書によって提供されます。 NetX Secure デバイスを商用クラウド サービス (アマゾン ウェブ サービスなど) に接続するには、デバイスに証明書を読み込むことによってアプリケーションに証明書をインポートする必要があります。

証明書と共に、証明書に関連付けられている "*秘密キー*" が必要になる場合もあります。 一部のアプリケーション (クライアント証明書認証が使用されない予定のときの TLS クライアントなど) では、証明書だけで十分ですが、デバイスの識別に証明書が使用される予定であれば、秘密キーが必要になります。 秘密キーは一般に、証明書を作成するときに生成され、別個のファイルに格納されます。多くの場合、パスワードで暗号化されます。

### <a name="certificate-types"></a>証明書の種類

デジタル証明書は、一般に、ネットワーク上のエンティティを識別するために使用されますが、それらのアプリケーションによっては、それらの特性が少し異なってきます。

### <a name="local-certificates"></a>ローカル証明書

このドキュメントでは、ローカル デバイスの ID を提供する証明書として "ローカル証明書" に言及します (その他に使用できる名前は "デバイス証明書" です)。 これらの証明書は、リモート ホストでローカル デバイスを認証する必要があるときに、リモート ホストに提供されます。

### <a name="remote-certificates"></a>リモート証明書

このドキュメントでは、"リモート証明書" は、該当する場合に TLS ハンドシェイク中にリモート ホストによって提供される証明書を指します。 これらの証明書のために、領域が割り当てられている必要があり、そうでないと NetX Secure でそれらを解析できず、TLS ハンドシェイクを完了することができなくなります。

### <a name="signing-certificates"></a>署名証明書

"署名証明書" は、認証の目的で、その他の証明書またはデータにデジタル署名するために使用されます。 これらの証明書は、公開キー基盤 (PKI) 内の中間証明書またはルート証明書のいずれかである可能性があり、通常は、個々のデバイスやホストの識別には使用されません。

### <a name="root-ca-certificates"></a>［ルート CA 証明書］

"ルート CA 証明書" は、PKI の基盤を提供する署名する側の証明書であり、別の署名証明書によって署名されるのではなく、自己署名されています。 TLS クライアントでリモート サーバーを検証するためには、一般に、少なくとも 1 つのルート CA 証明書が必要です。

### <a name="certificate-formats"></a>証明書の形式

デジタル証明書は、単純に、ASN.1 構文を使用してエンコードされた構造化データが含まれるファイルです。 ただし、証明書を格納できるさまざまな形式が存在するため、証明書を NetX Secure アプリケーションに読み込む前に適切な形式にすることが重要です。

証明書の最も一般的な形式は、DER と PEM です。 DER (ANS.1 形式の 1 つである *Distinguished Encoding Rules*) は、初期ハンドシェイクを実行するときに TLS によって使用されるバイナリ形式です。 PEM (*Privacy Enhanced Mail* に由来) は、Web でのメール送信や HTTP 経由の送信に適した、DER 形式の base 64 エンコード バージョンです。 ベンダーが異なると、PEM 証明書の場合は ".pem" や ".crt" などの異なるファイル名拡張子が使用され、DER 証明書の場合は "der" が使用されます。 証明書があり、どの形式が使用されているかが明確でない場合は、このファイルをテキスト エディターで開くと、種類を確認することができます。DER ファイルはエンコードされたバイナリ形式で、PEM ファイルは、"-----BEGIN CERTIFICATE-----" というヘッダーで始まる標準の ASCII テキストであるためです。

NetX Secure では、証明書はバイナリ DER 形式である必要があるため、インポートする前に証明書を DER 形式に変換する必要があります。 これは、すぐに入手できる OpenSSL などのツールで行うことができます。

アプリケーションの秘密キーが必要な場合、キー ファイルは、PEM または DER を使用して、特定の形式 (RSA の場合は PKCS # 1、ECC の場合は RFC 5915) でエンコードされます。 秘密キーファイルは、インポートする前に DER に変換する必要があります。

以下の OpenSSL コマンドは、証明書と RSA キー ファイルを、NetX Secure で必要な DER 形式に変換する例として示されています (ECC も似ています。OpenSSL のドキュメントを参照してください)。

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a>秘密キーと証明書

デバイスを識別する証明書については、関連付けられている秘密キーを証明書と一緒に読み込む必要があります。 TLS サーバーでは、秘密キー (RSA、Diffie-Hellman、楕円曲線暗号化など、いずれかの公開キー アルゴリズム用である可能性があります) を使用して、TLS クライアントから受信するキー マテリアル ("事前マスター シークレット") を解読し、それによってクライアントに対して自身を認証します。 TLS クライアントについては、ID 証明書 (関連付けられている秘密キーがある証明書) が提供され、サーバーがクライアント証明書を要求すると、秘密キーを使用してクライアントの認証が行われます。RSA の場合、クライアントにより、秘密キーを使用してトークンが暗号化されます。次にサーバーにより、クライアント証明書で提供されたクライアントの公開キーを使用してトークンが解読されます (Diffie-Hellman と ECC の認証は同様の方法で行われますが、詳細は少し異なります)。

NetX Secure では、サービス *nx_secure_x509_certificate_initialize* を使用して、X.509 証明書が初期化されます (詳細については、「デバイスへの証明書の読み込み」を参照)。また、オプションで、秘密キーをその証明書に関連付けます。

秘密キーが指定されている場合、その証明書は、デバイスを識別するために使用される "ID" 証明書であるとマークされます。 キーは、関連付けられたキーの種類がある、連続するバイナリ BLOB および長さとして渡されます。 キーの種類は、キーの種類 (例: RSA、ECC など) と形式 (例: PKCS # 1 DER など) によって異なります。 キーが指定されていない場合は、値 NX_SECURE_X509_KEY_TYPE_NONE (値 0x0) を渡して、キーが指定されていないことを示すことができます (データ パラメーターに長さ 0 の NX_NULL ポインターを指定すると同じ効果が得られます)。

次の表に、NetX Secure で認識されるキーの種類と、*nx_secure_x509_certificate_initialize* に渡される、関連付けられている種類の識別子を示します。 NetX Secure に追加される暗号化アルゴリズムが増えるにつれて、その他のキーの種類が追加されます。

| 識別子                              | アルゴリズム | Format   | Encoding | 値 |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| NX_SECURE_X509_KEY_TYPE_NONE            | None      | 該当なし      | 該当なし      | 0x0   |
| NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER   | RSA       | PKCS#1   | DER      | 0x1   |
| NX_SECURE_X509_KEY_TYPE_EC_DER          | ECDSA     | RFC 5915 | DER      | 0x2   |

### <a name="user-defined-private-key-types"></a>ユーザー定義の秘密キーの種類

*nx_secure_x509_certificate_initialize* サービスのキーの種類の識別子の値によって、キーが指定されたときに実行されるアクションが制御されます。 既知の種類の場合、値の範囲は 0x0000 0000 ～ 0x0000 FFFF (32 ビット符号なし整数の下位 16 ビット) です。 カスタム キーの種類<sup>17</sup> があるプラットフォームの場合 (一部のハードウェアベースの暗号化エンジンの場合と同様に)、範囲 0x0000 1000 ～ 0xFFFF FFFF (0 以外の上位 16 ビット) のユーザー定義のキーの種類を、キーの種類として渡すことができます。 キーの種類の上位 16 ビットのいずれかが設定されている場合、秘密キーのデータは、TLS 暗号スイート テーブルで指定されている適切な暗号化ルーチン (RSA など) に直接渡されます。 ユーザー定義のキーの種類は、暗号化ルーチンに渡される前に、解析されたり他の方法で処理されたりすることはありません。 さらに、どのような適切な処理でもそのレベルで処理できるように、ユーザー定義のキーの種類も暗号化ルーチンに渡されます。

ユーザー定義のキーの種類は、一般に、(おそらく暗号化された) カスタム キー データを利用する特定のハードウェア プラットフォームのために使用されることに注意してください。 一般にこれは、そのハードウェア ベンダー (または、PKCS#11 のような標準の場合は 1 つの特定の標準) に固有のメカニズムを使用して、キー データの生成またはエンコードが行われることを意味します。 詳細については、お使いのハードウェア プラットフォームのドキュメントを参照してください。

17. ユーザー定義のキーの種類を使用するには、カスタム キーの形式を処理するために、対応するカスタム暗号化ルーチンが必要です。 暗号化ルーチンには対応するアルゴリズム (RSA など) が備わっていて、暗号スイート テーブルで TLS に渡される必要があります。 

### <a name="loading-certificates-onto-your-device"></a>デバイスへの証明書の読み込み

証明書をインポートするのは、デバイスにファイルを読み込むどの方法でもかまいません。

証明書を読み込む最も簡単な方法は、バイナリ DER でエンコードされたデータを C 配列に変換し、それを定数としてアプリケーション内にコンパイルすることです。 これは、Linux の "xxd" などのツールで簡単に行うことができます ("-i" オプションを使用します)。

または、証明書データへのポインターを NetX Secure API に渡すことができる限り、フラッシュ ファイル システムまたはその他のストレージ オプションに証明書を読み込むことができます。

### <a name="certificate-files-needed-for-netx-secure"></a>NetX Secure に必要な証明書ファイル

インポートする必要がある証明書ファイルは、お使いのアプリケーションによって異なります。 一般に、TLS サーバーにはデバイスを識別するための証明書が必要で、TLS クライアントには、リモート サーバーを認証するための "*信頼された証明書*" が 1 つ以上必要です。 次の表に、いくつかの異なる TLS アプリケーションに必要な証明書を示します。

| **TLS の機能/オプション**                     | **必要な証明書/キー (最小限)**              |
| ------------------------------------------------- | --------------------------------------------------- |
| TLS クライアント                                        | ルート CA 証明書                                 |
| TLS サーバー                                        | ローカル証明書、その証明書の秘密キー |
| クライアント証明書認証を行う TLS サーバー | ローカル証明書、秘密キー、ルート CA             |
| クライアント証明書認証を行う TLS クライアント | ローカル証明書、秘密キー、ルート CA             |
| 事前共有キーのみを使用する TLS クライアントまたはサーバー    | なし (証明書の代わりに PSK が使用される)             |

証明書の読み込みに関連するサービスは以下のとおりです。

| **[API Name]\(アプリ名\)**                                   | **目的**                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| nx_secure_x509_certificate_initialize      | 証明書データと秘密キーを使用して NX_SECURE_X509_CERT 構造体にデータを格納するため、すべての証明書に対してを呼び出す必要があります。 |
| nx_secure_tls_local_certificate_add       | デバイスを識別するためにローカル証明書を TLS セッションに追加します。                                                                |
| nx_secure_tls_local_certificate_remove    | TLS セッションからローカル証明書を削除します。                                                                                   |
| nx_secure_tls_remote_certificate_allocate | (初期化されていない NX_SECURE_X509_CERT を使用して呼び出される) リモート証明書用の領域を割り当てます。                                   |
| nx_secure_tls_trusted_certificate_add     | リモート ホストを認証するための信頼された証明書として、TLS セッションに証明書を追加します。                                     |
| nx_secure_tls_trusted_certificate_remove  | TLS セッションから信頼された証明書を削除します。                                                                                 |

### <a name="working-with-aws-iot-certificates"></a>AWS IoT 証明書の操作

アマゾン ウェブ サービスの IoT インターフェイスで、サイドバー メニューから [セキュリティ] を選択し、[証明書] を選択します。 新しい証明書を作成し、指示に従って新しいデバイス証明書をダウンロードします。

証明書をダウンロードしたら、OpenSSL または同様のユーティリティを使用して、それらを DER 形式に変換する必要があります。

注: AWS では公開キー ファイルも提供されます。 公開キーは、ローカル デバイス証明書に含まれているので、アプリケーションにインポートする必要はありません。

例として、NetX Secure で使用するために、ローカル デバイス証明書とその秘密キーを DER 形式に変換するコマンドを次に示します。

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
変換されたファイルは、上の手順に従ってアプリケーションにインポートできます。

## <a name="x509-certificate-validation-in-netx-secure"></a>NetX Secure での X.509 証明書の検証 

ホストの識別と検証のために X.509 証明書と TLS を使用する場合、それらの証明書が実際にどのように検証されるかを理解しておくことが重要です。 TLS 仕様には、証明書の検証方法に関する詳細な手順は記載されていませんが、X.509 仕様 (RFC 5280) が参照されています。 一般に、TLS では、受信する証明書 (TLS ハンドシェイク中にリモート ホストによって提供される証明書) に対して少なくとも基本的な検証を実行することが予期されていて、それは NetX Secure TLS でも同様です。

### <a name="basic-x509-validation"></a>基本的な X.509 検証

受信するすべての証明書について、NetX Secure TLS では基本的な X.509 パス検証が実行されます。 このプロセスでは、各証明書のデジタル署名の確認が、リモート ホストによって提供されたか、信頼された証明書ストアに置かれている可能性がある、発行者の証明書に対して行われます (信頼された証明書をインポートすることの詳細については、「X.509 証明書の NetX Secure へのインポート」のセクションを参照)。 検証プロセスは、信頼された証明書に到達するか、チェーンが終了する (自己署名証明書があるか、発行者証明書がない状態) まで、発行者の証明書に対して再帰的に繰り返されます。 信頼された証明書に到達した場合、証明書は検証されますが、それ以外の場合は拒否されます。 さらに、検証プロセスの各段階で、アプリケーションのタイムスタンプ関数によって提供された時間に対して、各証明書の有効期限日がチェックされます (詳細についてはサービス "nx_secure_tls_session_time_function_set" を参照)。

X.509 仕様には、"ポリシー" をサポートするためのアルゴリズムも用意されています。これは、パスの検証中にチェックすることができる、X.509 拡張機能に存在する識別子です。 NetX Secure では、現在のところ、"anyPolicy" オプションが定義されているかのように X.509 証明書を処理します。つまり、すべてのポリシーが受け入れられ、オプションのポリシー チェックは実行されません。 NetX Secure X.509 の実装は、今後のリリースでこの機能が導入されて強化される可能性があります。 現時点では、ポリシー拡張機能は *nx_secure_x509_extension_find* API を使用して証明書から取得することができます。

基本パスの検証が完了すると、TLS では、*nx_secure_tls_session_certificate_callback_set* API を使用して、アプリケーションによって提供される証明書の検証コールバックが呼び出されます。 コールバックが指定されていない場合、パスの検証に成功した後の証明書は、信頼されていると見なされます。 コールバックが指定されている場合は、アプリケーションに要求されている追加の証明書の検証があれば、コールバックによって実行されます。 コールバックからの戻り値は、TLS ハンドシェイクを続行するか、検証エラーが原因でハンドシェイクを中止するかを決めるために使用されます。

コールバックは、関連する TLS セッションへのポインターと、検証する証明書への NX_SECURE_X509_CERT ポインターを使用して呼び出されます。 追加の検証チェックを実行するために必要な TLS からのすべてのデータは、TLS セッションと証明書の間のアプリケーションに置かれています。

NetX Secure では、追加の検証の助けになるように、DNS の検証や証明書失効リストのチェックなど、いくつかの一般的な検証操作のための X.509 ルーチンが提供されます。 これらのルーチンはすべて、証明書の検証コールバック内での使用に適していますが、X.509 証明書のオフライン チェックを実行するためにも使用できます。

次の表は、X.509 証明書の処理に使用できるヘルパー関数をまとめたものです。 操作に関する詳細な説明については、後続のセクションと、第 4 章の API リファレンスを参照してください。  
  
NetX Secure サービスの説明に、特定のルーチンに関する追加の詳細が記載されています。

| **[API Name]\(アプリ名\)**                             | **説明**                               |
| ---------------------------------------- | -------------------------------------- |
| nx_secure_x509_common_name_dns_check               | X.509 サブジェクトの共通名と SubjectAltName を、必要な DNS 名に対して確認します |
| nx_secure_x509_crl_revocation_check                 | X.509 証明書失効リスト (CRL) に失効した証明書があるかどうかを確認します       |
| nx_secure_x509_extended_key_usage_extension_parse | 証明書内の特定の拡張キー使用法 OID を解析し、見つけます                   |
| nx_secure_x509_key_usage_extension_parse           | 証明書内のキー使用法のビットフィールドを解析して返します                            |
| nx_secure_x509_extension_find                        | 特定の拡張機能の、DER でエンコードされた ASN.1 RAW データを見つけて返します。            |

証明書の検証コールバックで使用するための X.509 ヘルパー関数

### <a name="x509-extensions"></a>X.509 の拡張機能

X.509 仕様では、証明書の検証で利用できる追加情報を提供するために使用できる、いくつかの "拡張機能" について説明しています。 ほとんどの場合、これらの拡張機能は省略可能であり、信頼されたルート証明書に対して、デジタル証明書のセキュリティで保護された検証を行うために要求なものではありません。 ただし、NetX Secure で実際に、いくつかの基本的な拡張機能がサポートされています。 今後のリリースで、その他の拡張機能のサポートが追加される可能性があります。

次の表に、現在サポートされている拡張機能の一覧を示します。

| 拡張機能の名前           | 説明                                                                   | 関連 API                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| キー使用法                | ビットフィールドの証明書の公開キーに対して許容される使用法を提供します         | nx_secure_x509_key_usage_extension_parse           |
| 拡張キー使用法       | OID を使用した証明書の公開キーのための、許容される追加の使用法を提供します | nx_secure_x509_extended_key_usage_extension_parse |
| サブジェクト代替名 | 証明書によっても表現される代替 DNS 名を提供します   | nx_secure_x509_common_name_dns_check               |

### <a name="unsupported-x509-extensions"></a>サポートされていない X.509 拡張機能

NetX Secure の X.509 実装では、サポートされていない拡張機能を抽出するサービスに加えて、*nx_secure_x509_extension_find* が提供されています。 この API は、返されたデータを解析するために、DER でエンコードされた ASN.1 の知識が必要なため、上級ユーザーを対象としています。 これは、サポートされている拡張機能を抽出するために内部的に使用されますが、X.509 拡張機能のカスタマイズしたサポートを開発する際に便利なように提供されています。

nx_secure_x509_extension_find を使用するために、証明書や拡張機能 ID と一緒に、NX_SECURE_X509_EXTENSION が渡されます。これは、既知の拡張機能の種類を表す可変長の OID 文字列を整数で表したものです。 X.509 拡張機能でサポートされている OID の完全な一覧は、API リファレンスの 178 ページ、nx_secure_x509_extension_find に記載されています。

NX_SECURE_X509_EXTENSION 構造体は次のように定義されています。

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
サービスが正常に返されると、証明書の関連データが構造体に格納されます。 nx_secure_x509_extension_id フィールドは、一般に内部的な目的で使用されますが、関連する OID 整数表現が格納されます。 nx_secure_x509_extension_critical フィールドでは、X.509 拡張機能の重要性を示すフラグ値 (ブール値) が公開されます。 nx_secure_x509_extension_data および nx_secure_x509_extension_data_length の各フィールドには、それぞれ、DER でエンコードされた拡張機能用の ASN.1 データへのポインターと、そのデータの長さが格納されます。

拡張機能の ASN.1 データの実際の解析は、このドキュメントの範囲を超えていますが、NetX Secure TLS ソースにアクセスできる場合は、サポートされている拡張機能に対して nx_secure_x509_extension_find が呼び出されるすべての場所で、解析がどのように行われるかを確認できます。

### <a name="x509-dns-validation"></a>X.509 の DNS 検証

TLS での一般的な証明書の検証操作では、TLS ハンドシェイク中に、そのホストによって提供された X.509 証明書に対して、リモート ホストのトップレベル ドメイン (TLD) 名を確認する必要があります。 この操作は、DNS 参照が信頼できるという前提で、証明書が、それを提供したホスト サーバーと確かに一致していることを確認するのに役立ちます。 NetX Secure TLS では、この機能はサービス **nx_secure_x509_common_name_dns_check** によって提供されます。これは、証明書と、ホストへのアクセスに使用される URL の TLD の部分を含む文字列を受け取ります。 TLD は証明書の共通名フィールドと比較されて、一致する場合は NX_SUCCESS が返されます。 共通名が一致しない場合、ルーチンでは、X.509 証明書拡張機能 *subjectAltName* が存在するかどうかの確認も行われます。 subjectAltName が存在する場合は、指定された TLD に対して、拡張機能内のすべての DNSName エントリも確認されます。 この場合も、一致する場合は NX_SUCCESS が返されます。 一致するものが見つからない場合は、証明書検証コールバックから返すのに適したエラーが返されます。

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a>X.509 キー使用法拡張機能と拡張キー使用法拡張機能

X.509 キー使用法拡張機能と拡張キー使用法拡張機能では、証明書の認証時に証明書の公開キーを使用可能にする方法についての情報が提供されます。 キー使用法は、証明書の署名と発行が行われるときに証明書の発行者によって提供されます。 キー使用法を TLS ホストで使用すると、リモート TLS ホストを認証してその他の操作を実行するために、その証明書の利用が認められていることを確認できます。

キー使用法拡張機能は、各ビットが特定のキーの使用法を表す単純なビットフィールドで構成されています。 これらの値の完全な一覧は、API リファレンスの 183 ページ、*nx_secure_x509_key_usage_extension_parse* に記載されています。 キー使用法におけるビットとそれらの意味のより完全な説明については、RFC 5280 のセクション 4.2.1.3 を参照してください。

キー使用法拡張機能と同様に、拡張キー使用拡張機能では、許容されるキーの使用に関する情報が提供されます。 ただし、任意の使用法をサポートするために、拡張キー使用法拡張機能では、ビットフィールドではなく OID が利用されています。 NetX Secure X.509 の拡張キー使用法拡張機能を解析するときには、OID を表す整数がアプリケーションから提供されます。その後、*nx_secure_x509_extended_key_usage_extension_parse* サービスから、その OID が存在するかどうかが返されます。 拡張キー使用法でサポートされている OID の完全な一覧は、API リファレンス 175 ページの *nx_secure_x509_extended_key_usage_extension_parse* に記載されています。 OID とそれらの意味のより完全な説明については、RFC 5280 のセクション 4.2.1.12 を参照してください。

### <a name="x509-crl-revocation-status-checking"></a>X.509 CRL 失効状態チェック

X.509 では、デジタル証明書署名機関が、署名した証明書の有効性を失効させることを可能にする、"*証明書失効リスト*" (CRL) と呼ばれるメカニズムが提供されています。 署名機関からの証明書を検証する必要があるどのアプリケーションでも、CRL を取得し、その機関 (発行者) によって署名された任意の証明書を CRL に対して比較して、何らかの理由 (秘密キーが侵害されたなど) で証明書の状態が失効しているかどうかを確認することができます。 アプリケーションでは、このようにして、証明書の他の検証チェックに合格するおそれがある危険な証明書の使用を回避できます。

DER でエンコードされたリストを、事前に定義されたサーバーから、または他の何からの方法を通してダウンロードすることによって、アプリケーションで CRL の取得が行われます。 実際の設定は発行者によって異なるため、NetX Secure には CRL 取得用のメカニズムは用意されていませんが、CRL に対して証明書をチェックするルーチン **nx_secure_x509_crl_revocation_check** が用意されています。

この API は、DER でエンコードされた CRL、チェックの基準となる証明書ストア (TLS セッション内のものなど)、確認する証明書を取ります。 ルーチンでは、まず、信頼されたストア (アプリケーションによって提供された証明書ストアの一部) に対して CRL を検証します。 これが重要なのは、サービス拒否攻撃に使用されている不正な CRL からの保護を行い、その CRL が実際に適切な発行者からのものであることを確証するためです。 CRL の検証に続き、発行者がチェックされます。CRL の発行者が証明書の発行者と一致しない場合、CRL はその証明書に対して無効であり、エラーが返されます。 この時点で TLS ハンドシェイクを続行できるかどうかの決定は、アプリケーションで行います。 発行者が確かに一致する場合は、その CRL で、検証対象の証明書のシリアル番号が検索されます。 そのシリアル番号がリストにある場合は、証明書が失効したことを示すエラーが返されます。 一致が見つからない場合は、NX_SUCCESS が返されます。

## <a name="client-certificate-authentication-in-netx-secure-tls"></a>NetX Secure TLS でのクライアント証明書の認証

X.509 証明書認証を使用する場合、TLS プロトコルでは、TLS サーバー インスタンスから ID の証明書が提供される必要がありますが、既定では、TLS クライアント インスタンスから認証用の証明書を提供する必要はありません。その代わりに、別の形式の認証 (ユーザー名とパスワードの組み合わせなど) が使用されます。 これは、インターネットでの、Web サイト向けの最も一般的な TLS の使用法に合致しています。 たとえばオンライン小売サイトでは、Web ブラウザーを使用している潜在顧客に、サーバーが正当なものであることを証明する必要がありますが、ユーザーはログインとパスワードを使用して特定のアカウントにアクセスします。

ただし、既定のケースが常に望ましいとは限らないため、TLS では必要に応じて、TLS サーバー インスタンスからリモート クライアントに証明書を要求することができます。 この機能が有効になっているときには、ハンドシェイク中に、TLS サーバーから TLS クライアントに CertificateRequest メッセージが送信されます。 クライアントでは、それ自身の証明書と、その証明書に関連付けられている一致する秘密キーがクライアントに所有されていることを証明する暗号化トークンが含まれる CertificateVerify メッセージで応答する必要があります。 検証が失敗した場合や、証明書がサーバー上の信頼された証明書に接続されていない場合は、TLS ハンドシェイクが失敗します。

TLS でのクライアント証明書認証には 2 つの異なるケースがあります。後続のセクションでは、両方のケースについて説明します。

### <a name="client-certificate-authentication-for-tls-clients"></a>TLS クライアントでのクライアント証明書認証

TLS クライアントは、クライアント認証のために証明書を要求するサーバーへの接続を試みることがあります。 この場合、クライアントはサーバーに証明書を提供し、一致する秘密キーを所有していることを立証する必要があります。そうしないと、サーバーによって TLS ハンドシェイクが終了されます。

NetX Secure TLS に、この機能をサポートするための特別な構成はありませんが、アプリケーションで *nx_secure_tls_session_local_certificate_add* サービスを使用して、TLS クライアント インスタンスのローカル ID 証明書を提供する必要があります。 アプリケーションによって証明書が提示されず、リモート サーバーでクライアント証明書認証が使用されていて証明書が要求される場合、その TLS ハンドシェイクは失敗します。 TLS ハンドシェイクを完了するためには、*nx_secure_tls_local_certificate_add* を使用して TLS セッションに提供される証明書が、リモート サーバーによって認識される必要があります。

### <a name="client-certificate-authentication-for-tls-servers"></a>TLS サーバーでのクライアント証明書の認証

クライアント証明書認証の TLS サーバーでのケースは、この機能がオプションであるため、TLS クライアントのケースより少し複雑です。 この場合 TLS サーバーでは、リモート TLS クライアントに証明書を要求してから CertificateVerify メッセージを処理し、リモート クライアントが一致する秘密キーを所有していることを検証する必要があります。その後サーバーで、クライアントから提供された証明書を、ローカルの信頼された証明書ストア内の証明書まで追跡できることを確認する必要があります。

NetX Secure TLS サーバー インスタンスでは、クライアント証明書認証は <br>
*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify <span class="underline">_</span>enable* サービスと<br>
*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify <span class="underline">_</span>disable* サービスによって制御されます。

クライアント証明書認証を有効にするには、アプリケーションで、<br>
*nx_secure_tls_session_start* を呼び出す前に TLS サーバー セッションを使用して、*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify <span class="underline">_</span>enable* を呼び出す必要があります。 TLS クライアント接続に使用される TLS セッションでこのサービスを呼び出しても何の影響もないことに注意してください。

クライアント証明書認証が有効になっているときには、TLS ハンドシェイク中に、TLS サーバーからリモート TLS クライアントに証明書が要求されます。 NetX Secure TLS サーバーでは、X.509 発行者チェーンをたどり、*nx <span class="underline"> _</span>secure_tls <span class="underline">_</span>trusted <span class="underline"> _</span>certificate <span class="underline">_</span>add* を使用して作成された、信頼された証明書のストアに対して、クライアント証明書がチェックされます。 リモート クライアントでは、その ID 証明書が、信頼されたストア内の証明書につながるチェーンを提供する必要があります。そうしないと TLS ハンドシェイクが失敗します。 さらに、CertificateVerify メッセージの処理が失敗した場合、TLS ハンドシェイクも失敗します。

CertificateVerify メソッドに使用される署名方法は、TLS バージョン 1.0 および TLS バージョン 1.1 では固定されており、TLS バージョン 1.2 では、TLS サーバーによって指定されます。 TLS 1.2 の場合、サポートされる署名方法は、一般に、暗号化方式のテーブルで指定されている関連方式に従っていますが、通常は RSA が SHA-256 と共に使用されます (暗号化方式を使用した TLS の初期化の詳細については、「NetX Secure TLS での暗号化」を参照してください)。

## <a name="cryptography-in-netx-secure-tls"></a>NetX Secure TLS での暗号化

TLS では、暗号化を使用してネットワーク通信をセキュリティで保護できるプロトコルが定義されています。 そのため、実際に使用される暗号化に関して TLS ユーザーには幅広い選択肢があります。 仕様では、1 つの暗号スイートを実装することのみが要求されます。TLS 1.2 の場合、その暗号スイートは TLS_RSA_WITH_AES_128_CBC_SHA であり、公開キー操作に RSA、セッションの暗号化に 128 ビットのキーを使用する CBC モードの AES、メッセージ認証のハッシュに SHA-1 が使用されることを示します。

NetX Secure は、TLS 1.2 に準拠しており、既定で必須の TLS_RSA_WITH_AES_128_CBC_SHA 暗号スイートが有効にされます。ただし、ハードウェアの機能やその他の考慮事項によって暗号化方式ごとに可能な実装が多数あるため、NetX Secure では、TLS で使用される暗号化方式をユーザーが指定できるようにする汎用の暗号化 API が提供されています。

注: 汎用の暗号化 API メカニズムを使用すると、ユーザーが独自の暗号スイートを実装することもできますが、これは、TLS の暗号スイートや拡張機能に精通している上級ユーザーにお勧めします。 独自の暗号スイートのサポートに関心がある場合は、Express Logic の担当者にお問い合わせください。

### <a name="cryptographic-methods"></a>暗号化方式

NetX Secure TLS では、特定のハードウェア プラットフォーム用のハードウェア ドライバーを備えたソフトウェアに、DES、3DES、AES、MD5、HMAC-MD5、SHA-1、HMAC-SHA1、SHA-256、HMAC-SHA256、RSA、ECC (選択曲線) が実装されています。 アプリケーションでは、NetX Secure に用意されている暗号化ルーチンを使用することも、エンド ユーザーまたはサード パーティが提供するカスタム ルーチンを使用することもできます。

*NX_CRYPTO_METHOD* は、アプリケーションで、NetX Secure TLS で使用される暗号アルゴリズムの特定の実装を記述するために設計された制御ブロックです。 *NX_CRYPTO_METHOD* を使用すると、アプリケーション独自の暗号化実装を、NetX Secure に簡単に統合できます。 *NX_CRYPTO_METHOD* 構造体は次のように宣言されています。

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

以下に、*NX_CRYPTO_METHOD* 構造体の各要素の説明を示します。

- nx_crypto_algorithm: このフィールドで、変数 *method* に記述されているアルゴリズムを識別します。NetX Secure TLS で有効な値の一部は以下のとおりです (特定の値については nx_crypto_const.h を参照してください)。
    
  - NX_CRYPTO_NONE    
  - NX_CRYPTO_ENCRYPTION_NULL    
  - NX_CRYPTO_ENCRYPTION_AES_CBC    
  - NX_CRYPTO_AUTHENTICATION_NONE    
  - TLS_HASH_SHA_1    
  - TLS_HASH_SHA_256    
  - TLS_HASH_MD5    
  - TLS_CIPHER_RSA    
  - TLS_CIPHER_NULL

- nx_crypto_key_size_in_bits: このフィールドでは、その方式で使用される秘密キーのサイズを指定します。

- nx_crypto_IV_size_in_bits: このフィールドでは、初期化ベクトル (IV) のサイズを指定します。 ほとんどの場合、IV ブロックは暗号化/解読アルゴリズムについてのみ使用されることに注意してください。 このフィールドは、認証や検証のアルゴリズムではめったに使用されません。

- nx_crypto_ICV_size_in_bits: このフィールドでは、整合性チェック値 (ICV) ブロックのサイズを指定します。 注: このブロックは IPsec での使用を目的としており、TLS では使用されません。 詳細については、NetX Duo IPsec に関するページを参照してください。

- nx_crypto_block_size_in_bytes: このフィールドでは、ブロックベースの暗号の暗号アルゴリズム ブロックのサイズをバイト単位で指定します。 ほとんどの場合、これは暗号化ルーチンによって使用され、認証ルーチンによって使用されることはほとんどありません。

- nx_crypto_metadata_area_size: このフィールドでは、このメソッドが必要とするメタデータ領域のサイズを指定します。 各実装では、状態情報を格納するため、中間データ (キー変換マテリアルなど) を格納するため、またはスクラッチ領域として使用するために、一定のメモリが必要とされる場合があります。 実装に必要な領域のサイズを、このフィールドで指定します。 アプリケーションからは、TLS セッションの作成時にメモリ領域が提供されます。 このメタデータ領域を管理する必要があるのは、暗号化機能です。

- nx_crypto_init: これは、暗号アルゴリズムの初期化関数です。 初期化ルーチンを必要としない実装では、このフィールドを NX_NULL に設定してもかまいません。 初期化関数の典型的な使い方は、アルゴリズムのために内部データ構造を初期化することです。 NetX Secure TLS では、内部でこの関数を呼び出すことによって、暗号化ルーチンの初期化を処理します。

初期化関数のプロトタイプは次のとおりです。

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - method は、その暗号化方式の制御ブロックへのポインターです。

  - key は、データ パケットを処理するための秘密キー文字列です。

  - key_size_in_bits では、秘密キーのサイズをビット単位で定義します。

  - handle は、特定の暗号化セッションを識別する、実装で定義されている項目です。 値は初期化ルーチンによって生成されて、呼び出し元に戻されます。 後続の暗号化操作やクリーンアップ ルーチンでは、このハンドルを使用してセッションを識別します。

  - crypto_metadata は、このアルゴリズムの実装で必要とされているメタデータ領域へのポインターです。 メタデータ領域を必要としないアルゴリズムの場合、このフィールドは NX_NULL に設定されます。また、初期化ルーチンでメタデータ領域にアクセスしてはいけません。

  - crypto_metadata_size では、メタデータ領域のサイズを指定します。 メタデータ領域なしで作成された SA の場合、このフィールドは 0 に設定されます。また、初期化ルーチンでメタデータ領域にアクセスしてはいけません。

  - 初期化プロセスが成功した場合は、このルーチンから *NX_SUCCESS* が返されるはずです。 呼び出し元は、その他の戻り値をすべてエラーとして扱います。

- nx_crypto_cleanup: これは、暗号アルゴリズムの実装に対して定義されたクリーンアップ ルーチンです。 これは、TLS セッションが削除または再起動されたときに呼び出されます。

クリーンアップ関数のプロトタイプは次のとおりです。

```C
UINT crypto_cleanup_function(VOID *handle);
```
- handle は、呼び出し元によってクリーンアップ関数に渡されます。 ハンドルは、暗号化の初期化ルーチンによって初期化されて、暗号アルゴリズムの状態を識別するために使用されます。

- クリーンアップ プロセスが成功した場合は、このルーチンから *NX_SUCCESS* が返されるはずです。 呼び出し元は、その他の戻り値をすべてエラーとして扱います。

- nx_crypto_operation: これは、実際の暗号化、解読、認証のサービスを実行するルーチンです。 操作ルーチンの関数プロトタイプは次のとおりです。

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- op は、このルーチンで実行する必要がある操作の種類を示します。有効な値は次のとおりです。
    
    - NX_CRYPTO_ENCRYPT
    - NX_CRYPTO_DECRYPT
    - NX_CRYPTO_AUTHENTICATE
    - NX_CRYPTO_VERIFY

- handle は、呼び出し元によって操作関数に渡されます。 これは、暗号化初期化ルーチンによって生成されます。
- method は、その暗号化方式の制御ブロックを指し示します
- key は、この操作に使用される秘密キーを指し示します
- key_size_in_bits は秘密キーのサイズです (ビット単位)
- input は、操作対象メッセージの先頭へのポインターです。
- input_length_in_byte は、操作対象のメッセージのサイズを示すために呼び出し元によって渡されます。
- iv_ptr は、IV ブロックの先頭を指し示すために呼び出し元によって設定されます。 IV ブロック用のメモリは、呼び出し元によって提供されることに注意してください。 暗号化では、操作関数によって IV の情報をこのメモリ ブロックに書き込む必要があります。解読では、操作関数によって、このメモリ ブロックから IV 情報を取得する必要があります。 認証および検証の操作のためのアルゴリズムでは、一般に、初期化ベクトルは使用されません。
- output は、出力バッファーを指し示すために呼び出し元によって設定されます。 出力バッファー用のメモリは、呼び出し元によって提供されることに注意してください。 暗号化では、操作関数によって出力バッファーに暗号テキストを書き込む必要があります。解読では、解読されたテキスト (クリア テキスト) を出力バッファーに書き込む必要があります。認証では、出力バッファーにハッシュ値を書き込む必要があります。 検証では、ハッシュ情報を格納するために出力バッファーが使用されます。
- output_length_in_byte では、出力バッファーのサイズを指定します。
- crypto_metadata は、この暗号化操作によって使用されるメタデータ領域を指し示します。 暗号化メタデータ領域は、一般に、crypto_init_function によって初期化されます。
- crypto_metadata_size では、メタデータ領域のサイズを指定します。
- 操作プロセスが成功した場合は、このルーチンから *NX_SUCCESS* が返されるはずです。 呼び出し元は、その他の戻り値をすべてエラーとして扱います。
- packet_ptr: 処理されるデータが含まれるパケット。 注: このパラメーターは TLS では使用されておらず、NX_NULL に設定する必要があります。
- nx_crypto_hw_process_callback: その暗号化方式で提供されているコールバック関数。 これは、暗号化関数がハードウェアによって提供されていて、コールバック ルーチンが必要な場合に使用されます。

NetX Secure TLS には、以下の暗号化方式が用意されています。

- *AES*  
- *RSA*  
- *NULL*

NetX Secure TLS には、以下の認証方法が用意されています。

- *HMAC-MD5*  
- *HMAC-SHA1*  
- *HMAC-SHA256*

以下の例では、NetX Duo IPsec によって提供される暗号化と認証のメソッドを使用するように *NX_CRYPTO_METHOD* 構造体を構成する方法を示しています。

***AES:***

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
***NULL***

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
***HMAC-SHA1***
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
***NONE***

特殊なメソッドの **NX_CRYPTO_NONE** は、暗号化または認証のサービスが不要であることを IPsec モジュールに通知するために使用されます。 これは以下のように構成されています。

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a>暗号化方式を使用した TLS の初期化

前のセクションで説明した暗号化方式の署名に準拠した暗号化ルーチンを作成したら、NX_SECURE_TLS_SESSION 制御ブロックを初期化するときに、それらを TLS に渡す必要があります。 これは、TLS サービスの nx_secure_tls_session_create で実行します。

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- session_pointer は、NX_SECURE_TLS_SESSION 制御ブロックへのポインターです。
- tls_cipher_table は、後述する NX_SECURE_TLS_CRYPTO 制御ブロックへのポインターです。
- encryption_metadata_area は、TLS で暗号化ルーチンによって使用される領域を指し示します。
- encryption_metadata_size は、メタデータ領域のサイズです (バイト単位)。

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a>NetX Secure TLS での楕円曲線暗号 (ECC)

楕円曲線暗号 (ECC) は、RSA の代わりに使用できる公開キー暗号化スキームです。 ECC は一般的により高速であり、RSA よりも小さなキーを使用するので、組み込まれる TLS では有益なオプションとなる可能性があります。 Azure RTOS 6.0 より前のバージョンの X-Ware では、ECC はアドオンとして出荷されており、プロジェクトに ECC ソース コードをインストールする必要がありました。 Azure RTOS 6.0 では、ECC はメインライン コードベースに統合されたため、ECC ファイルのインストールは不要になっています。 ただし、ECC では引き続き、以前のバージョンと同様の初期化が必要です。

### <a name="supported-ecc-curves"></a>サポートされている ECC 曲線

NetX Secure では、<http://www.secg.org/sec2-v2.pdf> に従って曲線のパーツが実装されています。 以下の曲線がサポートされています<sup>18</sup>:

  - secp256r1 
  - secp384r1 
  - secp521r1 

その他の ECC 曲線が使用されている場合、*nx_secure_tls_session_start ()* ルーチンから、サポートされていない曲線が使用されたことを示すエラー NX_SECURE_TLS_NO_SUPPORTED_CIPHERS が返されます。

ECC アルゴリズムによって TLS 証明書チェーンも暗号化される場合があることに注意してください。 TLS クライアントによって提供される曲線はサポートされていますが、証明書チェーンで使用される ECC 曲線はサポートされていない可能性があります。 この場合、*nx_secure_tls_session_start* ルーチンから、NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER が返されます。

ECC の既定の暗号スイート テーブルの例が、nx_crypto_generic_ciphersuites.c で提供されています。 暗号スイート テーブルの詳細については、「TLS 暗号化暗号テーブル」のセクションを参照してください。

18. 曲線 secp192r1 と secp224r1are の実装も、レガシ アプリケーション用に提供されています。 ただし、これらの曲線は今では脆弱であると見なされており、新しいアプリケーションの開発には使用すべきではありません。

### <a name="crypto-methods-for-ecc"></a>ECC の暗号化メソッド

楕円曲線グループの暗号化メソッド:

- NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>  
- NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>  
- NX_CRYPTO_METHOD crypto_method_ec_secp256  
- NX_CRYPTO_METHOD crypto_method_ec_secp384  
- NX_CRYPTO_METHOD crypto_method_ec_secp521

ECC 曲線の暗号化メソッドは nx_crypto_generic_ciphersuites.c で定義されています。

ECDHE の暗号化メソッド:

- NX_CRYPTO_METHOD crypto_method_ecdhe

ECDSA の暗号化メソッド:

- NX_CRYPTO_METHOD crypto_method_ecdsa

ECDSA および ECDHE の暗号化メソッドは nx_crypto_generic_ciphersuites.c で定義されています。

これらは、RSA、SHA、AES などの他の暗号化方式と組み合わせて、暗号スイート ルックアップ テーブルの構成要素として使用できます。

### <a name="enabling-ecc-support-for-tls"></a>TLS での ECC サポートの有効化

ECC は、TLS で既定で有効になっています。 ECC のサポートを無効にするには、シンボル NX_SECURE_DISABLE_ECC_CIPHERSUITE を定義する必要があります。

変更を有効にするには、NetX Secure ライブラリと、そのライブラリを使用するすべてのアプリケーションをリビルドする必要があります。

アプリケーション コードでは、TLS セッションの作成後に API n *x_secure_tls_ecc_initialize ()* を呼び出す必要があります。 この API により、TLS セッションに、TLS のキー交換操作および証明書の検証に使用される曲線の種類が通知されます。 ECC アルゴリズムが選択されている場合は、TLS ハンドシェイク フェーズの間にクライアントとサーバーが ECC 曲線関連のパラメーターを交換して、どの曲線を使用するかが決定されます。

次のコード セグメントで、この API の使用方法を示します。 引数 (*nx_crypto_ecc_supported_groups、nx_crypto_ecc_supported_groups_size、nx_crypto_ecc_curves)* はすべて、*nx_crypto_generic_ciphersuites.c* で定義されていることに注意してください。 そのため、これらのシンボルは直接使用できます。

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
nx_crypto_generic_ciphersuites.c の構成例には、ECC が有効になっているときに使用される ECC 暗号スイート ルックアップ テーブルが含まれています。 ECC を使用するには、nx_secure_tls_session_create を使用して TLS セッションを作成するときに、単純に暗号スイート テーブルのパラメーターとして nx_crypto_tls_ciphers_ecc を渡します。 このテーブル例には、ECC 用と非 ECC 用の両方の暗号スイートが含まれています。

### <a name="tls-cryptographic-cipher-table"></a>TLS 暗号化暗号テーブル

The NX_SECURE_TLS_CRYPTO 構造体は以下のように定義されています。

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
このテーブルは、NetX Secure TLS プロジェクト内にある静的定数にこの構造体のエントリを格納することによって作成されます。この定数は通常、暗号化のルーチンおよびモジュールと共に配置されています。

例として、NetX Secure で提供されるソフトウェア専用の ("汎用") 暗号化ライブラリには、以下のテーブル定義が含まれています (ECC 以外の暗号スイートのサポート用<sup>19</sup>)。

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
この構造体では、最初のエントリが TLS 暗号スイート テーブルです。 NX_SECURE_TLS_CIPHERSUITE_INFO 構造体では、暗号化ルーチン (NX_CRYPTO_METHOD ポインターの形式になっています) が、TLS 仕様で定義されている特定の暗号スイートにマップされています。 2 番目の値は、最初のフィールドが指し示すテーブル内のエントリの数です。

次のフィールドは、デジタル証明書の処理時に X.509 によって使用されるルーチンのテーブルを指し示しており、構造体 NX_SECURE_X509_CRYPTO は、形式が NX_SECURE_TLS_CIPHERSUITE_INFO に類似しています。 次のフィールドは、テーブル内のエントリの数です。

ルックアップ テーブルに続くのは、特定のバージョンの TLS に必要ないくつかのルーチンです。 たとえば、TLS バージョン 1.2 より前は、キー生成とハンドシェイク ハッシュのルーチンは、SHA-1 と MD5 の組み合わせを使用するように固定されていました。これらのルーチンのメソッドは、特定の暗号スイートに関連付けられていないため、この暗号構造体の中で明示的に呼び出されます。 TLS バージョン 1.2 では、キー生成とハッシュのルーチンは暗号スイートによって選択されますが、使用するルーチンが指定されていない暗号スイートでは、SHA-256 ハッシュ方式が使用され、この暗号構造体によってそのルーチンが明示的に呼び出されます。

TLS 1.3 では、さまざまな操作に対していくつかの特定の暗号が追加で必要です。

19. TLS 1.3 が有効になっている場合は、TLS 1.3 のサポートのために ECC が必要であることに注意します。nx_crypto_tls_ciphers_ecc を使用してください。

### <a name="tls-ciphersuite-lookup-table"></a>TLS 暗号スイート ルックアップ テーブル

TLS の暗号テーブルを入力するには、暗号化ルーチンを特定の暗号スイート識別子にマップする暗号スイート ルックアップ テーブルも作成する必要があります。 これらの識別子は、IANA で登録されている世界共通の値です。 詳細については、TLS の RFC を参照してください。 これらのルーチンは、各暗号スイートで使用される 5 つの別個の方法である、パブリック暗号、公開キー認証、セッション暗号、セッション ハッシュ ルーチン、TLS 擬似ランダム関数 (PRF) を表しています (一部の暗号スイートでは 5 つすべては使用されないことがあります)。 次の表で、5 つの方法それぞれについて説明します。

| **ルーチンのカテゴリ**      | **説明**                                                                                       | **アルゴリズムの例**                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| パブリック暗号             | TLS ハンドシェイク中にキーを交換するために使用されます                                                        | RSA、Diffie-Hellman、ECC                                          |
| 公開キー認証 | TLS ハンドシェイク中にデータの認証や署名を行うために使用されます                                            | RSA、DSS                                                          |
| セッション暗号            | TLS セッション中にアプリケーション データを暗号化するために使用される対称キー アルゴリズム                       | AES、RC4                                                          |
| セッション ハッシュ              | TLS セッション中に、メッセージの整合性を維持するために使用されます (データが変更されていないことを保証します) | SHA-1、SHA-256                                                    |
| TLS PRF                   | TLS ハンドシェイクで、キー マテリアルとハンドシェイク ハッシュを生成するために使用されます                          | PRF はハッシュ ルーチン (SHA-1 と MD5、SHA-256、SHA-512) に基づいています |

NX_SECURE_X509_EXTENSION 構造体は、以下のように定義されています。

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
nx_secure_tls_ciphersuite フィールドには IANA の暗号スイートの値が格納されており、NX_CRYPTO_METHOD ポインターは、その暗号スイートによって使用される 5 つの方法を表しています。 スカラー値 (nx_secure_tls_iv_size、nx_secure_tls_key_size、nx_secure_tls_hash_size) は情報提供用で、NX_CRYPTO_METHOD エントリでは取得できない可能性がある情報が提供されます。

例として、TLS の既定の暗号スイートである TLS_RSA_WITH_AES_128_CBC_SHA を見てみましょう。これにより、RSA、128 ビット キーを使用する AES-CBC、セッション ハッシュ用の SHA-1 を使用することが指定されています。 この暗号スイートに対しては TLS PRF が指定されていないので、TLSv1.2 モードでは、既定の SHA-256 PRF が使用されます。 表で指定されている PRF に関わらず、TLS 1.0 および 1.1 では、すべての暗号スイートで SHA-1 と MD5 による PRF が使用されることに注意してください。

汎用暗号化ライブラリの NX_SECURE_TLS_CIPHERSUITE_INFO テーブル内のエントリでは、以下のように定義されています。

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

セッション暗号については、キー サイズは暗号スイートによって決定されるますが、公開キーの方法では、ハンドシェイク中に交換されるデジタル証明書に公開キーが含まれているため、TLS ハンドシェイクの進行中はキー サイズが不明です。

### <a name="x509-cipher-lookup-table"></a>X.509 暗号ルックアップ テーブル

NX_SECURE_TLS_CIPHERSUITE_INFO テーブルと同様に、NX_SECURE_X509_CRYPTO 構造体では、暗号化ルーチンが既知の値にマップされています。 X.509 の場合、識別子は実際には X.509 によって定義されており、標準化団体の ISO および ITU に登録されています。 OID は、デジタル証明書で使用される暗号化ルーチンなど、さまざまな通信規格において多様な情報を一意に識別するために設計された、可変長のマルチバイト値です。 OID は可変長であるため、NetX Secure TLS では、公式の OID 値を、内部で使用されている固定長の定数にマップしています (nx_secure_x509.h を参照)。 これらの定数は、NX_SECURE_X509_CRYPTO 構造体で使用されており、この構造体は以下のように定義されています。

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

最初のフィールド *nx_secure_x509_crypto_identifier* は、NetX Secure で使用されている内部的な OID 表現です。

2 番目と 3 番目のフィールドは、OID によって識別される暗号化の方法を表す NX_CRYPTO_METHOD オブジェクトを指し示しています。これは、ハッシュ ルーチンと組みにされた公開キー操作です。 各デジタル証明書には、暗号化ルーチンに対して複数の OID が含まれている場合があることに注意してください。

X.509 用の方法のテーブルは、暗号スイート ルックアップ テーブルと同じ方法で作成されます。 例として、RSA_SHA1 の OID を見てみましょう。 RSA_SHA1 の実際の OID は次のとおりです。

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
OID は、ASN.1 構文で表現されていて、1.2.840.113549.1.1.5 という数値になっています。 この値は次に、バイナリ形式でエンコードされ、次のバイトが作成されます。

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
ASN.1 からバイナリ形式への実際の変換については、このドキュメントの範囲外となっています。 詳細については、"OID のための ASN.1 エンコード" を検索してください。 NetX Secure でサポートされている OID のバイナリ表現は、ファイル *nx_secure_x509.c* に記載されています。

実際の OID から内部で認識される定数へのマッピングが用意できたら、NX_SECURE_X509_CRYPTO テーブル内に RSA_SHA1 のためのエントリを作成できます。

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a>既定の TLS ルーチン

前述のように、TLS では、ハンドシェイク中にキーの生成とメッセージの検証を行うため、既定のルーチンがいくつか必要です。 プライマリ ルーチンは、TLS 擬似ランダム関数 (PRF) です。 PRF はハッシュ ルーチンに基づいており、キー生成やその他の目的で、任意の量の擬似ランダム データ<sup>20</sup> を生成するために使用できます。

PRF に加えて、各バージョンの TLS で、既定のハッシュ ルーチンが利用されます。このルーチンも提供する必要があります。 TLS バージョン 1.0 および 1.1 では、MD5 と SHA-1 がそれらのハッシュ ルーチンです。 TLS バージョン 1.2 に必要なのは SHA-256 だけです。

NX_SECURE_TLS_CRYPTO 構造体には、MD5、SHA-1、SHA-256、TLS バージョン 1.0/1.1 の PRF、既定の TLS 1.2 のための PRF を表す NX_CRYPTO_METHOD ポインターがあります。

TLS 1.3 をサポートすると、HKDF (キーの生成)、HMAC (ハンドシェイク中に使用される特定のハッシュ操作用)、ECDHE (TLS 1.3 の機能に必要) のフィールドが追加されます。

汎用ソフトウェア暗号化ライブラリで提供されるのは、ソフトウェア バージョンの TLS PRF です。 TLS 1.0/1.1 の場合、この関数は *nx_crypto_tls_prf_1* という名称です。 TLS 1.2 の場合、関数は *nx_secure_tls_prf_sha256* という名前です。 サフィックス "1" は、従来の TLS 1.0 PRF を表していて、"sha256" サフィックスは、TLS 1.2 の既定の PRF は SHA-256 に基づいているという事実に触れています。 その他の PRF ルーチンのサポートが必要な場合は、それらのルーチンのサフィックスに、使用されるハッシュ方式が反映されます。 PRF ルーチンはハッシュ方式に基づくため、基になるハッシュ ルーチンに対しては、さまざまなターゲット プラットフォームで独立してハードウェア アクセラレータを使用できます。

TLS 暗号スイートと X.509 ルックアップ テーブルに加えて、NX_SECURE_TLS_CRYPTO 構造体には既定の PRF とハッシュ ルーチンを格納することができ、TLS セッションの初期化に使用することができます。

20. "擬似ランダム" とは、PRF が決定論的であるという事実を指していて、同じ入力であれば常に同じ出力が生成されることを意味します。しかし、出力が予測不能であるという事実に関してはランダムです。 TLS では、PRF のこの特性を利用して、ハンドシェイク中に RSA のような公開キー暗号を使用して交換されたマスター シークレットと組み合わせたさまざまなパブリック データから、セッション キーを生成しています。

### <a name="cryptographic-metadata"></a>暗号化メタデータ

NX_SECURE_TLS_CRYPTO テーブルを使用して TLS セッションを初期化する前に、暗号化ルーチン メタデータ用のバッファー領域を割り当てる必要があります。 メタデータは、その制御ブロックによって表される特定のルーチンに関連付けられている、すべての状態を格納するために使用されます。 それぞれの NX_CRYPTO_METHOD の *nx_crypto_metadata_area_size* フィールドは、そのルーチンに関連付けられている制御構造のサイズに設定する必要があります。そうしないと、TLS の初期化で、必要な領域が適切に計算されないため、バッファー オーバーランの問題が発生する可能性があります。

TLS セッションが作成される前に、メタデータ バッファーを割り当てる必要があります。 このバッファーは、nx_secure_tls_session_create によって自動的に分割されて、暗号化方式の表に示した各ルーチンのために領域が予約されます。 1 つの TLS セッションで一度にアクティブになる暗号スイートは 1 つだけであるため、サポートされる暗号化スイートの数は、必要とされるメタデータ領域には影響しません。暗号スイート ルックアップ テーブルでの、そのカテゴリに対する最大制御ブロック サイズを使用して、5 つの暗号スイート ルーチンごとに領域が予約されます。

メタデータ バッファー サイズの計算を簡単にするため、サービス *nx_secure_metadata_size_calculate* では nx_secure_tls_session_create と同じ計算が実行されますが、単純に、必要なメタデータ バッファーの合計サイズがバイト単位で返されます。

### <a name="initializing-the-tls-session"></a>TLS セッションの初期化

NX_CRYPTO_METHOD オブジェクトと NX_SECURE_TLS_CRYPTO オブジェクトが作成され、メタデータ領域が予約されたら、以下のように TLS セッションを初期化できます (上記の例の値を使用)。

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
