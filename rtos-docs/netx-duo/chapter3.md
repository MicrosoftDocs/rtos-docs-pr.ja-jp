---
title: 第 3 章 - Azure RTOS NetX Duo の機能コンポーネント
description: この章では、機能の観点から見た高パフォーマンスの Azure RTOS NetX Duo TCP/IP スタックについて説明します。
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 31900c7b822c88079e4b9fe28a8a388d20f819aa
ms.sourcegitcommit: 60ad844b58639d88830f2660ab0c4ff86b92c10f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/07/2021
ms.locfileid: "106549846"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx-duo"></a><span data-ttu-id="b06e6-103">第 3 章 - Azure RTOS NetX Duo の機能コンポーネント</span><span class="sxs-lookup"><span data-stu-id="b06e6-103">Chapter 3 - Functional Components of Azure RTOS NetX Duo</span></span>

<span data-ttu-id="b06e6-104">この章では、機能の観点から見た高パフォーマンスの Azure RTOS NetX Duo TCP/IP スタックについて説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-104">This chapter contains a description of the high- performance Azure RTOS NetX Duo TCP/IP stack from a functional perspective.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="b06e6-105">実行の概要</span><span class="sxs-lookup"><span data-stu-id="b06e6-105">Execution Overview</span></span>

<span data-ttu-id="b06e6-106">NetX Duo アプリケーション内のプログラム実行には、初期化、アプリケーション インターフェイス呼び出し、内部 IP スレッド、IP の定期的なタイマー、およびネットワーク ドライバーの 5 種類があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-106">There are five types of program execution within a NetX Duo application: initialization, application interface calls, internal IP thread, IP periodic timers, and the network driver.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-107">*NetX Duo は、ThreadX の存在を前提としており、スレッドの実行、中断、定期的なタイマー、および相互排他設備に依存します。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-107">*NetX Duo assumes the existence of ThreadX and depends on its thread execution, suspension, periodic timers, and mutual exclusion facilities.*</span></span>

### <a name="initialization"></a><span data-ttu-id="b06e6-108">初期化</span><span class="sxs-lookup"><span data-stu-id="b06e6-108">Initialization</span></span>

<span data-ttu-id="b06e6-109">サービス \***nx_system_initialize** _ を他の NetX Duo サービスが呼び出される前に呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-109">The service \***nx_system_initialize** _ must be called before any other NetX Duo service is called.</span></span> <span data-ttu-id="b06e6-110">システムの初期化は、ThreadX _ *_tx_application_define_*\* 関数から、またはアプリケーション スレッドから呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-110">System initialization can be called either from the ThreadX _ *_tx_application_define_*\* function or from application threads.</span></span>

<span data-ttu-id="b06e6-111">\***nx_system_initialize** _ が返されると、パケット プールと IP インスタンスを作成する準備がシステムで整います。</span><span class="sxs-lookup"><span data-stu-id="b06e6-111">After \***nx_system_initialize** _ returns, the system is ready to create packet pools and IP instances.</span></span> <span data-ttu-id="b06e6-112">IP インスタンスを作成するには既定のパケット プールが必要であるため、IP インスタンスを作成する前に少なくとも 1 つの NetX Duo パケット プールが存在している必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-112">Because creating an IP instance requires a default packet pool, at least one NetX Duo packet pool must exist prior to creating an IP instance.</span></span> <span data-ttu-id="b06e6-113">ThreadX 初期化関数 _ *_tx_application_define_*\* とアプリケーション スレッドから、パケット プールと IP インスタンスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-113">Creating packet pools and IP instances are allowed from the ThreadX initialization function _ *_tx_application_define_*\* and from application threads.</span></span>

<span data-ttu-id="b06e6-114">内部的には、IP インスタンスの作成は 2 段階で行われます。第 1 段階は、***tx_application_define*** から、またはアプリケーション スレッドのコンテキストから、呼び出し元のコンテキスト内で行われます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-114">Internally, creating an IP instance is accomplished in two parts: The first part is done within the context of the caller, either from ***tx_application_define*** or from an application thread's context.</span></span> <span data-ttu-id="b06e6-115">これには、IP データ構造の設定やさまざまな IP リソースの作成が含まれます (内部 IP スレッドを含む)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-115">This includes setting up the IP data structure and creating various IP resources, including the internal IP thread.</span></span> <span data-ttu-id="b06e6-116">2 番目の段階は、内部 IP スレッドからの初期実行時に実行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-116">The second part is performed during the initial execution from the internal IP thread.</span></span> <span data-ttu-id="b06e6-117">ここで、IP 作成の第 1 段階で提供されるネットワーク ドライバーが最初に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-117">This is where the network driver, supplied during the first part of IP creation, is first called.</span></span> <span data-ttu-id="b06e6-118">内部 IP スレッドからネットワーク ドライバーを呼び出すと、ドライバーは、I/O を実行して初期化処理中に一時停止できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-118">Calling the network driver from the internal IP thread enables the driver to perform I/O and suspend during its initialization processing.</span></span>

<span data-ttu-id="b06e6-119">初期化処理からネットワーク ドライバーが返されると、IP の作成が完了します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-119">When the network driver returns from its initialization processing, the IP creation is complete.</span></span>

<span data-ttu-id="b06e6-120">NetX Duo での IPv6 の初期化には、追加の NetX Duo サービスがいくつか必要です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-120">Initialization of IPv6 in NetX Duo requires a few additional NetX Duo services.</span></span> <span data-ttu-id="b06e6-121">これらについては、この章の後半の「[NetX Duo での IPv6](#ipv6-in-netx-duo)」セクションで詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-121">These are described in greater detail in the section [IPv6 in NetX Duo](#ipv6-in-netx-duo) later in this chapter.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-122">*NetX Duo サービス **nx_ip_status_check** は、IP インスタンスとそのプライマリ インターフェイスのステータスに関する情報を取得するために使用できます。そのようなステータス情報には、リンクが初期化、有効化されているかどうか、また IP アドレスが解決されているかどうかが含まれます。この情報は、新しく作成された IP インスタンスを使用する必要があるアプリケーション スレッドを同期するために使用されます。マルチホーム システムについては、「[マルチホーム サポート](#multihome-support)」を参照してください。\*\*nx_ip_interface_status_check*\* は、指定されたインターフェイスに関する 3 つの情報を取得するために使用できます。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-122">*The NetX Duo service **nx_ip_status_check** is available to obtain information on the IP instance and its primary interface status. Such status information includes whether or not the link is initialized, enabled and IP address is resolved. This information is used to synchronize application threads needing to use a newly created IP instance. For multihome systems, see [Multihome Support](#multihome-support). **nx_ip_interface_status_check** is available to obtain 3information on the specified interface.*</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="b06e6-123">アプリケーション インターフェイスの呼び出し</span><span class="sxs-lookup"><span data-stu-id="b06e6-123">Application Interface Calls</span></span>

<span data-ttu-id="b06e6-124">アプリケーションからの呼び出しは、ほとんどの場合、ThreadX RTOS で実行されているアプリケーション スレッドから作成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-124">Calls from the application are largely made from application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="b06e6-125">ただし、一部の初期化、作成、および有効化のサービスは ***tx_application_define*** から呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-125">However, some initialization, create, and enable services may be called from ***tx_application_define***.</span></span> <span data-ttu-id="b06e6-126">「[第 4 章 - Azure RTOS NetX Duo サービスの説明](chapter4.md)」の「許可元」セクションでは、それぞれの NetX Duo サービスをどこから呼び出すことができるかを示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-126">The "Allowed From" sections in [Chapter 4 - Description of Azure RTOS NetX Duo Services](chapter4.md) indicate from which each NetX Duo service can be called.</span></span>

<span data-ttu-id="b06e6-127">ほとんどの場合、チェックサムの計算などの負荷の高いアクティビティは、他のスレッドの IP インスタンスへのアクセスをブロックすることなく、呼び出し元スレッドのコンテキスト内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-127">For the most part, processing intensive activities such as computing checksums is done within the calling thread's context—without blocking access of other threads to the IP instance.</span></span> <span data-ttu-id="b06e6-128">たとえば、送信時に、基になる IP 送信関数を呼び出す前に、\***nx_udp_socket_send** _ サービス内で UDP チェックサム計算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-128">For example, on transmission, the UDP checksum calculation is performed inside the \***nx_udp_socket_send** _ service, prior to calling the underlying IP send function.</span></span> <span data-ttu-id="b06e6-129">受信したパケットでは、_ *_nx_udp_socket_receive_*\* サービスで UDP チェックサムが計算され、アプリケーション スレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-129">On a received packet, the UDP checksum is calculated in the _ *_nx_udp_socket_receive_*\* service, executed in the  of the application thread.</span></span> <span data-ttu-id="b06e6-130">これにより、優先度の低いスレッドで負荷の高いチェックサム計算が行われることが原因で、優先順位の高いスレッドのネットワーク要求が停止されるのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-130">This helps prevent stalling network requests of higher-priority threads because of processing intensive checksum computation in lower-priority threads.</span></span>

<span data-ttu-id="b06e6-131">IP アドレスやポート番号などの値は、ホストのバイト順で API に渡されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-131">Values, such as IP addresses and port numbers, are passed to APIs in host byte order.</span></span> <span data-ttu-id="b06e6-132">内部的には、これらの値はホストのバイト順で格納もされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-132">Internally these values are stored in host byte order as well.</span></span> <span data-ttu-id="b06e6-133">これにより、開発者はデバッガーを使用して値を簡単に表示できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-133">This allows developers to easily view the values via a debugger.</span></span> <span data-ttu-id="b06e6-134">これらの値は、送信のためにフレーム内にプログラミングされた場合、ネットワークのバイト順に変換されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-134">When these values are programmed into a frame for transmission, they are converted to network byte order.</span></span>

### <a name="internal-ip-thread"></a><span data-ttu-id="b06e6-135">内部 IP スレッド</span><span class="sxs-lookup"><span data-stu-id="b06e6-135">Internal IP Thread</span></span>

<span data-ttu-id="b06e6-136">前述のように、NetX Duo の各 IP インスタンスには独自のスレッドがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-136">As mentioned, each IP instance in NetX Duo has its own thread.</span></span> <span data-ttu-id="b06e6-137">内部 IP スレッドの優先順位とスタック サイズは、***nx_ip_create*** サービスで定義されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-137">The priority and stack size of the internal IP thread is defined in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="b06e6-138">内部 IP スレッドは、実行可能モードで作成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-138">The internal IP thread is created in a ready-to-execute mode.</span></span> <span data-ttu-id="b06e6-139">IP スレッドの優先順位が呼び出し元のスレッドよりも高い場合、IP 作成呼び出しの内部でプリエンプションが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-139">If the IP thread has a higher priority than the calling thread, preemption may occur inside the IP create call.</span></span>

<span data-ttu-id="b06e6-140">内部 IP スレッドのエントリ ポイントは、内部関数 _ ***nx_ip_thread_entry*** にあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-140">The entry point of the internal IP thread is at the internal function _ ***nx_ip_thread_entry***.</span></span> <span data-ttu-id="b06e6-141">開始されると、内部 IP スレッドでは最初にネットワーク ドライバーの初期化が完了されます。これは、アプリケーション固有のネットワーク ドライバーに対する 3 回の呼び出しで構成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-141">When started, the internal IP thread first completes network driver initialization, which consists of making three calls to the application-specific network driver.</span></span> <span data-ttu-id="b06e6-142">最初の呼び出しでは、ネットワーク ドライバーを IP インスタンスに接続した後、初期化呼び出しを実行します。これにより、ネットワーク ドライバーは初期化プロセスを実行できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-142">The first call is to attach the network driver to the IP instance, followed by an initialization call, which allows the network driver to go through the initialization process.</span></span> <span data-ttu-id="b06e6-143">ネットワーク ドライバーが初期化から戻されると (ハードウェアが適切に設定されるのを待機している間に停止される場合があります)、内部 IP スレッドはネットワーク ドライバーを再度呼び出して、リンクを有効にします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-143">After the network driver returns from initialization (it may suspend while waiting for the hardware to be properly set up), the internal IP thread calls the network driver again to enable the link.</span></span> <span data-ttu-id="b06e6-144">ネットワーク ドライバーがリンク有効化の呼び出しから戻されると、内部 IP スレッドは永久ループに入り、この IP インスタンスの処理を必要とするさまざまなイベントを確認します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-144">After the network driver returns from the link enable call, the internal IP thread enters a forever loop checking for various events that need processing for this IP instance.</span></span> <span data-ttu-id="b06e6-145">このループで処理されるイベントには、遅延 IP パケット受信、IP パケット フラグメント アセンブリ、ICMP ping 処理、IGMP 処理、TCP パケット キュー処理、TCP 周期処理、IP フラグメント アセンブリ タイムアウト、および IGMP 周期処理が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-145">Events processed in this loop include deferred IP packet reception, IP packet fragment assembly, ICMP ping processing, IGMP processing, TCP packet queue processing, TCP periodic processing, IP fragment assembly timeouts, and IGMP periodic processing.</span></span> <span data-ttu-id="b06e6-146">イベントには、アドレス解決アクティビティ、IPv4 での ARP パケット処理と ARP 定期処理、重複アドレス検出、ルーター要請、IPv6 での近隣探索も含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-146">Events also include address resolution activities; ARP packet processing and ARP periodic processing in IPv4, Duplicate Address Detection, Router Solicitation, and Neighbor Discovery in IPv6.</span></span>

> [!CAUTION]
> <span data-ttu-id="b06e6-147">*リッスンや切断のコールバックを含む NetX Duo コールバック関数は、元の呼び出し元スレッドではなく、内部 IP スレッドから呼び出されます。アプリケーションは、NetX Duo コールバック関数内で中断しないように注意する必要があります。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-147">*The NetX Duo callback functions, including listen and disconnect callbacks, are called from the internal IP thread—not the original calling thread. The application must take care not to suspend inside any NetX Duo callback function.*</span></span>

### <a name="ip-periodic-timers"></a><span data-ttu-id="b06e6-148">IP の定期的なタイマー</span><span class="sxs-lookup"><span data-stu-id="b06e6-148">IP Periodic Timers</span></span>

<span data-ttu-id="b06e6-149">各 IP インスタンスには、ThreadX の定期的なタイマーが 2 つ使用されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-149">There are two ThreadX periodic timers used for each IP instance.</span></span> <span data-ttu-id="b06e6-150">1 つ目は、ARP、IGMP、TCP タイムアウト用の 1 秒のタイマーで、IP フラグメントの再アセンブル処理にも使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-150">The first one is a one-second timer for ARP, IGMP, TCP timeout, and it also drives IP fragment reassemble processing.</span></span> <span data-ttu-id="b06e6-151">2 つ目のタイマーは、TCP 再送信タイムアウトと IPv6 関連操作に使用される 100 ミリ秒タイマーです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-151">The second timer is a 100ms timer to drive the TCP retransmission timeout and IPv6-related operations.</span></span>

### <a name="network-driver"></a><span data-ttu-id="b06e6-152">ネットワーク ドライバー</span><span class="sxs-lookup"><span data-stu-id="b06e6-152">Network Driver</span></span>

<span data-ttu-id="b06e6-153">NetX Duo の各 IP インスタンスには、プライマリ インターフェイスがあります。これは、***nx_ip_create*** サービスで指定されているデバイス ドライバーによって識別されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-153">Each IP instance in NetX Duo has a primary interface, which is identified by its device driver specified in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="b06e6-154">ネットワーク ドライバーでは、パケットの送信、パケットの受信、状態と制御の要求など、さまざまな NetX Duo 要求が処理されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-154">The network driver is responsible for handling various NetX Duo requests, including packet transmission, packet reception, and requests for status and control.</span></span> 

<span data-ttu-id="b06e6-155">マルチホーム システムの場合、IP インスタンスは複数のインターフェイスを持ち、それぞれのインターフェイスでこれらのタスクを実行するネットワーク ドライバーが関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-155">For a multi-home system, the IP instance has multiple interfaces, each with an associated network driver that performs these tasks for the respective interface.</span></span>

<span data-ttu-id="b06e6-156">ネットワーク ドライバーでは、メディアで発生している非同期イベントも処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-156">The network driver must also handle asynchronous events occurring on the media.</span></span> <span data-ttu-id="b06e6-157">メディアからの非同期イベントには、パケットの受信、パケット送信の完了、および状態の変更が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-157">Asynchronous events from the media include packet reception, packet transmission completion, and status changes.</span></span> <span data-ttu-id="b06e6-158">NetX Duo では、さまざまなイベントを処理するいくつかのアクセス関数がネットワーク ドライバーに提供されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-158">NetX Duo provides the network driver with several access functions to handle various events.</span></span> <span data-ttu-id="b06e6-159">これらの関数は、ネットワーク ドライバーの割り込みサービスのルーチン部分から呼び出されるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-159">These functions are designed to be called from the  interrupt service routine portion of the network driver.</span></span> <span data-ttu-id="b06e6-160">IPv4 ネットワークの場合、ネットワーク ドライバーは、受信したすべての ARP パケットを ***_nx_arp_packet_deferred_receive*** 内部関数に転送する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-160">For IPv4 networks, the network driver should forward all ARP packets received to the ***_nx_arp_packet_deferred_receive*** internal function.</span></span> <span data-ttu-id="b06e6-161">すべての RARP パケットは \* **_nx_rarp_packet_deferred_receive** _ 内部関数に転送される必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-161">All RARP packets should be forwarded to \***_nx_rarp_packet_deferred_receive** _ internal function.</span></span> <span data-ttu-id="b06e6-162">IP パケットには 2 つのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-162">There are two options for IP packets.</span></span> <span data-ttu-id="b06e6-163">IP パケットの高速ディスパッチが必要な場合は、受信 IP パケットを _ *_ _nx_ip_packet_receive_* _ に転送してすぐに処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-163">If fast dispatch of IP packets is required, incoming IP packets should be forwarded to _ *_ _nx_ip_packet_receive_* _ for immediate processing.</span></span> <span data-ttu-id="b06e6-164">これにより、IP パケットを処理する際の NetX Duo のパフォーマンスが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-164">This greatly improves NetX Duo performance in handling IP packets.</span></span> <span data-ttu-id="b06e6-165">それ以外の場合は、IP パケットを _ *_ _nx_ip_packet_deferred_receive_*\* に転送する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-165">Otherwise, forwarding IP packets to _ *_ _nx_ip_packet_deferred_receive_*\* should be done.</span></span> <span data-ttu-id="b06e6-166">このサービスでは、IP パケットが遅延処理キューに配置されます。このキューでパケットは内部 IP スレッドによって処理されます。これにより、ISR 処理時間が最短になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-166">This service places the IP packet in the deferred processing queue where it is then handled by the internal IP thread, which results in the least amount of ISR processing time.</span></span>

<span data-ttu-id="b06e6-167">また、ネットワーク ドライバーでは、割り込み処理を遅延させて、IP スレッドのコンテキストから実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-167">The network driver can also defer interrupt processing to run out of the context of the IP thread.</span></span> <span data-ttu-id="b06e6-168">このモードの ISR では、必要な情報が保存され、内部関数 ***_nx_ip_driver_deferred_processing*** が呼び出されて、割り込みコントローラーが確認されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-168">In this mode, the ISR shall save the necessary information, call the internal function ***_nx_ip_driver_deferred_processing***, and acknowledge the interrupt controller.</span></span> <span data-ttu-id="b06e6-169">このサービスでは、割り込みを発生させるイベントのプロセスを完了するために、デバイス ドライバーへのコールバックをスケジュールするように、IP スレッドに通知されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-169">This service notifies IP thread to schedule a callback to the device driver to complete the process of the event that causes the interrupt.</span></span>

<span data-ttu-id="b06e6-170">一部のネットワーク コントローラーでは、貴重な CPU リソースを消費することなく、ハードウェアで TCP/IP ヘッダー チェックサムの計算と検証が実行されるようにできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-170">Some network controllers are capable of performing TCP/IP header checksum computation and validation in hardware, without taking up valuable CPU resources.</span></span> <span data-ttu-id="b06e6-171">ハードウェア機能を利用するために、NetX Duo では、さまざまなソフトウェア チェックサム計算をコンパイル時に有効または無効にするオプションに加えて、デバイス ドライバーが IP 層と通信できる場合に、チェックサム計算を実行時に有効または無効にするオプションを提供しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-171">To take advantage of the hardware capability feature, NetX Duo provides options to enable or disable various software checksum computation at compilation time, as well as turning on or off checksum computation at run time, if the device driver is able to communicate with the IP layer about is hardware capabilities.</span></span> <span data-ttu-id="b06e6-172">NetX Duo ネットワーク ドライバーの記述の詳細については、「[第 5 章 - Azure RTOS NetX Duo ネットワーク ドライバー](chapter5.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-172">See [Chapter 5 - Azure RTOS NetX Duo Network Drivers](chapter5.md) for more detailed information on writing NetX Duo network drivers.</span></span>

### <a name="multihome-support"></a><span data-ttu-id="b06e6-173">マルチホーム サポート</span><span class="sxs-lookup"><span data-stu-id="b06e6-173">Multihome Support</span></span>

<span data-ttu-id="b06e6-174">NetX Duo では、単一の IP インスタンスを使用して複数の物理デバイスに接続されたシステムがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-174">NetX Duo supports systems connected to multiple physical devices using a single IP instance.</span></span> <span data-ttu-id="b06e6-175">各物理インターフェイスは、IP インスタンス内のインターフェイス制御ブロックに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-175">Each physical interface is assigned to an interface control block in the IP instance.</span></span> <span data-ttu-id="b06e6-176">マルチホーム システムを使用するアプリケーションでは、\***NX_MAX_PHSYCIAL_INTERFACES** _ の値をシステムに接続されている物理デバイスの数に定義し、NetX Duo ライブラリをリビルドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-176">Applications wishing to use a multihome system must define the value for \***NX_MAX_PHSYCIAL_INTERFACES** _ to the number of physical devices attached to the system, and rebuild NetX Duo library.</span></span> <span data-ttu-id="b06e6-177">既定では _ *_NX_MAX_PHYSICAL_INTERFACES_*\* が 1 に設定され、IP インスタンスに 1 つのインターフェイス制御ブロックが作成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-177">By default _ *_NX_MAX_PHYSICAL_INTERFACES_*\* is set to one, creating one interface control block in the IP instance.</span></span>

<span data-ttu-id="b06e6-178">NetX Duo アプリケーションでは、\***nx_ip_create** _ サービスを使用して、プライマリ デバイス用の単一の IP インスタンスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-178">The NetX Duo application creates a single IP instance for the primary device using the \***nx_ip_create** _ service.</span></span> <span data-ttu-id="b06e6-179">追加のネットワーク デバイスごとに、アプリケーションで _ *_nx_ip_interface_attach_*\* サービスを使用して、デバイスが IP インスタンスに接続されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-179">For each additional network devices, the application attaches the device to the IP instance using the _ *_nx_ip_interface_attach_*\* service.</span></span>

<span data-ttu-id="b06e6-180">各ネットワーク インターフェイス構造には、IP 制御ブロックに含まれるネットワーク インターフェイスに関するネットワーク情報のサブセットが含まれています。これには、インターフェイス IPv4 アドレス、サブネット マスク、IP MTU サイズ、および MAC レイヤー アドレス情報が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-180">Each network interface structure contains a subset of network information about the network interface that is contained in the IP control block, including interface IPv4 address, subnet mask, IP MTU size, and MAC-layer address information.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-181">*マルチホーム サポートが有効な NetX Duo には、以前のバージョンの NetX Duo との下位互換性があります。明示的なインターフェイス情報を受け取らないサービスは、既定でプライマリ ネットワーク デバイスに設定されます。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-181">*NetX Duo with multihome support is backward compatible with earlier versions of NetX Duo. Services that do not take explicit interface information default to the primary network device.*</span></span>

<span data-ttu-id="b06e6-182">IP インスタンスの一覧で、プライマリ インターフェイスはインデックス 0 になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-182">The primary interface has index zero in the IP instance list.</span></span> <span data-ttu-id="b06e6-183">IP インスタンスに接続されているそれ以降の各デバイスには、次のインデックスが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-183">Each subsequent device attached to the IP instance is assigned the next index.</span></span>

<span data-ttu-id="b06e6-184">IP インスタンスが有効になっているすべての上位層プロトコルサービス (TCP、UDP、ICMP、IGMP を含む) は、接続されているすべてのデバイスで使用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-184">All upper layer protocol services for which the IP instance is enabled, including TCP, UDP, ICMP, and IGMP, are available to all the attached devices.</span></span>

<span data-ttu-id="b06e6-185">ほとんどの場合、NetX Duo ではパケットの送信時に使用する最適な送信元アドレスを決定できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-185">In most cases, NetX Duo can determine the best source address to use when transmitting a packet.</span></span> <span data-ttu-id="b06e6-186">送信元アドレスの選択は、宛先アドレスに基づいています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-186">The source address selection is based on the destination address.</span></span> <span data-ttu-id="b06e6-187">NetX Duo サービスは、宛先アドレスによって最適な送信元アドレスを特定できない場合に、使用する特定の送信元アドレスをアプリケーションで指定できるように追加されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-187">NetX Duo services are added to allow applications to specify a specific source address to use, in cases where the most suitable one cannot be determined by the destination address.</span></span> <span data-ttu-id="b06e6-188">例として、アプリケーションが IPv4 ブロードキャストまたはマルチキャストの宛先アドレスにパケットを送信する必要があるマルチホーム システムの場合を考えます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-188">An example would be in a multihome system, an application needs to send a packet to an IPv4 broadcast or multicast destination addresses.</span></span>

<span data-ttu-id="b06e6-189">マルチホーム アプリケーションの開発に特化したサービスには、次のものがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-189">Services specifically for developing multihome applications include the following:</span></span>

- <span data-ttu-id="b06e6-190">*nx_igmp_multicast_interface_join*</span><span class="sxs-lookup"><span data-stu-id="b06e6-190">*nx_igmp_multicast_interface_join*</span></span>
- <span data-ttu-id="b06e6-191">*nx_igmp_multicast_interface_leave*</span><span class="sxs-lookup"><span data-stu-id="b06e6-191">*nx_igmp_multicast_interface_leave*</span></span>
- <span data-ttu-id="b06e6-192">*nx_ip_driver_interface_direct_command*</span><span class="sxs-lookup"><span data-stu-id="b06e6-192">*nx_ip_driver_interface_direct_command*</span></span>
- <span data-ttu-id="b06e6-193">*nx_ip_interface_address_get*</span><span class="sxs-lookup"><span data-stu-id="b06e6-193">*nx_ip_interface_address_get*</span></span>
- <span data-ttu-id="b06e6-194">*nx_ip_interface_address_mapping_configure*</span><span class="sxs-lookup"><span data-stu-id="b06e6-194">*nx_ip_interface_address_mapping_configure*</span></span>
- <span data-ttu-id="b06e6-195">*nx_ip_interface_address_set*</span><span class="sxs-lookup"><span data-stu-id="b06e6-195">*nx_ip_interface_address_set*</span></span>  
- <span data-ttu-id="b06e6-196">*nx_ip_interface_attach*</span><span class="sxs-lookup"><span data-stu-id="b06e6-196">*nx_ip_interface_attach*</span></span>
- <span data-ttu-id="b06e6-197">*nx_ip_interface_capability_get*</span><span class="sxs-lookup"><span data-stu-id="b06e6-197">*nx_ip_interface_capability_get*</span></span> 
- <span data-ttu-id="b06e6-198">*nx_ip_interface_capability_set*</span><span class="sxs-lookup"><span data-stu-id="b06e6-198">*nx_ip_interface_capability_set*</span></span>
- <span data-ttu-id="b06e6-199">*nx_ip_interface_detach*</span><span class="sxs-lookup"><span data-stu-id="b06e6-199">*nx_ip_interface_detach*</span></span>
- <span data-ttu-id="b06e6-200">*nx_ip_interface_info_get*</span><span class="sxs-lookup"><span data-stu-id="b06e6-200">*nx_ip_interface_info_get*</span></span>
- <span data-ttu-id="b06e6-201">*nx_ip_interface_mtu_set*</span><span class="sxs-lookup"><span data-stu-id="b06e6-201">*nx_ip_interface_mtu_set*</span></span>
- <span data-ttu-id="b06e6-202">*nx_ip_interface_physical_address_get*</span><span class="sxs-lookup"><span data-stu-id="b06e6-202">*nx_ip_interface_physical_address_get*</span></span>
- <span data-ttu-id="b06e6-203">*nx_ip_interface_physical_address_set*</span><span class="sxs-lookup"><span data-stu-id="b06e6-203">*nx_ip_interface_physical_address_set*</span></span>
- <span data-ttu-id="b06e6-204">*nx_ip_interface_status_check*</span><span class="sxs-lookup"><span data-stu-id="b06e6-204">*nx_ip_interface_status_check*</span></span>
- <span data-ttu-id="b06e6-205">*nx_ip_raw_packet_source_send*</span><span class="sxs-lookup"><span data-stu-id="b06e6-205">*nx_ip_raw_packet_source_send*</span></span>
- <span data-ttu-id="b06e6-206">*nx_ipv4_multicast_interface_join*</span><span class="sxs-lookup"><span data-stu-id="b06e6-206">*nx_ipv4_multicast_interface_join*</span></span>
- <span data-ttu-id="b06e6-207">*nx_ipv4_multicast_interface_leave*</span><span class="sxs-lookup"><span data-stu-id="b06e6-207">*nx_ipv4_multicast_interface_leave*</span></span>
- <span data-ttu-id="b06e6-208">*nx_udp_socket_source_send*</span><span class="sxs-lookup"><span data-stu-id="b06e6-208">*nx_udp_socket_source_send*</span></span>
- <span data-ttu-id="b06e6-209">*nxd_ipv6_multicast_interface_join*</span><span class="sxs-lookup"><span data-stu-id="b06e6-209">*nxd_ipv6_multicast_interface_join*</span></span>
- <span data-ttu-id="b06e6-210">*nxd_ipv6_multicast_interface_leave*</span><span class="sxs-lookup"><span data-stu-id="b06e6-210">*nxd_ipv6_multicast_interface_leave*</span></span> 
- <span data-ttu-id="b06e6-211">*nxd_udp_socket_source_send*</span><span class="sxs-lookup"><span data-stu-id="b06e6-211">*nxd_udp_socket_source_send*</span></span>
- <span data-ttu-id="b06e6-212">*nxd_icmp_source_ping*</span><span class="sxs-lookup"><span data-stu-id="b06e6-212">*nxd_icmp_source_ping*</span></span>
- <span data-ttu-id="b06e6-213">*nxd_ip_raw_packet_source_send*</span><span class="sxs-lookup"><span data-stu-id="b06e6-213">*nxd_ip_raw_packet_source_send*</span></span>
- <span data-ttu-id="b06e6-214">*nxd_udp_socket_source_send*</span><span class="sxs-lookup"><span data-stu-id="b06e6-214">*nxd_udp_socket_source_send*</span></span>

<span data-ttu-id="b06e6-215">これらのサービスについては、[NetX Duo サービスの説明](chapter4.md)に関するページで詳しく説明しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-215">These services are explained in greater detail in [Description of NetX Duo Services](chapter4.md).</span></span>

### <a name="loopback-interface"></a><span data-ttu-id="b06e6-216">ループバック インターフェイス</span><span class="sxs-lookup"><span data-stu-id="b06e6-216">Loopback Interface</span></span>

<span data-ttu-id="b06e6-217">ループバック インターフェイスは、物理リンクがアタッチされていない特殊なネットワーク インターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-217">The loopback interface is a special network interface without an physical link attached to.</span></span> <span data-ttu-id="b06e6-218">ループバック インターフェイスを使用すると、アプリケーションで IPv4 ループバック アドレス 127.0.0.1 を使用して通信できます。論理ループバック インターフェイスを利用するには、構成可能なオプション ***NX_DISABLE_LOOPBACK_INTERFACE*** が設定されていないことを確認してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-218">The loopback interface allows applications to communicate using the IPv4 loopback address 127.0.0.1 To utilize a logical loopback interface, ensure the configurable option ***NX_DISABLE_LOOPBACK_INTERFACE*** is not set.</span></span>

### <a name="interface-control-blocks"></a><span data-ttu-id="b06e6-219">インターフェイス制御ブロック</span><span class="sxs-lookup"><span data-stu-id="b06e6-219">Interface Control Blocks</span></span>

<span data-ttu-id="b06e6-220">IP インスタンス内のインターフェイス制御ブロックの数は、物理インターフェイスの数 (\***NX_MAX_PHYSICAL_INTERFACES** _ によって定義されます) に、ループバック インターフェイス (有効になっている場合) を加算したものです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-220">The number of interface control blocks in the IP instance is the number of physical interfaces (defined by \***NX_MAX_PHYSICAL_INTERFACES** _) plus the loopback interface if it is enabled.</span></span> <span data-ttu-id="b06e6-221">インターフェイスの合計数は、_*_NX_MAX_IP_INTERFACES_*\* で定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-221">The total number of interfaces is defined in _\*_NX_MAX_IP_INTERFACES_\*\*.</span></span>

## <a name="protocol-layering"></a><span data-ttu-id="b06e6-222">プロトコルのレイヤー化</span><span class="sxs-lookup"><span data-stu-id="b06e6-222">Protocol Layering</span></span>

<span data-ttu-id="b06e6-223">NetX Duo によって実装される TCP/IP は、レイヤー化されたプロトコルです。これは、より複雑なプロトコルが、より単純な基盤となるプロトコルの上に構築されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-223">The TCP/IP implemented by NetX Duo is a layered protocol, which means more complex protocols are built on top of simpler underlying protocols.</span></span> <span data-ttu-id="b06e6-224">TCP/IP では、最下位層のプロトコルは "*リンク レベル*" にあり、ネットワーク ドライバーによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-224">In TCP/IP, the lowest layer protocol is at the *link level* and is handled by the network driver.</span></span> <span data-ttu-id="b06e6-225">このレベルは、通常、イーサネットを対象としていますが、ファイバー、シリアル、または事実上すべての物理メディアである可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-225">This level is typically targeted towards Ethernet, but it could also be fiber, serial, or virtually any physical media.</span></span>

<span data-ttu-id="b06e6-226">リンク層の上には "*ネットワーク層*" があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-226">On top of the link layer is the *network layer*.</span></span> <span data-ttu-id="b06e6-227">TCP/IP では、これは IP です。基本的には、ネットワーク全体で、ベストエフォート方式で単純なパケットを送受信する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="b06e6-227">In TCP/IP, this is the IP, which is basically responsible for sending and receiving simple packets—in a best-effort manner—across the network.</span></span> <span data-ttu-id="b06e6-228">ICMP や IGMP などの管理の種類のプロトコルは、通常、送信と受信のために IP に依存している場合でも、ネットワーク層として分類されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-228">Management-type protocols like ICMP and IGMP are typically also categorized as network layers, even though they rely on IP for sending and receiving.</span></span>

<span data-ttu-id="b06e6-229">"*トランスポート層*" は、ネットワーク層の上に置かれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-229">The *transport layer* rests on top of the network layer.</span></span> <span data-ttu-id="b06e6-230">この層は、ネットワーク上でホスト間のデータ フローを管理する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="b06e6-230">This layer is responsible for managing the flow of data between hosts on the network.</span></span> <span data-ttu-id="b06e6-231">NetX Duo でサポートされる転送サービスには、UDP と TCP の 2 種類があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-231">There are two types of transport services supported by NetX Duo: UDP and TCP.</span></span> <span data-ttu-id="b06e6-232">UDP サービスは、コネクションレス方式で 2 つのホスト間でデータをベストエフォートで送受信します。一方、TCP は、2 つのホスト エンティティ間に信頼性の高い接続指向サービスを提供します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-232">UDP services provide best-effort sending and receiving of data between two hosts in a connectionless manner, while TCP provides reliable connection-oriented service between two host entities.</span></span>

<span data-ttu-id="b06e6-233">このレイヤー化は、実際のネットワーク データ パケットに反映されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-233">This layering is reflected in the actual network data packets.</span></span> <span data-ttu-id="b06e6-234">TCP/IP の各層には、ヘッダーと呼ばれる情報のブロックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-234">Each layer in TCP/IP contains a block of information called a header.</span></span> <span data-ttu-id="b06e6-235">データ (および場合によってはプロトコル情報) をヘッダーで囲むこの手法は、一般にデータのカプセル化と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-235">This technique of surrounding data (and possibly protocol information) with a header is typically called data encapsulation.</span></span> <span data-ttu-id="b06e6-236">図 1 は、NetX Duo のレイヤー化の例を示し、図 2 は、送信される UDP データのデータ カプセル化を示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-236">Figure 1 shows an example of NetX Duo layering and Figure 2 shows the resulting data encapsulation for UDP data being sent.</span></span>

![プロトコルのレイヤー化](./media/user-guide/image12.jpg)

<span data-ttu-id="b06e6-238">**図 1. プロトコルのレイヤー化**</span><span class="sxs-lookup"><span data-stu-id="b06e6-238">**FIGURE 1. Protocol Layering**</span></span>

## <a name="packet-pools"></a><span data-ttu-id="b06e6-239">パケット プール</span><span class="sxs-lookup"><span data-stu-id="b06e6-239">Packet Pools</span></span>

<span data-ttu-id="b06e6-240">パケットを高速かつ決定論的な方法で割り当てることは、常に、リアルタイム ネットワーク アプリケーションの課題です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-240">Allocating packets in a fast and deterministic manner is always a challenge in real-time networking applications.</span></span> <span data-ttu-id="b06e6-241">これを念頭に置いて、NetX Duo では、固定サイズのネットワーク パケットの複数のプールを作成および管理する機能が提供されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-241">With this in mind, NetX Duo provides the ability to create and manage multiple pools of fixed-size network packets.</span></span>

<span data-ttu-id="b06e6-242">NetX Duo のパケット プールは固定サイズのメモリ ブロックで構成されているため、内部断片化の問題は発生しません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-242">Because NetX Duo packet pools consist of fixed-size memory blocks, there are never any internal fragmentation problems.</span></span> <span data-ttu-id="b06e6-243">もちろん、断片化によって本質的に非決定論的な動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-243">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="b06e6-244">さらに、NetX Duo パケットを割り当てて解放するために必要な時間は、単純なリンクリスト操作と同等です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-244">In addition, the time required to allocate and free a NetX Duo packet amounts to simple linked-list manipulation.</span></span> <span data-ttu-id="b06e6-245">さらに、使用可能な一覧の先頭でパケットの割り当てと割り当て解除が行われます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-245">Furthermore, packet allocation and deallocation is done at the head of the available list.</span></span> <span data-ttu-id="b06e6-246">これにより、可能なリンク リストの処理が最速になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-246">This provides the fastest possible linked list processing.</span></span>

![UDP データのカプセル化](./media/user-guide/image13.png)

<span data-ttu-id="b06e6-248">**図 2. UDP データのカプセル化**</span><span class="sxs-lookup"><span data-stu-id="b06e6-248">**FIGURE 2. UDP Data Encapsulation**</span></span>

<span data-ttu-id="b06e6-249">通常、固定サイズのパケット プールの主な欠点は、柔軟性の欠如です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-249">Lack of flexibility is typically the main drawback of fixed-size packet pools.</span></span> <span data-ttu-id="b06e6-250">最悪の場合の受信パケットも処理できる最適なパケット ペイロード サイズを判断することは、困難な作業です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-250">Determining the optimal packet payload size that also handles the worst-case incoming packet is a difficult task.</span></span> <span data-ttu-id="b06e6-251">NetX Duo パケットは、"パケット チェーン" と呼ばれるオプションの機能を使用してこの問題に対処します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-251">NetX Duo packets address this problem with an optional feature called packet chaining.</span></span> <span data-ttu-id="b06e6-252">実際のネットワーク パケットは、互いにリンクされた 1 つ以上の NetX Duo パケットで構成されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-252">An actual network packet can be made of one or more NetX Duo packets linked together.</span></span> <span data-ttu-id="b06e6-253">また、パケット ヘッダーはパケットの先頭へのポインターを保持します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-253">In addition, the packet header maintains a pointer to the top of the packet.</span></span> <span data-ttu-id="b06e6-254">プロトコルが追加されると、このポインターは単純に後方に移動されて、新しいヘッダーがデータの前に直接書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-254">As additional protocols are added, this pointer is simply moved backwards and the new header is written directly in front of the data.</span></span> <span data-ttu-id="b06e6-255">柔軟なパケット テクノロジを使用しない場合、スタックは別のバッファーを割り当て、新しいヘッダーを使用して新しいバッファーにデータをコピーする必要があります。これは、負荷の高い処理です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-255">Without the flexible packet technology, the stack would have to allocate another buffer and copy the data into a new buffer with the new header, which is processing intensive.</span></span>

<span data-ttu-id="b06e6-256">各パケットのペイロード サイズは特定のパケット プールに対して固定されているため、ペイロード サイズを超えるアプリケーション データでは、複数のパケットが連結されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-256">Since each packet payload size is fixed for a given packet pool, application data larger than the payload size would require multiple packets chained together.</span></span> <span data-ttu-id="b06e6-257">パケットにユーザー データを入力する場合は、アプリケーションでサービス ***nx_packet_data_append*** を使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-257">When filling a packet with user data, the application shall use the service ***nx_packet_data_append***.</span></span> <span data-ttu-id="b06e6-258">このサービスによって、アプリケーション データがパケットに移動されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-258">This service moves application data into a packet.</span></span> <span data-ttu-id="b06e6-259">パケットがユーザー データを保持するのに十分でない場合は、ユーザー データを格納するための追加のパケットが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-259">In situations where a packet is not enough to hold user data, additional packets are allocated to store user data.</span></span> <span data-ttu-id="b06e6-260">パケット チェーンを使用するには、ドライバーがチェーン化されたパケットとの間で送受信できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-260">To use packet chaining, the driver must be able to receive into or transmit from chained packets.</span></span>

<span data-ttu-id="b06e6-261">パケット チェーン機能を使用する必要のない組み込みシステムの場合、\***NX_DISABLE_PACKET_CHAIN** _ で NetX Duo ライブラリをビルドして、パケット チェーン ロジックを削除することができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-261">For embedded systems that do not need to use the packet chaining feature, the NetX Duo library can be built with \***NX_DISABLE_PACKET_CHAIN** _ to remove the packet chaining logic.</span></span> <span data-ttu-id="b06e6-262">注意点として、IP の断片化と再アセンブリの機能では、チェーン化パケット機能を利用することが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-262">Note that the IP fragmentation and reassembly feature may need to utilize the chained packet feature.</span></span> <span data-ttu-id="b06e6-263">したがって、_*_NX_DISABLE_PACKET_CHAIN_*_ を定義するには _ *_NX_DISABLE_FRAGMENTATION_*\* も定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-263">Therefore defining _*_NX_DISABLE_PACKET_CHAIN_*_ requires _ *_NX_DISABLE_FRAGMENTATION_*\* also be defined.</span></span> 

<span data-ttu-id="b06e6-264">各 NetX Duo パケット メモリ プールは、パブリック リソースです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-264">Each NetX Duo packet memory pool is a public resource.</span></span> <span data-ttu-id="b06e6-265">NetX Duo では、パケット プールの使用方法に関する制約はありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-265">NetX Duo places no constraints on how packet pools are used.</span></span> 

### <a name="packet-pool-memory-area"></a><span data-ttu-id="b06e6-266">パケット プールのメモリ領域</span><span class="sxs-lookup"><span data-stu-id="b06e6-266">Packet Pool Memory Area</span></span>

<span data-ttu-id="b06e6-267">パケット プールのメモリ領域は、作成時に指定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-267">The memory area for the packet pool is specified during creation.</span></span> <span data-ttu-id="b06e6-268">ThreadX オブジェクトと NetX Duo オブジェクトの他のメモリ領域と同様に、ターゲットのアドレス空間内のどこにでも配置できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-268">Like other memory areas for ThreadX and NetX Duo objects, it can be located anywhere in the target's address space.</span></span> 

<span data-ttu-id="b06e6-269">アプリケーションに非常に高い柔軟性が提供されるため、これは重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-269">This is an important feature because of the considerable flexibility it gives the application.</span></span> <span data-ttu-id="b06e6-270">たとえば、ネットワーク バッファー用に高速メモリ領域がある通信製品を考えます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-270">For example, suppose that a communication product has a high-speed memory area for network buffers.</span></span> <span data-ttu-id="b06e6-271">このメモリ領域を NetX Duo パケット メモリ プール内に作成することで、この領域を簡単に利用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-271">This memory area is easily utilized by making it into a NetX Duo packet memory pool.</span></span>

### <a name="creating-packet-pools"></a><span data-ttu-id="b06e6-272">パケット プールの作成</span><span class="sxs-lookup"><span data-stu-id="b06e6-272">Creating Packet Pools</span></span>

<span data-ttu-id="b06e6-273">パケット プールは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-273">Packet pools are created either during initialization or during runtime by  application threads.</span></span> <span data-ttu-id="b06e6-274">NetX Duo アプリケーションのパケット メモリ プールの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-274">There are no limits on the number of packet memory pools in a NetX Duo application.</span></span>

### <a name="dual-packet-pool"></a><span data-ttu-id="b06e6-275">デュアル パケット プール</span><span class="sxs-lookup"><span data-stu-id="b06e6-275">Dual Packet Pool</span></span>

<span data-ttu-id="b06e6-276">通常、既定の IP パケット プールのペイロード サイズは、最大でネットワーク インターフェイス MTU のサイズのフレームを収容するのに十分な大きさです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-276">Typically the payload size of the default IP packet pool is large enough to accommodate frame size up to the network interface MTU.</span></span> <span data-ttu-id="b06e6-277">通常の操作中、IP スレッドでは、ARP、TCP 制御メッセージ、IGMP メッセージ、ICMPv6 メッセージなどのメッセージを送信する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-277">During normal operation, the IP thread needs to send messages such as ARP, TCP control messages, IGMP messages, ICMPv6 messages.</span></span> <span data-ttu-id="b06e6-278">これらのメッセージでは、IP インスタンス内の既定のパケットプールから割り当てられたパケットを使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-278">These messages use the packets allocated from the default packet pool in the IP instance.</span></span> <span data-ttu-id="b06e6-279">メモリの制約があり、パケット プールに使用できるメモリの量が限られているシステムでは、(MTU サイズに合わせた大きなペイロード サイズの) 1 つのパケット プールを使用するのは最適なソリューションではない場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-279">On a memory-constrained system where the amount of memory available for packet pool is limited, using a single packet pool (with the large payload size to match MTU size) may not be an optimal solution.</span></span> <span data-ttu-id="b06e6-280">NetX Duo を使用すると、アプリケーションでは、ペイロード サイズが比較的小さい補助パケット プールをインストールできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-280">NetX Duo allows application to install an auxiliary packet pool, where the payload size is smaller.</span></span> <span data-ttu-id="b06e6-281">補助パケット プールがインストールされると、IP ヘルパー スレッドでは、送信するメッセージのサイズに応じて、既定のパケット プールまたは補助プールのどちらかからパケットを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-281">Once the auxiliary packet pool is installed, the IP helper thread would allocate packets from either the default packet pool or the auxiliary pool, depending on the size of the message it transmits.</span></span> <span data-ttu-id="b06e6-282">補助パケット プールの場合、200 バイトのペイロード サイズは、IP ヘルパー スレッドで送信するほとんどのメッセージに十分です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-282">For an auxiliary packet pool, a payload size of 200 bytes would work with most of the messages the IP helper thread transmits.</span></span>

<span data-ttu-id="b06e6-283">既定では、NetX Duo ライブラリはデュアル パケット プールを有効にせずにビルドされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-283">By default NetX Duo library is built without enabling dual packet pool.</span></span> <span data-ttu-id="b06e6-284">この機能を有効にするには、\***NX_DUAL_PACKET_POOL_ENABLE** _ を定義してライブラリをビルドします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-284">To enable the feature, build the library with \***NX_DUAL_PACKET_POOL_ENABLE** _ defined.</span></span> <span data-ttu-id="b06e6-285">これ以降、_*_nx_ip_auxiliary_packet_pool_set_*\* を呼び出して補助パケット プールを設定できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-285">Then the auxiliary packet pool can be set by calling _\*_nx_ip_auxiliary_packet_pool_set_\*\*.</span></span>

<span data-ttu-id="b06e6-286">複数のパケット プールを作成するオプションもあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-286">There is also the option of creating more than one packet pool.</span></span> <span data-ttu-id="b06e6-287">たとえば、送信パケット プールは、予想されるメッセージ サイズに最適なペイロード サイズで作成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-287">For example a transmit packet pool is created with optimal payload size for expected message sizes.</span></span> <span data-ttu-id="b06e6-288">受信パケットのサイズは予測できないため、ドライバーでは、ドライバー MTU に設定されたペイロード サイズで受信パケット プールが作成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-288">A receive packet pool is created in the driver with a payload size set to the driver MTU, since one cannot predict the size of received packets.</span></span>

### <a name="packet-header-nx_packet"></a><span data-ttu-id="b06e6-289">パケット ヘッダー NX_PACKET</span><span class="sxs-lookup"><span data-stu-id="b06e6-289">Packet Header NX_PACKET</span></span>   
<span data-ttu-id="b06e6-290">既定では、NetX Duo ではパケット ペイロード領域の直前にパケット ヘッダーが配置されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-290">By default, NetX Duo places the packet header immediately before the packet payload area.</span></span> <span data-ttu-id="b06e6-291">パケット メモリ プールは基本的に一連のパケットで、ヘッダーの直後にパケット ペイロードが続きます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-291">The packet memory pool is basically a series of packets— headers followed immediately by the packet payload.</span></span> <span data-ttu-id="b06e6-292">パケット ヘッダー (***NX_PACKET***) とパケット プールのレイアウトを図 3 に示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-292">The packet header (***NX_PACKET***) and the layout of the packet pool are pictured in Figure 3.</span></span>

<span data-ttu-id="b06e6-293">ゼロ コピー操作を実行できるネットワーク デバイス ドライバーでは、通常、パケット ペイロード領域の開始アドレスが DMA ロジックにプログラミングされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-293">For network devices driver that are able to perform zero copy operations, typically the starting address of the packet payload area is programmed into the DMA logic.</span></span> <span data-ttu-id="b06e6-294">特定の DMA エンジンでは、ペイロード領域にアラインメントの要件があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-294">Certain DMA engines have alignment requirement on the payload area.</span></span> <span data-ttu-id="b06e6-295">ペイロード領域の開始アドレスを、DMA エンジンまたはキャッシュ操作に合わせて適切に整列させるために、ユーザーはシンボル ***NX_PACKET_ALIGNMENT*** を定義できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-295">To make the starting address of the payload area align properly for the DMA engine, or the cache operation, the user can define the symbol ***NX_PACKET_ALIGNMENT***.</span></span>

> [!WARNING]
> <span data-ttu-id="b06e6-296">*パケットの伝送が完了したら、ネットワーク ドライバーで **nx_packet_transmit_release** 関数を使用することが重要です。この関数によって、パケットが使用可能なプールに実際に戻される前に、TCP 出力キューに含まれていないことが確認されます。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-296">*It is important for the network driver to use the **nx_packet_transmit_release** function when transmission of a packet is complete. This function checks to make sure the packet is not part of a TCP output queue before it is actually placed back in the available pool.*</span></span>

![パケット ヘッダーとパケット プールのレイアウト](./media/user-guide/image14.jpg)

<span data-ttu-id="b06e6-298">**図 3. パケット ヘッダーとパケット プールのレイアウト**</span><span class="sxs-lookup"><span data-stu-id="b06e6-298">**FIGURE 3. Packet Header and Packet Pool Layout**</span></span>

<span data-ttu-id="b06e6-299">パケット ヘッダーのフィールドは次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-299">The fields of the packet header are defined as follows.</span></span> <span data-ttu-id="b06e6-300">この表は、*NX_PACKET* 構造のすべてのメンバーの包括的な一覧ではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-300">Note that this table is not a comprehensive list of all the members in the *NX_PACKET* structure.</span></span>

|<span data-ttu-id="b06e6-301">パケット ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b06e6-301">Packet header</span></span> | <span data-ttu-id="b06e6-302">目的</span><span class="sxs-lookup"><span data-stu-id="b06e6-302">Purpose</span></span> |
|---|---|
|<span data-ttu-id="b06e6-303">***nx_packet_pool_owner***</span><span class="sxs-lookup"><span data-stu-id="b06e6-303">***nx_packet_pool_owner***</span></span>|<span data-ttu-id="b06e6-304">このフィールドは、この特定のパケットを所有するパケット プールを指します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-304">This field points to the packet pool that owns this particular packet.</span></span> <span data-ttu-id="b06e6-305">パケットが解放されると、この特定のプールに解放されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-305">When the packet is released, it is released to this particular pool.</span></span> <span data-ttu-id="b06e6-306">各パケット内のプール所有権に基づいて、データグラムが複数のパケット プールの複数のパケットにまたがる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-306">With the pool ownership inside each packet, it is possible for a datagram to span multiple packets from multiple packet pools.</span></span>|
|<span data-ttu-id="b06e6-307">\***nx_packet_next** _</span><span class="sxs-lookup"><span data-stu-id="b06e6-307">\***nx_packet_next** _</span></span>|<span data-ttu-id="b06e6-308">このフィールドは、同じフレーム内の次のパケットを指します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-308">This field points to the next packet within the same frame.</span></span> <span data-ttu-id="b06e6-309">NULL の場合、フレームに含まれる追加のパケットはありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-309">If NULL, there are no additional packets that are part of the frame.</span></span> <span data-ttu-id="b06e6-310">このフィールドは、パケット全体が再アセンブル可能になるまでの間、断片化されたパケットを保持するためにも使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-310">This field is also used to hold fragmented packets until the entire packet can be re-assembled.</span></span> <span data-ttu-id="b06e6-311">_*_NX_DISABLE_PACKET_CHAIN_*\* が定義されている場合、削除されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-311">it is removed if _\*_NX_DISABLE_PACKET_CHAIN_\*\*is defined.</span></span>|
|<span data-ttu-id="b06e6-312">\***nx_packet_last** _</span><span class="sxs-lookup"><span data-stu-id="b06e6-312">\***nx_packet_last** _</span></span>|<span data-ttu-id="b06e6-313">このフィールドは、同じネットワーク パケット内の最後のパケットを指します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-313">This field points to the last packet within the same network packet.</span></span> <span data-ttu-id="b06e6-314">NULL の場合、このパケットはネットワーク パケット全体を表します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-314">If NULL, this packet represents the entire network packet.</span></span> <span data-ttu-id="b06e6-315">_*_NX_DISABLE_PACKET_CHAIN_*\* が定義されている場合、このフィールドは削除されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-315">This field is removed if _\*_NX_DISABLE_PACKET_CHAIN_\*\*is defined.</span></span>|
|<span data-ttu-id="b06e6-316">\***nx_packet_length** _</span><span class="sxs-lookup"><span data-stu-id="b06e6-316">\***nx_packet_length** _</span></span>| <span data-ttu-id="b06e6-317">このフィールドには、ネットワーク パケット全体の合計バイト数が含まれます。これには、_nx_packet_next\* メンバーによって連結されているすべてのパケットの合計バイト数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-317">This field contains the total number of bytes in the entire network packet, including the total of all bytes in all packets chained together by the _nx_packet_next\*member.</span></span>|
|<span data-ttu-id="b06e6-318">***nx_packet_ip_interface***</span><span class="sxs-lookup"><span data-stu-id="b06e6-318">***nx_packet_ip_interface***</span></span>| <span data-ttu-id="b06e6-319">このフィールドは、インターフェイス ドライバーによって、また発信パケットのために NetX Duo によって受信されるときにパケットに割り当てられるインターフェイス制御ブロックです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-319">This field is the interface control block which is assigned to the packet when it is received by the interface driver, and by NetX Duo for outgoing packets.</span></span> <span data-ttu-id="b06e6-320">インターフェイス制御ブロックはインターフェイスを記述します。たとえば、ネットワーク アドレス、MAC アドレス、IP アドレス、およびのインターフェイスの状態 (リンクが有効、物理マッピングが必要、など) を表します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-320">An interface control block describes the interface e.g. network address, MAC address, IP address and interface status such as link enabled and physical mapping required.</span></span>|
|<span data-ttu-id="b06e6-321">\***nx_packet_data_start** _</span><span class="sxs-lookup"><span data-stu-id="b06e6-321">\***nx_packet_data_start** _</span></span>| <span data-ttu-id="b06e6-322">このフィールドは、このパケットの物理ペイロード領域の開始位置を示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-322">This field points to the start of the physical payload area of this packet.</span></span> <span data-ttu-id="b06e6-323">NX_PACKET ヘッダーの直後に配置する必要はありませんが、これが _ *_nx_packet_pool_create_*\* サービスの既定の設定です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-323">It does not have to be immediately following the NX_PACKET header, but that is the default for the _ *_nx_packet_pool_create_*\* service.</span></span>|
|<span data-ttu-id="b06e6-324">\***nx_packet_data_end** _</span><span class="sxs-lookup"><span data-stu-id="b06e6-324">\***nx_packet_data_end** _</span></span>|<span data-ttu-id="b06e6-325">このフィールドは、このパケットの物理ペイロード領域の最後を指しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-325">This field points to the end of the physical payload area of this packet.</span></span> <span data-ttu-id="b06e6-326">このフィールドと _nx_packet_data_start\* フィールドの差は、ペイロード サイズを表します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-326">The difference between this field and the _nx_packet_data_start\* field represents the payload size.</span></span>|
|<span data-ttu-id="b06e6-327">\***nx_packet_prepend_ptr** _</span><span class="sxs-lookup"><span data-stu-id="b06e6-327">\***nx_packet_prepend_ptr** _</span></span>|<span data-ttu-id="b06e6-328">このフィールドは、パケット データ (プロトコル ヘッダーまたは実際のデータ) が、パケット ペイロード領域内の既存のパケット データ (存在する場合) の前に追加される場所を指します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-328">This field points to the location of where packet data, either protocol header or actual data, is added in front of the existing packet data (if any) in the packet payload area.</span></span> <span data-ttu-id="b06e6-329">_nx_packet_data_start\* ポインターの位置以上で、*nx_packet_append_ptr* ポインター以下である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-329">It must be greater than or equal to the _nx_packet_data_start\* pointer location and less than or equal to the *nx_packet_append_ptr* pointer.</span></span>|
> [!CAUTION]
> <span data-ttu-id="b06e6-330">*NetX Duo では、パフォーマンス上の理由から、パケットが伝送のために NetX Duo サービスに渡されるときに、プリペンド ポインターがロング ワード単位で揃えたアドレスを指していることを前提としています。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-330">*For performance reasons, NetX Duo assumes that when the packet is passed into NetX Duo services for transmission, the prepend pointer points to long word aligned address.*</span></span>

| <span data-ttu-id="b06e6-331">パケット ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b06e6-331">Packet header</span></span> | <span data-ttu-id="b06e6-332">目的</span><span class="sxs-lookup"><span data-stu-id="b06e6-332">Purpose</span></span> |
|---|---|
|<span data-ttu-id="b06e6-333">\***nx_packet_append_ptr** _</span><span class="sxs-lookup"><span data-stu-id="b06e6-333">\***nx_packet_append_ptr** _</span></span>|<span data-ttu-id="b06e6-334">このフィールドは、現在パケット ペイロード領域にあるデータの末尾を指します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-334">This field points to the end of the data currently in the packet payload area.</span></span> <span data-ttu-id="b06e6-335">これは、_nx_packet_prepend_ptr\* と *nx_packet_data_end* によって示されるメモリ位置の間にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-335">It must be in between the memory location pointed to by _nx_packet_prepend_ptr\* and *nx_packet_data_end.*</span></span> <span data-ttu-id="b06e6-336">このフィールドと *nx_packet_prepend_ptr* フィールドの差は、このパケット内のデータの量を表します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-336">The difference between this field and the *nx_packet_prepend_ptr* field represents the amount of data in this packet.</span></span>|
|<span data-ttu-id="b06e6-337">\***nx_packet_packet_pad** _</span><span class="sxs-lookup"><span data-stu-id="b06e6-337">\***nx_packet_packet_pad** _</span></span>|<span data-ttu-id="b06e6-338">このフィールドでは、必要なアラインメント要件を達成するために、4 バイト ワードの埋め込みの長さを定義します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-338">This fields defines the length of padding in 4-byte words to achieve the desired alignment requirement.</span></span> <span data-ttu-id="b06e6-339">_*_NX_PACKET_HEADER_PAD_*_ が定義されていない場合、このフィールドは削除されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-339">This field is removed if _*_NX_PACKET_HEADER_PAD_*_ is not defined.</span></span> <span data-ttu-id="b06e6-340">_nx_packet_header_pad\* を定義する代わりに _*_NX_PACKET_ALIGNMENT_*_ を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-340">Alternatively _*_NX_PACKET_ALIGNMENT_*_ can be used instead of defining _nx_packet_header_pad.\*</span></span>|

### <a name="packet-header-offsets"></a><span data-ttu-id="b06e6-341">パケット ヘッダーのオフセット</span><span class="sxs-lookup"><span data-stu-id="b06e6-341">Packet Header Offsets</span></span>

<span data-ttu-id="b06e6-342">ヘッダーのサイズを格納するのに十分な領域を確保するために、パケット ヘッダーのサイズが定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-342">Packet header size is defined to allow enough room  to accommodate the size of the header.</span></span> <span data-ttu-id="b06e6-343">***nx_packet_allocate*** サービスは、パケットを割り当て、指定されたパケットの種類に従ってパケット内のプリペンド ポインターを調整するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-343">The ***nx_packet_allocate*** service is used to allocate a packet and adjusts the prepend pointer in the packet according to the type of packet specified.</span></span> <span data-ttu-id="b06e6-344">パケットの種類によって、プロトコルのデータの前にプロトコル ヘッダー (UDP、TCP、ICMP など) を挿入するために必要なオフセットが NetX Duo に示されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-344">The packet type tells NetX Duo the offset required for inserting the protocol header (such as UDP, TCP, or ICMP) in front of the protocol data.</span></span>

<span data-ttu-id="b06e6-345">パケット内の IP ヘッダーと物理層 (イーサネット) ヘッダーを考慮するために、NetX Duo で次の種類が定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-345">The following types are defined in NetX Duo to take into account the IP header and physical layer (Ethernet) header in the packet.</span></span> <span data-ttu-id="b06e6-346">後者の場合は、必要な 4 バイトのアラインメントを考慮して、16 バイトであると想定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-346">In the latter case, it is assumed to be 16 bytes taking the required 4-byte alignment into consideration.</span></span> <span data-ttu-id="b06e6-347">IPv4 ネットワークのパケットを割り当てるために、アプリケーション向けに NetX Duo で IPv4 パケットが引き続き定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-347">IPv4 packets are still defined in NetX Duo for applications to allocate packets for IPv4 networks.</span></span> <span data-ttu-id="b06e6-348">IPv6 を有効にして NetX Duo ライブラリをビルドする場合、汎用のパケットの種類 (NX_IP_PACKET など) は IPv6 バージョンにマップされることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-348">Note that if the NetX Duo library is built with IPv6 enabled, the generic packet types (such as NX_IP_PACKET) are mapped to the IPv6 version.</span></span> <span data-ttu-id="b06e6-349">IPv6 を有効にせずに NetX Duo ライブラリをビルドする場合、これらの汎用のパケットの種類は IPv4 バージョンにマップされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-349">If the NetX Duo Library is built without IPv6 enabled, these generic packet types are mapped to the IPv4 version.</span></span>

<span data-ttu-id="b06e6-350">次の表は、IPv6 を有効にして定義されたシンボルを示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-350">The following table shows symbols defined with IPv6 enabled:</span></span>

|<span data-ttu-id="b06e6-351">**パケットの種類**</span><span class="sxs-lookup"><span data-stu-id="b06e6-351">**Packet Type**</span></span> |<span data-ttu-id="b06e6-352">**Value**</span><span class="sxs-lookup"><span data-stu-id="b06e6-352">**Value**</span></span> |
|---|---|
|<span data-ttu-id="b06e6-353">NX_IPv6_PACKET (NX_IP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="b06e6-353">NX_IPv6_PACKET (NX_IP_PACKET)</span></span> | <span data-ttu-id="b06e6-354">0x38</span><span class="sxs-lookup"><span data-stu-id="b06e6-354">0x38</span></span> |
|<span data-ttu-id="b06e6-355">NX_UDPv6_PACKET (NX_UDP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="b06e6-355">NX_UDPv6_PACKET (NX_UDP_PACKET)</span></span> |<span data-ttu-id="b06e6-356">0x40</span><span class="sxs-lookup"><span data-stu-id="b06e6-356">0x40</span></span> |
|<span data-ttu-id="b06e6-357">NX_TCPv6_PACKET (NX_TCP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="b06e6-357">NX_TCPv6_PACKET (NX_TCP_PACKET)</span></span> |<span data-ttu-id="b06e6-358">0x4c</span><span class="sxs-lookup"><span data-stu-id="b06e6-358">0x4c</span></span> |
|<span data-ttu-id="b06e6-359">NX_IPv4_PACKET</span><span class="sxs-lookup"><span data-stu-id="b06e6-359">NX_IPv4_PACKET</span></span> |<span data-ttu-id="b06e6-360">0x24</span><span class="sxs-lookup"><span data-stu-id="b06e6-360">0x24</span></span> |
|<span data-ttu-id="b06e6-361">NX_IPv4_UDP_PACKET</span><span class="sxs-lookup"><span data-stu-id="b06e6-361">NX_IPv4_UDP_PACKET</span></span> |<span data-ttu-id="b06e6-362">0x2c</span><span class="sxs-lookup"><span data-stu-id="b06e6-362">0x2c</span></span> |
|<span data-ttu-id="b06e6-363">NX_IPv4_TCP_PACKET</span><span class="sxs-lookup"><span data-stu-id="b06e6-363">NX_IPv4_TCP_PACKET</span></span> |<span data-ttu-id="b06e6-364">0x38</span><span class="sxs-lookup"><span data-stu-id="b06e6-364">0x38</span></span> |

<span data-ttu-id="b06e6-365">次の表は、IPv6 を無効にして定義されたシンボルを示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-365">The following table shows symbols defined with IPv6 disabled:</span></span>

|<span data-ttu-id="b06e6-366">**パケットの種類**</span><span class="sxs-lookup"><span data-stu-id="b06e6-366">**Packet Type**</span></span> |<span data-ttu-id="b06e6-367">**Value**</span><span class="sxs-lookup"><span data-stu-id="b06e6-367">**Value**</span></span> |
|---|---|
|<span data-ttu-id="b06e6-368">NX_IPv4_PACKET (NX_IP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="b06e6-368">NX_IPv4_PACKET (NX_IP_PACKET)</span></span> |<span data-ttu-id="b06e6-369">0x24</span><span class="sxs-lookup"><span data-stu-id="b06e6-369">0x24</span></span> |
|<span data-ttu-id="b06e6-370">NX_IPv4_UDP_PACKET (NX_UDP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="b06e6-370">NX_IPv4_UDP_PACKET (NX_UDP_PACKET)</span></span> |<span data-ttu-id="b06e6-371">0x2c</span><span class="sxs-lookup"><span data-stu-id="b06e6-371">0x2c</span></span> |
|<span data-ttu-id="b06e6-372">NX_IPv4_TCP_PACKET (NX_TCP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="b06e6-372">NX_IPv4_TCP_PACKET (NX_TCP_PACKET)</span></span> |<span data-ttu-id="b06e6-373">0x38</span><span class="sxs-lookup"><span data-stu-id="b06e6-373">0x38</span></span> |

<span data-ttu-id="b06e6-374">*NX_IPSEC_ENABLE* が定義されている場合、これらの値は変わることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-374">Note that these values will change if *NX_IPSEC_ENABLE* is defined.</span></span> <span data-ttu-id="b06e6-375">IPsec を使用するアプリケーションについては、NetX Duo IPsec ユーザー ガイドで詳細を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-375">For application using IPsec, refer to NetX Duo IPsec User Guide for more information.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="b06e6-376">プールの容量</span><span class="sxs-lookup"><span data-stu-id="b06e6-376">Pool Capacity</span></span>

<span data-ttu-id="b06e6-377">パケット プール内のパケット数は、ペイロード サイズと、パケット プール作成サービスに渡されるメモリ領域内の合計バイト数と相関しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-377">The number of packets in a packet pool is a function of the payload size and the total number of bytes in the memory area supplied to the packet pool create service.</span></span> <span data-ttu-id="b06e6-378">プールの容量は、パケット サイズ (NX_PACKET ヘッダーのサイズ、ペイロード サイズ、適切なアラインメントなど) で、指定されたメモリ領域の合計バイト数を除算して計算されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-378">The capacity of the pool is calculated by dividing the packet size (including the size of the NX_PACKET header, the payload size, and proper alignment) into the total number of bytes in the supplied memory area.</span></span>

### <a name="payload-area-alignment"></a><span data-ttu-id="b06e6-379">ペイロード領域の整列</span><span class="sxs-lookup"><span data-stu-id="b06e6-379">Payload Area Alignment</span></span>

<span data-ttu-id="b06e6-380">NetX Duo のパケット プール設計では、ゼロ コピーをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-380">Packet pool design in NetX Duo supports zero-copy.</span></span> <span data-ttu-id="b06e6-381">デバイス ドライバー レベルでは、ドライバーはデータ受信のために、ペイロード領域をバッファー記述子に直接割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-381">At the device driver level, the driver is able to assign the payload area directly into buffer descriptors for data reception.</span></span> <span data-ttu-id="b06e6-382">DMA エンジンまたはキャッシュ同期メカニズムで、ペイロード領域の開始アドレスに特定のアラインメント要件があることが要求される場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-382">Sometimes the DMA engine or the cache synchronization mechanism requires the starting address of the payload area to have a certain alignment requirement.</span></span> <span data-ttu-id="b06e6-383">これは、必要なアラインメント要件 (バイト単位) を ***NX_PACKET_ALIGNMENT*** で定義することで実現できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-383">This can be achieved by defining the desired alignment requirement (in bytes) in ***NX_PACKET_ALIGNMENT***.</span></span> <span data-ttu-id="b06e6-384">パケット プールを作成するとき、ペイロード領域の開始アドレスはこの値に整列されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-384">When creating a packet pool, the starting address of the payload area will aligned to this value.</span></span> <span data-ttu-id="b06e6-385">既定では、開始アドレスは 4 バイトで整列されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-385">By default, starting address is 4-byte aligned.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="b06e6-386">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="b06e6-386">Thread Suspension</span></span>

<span data-ttu-id="b06e6-387">空のプールからのパケットを待機している間に、アプリケーション スレッドが停止する場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-387">Application threads can suspend while waiting for a packet from an empty pool.</span></span> <span data-ttu-id="b06e6-388">パケットがプールに返されると、停止されていたスレッドにこのパケットが割り当てられ、再開されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-388">When a packet is returned to the pool, the suspended thread is given this packet and resumed.</span></span>

<span data-ttu-id="b06e6-389">同じパケット プールで複数のスレッドが停止された場合、それらは停止された順序で再開されます (FIFO)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-389">If multiple threads are suspended on the same packet pool, they  resumed in the order they were suspended (FIFO).</span></span>

### <a name="pool-statistics-and-errors"></a><span data-ttu-id="b06e6-390">プールの統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b06e6-390">Pool Statistics and Errors</span></span>

<span data-ttu-id="b06e6-391">有効にすると、NetX Duo パケット管理ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-391">If enabled, the NetX Duo packet management software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b06e6-392">次の統計情報とエラー レポートがパケット プール向けに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-392">The following statistics and error reports are maintained for packet pools:</span></span>

- <span data-ttu-id="b06e6-393">プール内の合計パケット数</span><span class="sxs-lookup"><span data-stu-id="b06e6-393">Total Packets in Pool</span></span>
- <span data-ttu-id="b06e6-394">プール内の空きパケット数</span><span class="sxs-lookup"><span data-stu-id="b06e6-394">Free Packets in Pool</span></span>
- <span data-ttu-id="b06e6-395">パケット割り当ての合計</span><span class="sxs-lookup"><span data-stu-id="b06e6-395">Total Packet Allocations</span></span>
- <span data-ttu-id="b06e6-396">プールの空の割り当て要求</span><span class="sxs-lookup"><span data-stu-id="b06e6-396">Pool Empty Allocation Requests</span></span>
- <span data-ttu-id="b06e6-397">プールの空の割り当て保留</span><span class="sxs-lookup"><span data-stu-id="b06e6-397">Pool Empty Allocation Suspensions</span></span>
- <span data-ttu-id="b06e6-398">無効なパケットの解放</span><span class="sxs-lookup"><span data-stu-id="b06e6-398">Invalid Packet Releases</span></span>

<span data-ttu-id="b06e6-399">これらの統計情報およびエラー レポートはすべて、プール内の合計パケット数と空きパケット数を除いて、\***NX_DISABLE_PACKET_INFO** _ が定義されていない限り、NetX Duo ライブラリに組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-399">All of these statistics and error reports, except for total and free packet count in pool, are built into NetX Duo library unless \***NX_DISABLE_PACKET_INFO** _ is defined.</span></span> <span data-ttu-id="b06e6-400">このデータは、アプリケーションで _ *_nx_packet_pool_info_get_*\* サービスと共に使用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-400">This data is available to the application with the _ *_nx_packet_pool_info_get_*\* service.</span></span>

### <a name="packet-pool-control-block-nx_packet_pool"></a><span data-ttu-id="b06e6-401">パケット プール制御ブロック NX_PACKET_POOL</span><span class="sxs-lookup"><span data-stu-id="b06e6-401">Packet Pool Control Block NX_PACKET_POOL</span></span>

<span data-ttu-id="b06e6-402">各パケット メモリ プールの特性は、その制御ブロックに含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-402">The characteristics of each packet memory pool are found in its control block.</span></span> <span data-ttu-id="b06e6-403">ここには、空きパケットのリンク リスト、空きパケットの数、このプール内のパケットのペイロード サイズなどの有用な情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-403">It contains useful information such as the linked list of free packets, the number of free packets, and the payload size for packets in this pool.</span></span> <span data-ttu-id="b06e6-404">この構造体は ***nx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-404">This structure is defined in the ***nx_api.h*** file.</span></span>

<span data-ttu-id="b06e6-405">パケット プール制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-405">Packet pool control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

## <a name="ipv4-protocol"></a><span data-ttu-id="b06e6-406">IPv4 プロトコル</span><span class="sxs-lookup"><span data-stu-id="b06e6-406">IPv4 Protocol</span></span>

<span data-ttu-id="b06e6-407">NetX Duo のインターネット プロトコル (IP) コンポーネントは、インターネット上で IPv4 パケットを送受信する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="b06e6-407">The Internet Protocol (IP) component of NetX Duo is responsible for sending and receiving IPv4 packets on the Internet.</span></span> <span data-ttu-id="b06e6-408">このコンポーネントは、NetX Duo では、基盤となるネットワーク ドライバーを使用して、TCP、UDP、ICMP、および IGMP メッセージの送信および受信を最終的に担います。</span><span class="sxs-lookup"><span data-stu-id="b06e6-408">In NetX Duo, it is the component ultimately responsible for sending and receiving TCP, UDP, ICMP, and IGMP messages, utilizing the underlying network driver.</span></span>

<span data-ttu-id="b06e6-409">NetX Duo では、IPv4 プロトコル (RFC 791) と IPv6 プロトコル (RFC 2460) の両方をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-409">NetX Duo supports both IPv4 protocol (RFC 791) and IPv6 protocol (RFC 2460).</span></span> <span data-ttu-id="b06e6-410">このセクションでは、IPv4 について説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-410">This section discusses IPv4.</span></span> <span data-ttu-id="b06e6-411">IPv6 については次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-411">IPv6 is discussed in the next section.</span></span>

### <a name="ipv4-addresses"></a><span data-ttu-id="b06e6-412">IPv4 アドレス</span><span class="sxs-lookup"><span data-stu-id="b06e6-412">IPv4 Addresses</span></span>

<span data-ttu-id="b06e6-413">インターネット上の各ホストには、IP アドレスと呼ばれる 32 ビットの一意の識別子があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-413">Each host on the Internet has a unique 32-bit identifier called an IP address.</span></span> <span data-ttu-id="b06e6-414">図 4 に示すように、IPv4 アドレスには 5 つのクラスがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-414">There are five classes of IPv4 addresses as described in Figure 4.</span></span> <span data-ttu-id="b06e6-415">5 つの IPv4 アドレス クラスの範囲は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-415">The ranges of the five IPv4 address classes are as follows:</span></span>

|<span data-ttu-id="b06e6-416">クラス</span><span class="sxs-lookup"><span data-stu-id="b06e6-416">Class</span></span>|<span data-ttu-id="b06e6-417">Range</span><span class="sxs-lookup"><span data-stu-id="b06e6-417">Range</span></span>|
|---|---|
|<span data-ttu-id="b06e6-418">A</span><span class="sxs-lookup"><span data-stu-id="b06e6-418">A</span></span> |<span data-ttu-id="b06e6-419">0.0.0.0 ～ 127.255.255.255</span><span class="sxs-lookup"><span data-stu-id="b06e6-419">0.0.0.0 to 127.255.255.255</span></span>|
|<span data-ttu-id="b06e6-420">B</span><span class="sxs-lookup"><span data-stu-id="b06e6-420">B</span></span> |<span data-ttu-id="b06e6-421">128.0.0.0 ～ 191.255.255.255</span><span class="sxs-lookup"><span data-stu-id="b06e6-421">128.0.0.0 to 191.255.255.255</span></span>|
|<span data-ttu-id="b06e6-422">C</span><span class="sxs-lookup"><span data-stu-id="b06e6-422">C</span></span> |<span data-ttu-id="b06e6-423">192.0.0.0 ～ 223.255.255.255</span><span class="sxs-lookup"><span data-stu-id="b06e6-423">192.0.0.0 to 223.255.255.255</span></span>|
|<span data-ttu-id="b06e6-424">D</span><span class="sxs-lookup"><span data-stu-id="b06e6-424">D</span></span> |<span data-ttu-id="b06e6-425">224.0.0.0 ～ 239.255.255.255</span><span class="sxs-lookup"><span data-stu-id="b06e6-425">224.0.0.0 to 239.255.255.255</span></span>|
|<span data-ttu-id="b06e6-426">E</span><span class="sxs-lookup"><span data-stu-id="b06e6-426">E</span></span> |<span data-ttu-id="b06e6-427">240.0.0.0 ～ 247.255.255.255</span><span class="sxs-lookup"><span data-stu-id="b06e6-427">240.0.0.0 to 247.255.255.255</span></span>|

![IPv4 アドレス構造の図。](./media/user-guide/ipv4-address-structure.png)

### <a name="figure-4-ipv4-address-structure"></a><span data-ttu-id="b06e6-429">図 4.</span><span class="sxs-lookup"><span data-stu-id="b06e6-429">FIGURE 4.</span></span> <span data-ttu-id="b06e6-430">IPv4 アドレス構造</span><span class="sxs-lookup"><span data-stu-id="b06e6-430">IPv4 Address Structure</span></span>

<span data-ttu-id="b06e6-431">アドレス指定には、"*ユニキャスト*"、"*ブロードキャスト*"、"*マルチキャスト*" の 3 つの種類があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-431">There are also three types of address specifications: *unicast*, *broadcast*, and *multicast*.</span></span> <span data-ttu-id="b06e6-432">ユニキャスト アドレスは、インターネット上の特定のホストを識別する IPv4 アドレスです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-432">Unicast addresses are those IPv4 addresses that identify a specific host on the Internet.</span></span> <span data-ttu-id="b06e6-433">ユニキャスト アドレスには、送信元または宛先の IPv4 アドレスを指定できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-433">Unicast addresses can be either a source or a destination IPv4 address.</span></span> <span data-ttu-id="b06e6-434">ブロードキャスト アドレスは、特定のネットワークまたはサブネットワーク上のすべてのホストを識別し、宛先アドレスとしてのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-434">A broadcast address identifies all hosts on a specific network or sub-network and can only be used as destination addresses.</span></span> <span data-ttu-id="b06e6-435">ブロードキャスト アドレスは、アドレスのホスト ID 部分を 1 に設定することによって指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-435">Broadcast addresses are specified by having the host ID portion of the address set to ones.</span></span> <span data-ttu-id="b06e6-436">マルチキャスト アドレス (クラス D) は、インターネット上のホストの動的なグループを指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-436">Multicast addresses (Class D) specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="b06e6-437">マルチキャスト グループのメンバーは、いつでも参加し離脱することができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-437">Members of the multicast group may join and leave whenever they wish.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b06e6-438">*UDP over IPv4 のようなコネクションレス プロトコルでのみ、ブロードキャストと、マルチキャスト グループの制限付きブロードキャスト機能を利用できます。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-438">*Only connectionless protocols like UDP over IPv4 can utilize broadcast and the limited broadcast capability of the multicast group.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b06e6-439">\*マクロ *IP_ADDRESS* は \***nx_api.h** _ で定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-439">\*The macro *IP_ADDRESS* is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="b06e6-440">これにより、ピリオドではなくコンマを使用して IPv4 アドレスを簡単に指定できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-440">It allows easy specification of IPv4 addresses using commas instead of a periods.</span></span> <span data-ttu-id="b06e6-441">たとえば、図 4 に示すように、_IP_ADDRESS(128,0,0,0)\* では最初のクラス B アドレスが指定されます。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-441">For example, _IP_ADDRESS(128,0,0,0)\* specifies the first class B address shown in Figure 4.\*</span></span>

### <a name="ipv4-gateway-address"></a><span data-ttu-id="b06e6-442">IPv4 ゲートウェイ アドレス</span><span class="sxs-lookup"><span data-stu-id="b06e6-442">IPv4 Gateway Address</span></span>

<span data-ttu-id="b06e6-443">ネットワーク ゲートウェイは、ネットワーク上のホストが、ローカル ドメインの外部の宛先に送信するパケットをリレーするのを支援します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-443">Network gateways assist hosts on their networks to relay packets destined to destinations outside the local domain.</span></span> <span data-ttu-id="b06e6-444">宛先が近隣ノードのいずれかなのか、または、事前にプログラミングされた静的ルーティング テーブルを使用するのか、といった、宛先となるネクスト ホップに関するいくつかの情報が各ノードにあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-444">Each node has some knowledge of which next hop to send to, either the destination one of its neighbors, or through a pre-programmed static routing table.</span></span> <span data-ttu-id="b06e6-445">ただし、これらのアプローチが失敗した場合、ノードはパケットを既定のゲートウェイに転送する必要があります。ここには、パケットを宛先にルーティングする方法について、より適切な情報があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-445">However if these approaches fail, the node should forward the packet to its default gateway which has better knowledge on how to route the packet to its destination.</span></span> <span data-ttu-id="b06e6-446">既定のゲートウェイは、IP インスタンスに接続されている物理インターフェイスの 1 つを介して直接アクセスできる必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-446">Note that the default gateway must be directly accessible through one of the physical interfaces attached to the IP instance.</span></span> <span data-ttu-id="b06e6-447">アプリケーションは \***nx_ip_gateway_address_set** _ を呼び出して、IPv4 の既定のゲートウェイ アドレスを構成します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-447">The application calls \***nx_ip_gateway_address_set** _ to configure IPv4 default gateway address.</span></span> <span data-ttu-id="b06e6-448">現在の IPv4 ゲートウェイ設定を取得するには、サービス _*_nx_ip_gateway_address_get_*_ を使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-448">Use the service _*_nx_ip_gateway_address_get_*_ to retrieve the current IPv4 gateway settings.</span></span> <span data-ttu-id="b06e6-449">アプリケーションでは、サービス _ *_nx_ip_gateway_address_clear_*\* を使用してゲートウェイ設定をクリアします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-449">Application shall use the service _ *_nx_ip_gateway_address_clear_*\* to clear the gateway setting.</span></span>

### <a name="ipv4-header"></a><span data-ttu-id="b06e6-450">IPv4 ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b06e6-450">IPv4 Header</span></span>

<span data-ttu-id="b06e6-451">インターネット上で送信されるすべての IPv4 パケットについて、IPv4 ヘッダーが必要です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-451">For any IPv4 packet to be sent on the Internet, it must have an IPv4 header.</span></span> <span data-ttu-id="b06e6-452">上位レベルのプロトコル (UDP、TCP、ICMP、または IGMP) がパケットを送信するために IPv4 コンポーネントを呼び出すと、IP 送信モジュールによってデータの前に IPv4 ヘッダーが配置されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-452">When higher-level protocols (UDP, TCP, ICMP, or IGMP) call the IP component to send a packet, the IPv4 transmit module places an IPv4 header in front of the data.</span></span> <span data-ttu-id="b06e6-453">逆に、IP パケットをネットワークから受信した場合、IP コンポーネントでは、上位レベルのプロトコルにパケットを配信する前に IPv4 ヘッダーを削除します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-453">Conversely, when IP packets are received from the network, the IP component removes the IPv4 header from the packet before delivery to the higher-level protocols.</span></span> <span data-ttu-id="b06e6-454">図 5 は、IP ヘッダーの形式を示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-454">Figure 5 shows the format of the IP header.</span></span>

![IPv4 ヘッダーの形式](./media/user-guide/ipv4-header-format.png)

### <a name="figure-5-ipv4-header-format"></a><span data-ttu-id="b06e6-456">図 5.</span><span class="sxs-lookup"><span data-stu-id="b06e6-456">FIGURE 5.</span></span> <span data-ttu-id="b06e6-457">IPv4 ヘッダーの形式</span><span class="sxs-lookup"><span data-stu-id="b06e6-457">IPv4 Header Format</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b06e6-458">*TCP/IP 実装のすべてのヘッダーは、\*\*ビッグ エンディアン*\* 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに配置されます。たとえば、IP ヘッダーの 4 ビットのバージョンと 4 ビットのヘッダー長は、ヘッダーの最初のバイトに配置する必要があります。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-458">*All headers in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address. For example, the 4-bit version and the 4-bit header length of the IP header must be located on the first byte of the header.*</span></span>

<span data-ttu-id="b06e6-459">IPv4 ヘッダーのフィールドは次のように定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-459">The fields of the IPv4 header are defined as follows:</span></span>

|<span data-ttu-id="b06e6-460">IPv4 &nbsp;ヘッダー&nbsp; のフィールド</span><span class="sxs-lookup"><span data-stu-id="b06e6-460">IPv4&nbsp;Header&nbsp;Field</span></span> |<span data-ttu-id="b06e6-461">目的</span><span class="sxs-lookup"><span data-stu-id="b06e6-461">Purpose</span></span> |
|---|---|
|<span data-ttu-id="b06e6-462">***4 ビットのバージョン***</span><span class="sxs-lookup"><span data-stu-id="b06e6-462">***4-bit version***</span></span> |<span data-ttu-id="b06e6-463">このフィールドには、このヘッダーが表す IP のバージョンが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-463">This field contains the version of IP this header represents.</span></span> <span data-ttu-id="b06e6-464">NetX Duo でサポートされている IP バージョン 4 では、このフィールドの値は 4 です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-464">For IP version 4, which is what NetX Duo supports, the value of this field is 4.</span></span> |
|<span data-ttu-id="b06e6-465">***4 ビットのヘッダー長***</span><span class="sxs-lookup"><span data-stu-id="b06e6-465">***4-bit header length***</span></span> |<span data-ttu-id="b06e6-466">このフィールドは、IP ヘッダー内の 32 ビット ワードの数を指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-466">This field specifies the number of 32-bit words in the IP header.</span></span> <span data-ttu-id="b06e6-467">オプションのワードが存在しない場合、このフィールドの値は 5 になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-467">If no option words are present, the value for this field is 5.</span></span> |
|<span data-ttu-id="b06e6-468">***8 ビットのサービスの種類 (TOS)***</span><span class="sxs-lookup"><span data-stu-id="b06e6-468">***8-bit type of service (TOS)***</span></span> |<span data-ttu-id="b06e6-469">このフィールドは、この IP パケットに要求されるサービスの種類を指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-469">This field specifies the type of service requested for this IP packet.</span></span> <span data-ttu-id="b06e6-470">有効な要求を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-470">Valid requests are as follows:</span></span><br /><span data-ttu-id="b06e6-471">- 通常: 0x00</span><span class="sxs-lookup"><span data-stu-id="b06e6-471">- Normal: 0x00</span></span> <br /><span data-ttu-id="b06e6-472">- 最小遅延: 0x00</span><span class="sxs-lookup"><span data-stu-id="b06e6-472">- Minimum Delay: 0x00</span></span><br /><span data-ttu-id="b06e6-473">- 最大データ: 0x08</span><span class="sxs-lookup"><span data-stu-id="b06e6-473">- Maximum Data: 0x08</span></span><br /><span data-ttu-id="b06e6-474">- 最大信頼性: 0x04</span><span class="sxs-lookup"><span data-stu-id="b06e6-474">- Maximum Reliability: 0x04</span></span><br /><span data-ttu-id="b06e6-475">- 最小コスト: 0x02</span><span class="sxs-lookup"><span data-stu-id="b06e6-475">- Minimum Cost: 0x02</span></span> |
|<span data-ttu-id="b06e6-476">***16 ビットの合計長***</span><span class="sxs-lookup"><span data-stu-id="b06e6-476">***16-bit total length***</span></span> |<span data-ttu-id="b06e6-477">このフィールドには、IP ヘッダーを含む IP データグラムの合計長がバイト単位で表示されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-477">This field contains the total length of the IP datagram in bytes, including the IP header.</span></span> <span data-ttu-id="b06e6-478">IP データグラムは、TCP/IP インターネットで検出された情報の基本単位です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-478">An IP datagram is the basic unit of information found on a TCP/IP Internet.</span></span> <span data-ttu-id="b06e6-479">これには、データに加えて、宛先と送信元のアドレスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-479">It contains a destination and source address in addition to data.</span></span> <span data-ttu-id="b06e6-480">これは 16 ビットのフィールドであるため、IP データグラムの最大サイズは 65,535 バイトです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-480">Because it is a 16-bit field, the maximum size of an IP datagram is 65,535 bytes.</span></span>|
|<span data-ttu-id="b06e6-481">***16 ビットの ID***</span><span class="sxs-lookup"><span data-stu-id="b06e6-481">***16-bit identification***</span></span> |<span data-ttu-id="b06e6-482">このフィールドは、ホストから送信された各 IP データグラムを一意に識別するために使用される番号です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-482">The field is a number used to uniquely identify each IP datagram sent from a host.</span></span> <span data-ttu-id="b06e6-483">通常、この番号は IP データグラムの送信後にインクリメントされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-483">This number is typically incremented after an IP datagram is sent.</span></span> <span data-ttu-id="b06e6-484">これは、受信した IP パケット フラグメントをアセンブルする場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-484">It is especially useful in assembling received IP packet fragments.</span></span>|
|<span data-ttu-id="b06e6-485">***3 ビットのフラグ***</span><span class="sxs-lookup"><span data-stu-id="b06e6-485">***3-bit flags***</span></span> |<span data-ttu-id="b06e6-486">このフィールドには IP の断片化に関する情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-486">This field contains IP fragmentation information.</span></span> <span data-ttu-id="b06e6-487">ビット 14 は "フラグメント禁止" ビットです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-487">Bit 14 is the "don't fragment" bit.</span></span> <span data-ttu-id="b06e6-488">このビットが設定されている場合、発信 IP データグラムは断片化されません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-488">If this bit is set, the outgoing IP datagram will not be fragmented.</span></span> <span data-ttu-id="b06e6-489">ビット 13 は "フラグメント継続" ビットです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-489">Bit 13 is the "more fragments" bit.</span></span> <span data-ttu-id="b06e6-490">このビットが設定されている場合は、断片化が継続されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-490">If this bit is set, there are more fragments.</span></span> <span data-ttu-id="b06e6-491">このビットがクリアされている場合、これは IP パケットの最後のフラグメントです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-491">If this bit is clear, this is the last fragment of the IP packet.</span></span>|
|<span data-ttu-id="b06e6-492">***13 ビットのフラグメント オフセット***</span><span class="sxs-lookup"><span data-stu-id="b06e6-492">***13-bit fragment offset***</span></span> |<span data-ttu-id="b06e6-493">このフィールドには、フラグメント オフセットの上位 13 ビットが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-493">This field contains the upper 13-bits of the fragment offset.</span></span> <span data-ttu-id="b06e6-494">このため、フラグメント オフセットは 8 バイト境界でのみ許可されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-494">Because of this, fragment offsets are only allowed on 8-byte boundaries.</span></span> <span data-ttu-id="b06e6-495">断片化された IP データグラムの最初のフラグメントには、"フラグメント継続" ビットが設定され、オフセットは 0 になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-495">The first fragment of a fragmented IP datagram will have the "more fragments" bit set and have an offset of 0.</span></span>|
|<span data-ttu-id="b06e6-496">***8 ビットの Time to Live (TTL)***</span><span class="sxs-lookup"><span data-stu-id="b06e6-496">***8-bit time to live (TTL)***</span></span> |<span data-ttu-id="b06e6-497">このフィールドには、このデータグラムが通過できるルーターの数が含まれます。これによって基本的に、データグラムの有効期間が制限されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-497">This field contains the number of routers this datagram can pass, which basically limits the lifetime of the datagram.</span></span>|
|<span data-ttu-id="b06e6-498">***8 ビットのプロトコル***</span><span class="sxs-lookup"><span data-stu-id="b06e6-498">***8-bit protocol***</span></span>|<span data-ttu-id="b06e6-499">このフィールドでは、IP データグラムを使用しているプロトコルを指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-499">This field specifies which protocol is using the IP datagram.</span></span> <span data-ttu-id="b06e6-500">有効なプロトコルとその値の一覧を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-500">The following is a list of valid protocols and their values:</span></span><br /><span data-ttu-id="b06e6-501">- ICMP: 0x01</span><span class="sxs-lookup"><span data-stu-id="b06e6-501">- ICMP: 0x01</span></span> <br /><span data-ttu-id="b06e6-502">- IGMP: 0x02</span><span class="sxs-lookup"><span data-stu-id="b06e6-502">- IGMP: 0x02</span></span><br /><span data-ttu-id="b06e6-503">- TCP: 0X06</span><span class="sxs-lookup"><span data-stu-id="b06e6-503">- TCP: 0X06</span></span><br /><span data-ttu-id="b06e6-504">- UDP: 0X11</span><span class="sxs-lookup"><span data-stu-id="b06e6-504">- UDP: 0X11</span></span> |
|<span data-ttu-id="b06e6-505">***16 ビットのチェックサム***</span><span class="sxs-lookup"><span data-stu-id="b06e6-505">***16-bit checksum***</span></span> |<span data-ttu-id="b06e6-506">このフィールドには、IP ヘッダーのみを対象とする 16 ビットのチェックサムが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-506">This field contains the 16-bit checksum that covers the IP header only.</span></span> <span data-ttu-id="b06e6-507">上位レベルのプロトコルには、IP ペイロードに対応する追加のチェックサムがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-507">There are additional checksums in the higher level protocols that cover the IP payload.</span></span> |
|<span data-ttu-id="b06e6-508">***32 ビットの送信元 IP アドレス***</span><span class="sxs-lookup"><span data-stu-id="b06e6-508">***32-bit source IP address***</span></span> |<span data-ttu-id="b06e6-509">このフィールドには送信者の IP アドレスが含まれ、常にホスト アドレスです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-509">This field contains the IP address of the sender and is always a host address.</span></span> |
|<span data-ttu-id="b06e6-510">***32 ビットの宛先 IP アドレス***</span><span class="sxs-lookup"><span data-stu-id="b06e6-510">***32-bit destination IP address***</span></span> |<span data-ttu-id="b06e6-511">このフィールドには、アドレスがブロードキャストまたはマルチキャスト アドレスの場合、単一または複数の受信側の IP アドレスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-511">This field contains the IP address of the receiver or receivers if the address is a broadcast or multicast address.</span></span> |

### <a name="creating-ip-instances"></a><span data-ttu-id="b06e6-512">IP インスタンスの作成</span><span class="sxs-lookup"><span data-stu-id="b06e6-512">Creating IP Instances</span></span>

<span data-ttu-id="b06e6-513">IP インスタンスは、アプリケーション スレッドによる初期化中またはランタイムに作成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-513">IP instances are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="b06e6-514">アプリケーションで IPv6 ネットワークのみを使用する意図の場合でも、***nx_ip_create*** サービスによって、内部 IP スレッドの初期 IPv4 アドレス、ネットワーク マスク、既定のパケット プール、メディア ドライバー、メモリと優先順位が定義されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-514">The initial IPv4 address, network mask, default packet pool, media driver, and memory and priority of the internal IP thread are defined by the ***nx_ip_create*** service even if the application intends to use IPv6 networks only.</span></span> <span data-ttu-id="b06e6-515">IPv4 アドレスが無効なアドレス (0.0.0.0) に設定されている IP インスタンスをアプリケーションで初期化する場合は、後で RARP や、DHCP または同様のプロトコルを使用して、インターフェイス アドレスが手動構成によって解決されることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-515">If the application initializes the IP instance with its IPv4 address set to an invalid address(0.0.0.0), it is assumed that the interface address is going to resolved by manual configuration later, via RARP, or through DHCP or similar protocols.</span></span>

<span data-ttu-id="b06e6-516">複数のネットワーク インターフェイスがあるシステムでは、\***nx_ip_create** _ を呼び出すときにプライマリ インターフェイスが指定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-516">For systems with multiple network interfaces, the primary interface is designated when calling \***nx_ip_create** _.</span></span> <span data-ttu-id="b06e6-517">_*_nx_ip_interface_attach_*\* を呼び出すことによって、追加の各インターフェイスを同じ IP インスタンスにアタッチできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-517">Each additional interface can be attached to the same IP instance by calling _\*_nx_ip_interface_attach_\*\*.</span></span> <span data-ttu-id="b06e6-518">このサービスでは、ネットワーク インターフェイスに関する情報 (IP アドレス、ネットワーク マスクなど) をインターフェイス制御ブロックに格納し、ドライバー インスタンスを IP インスタンスのインターフェイス制御ブロックに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-518">This service stores information about the network interface (such as IP address, network mask) in the interface control block, and associates the driver instance with the interface control block in the IP instance.</span></span> <span data-ttu-id="b06e6-519">ドライバーでは、データ パケットが受信されたら、IP 受信ロジックに転送する前に、インターフェイス情報を NX_PACKET 構造体に格納する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-519">As the driver receives a data packet, it needs to store the interface information in the NX_PACKET structure before forwarding it to the IP receive logic.</span></span> <span data-ttu-id="b06e6-520">IP インスタンスは、インターフェイスをアタッチする前に既に作成されている必要があることに注意します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-520">Note an IP instance must already be created before attaching any interfaces.</span></span>

<span data-ttu-id="b06e6-521">\***nx_ip_create** _ を呼び出した後、IPv6 サービスは開始されません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-521">IPv6 services are not started after calling \***nx_ip_create** _.</span></span> <span data-ttu-id="b06e6-522">IPv6 サービスを使用するアプリケーションでは、サービス _ *_nx_ipv6_enable_*\* を呼び出して IPv6 を開始する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-522">Applications wishing to use IPv6 services must call the service _ *_nx_ipv6_enable_*\* to start IPv6.</span></span>

<span data-ttu-id="b06e6-523">IPv6 ネットワークでは、IP インスタンスの各インターフェイスが複数の IPv6 グローバル アドレスを持つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-523">On the IPv6 network, each interface in an IP instance may have multiple IPv6 global addresses.</span></span> <span data-ttu-id="b06e6-524">IPv6 アドレス割り当てに DHCPv6 を使用することに加えて、デバイスではステートレス アドレス自動構成も使用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-524">In addition to using DHCPv6 for IPv6 address assignment, a device may also use Stateless Address Autoconfiguration.</span></span> <span data-ttu-id="b06e6-525">詳細については、この章の後半の「IP 制御ブロック」および「IPv6 アドレス解決」のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-525">More information is available in the "IP Control Block" and "IPv6 Address Resolution" sections later in this chapter.</span></span>

### <a name="ip-send"></a><span data-ttu-id="b06e6-526">IP 送信</span><span class="sxs-lookup"><span data-stu-id="b06e6-526">IP Send</span></span>

<span data-ttu-id="b06e6-527">NetX Duo の IP 送信処理は非常に合理化されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-527">The IP send processing in NetX Duo is very streamlined.</span></span> <span data-ttu-id="b06e6-528">パケット内のプリペンド ポインターは、IP ヘッダーを格納するために後方に移動されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-528">The prepend pointer in the packet is moved backwards to accommodate the IP header.</span></span> <span data-ttu-id="b06e6-529">IP ヘッダーが完了し (呼び出し元のプロトコル レイヤーで指定されたすべてのオプションが使用されます)、IP チェックサムがインラインで計算され (IPv4 パケットの場合のみ)、関連付けられているネットワーク ドライバーにパケットがディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-529">The IP header is completed (with all the options specified by the calling protocol layer), the IP checksum is computed in-line (for IPv4 packets only), and the packet is dispatched to the associated network driver.</span></span> <span data-ttu-id="b06e6-530">また、発信の断片化は、IP 送信処理内からも調整されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-530">In addition, outgoing fragmentation is also coordinated from within the IP send processing.</span></span>

<span data-ttu-id="b06e6-531">IPv4 で宛先 IP アドレスに物理マッピングが必要な場合、NetX Duo で ARP 要求が開始されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-531">For IPv4, NetX Duo initiates ARP requests if physical mapping is needed for the destination IP address.</span></span> <span data-ttu-id="b06e6-532">IPv6 は、IPv6 アドレスから物理アドレスへのマッピングに近隣探索を使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-532">IPv6 uses Neighbor Discovery for IPv6-address-tophysical-address mapping.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-533">*IPv4 接続では、キューに格納されているパケットの数が ARP キューの深さ (シンボル **NX_ARP_MAX_QUEUE_DEPTH** によって定義されている) を超えない限り、IP アドレス解決 (つまり、物理マッピング) を必要とするパケットは ARP キューにエンキューされます。キューの深さに達した場合、NetX Duo ではキューの最も古いパケットが削除され、エンキューされた残りのアドレスの解決を待機し続けます。一方、ARP エントリが解決されない場合、ARP エントリの保留中のパケットは、ARP エントリのタイムアウト時に解放されます。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-533">*For IPv4 connectivity, packets that require IP address resolution (i.e., physical mapping) are enqueued on the ARP queue until the number of packets queued exceeds the ARP queue depth (defined by the symbol **NX_ARP_MAX_QUEUE_DEPTH**). If the queue depth is reached, NetX Duo will remove the oldest packet on the queue and continue waiting for address resolution for the remaining packets enqueued. On the other hand, if an ARP entry is not resolved, the pending packets on the ARP entry are released upon ARP entry timeout.*</span></span>

<span data-ttu-id="b06e6-534">複数のネットワーク インターフェイスがあるシステムでは、NetX Duo は宛先 IP アドレスに基づいてインターフェイスを選択します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-534">For systems with multiple network interfaces, NetX Duo chooses an interface based on the destination IP address.</span></span> <span data-ttu-id="b06e6-535">選択プロセスには、次の手順が適用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-535">The following procedure applies to the selection process:</span></span>

1. <span data-ttu-id="b06e6-536">送信者によって発信インターフェイスが指定され、そのインターフェイスが有効である場合は、そのインターフェイスを使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-536">If the sender specifies an outgoing interface and the interface is valid, use that interface.</span></span>
2. <span data-ttu-id="b06e6-537">宛先アドレスが IPv4 ブロードキャストまたはマルチキャストの場合、最初の有効化された物理インターフェイスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-537">If a destination address is IPv4 broadcast or multicast, the first enabled physical interface is used.</span></span>
3. <span data-ttu-id="b06e6-538">宛先アドレスが静的ルーティング テーブルで見つかった場合は、そのゲートウェイに関連付けられているインターフェイスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-538">If the destination address is found in the static routing table, the interface associated with the gateway is used.</span></span>
4. <span data-ttu-id="b06e6-539">宛先がオンリンクの場合は、オンリンク インターフェイスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-539">If the destination is on-link, the on-link interface is used.</span></span>
5. <span data-ttu-id="b06e6-540">宛先アドレスがリンクローカル アドレス (169.254.0.0/16) である場合、最初の有効なインターフェイスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-540">If the destination address is a link-local address (169.254.0.0/16), the first valid interface is used.</span></span>
6. <span data-ttu-id="b06e6-541">既定のゲートウェイが構成されている場合は、既定のゲートウェイに関連付けられているインターフェイスを使用してパケットを転送します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-541">If the default gateway is configured, use the interface associated with the default gateway to transmit the packet.</span></span>
7. <span data-ttu-id="b06e6-542">最後に、有効なインターフェイス IP アドレスの 1 つがリンクローカル アドレス (169.254.0.0/16) である場合、このインターフェイスが送信元アドレスとして送信に使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-542">Finally, if one of the valid interface IP address is link-local address (169.254.0.0/16), this interface is used as source address for the transmission.</span></span>
8. <span data-ttu-id="b06e6-543">上記のすべてが失敗した場合、出力パケットはドロップされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-543">The output packet is dropped if all above fails.</span></span>

### <a name="ip-receive"></a><span data-ttu-id="b06e6-544">IP 受信</span><span class="sxs-lookup"><span data-stu-id="b06e6-544">IP Receive</span></span>

<span data-ttu-id="b06e6-545">IP 受信処理は、ネットワーク ドライバーまたは内部 IP スレッドから呼び出されます (遅延受信パケット キューのパケットを処理するため)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-545">The IP receive processing is either called from the network driver or the internal IP thread (for processing packets on the deferred received packet queue).</span></span> <span data-ttu-id="b06e6-546">IP 受信処理では、プロトコル フィールドを調べて、適切なプロトコル コンポーネントにパケットをディスパッチしようとします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-546">The IP receive processing examines the protocol field and attempts to dispatch the packet to the proper protocol component.</span></span> <span data-ttu-id="b06e6-547">パケットが実際にディスパッチされる前に、IP ヘッダーの前にプリペンド ポインターを移動することで、IP ヘッダーが削除されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-547">Before the packet is actually dispatched, the IP header is removed by advancing the prepend pointer past the IP header.</span></span>

<span data-ttu-id="b06e6-548">IP 受信処理では、断片化された IP パケットも検出されて、断片化が有効になっている場合に再アセンブルするために必要な手順が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-548">IP receive processing also detects fragmented IP packets and performs the necessary steps to reassemble them if fragmentation is enabled.</span></span> <span data-ttu-id="b06e6-549">断片化が必要でも有効になっていない場合、パケットはドロップされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-549">If fragmentation is needed but not enabled, the packet is dropped.</span></span>

<span data-ttu-id="b06e6-550">NetX Duo では、パケットに指定されたインターフェイスに基づいて、適切なネットワーク インターフェイスが決定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-550">NetX Duo determines the appropriate network interface based on the interface specified in the packet.</span></span> <span data-ttu-id="b06e6-551">パケット インターフェイスが NULL の場合、NetX Duo では既定でプライマリ インターフェイスに設定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-551">If the packet interface is NULL, NetX Duo defaults to the primary interface.</span></span> <span data-ttu-id="b06e6-552">これは、NetX Duo のレガシ イーサネット ドライバーとの互換性を保証するために行われます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-552">This is done to guarantee compatibility with legacy NetX Duo Ethernet drivers.</span></span>

### <a name="raw-ip-send"></a><span data-ttu-id="b06e6-553">生 IP 送信</span><span class="sxs-lookup"><span data-stu-id="b06e6-553">Raw IP Send</span></span>

<span data-ttu-id="b06e6-554">生 IP パケットは、NetX Duo によって直接はサポート (および処理) されない上位層プロトコル ペイロードを含む IP フレームです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-554">A raw IP packet is an IP frame that contains upper layer protocol payload not directly supported (and processed) by NetX Duo.</span></span> <span data-ttu-id="b06e6-555">生のパケットを使用すると、開発者は独自の IP ベースのアプリケーションを定義できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-555">A raw packet allows developers to define their own IP-based applications.</span></span> <span data-ttu-id="b06e6-556">生 IP パケット処理が _*_nx_ip_raw_packet_enabled_*_ サービスで有効になっている場合、アプリケーションでは \***nxd_ip_raw_packet_send** _ サービスを使用して生 IP パケットを直接送信できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-556">An application may send raw IP packets directly using the ***nxd_ip_raw_packet_send** _ service if raw IP packet processing has been enabled with the _*_nx_ip_raw_packet_enabled_\*_ service.</span></span> <span data-ttu-id="b06e6-557">IPv6 ネットワークでユニキャスト パケットを送信するとき、NetX Duo では、パケットの送出に使用する最適な送信元 IPv6 アドレスを、宛先アドレスに基づいて自動的に決定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-557">When transmitting a unicast packet on an IPv6 network, NetX Duo automatically determines the best source IPv6 address to use to send the packets out on, based on the destination address.</span></span> <span data-ttu-id="b06e6-558">宛先アドレスがマルチキャスト (または IPv4 の場合のブロードキャスト) アドレスの場合でも、NetX Duo では既定で最初の (プライマリ) インターフェイスが設定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-558">If the destination address is a multicast (or broadcast for IPv4) address, however, NetX Duo will default to the first (primary) interface.</span></span> <span data-ttu-id="b06e6-559">そのため、このようなパケットをセカンダリ インターフェイスで送信するには、アプリケーションで _ *_nx_ip_raw_packet_source_send_*\* サービスを使用して、発信パケットに使用する送信元アドレスを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-559">Therefore, to send such packets out on secondary interfaces, the application must use the _ *_nx_ip_raw_packet_source_send_*\* service to specify the source address to use for the outgoing packet.</span></span>

### <a name="raw-ip-receive"></a><span data-ttu-id="b06e6-560">生 IP 受信</span><span class="sxs-lookup"><span data-stu-id="b06e6-560">Raw IP Receive</span></span>

<span data-ttu-id="b06e6-561">生 IP パケット処理が有効になっている場合、アプリケーションは \***nx_ip_raw_packet_receive** _ サービスを通じて生 IP パケットを受信する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-561">If raw IP packet processing is enabled, the application may receive raw IP packets through the \***nx_ip_raw_packet_receive** _ service.</span></span> <span data-ttu-id="b06e6-562">すべての受信パケットは、IP ヘッダーで指定されたプロトコルに従って処理されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-562">All incoming packets are processed according to the protocol specified in the IP header.</span></span> <span data-ttu-id="b06e6-563">プロトコルで UDP、TCP、IGMP、ICMP のいずれかが指定されている場合、NetX Duo ではパケット プロトコルの種類に適したハンドラーを使用してパケットを処理します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-563">If the protocol specifies UDP, TCP, IGMP or ICMP, NetX Duo will process the packet using the appropriate handler for the packet protocol type.</span></span> <span data-ttu-id="b06e6-564">プロトコルがこれらのプロトコルのいずれかではなく、生 IP 受信が有効になっている場合、受信パケットは生パケット キューに格納されて、アプリケーションで _*_nx_ip_raw_packet_receive_*\* サービスを介して受信されるのを待機します。また、生 IP パケットを待機している間に、オプションのタイムアウトでアプリケーション スレッドが停止されることもあります。生パケット キューに入れることができるパケットの数には制限があります。最大値は \***NX_IP_RAW_MAX_QUEUE_DEPTH**_ で定義され、その既定値は 20 です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-564">If the protocol is not one of these protocols, and raw IP receive is enabled, the incoming packet will be put into the raw packet queue waiting for the application to receive it via the _*_nx_ip_raw_packet_receive_*\* service. In addition, application threads may suspend with an optional timeout while waiting for a raw IP packet. The number of packets that can be queued on the raw packet queue is limited. The maximum value is defined in \***NX_IP_RAW_MAX_QUEUE_DEPTH**_, whose default value is 20.</span></span> <span data-ttu-id="b06e6-565">アプリケーションでは、_ *_nx_ip_raw_receive_queue_max_set_*\* サービスを呼び出して最大値を変更できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-565">An application may change the maximum value by calling the _ *_nx_ip_raw_receive_queue_max_set_*\* service.</span></span>

<span data-ttu-id="b06e6-566">代わりに、NetX Duo ライブラリを ***NX_ENABLE_IP_RAW_PACKET_FILTER*** でビルドすることもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-566">Alternatively, the NetX Duo library may be built with \***NX_ENABLE_IP_RAW_PACKET_FILTER\*.**</span></span> <span data-ttu-id="b06e6-567">この動作モードでは、アプリケーションは、未処理のプロトコルの種類であるパケットを受信するたびに呼び出されるコールバック関数を提供します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-567">In this mode of operation, the application provides a callback function that is invoked every time a packet with an unhandled protocol type is received.</span></span> <span data-ttu-id="b06e6-568">IP 受信ロジックでは、パケットをユーザー定義の生パケット受信フィルター ルーチンに転送します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-568">The IP receive logic forwards the packet to the user-defined raw packet receive filter routine.</span></span> <span data-ttu-id="b06e6-569">フィルター ルーチンでは、将来のプロセスのために生パケットを保持するかどうかを決定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-569">The filter routine decides whether or not to keep the raw packet for future process.</span></span> <span data-ttu-id="b06e6-570">コールバック ルーチンからの戻り値は、パケットが生パケット受信フィルターによって処理されたかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-570">The return value from the callback routine indicates whether the packet has been processed by the raw packet receive filter.</span></span> <span data-ttu-id="b06e6-571">パケットがコールバック関数によって処理される場合、アプリケーションでパケットが不要になったらパケットを解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-571">If the packet is processed by the callback function, the packet should be released after the application is done with the packet.</span></span> <span data-ttu-id="b06e6-572">それ以外の場合、パケットの解放は NetX Duo の責任です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-572">Otherwise, NetX Duo is responsible for releasing the packet.</span></span> <span data-ttu-id="b06e6-573">生パケット フィルター関数の使用方法の詳細については、**_nx_ip_raw_packet_filter_set_** を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-573">Refer to the **_nx_ip_raw_packet_filter_set_** for more information on how to use the raw packet filter function.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-574">\*NetX Duo の BSD ラッパー関数では、生パケット フィルター関数を使用して BSD 生ソケットを処理します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-574">\*The BSD wrapper function for NetX Duo relies on the raw packet filter function to handle BSD raw sockets.</span></span> <span data-ttu-id="b06e6-575">そのため、BSD ラッパーで生ソケットをサポートするためには、***NX_ENABLE_IP_RAW_PACKET_FILTER** _ を定義して NetX Duo ライブラリをビルドする必要があります。またアプリケーションでは、_*_nx_ip_raw_packet_filter_set_\*_ を使用してその独自の生パケット フィルター関数をインストールしてはなりません。_</span><span class="sxs-lookup"><span data-stu-id="b06e6-575">Therefore, to support raw socket in the BSD wrapper, the NetX Duo library must be built with ***NX_ENABLE_IP_RAW_PACKET_FILTER** _ defined, and the application should not use the _*_nx_ip_raw_packet_filter_set_\*_ to install its own raw packet filter functions._</span></span>

### <a name="default-packet-pool"></a><span data-ttu-id="b06e6-576">既定のパケット プール</span><span class="sxs-lookup"><span data-stu-id="b06e6-576">Default Packet Pool</span></span>

<span data-ttu-id="b06e6-577">各 IP インスタンスには、作成時に既定のパケット プールが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-577">Each IP instance is given a default packet pool during creation.</span></span> <span data-ttu-id="b06e6-578">このパケット プールは、ARP、RARP、ICMP、IGMP、各種 TCP 制御パケット (SYN、ACK など)、近隣探索、ルーター発見、重複アドレスの検出にパケットを割り当てるために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-578">This packet pool is used to allocate packets for ARP, RARP, ICMP, IGMP, various TCP control packets (SYN, ACK, and so on), Neighbor Discovery, Router Discovery, and Duplicate Address Detection.</span></span> <span data-ttu-id="b06e6-579">NetX Duo がパケットを割り当てる必要があるときに既定のパケット プールが空の場合、NetX Duo で特定の操作を中止することが必要になる場合があり、可能な場合はエラー メッセージを返します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-579">If the default packet pool is empty when NetX Duo needs to allocate a packet, NetX Duo may have to abort the particular operation, and will return an error message if possible.</span></span>

### <a name="ip-helper-thread"></a><span data-ttu-id="b06e6-580">IP ヘルパー スレッド</span><span class="sxs-lookup"><span data-stu-id="b06e6-580">IP Helper Thread</span></span>

<span data-ttu-id="b06e6-581">各 IP インスタンスには、ヘルパー スレッドがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-581">Each IP instance has a helper thread.</span></span> <span data-ttu-id="b06e6-582">このスレッドは、すべての遅延パケット処理とすべての周期処理を担います。</span><span class="sxs-lookup"><span data-stu-id="b06e6-582">This thread is responsible for handling all deferred packet processing and all periodic processing.</span></span> <span data-ttu-id="b06e6-583">IP ヘルパー スレッドは ***nx_ip_create*** で作成されます。ここで、スレッドのスタックと優先順位が指定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-583">The IP helper thread is created in ***nx_ip_create.*** This is where the thread is given its stack and priority.</span></span> <span data-ttu-id="b06e6-584">IP ヘルパー スレッドでの最初の処理は、IP 作成サービスに関連付けられているネットワーク ドライバーの初期化を完了することである点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-584">Note that the first processing in the IP helper thread is to finish the network driver initialization associated with the IP create service.</span></span> <span data-ttu-id="b06e6-585">ネットワーク ドライバーの初期化が完了すると、ヘルパー スレッドはパケットと定期的な要求を処理するために無限ループを開始します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-585">After the network driver initialization is complete, the helper thread starts an endless loop to process packet and periodic requests.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b06e6-586">*IP ヘルパー スレッド内で予期しない動作が見られた場合、最初のデバッグ手順は、IP 作成サービス中にスタック サイズを増やすことです。スタックが小さすぎる場合に、IP ヘルパー スレッドによってメモリが上書きされている可能性があります。これにより、通常とは異なる問題が発生することがあります。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-586">*If unexplained behavior is seen within the IP helper thread, increasing its stack size during the IP create service is the first debugging step. If the stack is too small, the IP helper thread could possibly be overwriting memory, which may cause unusual problems.*</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="b06e6-587">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="b06e6-587">Thread Suspension</span></span>

<span data-ttu-id="b06e6-588">生 IP パケットを受信しようとしているときに、アプリケーション スレッドが中断されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-588">Application threads can suspend while attempting to receive raw IP packets.</span></span> <span data-ttu-id="b06e6-589">生のパケットを受信すると、中断された最初のスレッドに新しいパケットが渡され、そのスレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-589">After a raw packet is received, the new packet is given to the first thread suspended and that thread is resumed.</span></span> <span data-ttu-id="b06e6-590">パケットを受信するためのすべての NetX Duo サービスには、省略可能な中断タイムアウトがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-590">NetX Duo services for receiving packets all have an optional suspension timeout.</span></span> <span data-ttu-id="b06e6-591">パケットが受信されるか、タイムアウトが経過すると、適切な完了ステータスでアプリケーション スレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-591">When a packet is received or the timeout expires, the application thread is resumed with the appropriate completion status.</span></span>

### <a name="ip-statistics-and-errors"></a><span data-ttu-id="b06e6-592">IP の統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b06e6-592">IP Statistics and Errors</span></span>

<span data-ttu-id="b06e6-593">有効にした場合、NetX Duo では、アプリケーションに役立つ可能性のあるいくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-593">If enabled, the NetX Duo keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b06e6-594">次の統計およびエラー レポートは、IP インスタンスごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-594">The following statistics and error reports are maintained for each IP instance:</span></span>

- <span data-ttu-id="b06e6-595">送信された IP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-595">Total IP Packets Sent</span></span>
- <span data-ttu-id="b06e6-596">送信された IP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-596">Total IP Bytes Sent</span></span>
- <span data-ttu-id="b06e6-597">受信した IP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-597">Total IP Packets Received</span></span>
- <span data-ttu-id="b06e6-598">受信した IP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-598">Total IP Bytes Received</span></span>
- <span data-ttu-id="b06e6-599">無効な IP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-599">Total IP Invalid Packets</span></span>
- <span data-ttu-id="b06e6-600">ドロップされた IP 受信パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-600">Total IP Receive Packets Dropped</span></span>
- <span data-ttu-id="b06e6-601">IP 受信チェックサム エラーの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-601">Total IP Receive Checksum Errors</span></span>
- <span data-ttu-id="b06e6-602">ドロップされた IP 送信パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-602">Total IP Send Packets Dropped</span></span>
- <span data-ttu-id="b06e6-603">送信された IP フラグメントの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-603">Total IP Fragments Sent</span></span>
- <span data-ttu-id="b06e6-604">受信した IP フラグメントの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-604">Total IP Fragments Received</span></span>

<span data-ttu-id="b06e6-605">これらの統計およびエラー レポートはすべて、***nx_ip_info_get*** サービスを使用してアプリケーションで利用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-605">All of these statistics and error reports are available to the application with the ***nx_ip_info_get*** service.</span></span>

### <a name="ip-control-block-nx_ip"></a><span data-ttu-id="b06e6-606">IP 制御ブロック NX_IP</span><span class="sxs-lookup"><span data-stu-id="b06e6-606">IP Control Block NX_IP</span></span>

<span data-ttu-id="b06e6-607">各 IP インスタンスの特性は、制御ブロックにあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-607">The characteristics of each IP instance are found in its control block.</span></span> <span data-ttu-id="b06e6-608">これには、各ネットワーク デバイスの IP アドレスとネットワーク マスク、近隣 IP および物理ハードウェア アドレス マッピングのテーブルなどの有用な情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-608">It contains useful information such as the IP addresses and network masks of each network device, and a table of neighbor IP and physical hardware address mapping.</span></span> <span data-ttu-id="b06e6-609">この構造体は \***nx_api.h** _ ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-609">This structure is defined in the \***nx_api.h** _file.</span></span> <span data-ttu-id="b06e6-610">IPv6 が有効になっている場合、これには IPv6 アドレスの配列も含まれ、その数はユーザーが構成可能なオプション _*_NX_MAX_IPV6_ADDRESSES_*\* で指定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-610">If IPv6 is enabled, it also contains an array of IPv6 address, the number of which is specified by the user configurable option _\*_NX_MAX_IPV6_ADDRESSES_\*\*.</span></span> <span data-ttu-id="b06e6-611">既定値では、物理ネットワーク インターフェイスはそれぞれ 3 つの IPv6 アドレスを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-611">The default value allows each physical network interface to have three IPv6 addresses.</span></span>

<span data-ttu-id="b06e6-612">IP インスタンス制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-612">IP instance control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="static-ipv4-routing"></a><span data-ttu-id="b06e6-613">静的 IPv4 ルーティング</span><span class="sxs-lookup"><span data-stu-id="b06e6-613">Static IPv4 Routing</span></span>

<span data-ttu-id="b06e6-614">静的ルーティング機能を使用すると、アプリケーションでは、特定のネットワーク外の宛先 IP アドレスに対して IPv4 ネットワークとネクスト ホップ アドレスを指定できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-614">The static routing feature allows an application to specify an IPv4 network and next hop address for specific out of network destination IP addresses.</span></span> <span data-ttu-id="b06e6-615">静的ルーティングが有効になっている場合、NetX Duo は静的ルーティング テーブルを検索し、送信するパケットの宛先アドレスと一致するエントリを検索します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-615">If static routing is enabled, NetX Duo searches through the static routing table for an entry matching the destination address of the packet to send.</span></span> <span data-ttu-id="b06e6-616">一致するものが見つからない場合、NetX Duo は物理インターフェイスの一覧を検索し、宛先 IP アドレスとネットワーク マスクに基づいて、送信元 IP アドレスとネクスト ホップ アドレスを選択します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-616">If no match is found, NetX Duo searches through the list of physical interfaces and chooses a source IP address and next hop address based on the destination IP address and the network mask.</span></span> <span data-ttu-id="b06e6-617">IP インスタンスに接続されているネットワーク ドライバーのどの IP アドレスとも宛先が一致しない場合、NetX Duo は、既定のゲートウェイに直接接続されているインターフェイスを選択し、送信元アドレスとしてインターフェイスの IP アドレスを使用し、ネクスト ホップとして既定のゲートウェイを使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-617">If the destination does not match any of the IP addresses of the network drivers attached to the IP instance, NetX Duo chooses an interface that is directly connected to the default gateway, and uses the IP address of the interface as source address, and the default gateway as the next hop.</span></span>

<span data-ttu-id="b06e6-618">***nx_ip_static_route_add** _ と _ *_nx_ip_static_route_delete_** サービスをそれぞれ使用して、静的ルーティング テーブルのエントリを追加および削除できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-618">Entries can be added and removed from the static routing table using the ***nx_ip_static_route_add** _ and _ *_nx_ip_static_route_delete_** services, respectively.</span></span> <span data-ttu-id="b06e6-619">静的ルーティングを使用するには、***NX_ENABLE_IP_STATIC_ROUTING*** を定義して、ホスト アプリケーションでこの機能を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-619">To use static routing, the host application must enable this feature by defining ***NX_ENABLE_IP_STATIC_ROUTING.***</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-620">*静的ルーティング テーブルにエントリを追加するときに、NetX Duo では、指定された宛先アドレスに一致するエントリがテーブル内に既に存在するかどうかを確認します。存在する場合は、ネットワーク マスクの中で、より小さいネットワーク (長いプレフィックス) のエントリを優先します。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-620">*When adding an entry to the static routing table, NetX Duo checks for a matching entry for the specified destination address already in the table. If one exists, it gives preference to the entry with the smaller network (longer prefix) in the network mask.*</span></span>

### <a name="ipv4-forwarding"></a><span data-ttu-id="b06e6-621">IPv4 転送</span><span class="sxs-lookup"><span data-stu-id="b06e6-621">IPv4 Forwarding</span></span>

<span data-ttu-id="b06e6-622">受信 IPv4 パケットの宛先がこのノードではなく、IPv4 転送機能が有効になっている場合、NetX Duo は他のインターフェイスを介してパケットを転送しようとします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-622">If the incoming IPv4 packet is not destined for this node and IPv4 forwarding feature is enabled, NetX Duo attempts to forward the packet out via the other interfaces.</span></span>  

### <a name="ip-fragmentation"></a><span data-ttu-id="b06e6-623">IP の断片化</span><span class="sxs-lookup"><span data-stu-id="b06e6-623">IP Fragmentation</span></span>

<span data-ttu-id="b06e6-624">ネットワーク デバイスには、発信パケットのサイズに制限がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-624">The network device may have limits on the size of outgoing packets.</span></span> <span data-ttu-id="b06e6-625">この制限は、最大転送単位 (MTU) と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-625">This limit is called the maximum transmission unit (MTU).</span></span> <span data-ttu-id="b06e6-626">IP の MTU は、IP パケットを断片化せずにリンク レイヤー ドライバーで送信できる最大 IP フレーム サイズです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-626">IP MTU is the largest IP frame size a link layer driver is able to transmit without fragmenting the IP packet.</span></span> <span data-ttu-id="b06e6-627">デバイス ドライバーの初期化フェーズでは、ドライバー モジュールはサービス ***nx_ip_interface_mtu_set*** を介して IP の MTU サイズを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-627">During a device driver initialization phase, the driver module must configure its IP MTU size via the service ***nx_ip_interface_mtu_set.***</span></span>

<span data-ttu-id="b06e6-628">推奨されませんが、アプリケーションでは、デバイスでサポートされている基になる IP MTU よりも大きいデータグラムが生成される場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-628">Although not recommended, the application may generate datagrams larger than the underlying IP MTU supported by the device.</span></span> <span data-ttu-id="b06e6-629">このような IP データグラムを送信する前に、IP レイヤーはこれらのパケットを断片化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-629">Before transmitting such IP datagram, the IP layer must fragment these packets.</span></span> <span data-ttu-id="b06e6-630">断片化された IP フレームを受信する場合、受信側は同じ断片化 ID を持つ断片化されたすべての IP フレームを格納し、順番に再アセンブルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-630">On receiving fragmented IP frames, the receiving end must store all fragmented IP frames with the same fragmentation ID, and reassemble them in order.</span></span> <span data-ttu-id="b06e6-631">IP 受信ロジックがすべてのフラグメントを収集して元の IP フレームを時間内に復元できない場合は、すべてのフラグメントが解放されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-631">If the IP receive logic is unable to collect all the fragments to restore the original IP frame in time, all the fragments are released.</span></span> <span data-ttu-id="b06e6-632">このようなパケット損失を検出して回復する作業は、上位層プロトコルが担います。</span><span class="sxs-lookup"><span data-stu-id="b06e6-632">It is up to the upper layer protocol to detect such packet loss and recover from it.</span></span>

<span data-ttu-id="b06e6-633">IP の断片化は、IPv4 と IPv6 両方のパケットに適用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-633">The IP fragmentation applies to both IPv4 and IPv6 packets.</span></span>

<span data-ttu-id="b06e6-634">IP の断片化と再アセンブリの操作をサポートするために、システム デザイナーは、***nx_ip_fragment_enable*** サービスを使用して NetX Duo の IP の断片化機能を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-634">In order to support IP fragmentation and reassembly operation, the system designer must enable the IP fragmentation feature in NetX Duo using the ***nx_ip_fragment_enable*** service.</span></span> <span data-ttu-id="b06e6-635">この機能が有効になっていない場合は、断片化された受信 IP パケットだけでなく、ネットワーク ドライバーの MTU を超えるパケットも破棄されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-635">If this feature is not enabled, incoming fragmented IP packets are discarded, as well as packets that exceed the network driver's MTU.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-636">*IP 断片化ロジックは、NetX Duo ライブラリをビルドするときに、\*\*\*NX_DISABLE_FRAGMENTATION*\* _ を定義することで完全に削除できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-636">\*The IP Fragmentation logic can be removed completely by defining \***NX_DISABLE_FRAGMENTATION** _ when building the NetX Duo library.</span></span> <span data-ttu-id="b06e6-637">これにより、NetX Duo のコード サイズを減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-637">Doing so helps reduce the code size of NetX Duo.</span></span> <span data-ttu-id="b06e6-638">この状況では、IPv4 と IPv6 両方の断片化/再アセンブリ関数が無効になっていることに注意してください。_</span><span class="sxs-lookup"><span data-stu-id="b06e6-638">Note that in this situation, both the IPv4 and IPv6 fragmentation/reassembly functions are disabled._</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-639">***NX_DISABLE_CHAINED_PACKET** が定義されている場合、IP の断片化を無効にする必要があります。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-639">*If **NX_DISABLE_CHAINED_PACKET** is defined, IP fragmentation must be disabled.*</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-640">*IPv6 ネットワークでは、データグラムのサイズが最小 MTU サイズを超える場合でも、ルーターはデータグラムを断片化しません。したがって、送信元と宛先の間で最小 MTU を決定すること、また IP データグラムのサイズがパスの MTU を超えないようにすることは送信側デバイスの責任です。NetX Duo では、シンボル **NX_ENABLE_IPV6_PATH_MTU_DISCOVERY** を定義して NetX Duo ライブラリをビルドすることで、IPv6 PATH MTU 検出を有効にすることができます。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-640">*In an IPv6 network, routers do not fragment a datagram if the size of the datagram exceeds its minimum MTU size. Therefore, it is up to the sending device to determine the minimum MTU between the source and the destination, and to ensure the IP datagram size does not exceed the path MTU. In NetX Duo, IPv6 PATH MTU discovery can be enabled by building NetX Duo library with the symbol **NX_ENABLE_IPV6_PATH_MTU_DISCOVERY** defined.*</span></span>

## <a name="address-resolution-protocol-arp-in-ipv4"></a><span data-ttu-id="b06e6-641">IPv4 のアドレス解決プロトコル (ARP)</span><span class="sxs-lookup"><span data-stu-id="b06e6-641">Address Resolution Protocol (ARP) in IPv4</span></span>

<span data-ttu-id="b06e6-642">アドレス解決プロトコル (ARP) は、32 ビットの IPv4 アドレスを、基になる物理メディアの IP アドレスに動的にマッピングする役割を担います (RFC 826)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-642">The Address Resolution Protocol (ARP) is responsible for dynamically mapping 32-bit IPv4 addresses to those of the underlying physical media (RFC 826).</span></span> <span data-ttu-id="b06e6-643">イーサネットは最も一般的な物理メディアであり、48 ビットのアドレスをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-643">Ethernet is the most typical physical media, and it supports 48-bit addresses.</span></span> <span data-ttu-id="b06e6-644">ARP の必要性は、\***nx_ip_create** _ サービスに提供されるネットワーク ドライバーによって決まります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-644">The need for ARP is determined by the network driver supplied to the \***nx_ip_create** _ service.</span></span> <span data-ttu-id="b06e6-645">物理マッピングが必要な場合、ネットワーク ドライバーでは _ *_nx_interface_address_mapping_needed_*\* サービスを使用して、ドライバー インターフェイスを適切に構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-645">If physical mapping is required, the network driver must use the _ *_nx_interface_address_mapping_needed_*\* service to configure the driver interface properly.</span></span>

### <a name="arp-enable"></a><span data-ttu-id="b06e6-646">ARP 有効化</span><span class="sxs-lookup"><span data-stu-id="b06e6-646">ARP Enable</span></span>

<span data-ttu-id="b06e6-647">ARP を正常に機能させるには、最初に ***nx_arp_enable*** サービスを使用してアプリケーションで有効化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-647">For ARP to function properly, it must first be enabled by the application with the ***nx_arp_enable*** service.</span></span> <span data-ttu-id="b06e6-648">このサービスでは、ARP 有効化サービスに提供されるメモリからの ARP キャッシュ領域の作成など、ARP 処理用にさまざまなデータ構造が設定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-648">This service sets up various data structures for ARP processing, including the creation of an ARP cache area from the memory supplied to the ARP enable service.</span></span>

### <a name="arp-cache"></a><span data-ttu-id="b06e6-649">ARP キャッシュ</span><span class="sxs-lookup"><span data-stu-id="b06e6-649">ARP Cache</span></span>

<span data-ttu-id="b06e6-650">ARP キャッシュは、内部 ARP マッピング データ構造の配列として表示できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-650">The ARP cache can be viewed as an array of internal ARP mapping data structures.</span></span> <span data-ttu-id="b06e6-651">各内部構造によって、IP アドレスと物理ハードウェア アドレスの間の関係を維持することができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-651">Each internal structure is capable of maintaining the relationship between an IP address and a physical hardware address.</span></span> <span data-ttu-id="b06e6-652">さらに、各データ構造にリンク ポインターがあるため、複数のリンク リストに含めることができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-652">In addition, each data structure has link pointers so it can be part of multiple linked lists.</span></span>

<span data-ttu-id="b06e6-653">ARP テーブルにマッピングが存在する場合、アプリケーションでは、サービス \***nx_arp_ip_address_find** _ を使用してハードウェア MAC アドレスを指定することにより、ARP キャッシュから IP アドレスを検索できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-653">Application can look up an IP address from the ARP cache by supplying hardware MAC address using the service \***nx_arp_ip_address_find** _ if the mapping exists in the ARP table.</span></span> <span data-ttu-id="b06e6-654">同様に、サービス _ *_nx_arp_hardware_address_find_*\* では、指定された IP アドレスの MAC アドレスが返されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-654">Similarly, the service _ *_nx_arp_hardware_address_find_*\* returns the MAC address for a given IP address.</span></span>

### <a name="arp-dynamic-entries"></a><span data-ttu-id="b06e6-655">ARP 動的エントリ</span><span class="sxs-lookup"><span data-stu-id="b06e6-655">ARP Dynamic Entries</span></span>

<span data-ttu-id="b06e6-656">既定では、ARP 有効化サービスは、ARP キャッシュ内のすべてのエントリを、使用可能な動的 ARP エントリの一覧に配置します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-656">By default, the ARP enable service places all entries in the ARP cache on the list of available dynamic ARP entries.</span></span> <span data-ttu-id="b06e6-657">マップされていない IP アドレスへの送信要求が検出されると、このリストから動的 ARP エントリが NetX Duo によって割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-657">A dynamic ARP entry is allocated from this list by NetX Duo when a send request to an unmapped IP address is detected.</span></span> <span data-ttu-id="b06e6-658">割り当てが完了すると、ARP エントリがセットアップされ、ARP 要求が物理メディアに送信されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-658">After allocation, the ARP entry is set up and an ARP request is sent to the physical media.</span></span>

<span data-ttu-id="b06e6-659">動的エントリは、サービス ***nx_arp_dynamic_entry_set*** で作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-659">A dynamic entry can also be created by the service ***nx_arp_dynamic_entry_set***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b06e6-660">*すべての動的 ARP エントリが使用されている場合、最も長く使用されていない ARP エントリが新しいマッピングに置き換えられます。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-660">*If all dynamic ARP entries are in use, the least recently used ARP entry is replaced with a new mapping.*</span></span>

### <a name="arp-static-entries"></a><span data-ttu-id="b06e6-661">ARP 静的エントリ</span><span class="sxs-lookup"><span data-stu-id="b06e6-661">ARP Static Entries</span></span>

<span data-ttu-id="b06e6-662">アプリケーションでは、\***nx_arp_static_entry_create** _ サービスを使用して静的 ARP マッピングを設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-662">The application can also set up static ARP mapping by using the \***nx_arp_static_entry_create** _service.</span></span> <span data-ttu-id="b06e6-663">このサービスは、動的 ARP エントリ リストから ARP エントリを割り当て、アプリケーションから提供されたマッピング情報を使用して静的リストに配置します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-663">This service allocates an ARP entry from the dynamic ARP entry list and places it on the static list with the mapping information supplied by the application.</span></span> <span data-ttu-id="b06e6-664">静的 ARP エントリは、再利用またはエージングの対象になりません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-664">Static ARP entries are not subject to reuse or aging.</span></span> <span data-ttu-id="b06e6-665">アプリケーションでは、サービス _*_nx_arp_static_entry_delete_*_ を使用して静的エントリを削除できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-665">The application can delete a static entry by using the service _*_nx_arp_static_entry_delete_*_.</span></span> <span data-ttu-id="b06e6-666">ARP テーブル内のすべての静的エントリを削除するために、アプリケーションでサービス _*_nx_arp_static_entries_delete_*\* が使用されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-666">To remove all static entries in the ARP table, the application may use the service _\*_nx_arp_static_entries_delete_\*\*.</span></span>

### <a name="automatic-arp-entry"></a><span data-ttu-id="b06e6-667">自動 ARP 入力</span><span class="sxs-lookup"><span data-stu-id="b06e6-667">Automatic ARP Entry</span></span>

<span data-ttu-id="b06e6-668">NetX Duo は、ARP 要求に対するピアの応答後に、ピアの IP/MAC マッピングを記録します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-668">NetX Duo records the peer's IP/MAC mapping after the peer responses to the ARP request.</span></span> <span data-ttu-id="b06e6-669">NetX Duo には、ネットワークからの要請されていない ARP 要求に基づいて、ピア IP/MAC アドレスのマッピングを記録する自動 ARP 入力機能も実装されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-669">NetX Duo also implements the automatic ARP entry feature where it records peer IP/MAC address mapping based on unsolicited ARP requests from the network.</span></span> <span data-ttu-id="b06e6-670">この機能を使用すると、ARP テーブルにピア情報が入力されるため、ARP 要求/応答サイクルを実行するために必要な遅延を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-670">This feature allows the ARP table to be populated with peer information, reducing the delay needed to go through the ARP request/response cycle.</span></span> <span data-ttu-id="b06e6-671">ただし、自動 ARP を有効にした場合の欠点は、ローカル リンク上に多数のノードがあるビジー状態のネットワークでは、ARP テーブルがすぐにいっぱいになる傾向があることです。これが最終的には ARP エントリの置換につながります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-671">However the downside with enabling automatic ARP is that the ARP table tend to fill up quickly on a busy network with many nodes on the local link, which would eventually lead to ARP entry replacement.</span></span>

<span data-ttu-id="b06e6-672">この機能は、既定で有効になっています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-672">This feature is enabled by default.</span></span> <span data-ttu-id="b06e6-673">無効にするには、定義されたシンボル ***NX_DISABLE_ARP_AUTO_ENTRY*** を使用して NetX Duo ライブラリをコンパイルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-673">To disable it, the NetX Duo library must be compiled with the symbol ***NX_DISABLE_ARP_AUTO_ENTRY*** defined.</span></span></p>

### <a name="arp-messages"></a><span data-ttu-id="b06e6-674">ARP メッセージ</span><span class="sxs-lookup"><span data-stu-id="b06e6-674">ARP Messages</span></span>

<span data-ttu-id="b06e6-675">前に説明したように、IP アドレスにマッピングが必要であることが IP タスクによって検出されると、ARP 要求メッセージが送信されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-675">As mentioned previously, an ARP request message is sent when the IP task detects that mapping is needed for an IP address.</span></span> <span data-ttu-id="b06e6-676">ARP 要求は、対応する ARP 応答を受信するまで、(\***NX_ARP_UPDATE_RATE** _ 秒ごとに) 定期的に送信されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-676">ARP requests are sent periodically (every \***NX_ARP_UPDATE_RATE** _ seconds) until a corresponding ARP response is received.</span></span> <span data-ttu-id="b06e6-677">ARP の試行が破棄される前に、合計で _ *_NX_ARP_MAXIMUM_RETRIES_*\* 回の ARP 要求が行われます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-677">A total of _ *_NX_ARP_MAXIMUM_RETRIES_*\* ARP requests are made before the ARP attempt is abandoned.</span></span> <span data-ttu-id="b06e6-678">ARP 応答を受信すると、関連付けられている物理アドレス情報がキャッシュ内の ARP エントリに格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-678">When an ARP response is received, the associated physical address information is stored in the ARP entry that is in the cache.</span></span>

<span data-ttu-id="b06e6-679">マルチホーム システムの場合、NetX Duo では、指定された宛先アドレスに基づいて ARP 要求と応答を送信するインターフェイスが決定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-679">For multihome systems, NetX Duo determines which interface to send the ARP requests and responses based on destination address specified.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-680">*送信 IP パケットは、NetX Duo が ARP 応答を待機している間、キューに登録されます。キューに置かれる発信 IP パケットの数は、定数 **NX_ARP_MAX_QUEUE_DEPTH** によって定義されます。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-680">*Outgoing IP packets are queued while NetX Duo waits for the ARP response. The number of outgoing IP packets queued is defined by the constant **NX_ARP_MAX_QUEUE_DEPTH**.*</span></span>

<span data-ttu-id="b06e6-681">NetX Duo は、ローカル IPv4 ネットワーク上の他のノードからの ARP 要求にも応答します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-681">NetX Duo also responds to ARP requests from other nodes on the local IPv4 network.</span></span> <span data-ttu-id="b06e6-682">ARP 要求を受信するインターフェイスの現在の IP アドレスと一致する外部 ARP 要求が行われると、NetX Duo は、現在の物理アドレスを含む ARP 応答メッセージを構築します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-682">When an external ARP request is made that matches the current IP address of the interface that receives the ARP request, NetX Duo builds an ARP response message that contains the current physical address.</span></span>

<span data-ttu-id="b06e6-683">イーサネットの ARP 要求と応答の形式を図 6 に示し、次に説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-683">The formats of Ethernet ARP requests and responses are shown in Figure 6 and are described below.</span></span>

| <span data-ttu-id="b06e6-684">**要求/応答&nbsp;フィールド**</span><span class="sxs-lookup"><span data-stu-id="b06e6-684">**Request/Response&nbsp;Field**</span></span>         | <span data-ttu-id="b06e6-685">**目的**</span><span class="sxs-lookup"><span data-stu-id="b06e6-685">**Purpose**</span></span>            |
| ---------------------------------- | ---------------------- |
| <span data-ttu-id="b06e6-686">***イーサネットの宛先アドレス***</span><span class="sxs-lookup"><span data-stu-id="b06e6-686">***Ethernet Destination Address***</span></span> | <span data-ttu-id="b06e6-687">この 6 バイトのフィールドには、ARP 応答の宛先アドレスが格納され、ARP 要求の場合はブロードキャスト (すべて) になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-687">This 6-byte field contains the destination address for the ARP response and is a broadcast (all ones) for ARP requests.</span></span> <span data-ttu-id="b06e6-688">このフィールドは、ネットワーク ドライバーによって設定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-688">This field is setup by the network driver.</span></span> 
| <span data-ttu-id="b06e6-689">***イーサネットの送信元アドレス***</span><span class="sxs-lookup"><span data-stu-id="b06e6-689">***Ethernet Source Address***</span></span>      | <span data-ttu-id="b06e6-690">この 6 バイトのフィールドには、ARP 要求または応答の送信者のアドレスが格納され、ネットワーク ドライバーによって設定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-690">This 6-byte field contains the address of the sender of the ARP request or response and is set up by the network driver.</span></span> |
| <span data-ttu-id="b06e6-691">***フレームの種類***</span><span class="sxs-lookup"><span data-stu-id="b06e6-691">***Frame Type***</span></span> | <span data-ttu-id="b06e6-692">この 2 バイトのフィールドには、存在するイーサネット フレームの種類が格納されます。ARP 要求と応答の場合、これは 0x0806 に相当します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-692">This 2-byte field contains the type of Ethernet frame present and, for ARP requests and responses, this is equal to 0x0806.</span></span> <span data-ttu-id="b06e6-693">これは、ネットワーク ドライバーで設定される最後のフィールドです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-693">This is the last field the network driver is responsible for setting up.</span></span> |
| <span data-ttu-id="b06e6-694">***ハードウェアの種類***</span><span class="sxs-lookup"><span data-stu-id="b06e6-694">***Hardware Type***</span></span> | <span data-ttu-id="b06e6-695">この 2 バイトのフィールドには、ハードウェアの種類が格納されます。イーサネットの場合は 0x0001 です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-695">This 2-byte field contains the hardware type, which is 0x0001 for Ethernet.</span></span> |
| <span data-ttu-id="b06e6-696">***プロトコルの種類***</span><span class="sxs-lookup"><span data-stu-id="b06e6-696">***Protocol Type***</span></span> | <span data-ttu-id="b06e6-697">この 2 バイトのフィールドには、プロトコルの種類が格納されます。IP アドレスの場合は 0x0800 です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-697">This 2-byte field contains the protocol type, which is 0x0800 for IP addresses.</span></span> |
| <span data-ttu-id="b06e6-698">***ハードウェア サイズ***</span><span class="sxs-lookup"><span data-stu-id="b06e6-698">***Hardware Size***</span></span> | <span data-ttu-id="b06e6-699">この 1 バイトのフィールドには、ハードウェア アドレスのサイズが格納されます。イーサネット アドレスの場合は 6 です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-699">This 1-byte field contains the hardware address size, which is 6 for Ethernet addresses.</span></span> |

![ARP パケット形式の図。](./media/user-guide/arp-packet-format.png)

<span data-ttu-id="b06e6-701">**図 6. ARP パケット形式**</span><span class="sxs-lookup"><span data-stu-id="b06e6-701">**FIGURE 6. ARP Packet Format**</span></span>

| <span data-ttu-id="b06e6-702">要求/応答&nbsp;フィールド</span><span class="sxs-lookup"><span data-stu-id="b06e6-702">Request/Response&nbsp;Field</span></span> | <span data-ttu-id="b06e6-703">目的</span><span class="sxs-lookup"><span data-stu-id="b06e6-703">Purpose</span></span> |
|---|---|
| <span data-ttu-id="b06e6-704">***プロトコル サイズ***</span><span class="sxs-lookup"><span data-stu-id="b06e6-704">***Protocol Size***</span></span> | <span data-ttu-id="b06e6-705">この 1 バイトのフィールドには IP アドレスのサイズが格納されます。IP アドレスの場合は 4 です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-705">This 1-byte field contains the IP address size, which is 4 for IP addresses.</span></span> |
| <span data-ttu-id="b06e6-706">***操作コード***</span><span class="sxs-lookup"><span data-stu-id="b06e6-706">***Operation Code***</span></span> | <span data-ttu-id="b06e6-707">この 2 バイトのフィールドには、この ARP パケットに対する操作が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-707">This 2-byte field contains the operation for this ARP packet.</span></span> <span data-ttu-id="b06e6-708">ARP 要求は 0x0001 の値で指定され、ARP 応答は 0x0002 の値で表されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-708">An ARP request is specified with the value of 0x0001, while an ARP response is represented by a value of 0x0002.</span></span> |
| <span data-ttu-id="b06e6-709">***送信者のイーサネット アドレス***</span><span class="sxs-lookup"><span data-stu-id="b06e6-709">***Sender Ethernet Address***</span></span> | <span data-ttu-id="b06e6-710">この 6 バイトのフィールドには、送信者のイーサネット アドレスが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-710">This 6-byte field contains the sender's Ethernet address.</span></span> |
| <span data-ttu-id="b06e6-711">***送信者の IP アドレス***</span><span class="sxs-lookup"><span data-stu-id="b06e6-711">***Sender IP Address***</span></span> | <span data-ttu-id="b06e6-712">この 4 バイトのフィールドには、送信者の IP アドレスが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-712">This 4-byte field contains the sender's IP address.</span></span> |
| <span data-ttu-id="b06e6-713">***ターゲット イーサネット アドレス***</span><span class="sxs-lookup"><span data-stu-id="b06e6-713">***Target Ethernet Address***</span></span> | <span data-ttu-id="b06e6-714">この 6 バイトのフィールドには、ターゲットのイーサネット アドレスが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-714">This 6-byte field contains the target's Ethernet address.</span></span> |
| <span data-ttu-id="b06e6-715">***ターゲット IP アドレス***</span><span class="sxs-lookup"><span data-stu-id="b06e6-715">***Target IP Address***</span></span> | <span data-ttu-id="b06e6-716">この 4 バイトのフィールドには、ターゲットの IP アドレスが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-716">This 4-byte field contains the target's IP address.</span></span> |

> [!NOTE]
> <span data-ttu-id="b06e6-717">*ARP の要求と応答は、イーサネットレベルのパケットです。その他のすべての TCP/IP パケットは、IP パケット ヘッダーによってカプセル化されます。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-717">*ARP requests and responses are Ethernet-level packets. All other TCP/IP packets are encapsulated by an IP packet header.*</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-718">*TCP/IP 実装のすべての ARP メッセージは、\*\*ビッグ エンディアン*\* 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-718">*All ARP messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="arp-aging"></a><span data-ttu-id="b06e6-719">ARP のエージング</span><span class="sxs-lookup"><span data-stu-id="b06e6-719">ARP Aging</span></span>

<span data-ttu-id="b06e6-720">NetX では、動的 ARP 入力の自動無効化がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-720">NetX supports automatic dynamic ARP entry invalidation.</span></span><span data-ttu-id="b06e6-721">\ ***NX_ARP_EXPIRATION_RATE** _ は、物理マッピングに対して確立された IP アドレスが有効な秒数を指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-721">\ ***NX_ARP_EXPIRATION_RATE** _ specifies the number of seconds an established IP address to physical mapping stays valid.</span></span> <span data-ttu-id="b06e6-722">有効期限が切れると、ARP キャッシュから ARP エントリが削除されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-722">After expiration, the ARP entry is removed from the ARP cache.</span></span> <span data-ttu-id="b06e6-723">対応する IP アドレスへの送信を次に試行したときに、新しい ARP 要求が発生します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-723">The next attempt to send to the corresponding IP address will result in a new ARP request.</span></span> <span data-ttu-id="b06e6-724">_ *_NX_ARP_EXPIRATION_RATE_*\* を 0 に設定すると、ARP のエージングが無効になります。これは既定の構成です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-724">Setting _ *_NX_ARP_EXPIRATION_RATE_*\* to zero disables ARP aging, which is the default configuration.</span></span>

### <a name="arp-defend"></a><span data-ttu-id="b06e6-725">ARP の防御</span><span class="sxs-lookup"><span data-stu-id="b06e6-725">ARP Defend</span></span>

<span data-ttu-id="b06e6-726">ARP 要求または ARP 応答パケットが受信され、送信元の IP アドレスが同じで、このノードの IP アドレスと競合している場合、NetX Duo によってそのアドレスに対する ARP 要求が防御として送信されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-726">When an ARP request or ARP response packet is received and the sender has the same IP address, which conflicts with the IP address of this node, NetX Duo sends an ARP request for that address as a defense.</span></span> <span data-ttu-id="b06e6-727">競合する ARP パケットが 10 秒以内に複数回受信された場合、NetX Duo はそれ以上の防御パケットを送信しません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-727">If the conflict ARP packet is received more than once in 10 seconds, NetX Duo does not send more defend packets.</span></span> <span data-ttu-id="b06e6-728">既定の間隔は 10 秒で、\***NX_ARP_DEFEND_INTERVAL** _ で再定義できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-728">The default interval 10 seconds can be redefined by \***NX_ARP_DEFEND_INTERVAL** _.</span></span> <span data-ttu-id="b06e6-729">この動作は、RFC5227 の 2.4(c) で指定されたポリシーに従います。</span><span class="sxs-lookup"><span data-stu-id="b06e6-729">This behavior follows the policy specified in 2.4(c) of RFC5227.</span></span> <span data-ttu-id="b06e6-730">Windows XP では ARP プローブの応答として ARP アナウンスが無視されるため、ユーザーは _ *_NX_ARP_DEFEND_BY_REPLY_*\* を定義して、追加の防御として ARP 応答を送信できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-730">Since Windows XP ignores ARP announcement as a response for its ARP probe, user can define _ *_NX_ARP_DEFEND_BY_REPLY_*\* to send ARP response as additional defence.</span></span>

### <a name="arp-statistics-and-errors"></a><span data-ttu-id="b06e6-731">ARP の統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b06e6-731">ARP Statistics and Errors</span></span>

<span data-ttu-id="b06e6-732">有効にすると、NetX Duo ARP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-732">If enabled, the NetX Duo ARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b06e6-733">次の統計およびエラー レポートは、IP の ARP 処理ごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-733">The following statistics and error reports are maintained for each IP's ARP processing:</span></span>

- <span data-ttu-id="b06e6-734">送信された ARP 要求の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-734">Total ARP Requests Sent</span></span>
- <span data-ttu-id="b06e6-735">受信した ARP 要求の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-735">Total ARP Requests Received</span></span>
- <span data-ttu-id="b06e6-736">送信された ARP 応答の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-736">Total ARP Responses Sent</span></span> 
- <span data-ttu-id="b06e6-737">受信した ARP 応答の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-737">Total ARP Responses Received</span></span> 
- <span data-ttu-id="b06e6-738">ARP 動的エントリの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-738">Total ARP Dynamic Entries</span></span> 
- <span data-ttu-id="b06e6-739">ARP 静的エントリの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-739">Total ARP Static Entries</span></span> 
- <span data-ttu-id="b06e6-740">ARP 期限切れエントリの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-740">Total ARP Aged Entries</span></span> 
- <span data-ttu-id="b06e6-741">ARP 無効メッセージの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-741">Total ARP Invalid Messages</span></span> 

<span data-ttu-id="b06e6-742">これらの統計およびエラー レポートはすべて、***nx_arp_info_get*** サービスを使用してアプリケーションで利用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-742">All these statistics and error reports are available to the application with the ***nx_arp_info_get*** service.</span></span>

## <a name="reverse-address-resolution-protocol-rarp-in-ipv4"></a><span data-ttu-id="b06e6-743">IPv4 の逆アドレス解決プロトコル (RARP)</span><span class="sxs-lookup"><span data-stu-id="b06e6-743">Reverse Address Resolution Protocol (RARP) in IPv4</span></span>

<span data-ttu-id="b06e6-744">逆アドレス解決プロトコル (RARP) は、ホストの 32 ビット IP アドレスのネットワーク割り当てを要求するためのプロトコルです (RFC 903)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-744">The Reverse Address Resolution Protocol (RARP) is the protocol for requesting network assignment of the host's 32-bit IP addresses (RFC 903).</span></span> <span data-ttu-id="b06e6-745">これは RARP 要求によって行われ、ネットワーク メンバーが RARP 応答でホスト ネットワーク インターフェイスに IP アドレスを割り当てるまで定期的に継続されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-745">This is done through an RARP request and continues periodically until a network member assigns an IP address to the host network interface in an RARP response.</span></span> <span data-ttu-id="b06e6-746">アプリケーションは、サービス ***nx_ip_create*** を使用して、IP インスタンスを IP アドレス 0 で作成します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-746">The application creates an IP instance by the service ***nx_ip_create*** with a zero IP address.</span></span> <span data-ttu-id="b06e6-747">RARP がアプリケーションで有効化されている場合は、RARP プロトコルを使用して、IP アドレスが 0 のインターフェイスを介してアクセス可能なネットワーク サーバーから IP アドレスを要求できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-747">If RARP is enabled by the application, it can use the RARP protocol to request an IP address from the network server accessible through the interface that has a zero IP address.</span></span>

### <a name="rarp-enable"></a><span data-ttu-id="b06e6-748">RARP 有効化</span><span class="sxs-lookup"><span data-stu-id="b06e6-748">RARP Enable</span></span>

<span data-ttu-id="b06e6-749">RARP を使用するには、アプリケーションで IP アドレスが 0 の IP インスタンスを作成してから、サービス ***nx_rarp_enable*** を使用して RARP を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-749">To use RARP, the application must create the IP instance with an IP address of zero, then enable RARP using the service ***nx_rarp_enable***.</span></span> <span data-ttu-id="b06e6-750">マルチホーム システムの場合は、IP インスタンスに関連付けられている少なくとも 1 つのネットワーク デバイスの IP アドレスが 0 である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-750">For multihome systems, at least one network device associated with the IP instance must have an IP address of zero.</span></span> <span data-ttu-id="b06e6-751">RARP の処理では、ネットワークに指定された IP アドレスを持つ有効な RARP 応答を受信するまで、IP アドレスを必要とする NetX Duo システムの RARP 要求メッセージが定期的に送信されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-751">The RARP processing periodically sends RARP request messages for the NetX Duo system requiring an IP address until a valid RARP reply with the network designated IP address is received.</span></span> <span data-ttu-id="b06e6-752">この時点で、RARP 処理は完了します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-752">At this point, RARP processing is complete.</span></span>

<span data-ttu-id="b06e6-753">RARP は、有効化された後ですべてのインターフェイス アドレスが解決されると、自動的に無効になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-753">After RARP has been enabled, it is disabled automatically after all interface addresses are resolved.</span></span> <span data-ttu-id="b06e6-754">アプリケーションは、サービス ***nx_rarp_disable*** を使用して、RARP を強制的に終了させることができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-754">The application may force RARP to terminate by using the service ***nx_rarp_disable***.</span></span>

### <a name="rarp-request"></a><span data-ttu-id="b06e6-755">RARP 要求</span><span class="sxs-lookup"><span data-stu-id="b06e6-755">RARP Request</span></span>

<span data-ttu-id="b06e6-756">RARP 要求パケットの形式は、[図 6](#arp-messages) に示されている ARP パケットとほぼ同じです。唯一の違いは、フレームの種類フィールドが 0x8035 で、*操作コード* フィールドが 3 で RARP 要求が指定されていることです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-756">The format of an RARP request packet is almost identical to the ARP packet shown in [Figure 6](#arp-messages).The only difference is the frame type field is 0x8035 and the *Operation Code* field is 3, designating an RARP request.</span></span> <span data-ttu-id="b06e6-757">前述のように、ネットワークで割り当てられた IP アドレスを持つ RARP 応答を受信するまで、RARP 要求は定期的に送信されます (***NX_RARP_UPDATE_RATE*** 秒ごと)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-757">As mentioned previously, RARP requests will be sent periodically (every ***NX_RARP_UPDATE_RATE*** seconds) until a RARP reply with the network assigned IP address is received.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-758">*TCP/IP 実装のすべての RARP メッセージは、\*\*ビッグ エンディアン*\* 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-758">*All RARP messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="rarp-reply"></a><span data-ttu-id="b06e6-759">RARP 応答</span><span class="sxs-lookup"><span data-stu-id="b06e6-759">RARP Reply</span></span>

<span data-ttu-id="b06e6-760">RARP 応答メッセージはネットワークから受信され、このホストに対するネットワーク割り当て IP アドレスが格納されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-760">RARP reply messages are received from the network and contain the network assigned IP address for this host.</span></span> <span data-ttu-id="b06e6-761">RARP 応答パケットの形式は、図 6 に示されている ARP パケットとほぼ同じです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-761">The format of an RARP reply packet is almost identical to the ARP packet shown in Figure 6.</span></span> <span data-ttu-id="b06e6-762">唯一の違いは、フレームの種類フィールドが 0x8035 で、*操作コード* フィールドは 4 で、RARP 応答を指定することです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-762">The only difference is the frame type field is 0x8035 and the *Operation Code* field is 4, which designates an RARP reply.</span></span> <span data-ttu-id="b06e6-763">受信後に、IP アドレスが IP インスタンスで設定され、RARP の定期的な要求は無効になり、IP インスタンスで通常のネットワーク操作ができるようになります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-763">After received, the IP address is setup in the IP instance, the periodic RARP request is disabled, and the IP instance is now ready for normal network operation.</span></span>

<span data-ttu-id="b06e6-764">マルチホーム ホストでは、要求元のネットワーク インターフェイスに IP アドレスが適用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-764">For multihome hosts, the IP address is applied to the requesting network interface.</span></span> <span data-ttu-id="b06e6-765">まだ IP アドレスの割り当てを要求している他のネットワーク インターフェイスがある場合、すべてのインターフェイス IP アドレス要求が解決されるまで、定期的に RARP サービスが続行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-765">If there are other network interfaces still requesting an IP address assignment, the periodic RARP service continues until all interface IP address requests are resolved.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-766">*アプリケーションでは、RARP 処理が完了するまで IP インスタンスを使用しないようにします。\*\*nx_ip_status_check*\* は、アプリケーションで RARP の完了を待機するために使用される場合があります。マルチホーム システムの場合、要求しているインターフェイスで RARP 処理が完了するまで、アプリケーションによってそのインターフェイスが使用されないようにします。セカンダリ デバイスの IP アドレスの状態は、**nx_ip_interface_status_check** サービスを使用して確認できます。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-766">*The application should not use the IP instance until the RARP processing is complete. The **nx_ip_status_check** may be used by applications to wait for the RARP completion. For multihome systems, the application should not use the requesting interface until the RARP processing is complete on that interface. Status of the IP address on the secondary device can be checked with the **nx_ip_interface_status_check** service.*</span></span>

### <a name="rarp-statistics-and-errors"></a><span data-ttu-id="b06e6-767">RARP の統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b06e6-767">RARP Statistics and Errors</span></span>

<span data-ttu-id="b06e6-768">有効にすると、NetX Duo RARP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-768">If enabled, the NetX Duo RARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b06e6-769">次の統計およびエラー レポートは、IP の RARP 処理ごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-769">The following statistics and error reports are maintained for each IP's RARP processing:</span></span>

- <span data-ttu-id="b06e6-770">送信された RARP 要求の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-770">Total RARP Requests Sent</span></span>
- <span data-ttu-id="b06e6-771">受信した RARP 応答の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-771">Total RARP Responses Received</span></span>
- <span data-ttu-id="b06e6-772">RARP 無効メッセージの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-772">Total RARP Invalid Messages</span></span>

<span data-ttu-id="b06e6-773">これらの統計およびエラー レポートはすべて、***nx_rarp_info_get*** サービスを使用してアプリケーションで利用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-773">All these statistics and error reports are available to the application with the ***nx_rarp_info_get*** service.</span></span>

## <a name="internet-control-message-protocol-icmp"></a><span data-ttu-id="b06e6-774">インターネット制御メッセージ プロトコル (ICMP)</span><span class="sxs-lookup"><span data-stu-id="b06e6-774">Internet Control Message Protocol (ICMP)</span></span>

<span data-ttu-id="b06e6-775">IPv4 のインターネット制御メッセージ プロトコル (ICMP) は、IP ネットワークのメンバー間でエラーおよび制御情報を渡すことに制限されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-775">Internet Control Message Protocol for IPv4 (ICMP) is limited to passing error and control information between IP network members.</span></span> <span data-ttu-id="b06e6-776">IPv6 のインターネット制御メッセージ プロトコル (ICMPv6) も、エラーおよび制御情報を処理します。ICMPv6 は、重複アドレス検出 (DAD) やステートレス アドレス自動構成などのアドレス解決プロトコルに必要です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-776">Internet Control Message Protocol for IPv6 (ICMPv6) also handles error and control information and is required for address resolution protocols such as Duplicate Address Detection (DAD) and stateless address autoconfiguration.</span></span>

<span data-ttu-id="b06e6-777">他のほとんどのアプリケーション レイヤー (TCP/IP など) メッセージと同様に、ICMP および IPv6 メッセージは ICMP (または IPv6) プロトコルの指定を使用して IP ヘッダーでカプセル化されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-777">Like most other application layer (e.g., TCP/IP) messages, ICMP and ICMPv6 messages are encapsulated by an IP header with the ICMP (or ICMPv6) protocol designation.</span></span>

### <a name="icmp-statistics-and-errors"></a><span data-ttu-id="b06e6-778">ICMP の統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b06e6-778">ICMP Statistics and Errors</span></span>

<span data-ttu-id="b06e6-779">有効にした場合、NetX Duo では、アプリケーションに役立つ可能性のあるいくつかの ICMP 統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-779">If enabled, NetX Duo keeps track of several ICMP statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b06e6-780">次の統計およびエラー レポートは、IP の ICMP 処理ごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-780">The following statistics and error reports are maintained for each IP's ICMP processing:</span></span> 

- <span data-ttu-id="b06e6-781">送信された ICMP ping の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-781">Total ICMP Pings Sent</span></span>  
- <span data-ttu-id="b06e6-782">ICMP ping タイムアウトの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-782">Total ICMP Ping Timeouts</span></span> 
- <span data-ttu-id="b06e6-783">中断された ICMP ping スレッドの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-783">Total ICMP Ping Threads Suspended</span></span> 
- <span data-ttu-id="b06e6-784">受信した ICMP ping 応答の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-784">Total ICMP Ping Responses Received</span></span> 
- <span data-ttu-id="b06e6-785">ICMP チェックサム エラーの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-785">Total ICMP Checksum Errors</span></span> 
- <span data-ttu-id="b06e6-786">未処理の ICMP メッセージの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-786">Total ICMP Unhandled Messages</span></span> 

<span data-ttu-id="b06e6-787">これらの統計およびエラー レポートはすべて、***nx_icmp_info_get*** サービスを使用してアプリケーションで利用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-787">All these statistics and error reports are available to the application with the ***nx_icmp_info_get*** service.</span></span>

## <a name="icmpv4-services-in-netx-duo"></a><span data-ttu-id="b06e6-788">NetX Duo の ICMPv4 サービス</span><span class="sxs-lookup"><span data-stu-id="b06e6-788">ICMPv4 Services in NetX Duo</span></span>

### <a name="icmpv4-enable"></a><span data-ttu-id="b06e6-789">ICMPv4 有効化</span><span class="sxs-lookup"><span data-stu-id="b06e6-789">ICMPv4 Enable</span></span>

<span data-ttu-id="b06e6-790">NetX Duo で ICMPv4 メッセージを処理する前に、アプリケーションは ***nx_icmp_enable*** サービスを呼び出して ICMPv4 処理を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-790">Before ICMPv4 messages can be processed by NetX Duo, the application must call the ***nx_icmp_enable*** service to enable ICMPv4 processing.</span></span> <span data-ttu-id="b06e6-791">この処理が完了すると、アプリケーションは ping 要求とフィールド受信 ping パケットを発行できるようになります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-791">After this is done, the application can issue ping requests and field incoming ping packets.</span></span>  

### <a name="icmpv4-echo-request"></a><span data-ttu-id="b06e6-792">ICMPv4 エコー要求</span><span class="sxs-lookup"><span data-stu-id="b06e6-792">ICMPv4 Echo Request</span></span>

<span data-ttu-id="b06e6-793">エコー要求は、通常、ホスト IP アドレスによって識別される、ネットワークにある特定ノードの存在を確認するために使用される ICMPv4 メッセージの 1 つの種類です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-793">An echo request is one type of ICMPv4 message that is typically used to check for the existence of a specific node on the network, as identified by its host IP address.</span></span> <span data-ttu-id="b06e6-794">一般的な ping コマンドは、ICMP エコー要求/エコー応答メッセージを使用して実装されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-794">The popular ping command is implemented using ICMP echo request/echo reply messages.</span></span> <span data-ttu-id="b06e6-795">特定のホストが存在する場合、そのネットワーク スタックは ping の要求と応答を ping 応答と共に処理します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-795">If the specific host is present, its network stack processes the ping request and responses with a ping response.</span></span> <span data-ttu-id="b06e6-796">図 7 では、ICMPv4 ping メッセージの形式について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-796">Figure 7 details the ICMPv4 ping message format.</span></span>

![ICMPv4 ping メッセージ](./media/user-guide/icmpv4-ping-message.png)  

<span data-ttu-id="b06e6-798">**図 7. ICMPv4 ping メッセージ**</span><span class="sxs-lookup"><span data-stu-id="b06e6-798">**FIGURE 7. ICMPv4 Ping Message**</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-799">*TCP/IP 実装のすべての ICMPv4 メッセージは、\*\*ビッグ エンディアン*\* 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-799">*All ICMPv4 messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="b06e6-800">次に、ICMPv4 ヘッダー形式について説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-800">The following describes the ICMPv4 header format:</span></span>

|<span data-ttu-id="b06e6-801">ヘッダー フィールド</span><span class="sxs-lookup"><span data-stu-id="b06e6-801">Header Field</span></span> |<span data-ttu-id="b06e6-802">目的</span><span class="sxs-lookup"><span data-stu-id="b06e6-802">Purpose</span></span> |
|---|---|
|<span data-ttu-id="b06e6-803">**Type**</span><span class="sxs-lookup"><span data-stu-id="b06e6-803">**Type**</span></span> |<span data-ttu-id="b06e6-804">このフィールドでは、ICMPv4 メッセージを指定します (ビット 31 ～ 24)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-804">This field specifies the ICMPv4 message (bits 31-24).</span></span> <span data-ttu-id="b06e6-805">最も一般的なものを次に示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-805">The most common are:</span></span><br /><span data-ttu-id="b06e6-806">-  0: エコー応答</span><span class="sxs-lookup"><span data-stu-id="b06e6-806">-  0: Echo Reply</span></span><br /><span data-ttu-id="b06e6-807">- 3: 宛先は到達不能です</span><span class="sxs-lookup"><span data-stu-id="b06e6-807">- 3: Destination Unreachable</span></span><br /><span data-ttu-id="b06e6-808">- 8: エコー要求</span><span class="sxs-lookup"><span data-stu-id="b06e6-808">- 8: Echo Request</span></span><br /><span data-ttu-id="b06e6-809">- 11: 時間超過</span><span class="sxs-lookup"><span data-stu-id="b06e6-809">- 11: Time Exceeded</span></span><br /><span data-ttu-id="b06e6-810">- 12: パラメーターの問題</span><span class="sxs-lookup"><span data-stu-id="b06e6-810">- 12: Parameter Problem</span></span> |
|<span data-ttu-id="b06e6-811">"**コード**"</span><span class="sxs-lookup"><span data-stu-id="b06e6-811">**Code**</span></span> |<span data-ttu-id="b06e6-812">このフィールドは、タイプ フィールドに固有のコンテキストです (ビット 23 ～ 16)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-812">This field is context specific on the type field (bits 23-16).</span></span> <span data-ttu-id="b06e6-813">エコー要求または応答の場合、コードは 0 に設定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-813">For an echo request or reply the code is set to zero.</span></span>|
|<span data-ttu-id="b06e6-814">**チェックサム**</span><span class="sxs-lookup"><span data-stu-id="b06e6-814">**Checksum**</span></span> |<span data-ttu-id="b06e6-815">このフィールドには、タイプ フィールドで始まる ICMPv4 ヘッダー全体を含めた、ICMPv4 メッセージの 1 の補数和の 16 ビット チェックサムが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-815">This field contains the 16-bit checksum of the one's complement sum of the ICMPv4 message including the entire the ICMPv4 header starting with the Type field.</span></span> <span data-ttu-id="b06e6-816">チェックサムを生成する前に、チェックサム フィールドはクリアされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-816">Before generating the checksum, the checksum field is cleared.</span></span>|
|<span data-ttu-id="b06e6-817">**[識別]**</span><span class="sxs-lookup"><span data-stu-id="b06e6-817">**Identification**</span></span> | <span data-ttu-id="b06e6-818">このフィールドには、ホストを識別する ID 値が格納されています。ホストは、ECHO REPLY のエコー要求から抽出された ID を使用する必要があります (ビット 31 ～ 16)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-818">This field contains an ID value identifying the host; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span>|
|<span data-ttu-id="b06e6-819">**Sequence number**</span><span class="sxs-lookup"><span data-stu-id="b06e6-819">**Sequence number**</span></span> |<span data-ttu-id="b06e6-820">このフィールドには、ID 値が格納されています。ホストは、ECHO REPLY のエコー要求から抽出された ID を使用する必要があります (ビット 31 ～ 16)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-820">This field contains an ID value; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span> <span data-ttu-id="b06e6-821">識別子フィールドとは異なり、この値は同じホストからの後続のエコー要求で変更されます (ビット 15 ～ 0)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-821">Unlike the identifier field, this value will change in a subsequent Echo request from the same host (bits 15-0).</span></span>|

### <a name="icmpv4-echo-response"></a><span data-ttu-id="b06e6-822">ICMPv4 エコー応答</span><span class="sxs-lookup"><span data-stu-id="b06e6-822">ICMPv4 Echo Response</span></span>    
<span data-ttu-id="b06e6-823">ping 応答は、外部の ping 要求に応答して ICMP コンポーネントによって内部的に生成される別の種類の ICMP メッセージです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-823">A ping response is another type of ICMP message that is generated internally by the ICMP component in response to an external ping request.</span></span> <span data-ttu-id="b06e6-824">ping 応答には、確認応答に加えて、ping 要求に指定されたユーザー データのコピーも含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-824">In addition to acknowledgement, the ping response also contains a copy of the user data supplied in the ping request.</span></span>

### <a name="icmpv4-error-messages"></a><span data-ttu-id="b06e6-825">ICMPv4 エラー メッセージ</span><span class="sxs-lookup"><span data-stu-id="b06e6-825">ICMPv4 Error Messages</span></span>   
<span data-ttu-id="b06e6-826">NetX Duo では、次の ICMPv4 エラー メッセージがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-826">The following ICMPv4 error messages are supported in NetX Duo:</span></span> 
- <span data-ttu-id="b06e6-827">宛先は到達不能です</span><span class="sxs-lookup"><span data-stu-id="b06e6-827">Destination Unreachable</span></span> 
- <span data-ttu-id="b06e6-828">時間超過</span><span class="sxs-lookup"><span data-stu-id="b06e6-828">Time Exceed</span></span> 
- <span data-ttu-id="b06e6-829">パラメーターの問題</span><span class="sxs-lookup"><span data-stu-id="b06e6-829">Parameter Problem</span></span>

## <a name="internet-group-management-protocol-igmp"></a><span data-ttu-id="b06e6-830">インターネット グループ管理プロトコル (IGMP)</span><span class="sxs-lookup"><span data-stu-id="b06e6-830">Internet Group Management Protocol (IGMP)</span></span>

<span data-ttu-id="b06e6-831">インターネット グループ管理プロトコル (IGMP) は、受信または参加を意図している近隣やそのルーターと通信するデバイスに、IPv4 マルチキャスト グループを提供します (RFC 1112 および RFC 2236)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-831">The Internet Group Management Protocol (IGMP) provides a device to communicate with its neighbors and its routers that it intends to receive, or join, an IPv4 multicast group (RFC 1112 and RFC 2236).</span></span> <span data-ttu-id="b06e6-832">マルチキャスト グループは、基本的にはネットワーク メンバーの動的なコレクションであり、クラス D の IP アドレスで表されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-832">A multicast group is basically a dynamic collection of network members and is represented by a Class D IP address.</span></span> <span data-ttu-id="b06e6-833">マルチキャスト グループのメンバーは、いつでも離脱することができ、新しいメンバーはいつでも参加できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-833">Members of the multicast group may leave at any time, and new members may join at any time.</span></span> <span data-ttu-id="b06e6-834">グループへの参加と離脱に関係する調整は、IGMP の役割です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-834">The coordination involved in joining and leaving the group is the responsibility of IGMP.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-835">*IGMP は IPv4 マルチキャスト グループ専用に設計されています。IPv6 ネットワークでは使用できません。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-835">*IGMP is designed only for IPv4 multicast groups. It cannot be used on the IPv6 network.*</span></span>

### <a name="igmp-enable"></a><span data-ttu-id="b06e6-836">IGMP 有効化</span><span class="sxs-lookup"><span data-stu-id="b06e6-836">IGMP Enable</span></span>     
<span data-ttu-id="b06e6-837">NetX Duo でマルチキャスト アクティビティを実行する前に、アプリケーションで ***nx_igmp_enable*** サービスを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-837">Before any multicasting activity can take place in NetX Duo, the application must call the ***nx_igmp_enable*** service.</span></span> <span data-ttu-id="b06e6-838">このサービスによって、マルチキャスト要求に対する準備の基本的な IGMP 初期化が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-838">This service performs basic IGMP initialization in preparation for multicast requests.</span></span>

### <a name="multicast-ipv4-addressing"></a><span data-ttu-id="b06e6-839">マルチキャスト IPv4 アドレス指定</span><span class="sxs-lookup"><span data-stu-id="b06e6-839">Multicast IPv4 Addressing</span></span>  
<span data-ttu-id="b06e6-840">前述のように、マルチキャスト アドレスは、[図 4](#ipv4-addresses) に示すように、実際にはクラス D の IP アドレスです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-840">As mentioned previously, multicast addresses are actually Class D IP addresses as shown in [Figure 4](#ipv4-addresses).</span></span> <span data-ttu-id="b06e6-841">クラス D アドレスの下位 28 ビットは、マルチキャスト グループ ID に対応しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-841">The lower 28-bits of the Class D address correspond to the multicast group ID.</span></span> <span data-ttu-id="b06e6-842">あらかじめ定義されているマルチキャスト アドレスがいくつかあります。ただし、IGMP 処理には、"*すべてのホスト アドレス*" (244.0.0.1) が特に重要です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-842">There are a series of pre-defined multicast addresses; however, the *all hosts address* (244.0.0.1) is particularly important to IGMP processing.</span></span> <span data-ttu-id="b06e6-843">"*すべてのホスト アドレス*" は、ルーターが、すべてのマルチキャスト メンバーを照会して、所属するマルチキャスト グループを報告するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-843">The *all hosts address* is used by routers to query all multicast members to report on which multicast groups they belong to.</span></span>  

### <a name="physical-address-mapping-in-ipv4"></a><span data-ttu-id="b06e6-844">IPv4 での物理アドレスのマッピング</span><span class="sxs-lookup"><span data-stu-id="b06e6-844">Physical Address Mapping in IPv4</span></span>
<span data-ttu-id="b06e6-845">クラス D マルチキャスト アドレスは、01.00.5e.00.00.00 から 01.00.5e.7f.ff.ff の範囲内の物理イーサネット アドレスに直接マップされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-845">Class D multicast addresses map directly to physical Ethernet addresses ranging from 01.00.5e.00.00.00 through 01.00.5e.7f.ff.ff.</span></span> <span data-ttu-id="b06e6-846">IP マルチキャスト アドレスの下位 23 ビットは、イーサネット アドレスの下位 23 ビットに直接マップされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-846">The lower 23 bits of the IP multicast address map directly to the lower 23 bits of the Ethernet address.</span></span>

### <a name="multicast-group-join"></a><span data-ttu-id="b06e6-847">マルチキャスト グループ参加</span><span class="sxs-lookup"><span data-stu-id="b06e6-847">Multicast Group Join</span></span>
<span data-ttu-id="b06e6-848">特定のマルチキャスト グループに参加する必要があるアプリケーションでは、***nx_igmp_multicast_join*** サービスを呼び出して参加することができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-848">Applications that need to join a particular multicast group may do so by calling the ***nx_igmp_multicast_join*** service.</span></span> <span data-ttu-id="b06e6-849">このサービスは、このマルチキャスト グループに参加する要求の数を追跡します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-849">This service keeps track of the number of requests to join this multicast group.</span></span> <span data-ttu-id="b06e6-850">これがマルチキャスト グループに参加するアプリケーションの最初の要求である場合は、このホストがグループに参加することを示す IGMP レポートがプライマリ ネットワークに送信されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-850">If this is the first application requestto join the multicast group, an IGMP report is sent out on the primary network indicating this host's intention to join the group.</span></span> <span data-ttu-id="b06e6-851">次に、ネットワーク ドライバーを呼び出して、このマルチキャスト グループのイーサネット アドレスを持つパケットをリッスンするように設定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-851">Next, the network driver is called to set up for listening for packets with the Ethernet address for this multicast group.</span></span>

<span data-ttu-id="b06e6-852">マルチホーム システムでは、特定のインターフェイスを介してマルチキャスト グループにアクセスできる場合、アプリケーションではサービス ***nx_igmp_multicast_interface_join** _ を、プライマリ ネットワーク上のマルチキャスト グループに限定された _*_nx_igmp_multicast_join_\*\* の代わりに使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-852">In a multihome system, if the multicast group is accessible via a specific interface, application shall use the service ***nx_igmp_multicast_interface_join** _ instead of _*_nx_igmp_multicast_join_\*\*, which is limited to multicast groups on the primary network.</span></span>

### <a name="multicast-group-leave"></a><span data-ttu-id="b06e6-853">マルチキャスト グループ脱退</span><span class="sxs-lookup"><span data-stu-id="b06e6-853">Multicast Group Leave</span></span>   
<span data-ttu-id="b06e6-854">以前に参加したマルチキャスト グループを離脱する必要があるアプリケーションでは、***nx_igmp_multicast_leave*** サービスを呼び出すことによってこれを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-854">Applications that need to leave a previously joined multicast group may do so by calling the ***nx_igmp_multicast_leave*** service.</span></span> <span data-ttu-id="b06e6-855">このサービスは、グループへの参加回数に関連付けられた内部カウントを減らします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-855">This service reduces the internal count associated with how many times the group was joined.</span></span> <span data-ttu-id="b06e6-856">グループに対する未処理の参加要求がない場合、このマルチキャスト グループのイーサネット アドレスを持つパケットのリッスンを無効にするために、ネットワーク ドライバーが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-856">If there are no outstanding join requests for a group, the network driver is called to disable listening for packets with this multicast group's Ethernet address.</span></span>

### <a name="multicast-loopback"></a><span data-ttu-id="b06e6-857">マルチキャスト ループバック</span><span class="sxs-lookup"><span data-stu-id="b06e6-857">Multicast Loopback</span></span>    
<span data-ttu-id="b06e6-858">アプリケーションでは、同じノードのいずれかのソースから送信されたマルチキャスト トラフィックを受信したい場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-858">An application may wish to receive multicast traffic originated from one of the sources on the same node.</span></span> <span data-ttu-id="b06e6-859">これには、サービス ***nx_igmp_loopback_enable*** を使用して、IP マルチキャスト コンポーネントでループバックが有効になっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-859">This requires the IP multicast component to have loopback enabled by using the service ***nx_igmp_loopback_enable***.</span></span>

### <a name="igmp-report-message"></a><span data-ttu-id="b06e6-860">IGMP レポート メッセージ</span><span class="sxs-lookup"><span data-stu-id="b06e6-860">IGMP Report Message</span></span>      
<span data-ttu-id="b06e6-861">アプリケーションがマルチキャスト グループに参加すると、IGMP レポート メッセージがネットワーク経由で送信され、ホストが特定のマルチキャスト グループに参加することが示されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-861">When the application joins a multicast group, an IGMP report message is sent via the network to indicate the host's intention to join a particular multicast group.</span></span> <span data-ttu-id="b06e6-862">IGMP レポート メッセージの形式を図 8 に示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-862">The format of the IGMP report message is shown in Figure 8.</span></span> <span data-ttu-id="b06e6-863">マルチキャスト グループ アドレスは、IGMP レポート メッセージのグループ メッセージと宛先 IP アドレスの両方に使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-863">The multicast group address is used for both the group message in the IGMP report message and the destination IP address.</span></span>

<span data-ttu-id="b06e6-864">上の図 (図 8) では、IGMP ヘッダーには、バージョン/タイプ フィールド、最大応答</span><span class="sxs-lookup"><span data-stu-id="b06e6-864">In the figure above (Figure 8), the IGMP header contains a version/type field, maximum response</span></span>

![IGMP レポート メッセージの図。](./media/user-guide/image17.jpg)

<span data-ttu-id="b06e6-866">**図 8. IGMP レポート メッセージ**</span><span class="sxs-lookup"><span data-stu-id="b06e6-866">**FIGURE 8. IGMP Report Message**</span></span>

<span data-ttu-id="b06e6-867">時間、チェックサム フィールド、およびマルチキャスト グループ アドレス フィールドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-867">time, a checksum field, and a multicast group address field.</span></span> <span data-ttu-id="b06e6-868">IGMPv1 メッセージの場合、最大応答時間フィールドは、IGMPv1 プロトコルの一部ではないため、常に 0 に設定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-868">For IGMPv1 messages, the Maximum Response Time field is always set to zero, as this is not part of the IGMPv1 protocol.</span></span> <span data-ttu-id="b06e6-869">最大応答時間フィールドは、IGMPv2 プロトコルで定義されているように、ホストがクエリ タイプとして IGMP メッセージを受信したときに設定され、ホストが別のホストのレポート タイプのメッセージを受信したときにクリアされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-869">The Maximum Response Time field is set when the host receives a Query type IGMP message and cleared when a host receives another host's Report type message as defined by the IGMPv2 protocol.</span></span>

<span data-ttu-id="b06e6-870">次に、IGMP ヘッダー形式について説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-870">The following describes the IGMP header format:</span></span>

|<span data-ttu-id="b06e6-871">ヘッダー フィールド</span><span class="sxs-lookup"><span data-stu-id="b06e6-871">Header Field</span></span>|<span data-ttu-id="b06e6-872">目的</span><span class="sxs-lookup"><span data-stu-id="b06e6-872">Purpose</span></span>|
|---|---|
|<span data-ttu-id="b06e6-873">**[バージョン]**</span><span class="sxs-lookup"><span data-stu-id="b06e6-873">**Version**</span></span> |<span data-ttu-id="b06e6-874">このフィールドでは、IGMP バージョンを指定します (ビット 31 ～ 28)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-874">This field specifies the IGMP version (bits 31- 28).</span></span>|
|<span data-ttu-id="b06e6-875">**Type**</span><span class="sxs-lookup"><span data-stu-id="b06e6-875">**Type**</span></span> |<span data-ttu-id="b06e6-876">このフィールドでは、IGMP メッセージのタイプを指定します (ビット 27 ～ 24)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-876">This field specifies the type of IGMP message (bits 27 -24).</span></span>|
|<span data-ttu-id="b06e6-877">**最大応答時間**</span><span class="sxs-lookup"><span data-stu-id="b06e6-877">**Maximum Response Time**</span></span> |<span data-ttu-id="b06e6-878">IGMP v1 では使用されません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-878">Not used in IGMP v1.</span></span> <span data-ttu-id="b06e6-879">IGMP v2 では、このフィールドは最大応答時間として機能します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-879">In IGMP v2 this field serves as the maximum response time.</span></span>|
|<span data-ttu-id="b06e6-880">**チェックサム**</span><span class="sxs-lookup"><span data-stu-id="b06e6-880">**Checksum**</span></span> |<span data-ttu-id="b06e6-881">このフィールドには、IGMP バージョンで始まる IGMP メッセージの 1 の補数和の 16 ビット チェックサムが格納されます (ビット 0 ～ 15)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-881">This field contains the 16-bit checksum of the one's complement sum of the IGMP message starting with the IGMP version (bits 0-15)</span></span>|
|<span data-ttu-id="b06e6-882">**グループ アドレス**</span><span class="sxs-lookup"><span data-stu-id="b06e6-882">**Group Address**</span></span> |<span data-ttu-id="b06e6-883">32 ビット クラス D グループ IP アドレス</span><span class="sxs-lookup"><span data-stu-id="b06e6-883">32-bit class D group IP address</span></span>|

<span data-ttu-id="b06e6-884">IGMP レポート メッセージは、マルチキャスト ルーターによって送信される IGMP クエリ メッセージに応答して送信されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-884">IGMP report messages are also sent in response to IGMP query messages sent by a multicast router.</span></span> <span data-ttu-id="b06e6-885">マルチキャスト ルーターは、クエリ メッセージを定期的に送信して、まだグループ メンバーシップが必要なホストを確認します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-885">Multicast routers periodically send query messages out to see which hosts still require group membership.</span></span> <span data-ttu-id="b06e6-886">クエリ メッセージの形式は、図 8 に示す IGMP レポート メッセージと同じです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-886">Query messages have the same format as the IGMP Report message shown in Figure 8.</span></span> <span data-ttu-id="b06e6-887">唯一の違いは、IGMP タイプが 1 で、グループ アドレス フィールドが 0 に設定されていることです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-887">The only differences are the IGMP type is equal to 1 and the group address field is set to 0.</span></span> <span data-ttu-id="b06e6-888">IGMP クエリ メッセージは、マルチキャスト ルーターによって "*すべてのホスト*" の IP アドレスに送信されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-888">IGMP Query messages are sent to the *all hosts* IP address by the multicast router.</span></span> <span data-ttu-id="b06e6-889">グループ メンバーシップを引き続き維持するホストは、別の IGMP レポート メッセージを送信することによって応答します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-889">A host that still wishes to maintain group membership responds by sending another IGMP Report message.</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-890">*TCP/IP 実装のすべてのメッセージは、\*\*ビッグ エンディアン*\* 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-890">*All messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="igmp-statistics-and-errors"></a><span data-ttu-id="b06e6-891">IGMP の統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b06e6-891">IGMP Statistics and Errors</span></span>    
<th><p><span data-ttu-id="b06e6-892">有効にすると、NetX Duo IGMP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-892">If enabled, the NetX Duo IGMP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b06e6-893">次の統計およびエラー レポートは、IP の IGMP 処理ごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-893">The following statistics and error reports are maintained for each IP's IGMP processing:</span></span> 

- <span data-ttu-id="b06e6-894">送信された IGMP レポートの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-894">Total IGMP Reports Sent</span></span> 
- <span data-ttu-id="b06e6-895">受信した IGMP クエリの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-895">Total IGMP Queries Received</span></span> 
- <span data-ttu-id="b06e6-896">IGMP チェックサム エラーの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-896">Total IGMP Checksum Errors</span></span> 
- <span data-ttu-id="b06e6-897">現在参加している IGMP グループの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-897">Total IGMP Current Groups Joined</span></span> 

<span data-ttu-id="b06e6-898">これらの統計およびエラー レポートはすべて、***nx_igmp_info_get*** サービスを使用してアプリケーションで利用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-898">All these statistics and error reports are available to the application with the ***nx_igmp_info_get*** service.</span></span> 

### <a name="multicast-without-igmp"></a><span data-ttu-id="b06e6-899">IGMP なしのマルチキャスト</span><span class="sxs-lookup"><span data-stu-id="b06e6-899">Multicast without IGMP</span></span>  
<span data-ttu-id="b06e6-900">IPv4 マルチキャスト トラフィックを想定しているアプリケーションでは、サービス ***nx_ipv4_multicast_interface_join*** を使用すると、IGMP メッセージを呼び出さなくてもマルチキャスト グループ アドレスに参加できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-900">Application expecting IPv4 multicast traffic can join a multicast group address without invoking IGMP messages by using the service ***nx_ipv4_multicast_interface_join***.</span></span> <span data-ttu-id="b06e6-901">このサービスは、IPv4 レイヤーと、基になるインターフェイス ドライバーに対し、指定された IPv4 マルチキャスト アドレスからのパケットを受け入れるように指示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-901">This service instructs the IPv4 layer and the underlying interface driver to accept packets from the designated IPv4 multicast address.</span></span> <span data-ttu-id="b06e6-902">ただし、このグループに関して送信または処理されている IGMP グループ管理メッセージはありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-902">However there is no IGMP group management messages being sent or processed for this group.</span></span>

<span data-ttu-id="b06e6-903">グループからトラフィックを受信することを希望しなくなったアプリケーションでは、サービス ***nx_ipv4_multicast_interface_leave*** を使用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-903">Application no longer wish to receive traffic from the group can use the service ***nx_ipv4_multicast_interface_leave.***</span></span>

## <a name="ipv6-in-netx-duo"></a><span data-ttu-id="b06e6-904">NetX Duo での IPv6</span><span class="sxs-lookup"><span data-stu-id="b06e6-904">IPv6 in NetX Duo</span></span>

### <a name="ipv6-addresses"></a><span data-ttu-id="b06e6-905">IPv6 アドレス</span><span class="sxs-lookup"><span data-stu-id="b06e6-905">IPv6 Addresses</span></span>   
<span data-ttu-id="b06e6-906">IPv6 アドレスは 128 ビットです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-906">IPv6 addresses are 128 bits.</span></span> <span data-ttu-id="b06e6-907">IPv6 アドレスのアーキテクチャについては、RFC 4291 で説明されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-907">The architecture of IPv6 address is described in RFC 4291.</span></span> <span data-ttu-id="b06e6-908">アドレスは、最上位ビットを含むプレフィックスと、下位ビットを含むホスト アドレスに分けられます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-908">The address is divided into a prefix containing the most significant bits and a host address containing the lower bits.</span></span> <span data-ttu-id="b06e6-909">プレフィックスはアドレスの種類を示し、IPv4 ネットワークのネットワーク アドレスにほぼ相当します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-909">The prefix indicates the type of address and is roughly the equivalent of the network address in IPv4 network.</span></span>

<span data-ttu-id="b06e6-910">IPv6 には、ユニキャスト、エニーキャスト (NetX Duo ではサポートされていません)、マルチキャストの 3 種類のアドレス仕様があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-910">IPv6 has three types of address specifications: unicast, anycast (not supported in NetX Duo), and multicast.</span></span> <span data-ttu-id="b06e6-911">ユニキャスト アドレスは、インターネット上の特定のホストを識別する IP アドレスです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-911">Unicast addresses are those IP addresses that identify a specific host on the Internet.</span></span> <span data-ttu-id="b06e6-912">ユニキャスト アドレスには、送信元または宛先の IP アドレスを指定できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-912">Unicast addresses can be either a source or a destination IP address.</span></span> <span data-ttu-id="b06e6-913">マルチキャスト アドレスは、インターネット上のホストの動的なグループを指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-913">Multicast addresses specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="b06e6-914">マルチキャスト グループのメンバーは、いつでも参加し離脱することができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-914">Members of the multicast group may join and leave whenever they wish.</span></span>

<span data-ttu-id="b06e6-915">IPv6 には、IPv4 のブロードキャスト メカニズムに相当するものはありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-915">IPv6 does not have the equivalent of the IPv4 broadcast mechanism.</span></span> <span data-ttu-id="b06e6-916">すべてのホストにパケットを送信する機能は、リンクローカルの "すべてのホスト" マルチキャスト グループにパケットを送信することによって実現できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-916">The ability to send a packet to all hosts can be achieved by sending a packet to the link-local all hosts multicast group.</span></span>

<span data-ttu-id="b06e6-917">IPv6 では、マルチキャスト アドレスを利用して、近隣探索、ルーター発見、ステートレス アドレス自動構成の各手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-917">IPv6 utilizes multicast addresses to perform Neighbor Discovery, Router Discovery, and Stateless Address Auto Configuration procedures.</span></span>

<span data-ttu-id="b06e6-918">IPv6 のユニキャスト アドレスは 2 種類あります。1 つはリンクローカル アドレスで、これは通常、よく知られたリンクローカル プレフィックスをインターフェイス MAC アドレスと組み合わせて構築されます。もう 1 つはグローバル IP アドレスで、これにはプレフィックス部分とホスト ID 部分もあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-918">There are two types of IPv6 unicast addresses: link local addresses, typically constructed by combining the well-known link local prefix with the interface MAC address, and global IP addresses, which also has the prefix portion and the host ID portion.</span></span> <span data-ttu-id="b06e6-919">グローバル アドレスは、手動で構成することも、ステートレス アドレス自動構成または DHCPv6 によって構成することもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-919">A global address may be configured manually, or through the Stateless Address Autoconfiguration or DHCPv6.</span></span> <span data-ttu-id="b06e6-920">NetX Duo では、リンクローカル アドレスとグローバル アドレスの両方をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-920">NetX Duo supports both link local address and global address.</span></span>

<span data-ttu-id="b06e6-921">IPv4 と IPv6 の両形式に対応するために、NetX Duo では、IPv4 および IPv6 アドレスを保持するための新しいデータ型 NXD_ADDRESS を提供しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-921">To accommodate both IPv4 and IPv6 formats, NetX Duo provides a new data type, NXD_ADDRESS, for holding IPv4 and IPv6 addresses.</span></span> <span data-ttu-id="b06e6-922">この構造体の定義を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-922">The definition of this structure is shown below.</span></span> <span data-ttu-id="b06e6-923">アドレス フィールドは、IPv4 および IPv6 アドレスの和集合です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-923">The address field is a union of IPv4 and IPv6 addresses.</span></span>

```c
typedef struct NXD_ADDRESS_STRUCT
{
    ULONG nxd_ip_version;
    union
    {
        ULONG v4;
        ULONG v6[4];
    } nxd_ip_address;
} NXD_ADDRESS;
```

<span data-ttu-id="b06e6-924">NXD_ADDRESS 構造体では、最初の要素 *nxd_ip_version* は IPv4 または IPv6 バージョンを示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-924">In the NXD_ADDRESS structure, the first element, *nxd_ip_version*, indicates IPv4 or IPv6 version.</span></span> <span data-ttu-id="b06e6-925">サポートされている値は NX_IP_VERSION_V4 または NX_IP_VERSION_V6 です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-925">Supported values are either NX_IP_VERSION_V4 or NX_IP_VERSION_V6.</span></span> <span data-ttu-id="b06e6-926">*nxd_ip_version* は、*nxd_ip_address* 和集合のどのフィールドを IP アドレスとして使用するかを示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-926">*nxd_ip_version* indicates which field in the *nxd_ip_address* union to use as the IP address.</span></span> <span data-ttu-id="b06e6-927">NetX Duo API サービスでは通常、ULONG (32 ビット) IP アドレスの代わりに、NXD_ADDRESS 構造体へのポインターを入力引数に取ります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-927">NetX Duo API services typically take a pointer to NXD_ADDRESS structure as input argument in lieu of the ULONG (32 bit) IP address.</span></span>

### <a name="link-local-addresses"></a><span data-ttu-id="b06e6-928">リンクローカル アドレス</span><span class="sxs-lookup"><span data-stu-id="b06e6-928">Link Local Addresses</span></span>     
<span data-ttu-id="b06e6-929">リンクローカル アドレスは、ローカル ネットワーク上でのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-929">A link-local address is only valid on the local network.</span></span> <span data-ttu-id="b06e6-930">デバイスは、有効なリンクローカル アドレスが割り当てられた後に、同じネットワーク上の別のデバイスとの間でパケットを送受信できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-930">A device can send and receive packets to another device on the same network after a valid link local address is assigned to it.</span></span> <span data-ttu-id="b06e6-931">アプリケーションでリンクローカル アドレスを割り当てるには、プレフィックス長パラメーターを 10 に設定して NetX Duo サービス ***nxd_ipv6_address_set*** を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-931">An application assigns a link-local address by calling the NetX Duo service ***nxd_ipv6_address_set***, with the prefix length parameter set to 10.</span></span> <span data-ttu-id="b06e6-932">アプリケーションでは、リンクローカル アドレスをサービスに提供できます。または、単純に NX_NULL をリンクローカル アドレスとして使用し、デバイスの MAC アドレスに基づいて NetX Duo にリンクローカル アドレスを構築させることができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-932">The application may supply a link-local address to the service, or it may simply use NX_NULL as the link-local address and allow NetX Duo to construct a link-local address based on the device's MAC address.</span></span>

<span data-ttu-id="b06e6-933">次の例では、プライマリ デバイス (インデックス 0) で、その MAC アドレスを使用してプレフィックス長 10 のリンクローカル アドレスを構成するよう、NetX Duo に指示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-933">The following example instructs NetX Duo to configure the link-local address with a prefix length of 10 on the primary device (index 0) using its MAC address:</span></span>

```c
nxd_ipv6_address_set(ip_ptr, 0, NX_NULL, 10, NX_NULL);
```
<span data-ttu-id="b06e6-934">上記の例では、インターフェイスの MAC アドレスが 54:32:10:1A:BC:67 の場合、対応するリンクローカル アドレスは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-934">In the example above, if the MAC address of the interface is 54:32:10:1A:BC:67, the corresponding link-local address would be:</span></span>

```c
FE80::5632:10FF:FE1A:BC67
```
<span data-ttu-id="b06e6-935">IPv6 アドレスのホスト ID 部分 (**5632:10FF:FE1A:BC67**) は、6 バイトの MAC アドレスで構成され、次の変更が加えられます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-935">Note that the host ID portion of the IPv6 address (**5632:10FF:FE1A:BC67**) is made up of the 6-byte MAC address, with the following modifications:</span></span>

- <span data-ttu-id="b06e6-936">MAC アドレスのバイト 3 とバイト 4 の間に **0xFFFE** を挿入する</span><span class="sxs-lookup"><span data-stu-id="b06e6-936">**0xFFFE** inserted between byte 3 and byte 4 of the MAC address</span></span>
- <span data-ttu-id="b06e6-937">MAC アドレスの最初のバイトの最下位から 2 番目のビット (U/L ビット) を 1 に設定する</span><span class="sxs-lookup"><span data-stu-id="b06e6-937">Second lowest bit of the first byte of the MAC address (U/L bit) is set to 1</span></span>

<span data-ttu-id="b06e6-938">IPv6 アドレスのホスト部分をそのインターフェイス MAC アドレスから構築する方法の詳細については、RFC 2464 (イーサネット ネットワーク経由での IPv6 パケットの送信) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-938">Refer to RFC 2464 (Transmission of IPv6 Packets over Ethernet Network) for more information on how to construct the host portion of an IPv6 address from its interface MAC address.</span></span>

<span data-ttu-id="b06e6-939">IPv6 には、1 つ以上のホストにマルチキャスト メッセージを送信するための特殊なマルチキャスト アドレスがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-939">There are a few special multicast addresses for sending multicast messages to one or more hosts in IPv6:</span></span>

| <span data-ttu-id="b06e6-940">Group</span><span class="sxs-lookup"><span data-stu-id="b06e6-940">Group</span></span>  | <span data-ttu-id="b06e6-941">Address</span><span class="sxs-lookup"><span data-stu-id="b06e6-941">Address</span></span>   | <span data-ttu-id="b06e6-942">説明</span><span class="sxs-lookup"><span data-stu-id="b06e6-942">Description</span></span>  |
|---|---|---|
|<span data-ttu-id="b06e6-943">すべてのノード グループ</span><span class="sxs-lookup"><span data-stu-id="b06e6-943">All nodes group</span></span> |<span data-ttu-id="b06e6-944">**FF02::1**</span><span class="sxs-lookup"><span data-stu-id="b06e6-944">**FF02::1**</span></span> |<span data-ttu-id="b06e6-945">ローカル ネットワーク上のすべてのホスト</span><span class="sxs-lookup"><span data-stu-id="b06e6-945">All hosts on the local network</span></span>|
|<span data-ttu-id="b06e6-946">すべてのルーター グループ</span><span class="sxs-lookup"><span data-stu-id="b06e6-946">All routers group</span></span> |<span data-ttu-id="b06e6-947">**FF02::2**</span><span class="sxs-lookup"><span data-stu-id="b06e6-947">**FF02::2**</span></span> |<span data-ttu-id="b06e6-948">ローカル ネットワーク上のすべてのルーター</span><span class="sxs-lookup"><span data-stu-id="b06e6-948">All routers on the local network</span></span>|
|<span data-ttu-id="b06e6-949">要請ノード</span><span class="sxs-lookup"><span data-stu-id="b06e6-949">Solicited-node</span></span> |<span data-ttu-id="b06e6-950">**FF02::1:FF00:0/104**</span><span class="sxs-lookup"><span data-stu-id="b06e6-950">**FF02::1:FF00:0/104**</span></span> |<span data-ttu-id="b06e6-951">以下で説明</span><span class="sxs-lookup"><span data-stu-id="b06e6-951">Explained below</span></span>|

<span data-ttu-id="b06e6-952">要請ノード マルチキャスト アドレスのターゲットは、すべての IPv6 ホストではなくローカル リンク上の特定のホストです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-952">A solicited-node multicast address targets specific hosts on the local link rather than all the IPv6 hosts.</span></span> <span data-ttu-id="b06e6-953">104 ビットのプレフィックス **FF02::1:FF00:0/104** と、ターゲット IPv6 アドレスの最後の 24 ビットで構成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-953">It consists of the prefix **FF02::1:FF00:0/104**, which is 104 bits and the last 24-bits of the target IPv6 address.</span></span> <span data-ttu-id="b06e6-954">たとえば、IPv6 アドレスが **205B:209D:D028::F058:D1C8:1024** の場合、要請ノード マルチキャスト アドレスは **FF02::1:FFC8:1024** です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-954">For example, an IPv6 address **205B:209D:D028::F058:D1C8:1024** has a solicitednode multicast address of address **FF02::1:FFC8:1024**.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b06e6-955">*2 連コロン表記は、間にあるビットがすべてゼロであることを示します。\*\*FF02::1:FF00:0/104*\* を完全に展開すると、次のようになります。\* **FF02:0000:0000:0000:0000:0001:FF00:0000**</span><span class="sxs-lookup"><span data-stu-id="b06e6-955">*The double colon notation indicates the intervening bits are all zeroes. **FF02::1:FF00:0/104** fully expanded looks like* **FF02:0000:0000:0000:0000:0001:FF00:0000**</span></span>

### <a name="global-addresses"></a><span data-ttu-id="b06e6-956">グローバル アドレス</span><span class="sxs-lookup"><span data-stu-id="b06e6-956">Global Addresses</span></span>    
<span data-ttu-id="b06e6-957">IPv6 グローバル アドレスの例は **2001:0123:4567:89AB:CDEF::1** です。NetX Duo では、IPv6 アドレスを NXD_ADDRESS 構造体に格納します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-957">An example of an IPv6 global address is **2001:0123:4567:89AB:CDEF::1** NetX Duo stores IPv6 addresses in the NXD_ADDRESS structure.</span></span> <span data-ttu-id="b06e6-958">下記の例で、NXD_ADDRESS の **global_ipv6_address** 変数にはユニキャスト IPv6 アドレスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-958">In the example below, the NXD_ADDRESS variable **global_ipv6_address** contains a unicast IPv6 address.</span></span> <span data-ttu-id="b06e6-959">次の例は、そのプライマリ デバイスの固有 IPv6 グローバル アドレスを作成する NetX Duo デバイスを示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-959">The following example demonstrates a NetX Duo device creating a specific IPv6 global address for its primary device:</span></span>

```c
NXD_ADDRESS global_ipv6_address;
UINT        primary_interface_index = 0;

global_ipv6_address.nxd_ip_version = NX_IP_VERSION_V6;
global_ipv6_address.nxd_ip_address.v6[0] = 0x20010123;
global_ipv6_address.nxd_ip_address.v6[1] = 0x456789AB;
global_ipv6_address.nxd_ip_address.v6[2] = 0xCDEF0000;
global_ipv6_address.nxd_ip_address.v6[3] = 0x00000001;

status = nxd_ipv6_address_set(
            &ip_0,
            primary_interface_index,
            &global_ipv6_address,
            64,
            NX_NULL);
```
<span data-ttu-id="b06e6-960">この IPv6 アドレスのプレフィックスは **2001:0123:4567:89AB** であることに注意してください。これは 64 ビット長で、イーサネットのグローバル ユニキャスト IPv6 アドレスに共通のプレフィックス長です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-960">Note that the prefix of this IPv6 address is **2001:0123:4567:89AB**, which is 64 bits long and is a common prefix length for global unicast IPv6 addresses on Ethernet.</span></span>

<span data-ttu-id="b06e6-961">NXD_ADDRESS 構造体には IPv4 アドレスも保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-961">The NXD_ADDRESS structure also holds IPv4 addresses.</span></span> <span data-ttu-id="b06e6-962">global_ipv4_address に格納される IP アドレス **192.1.168.10** (**0xC001A80A**) のメモリ レイアウトは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-962">An IP address of **192.1.168.10** (**0xC001A80A**) stored in global_ipv4_address would have the following memory layout:</span></span>

|<span data-ttu-id="b06e6-963">フィールド</span><span class="sxs-lookup"><span data-stu-id="b06e6-963">Field</span></span> |<span data-ttu-id="b06e6-964">値</span><span class="sxs-lookup"><span data-stu-id="b06e6-964">Value</span></span> |
|---|---|
|<span data-ttu-id="b06e6-965">global_ipv4_address.nxd_ip_version</span><span class="sxs-lookup"><span data-stu-id="b06e6-965">global_ipv4_address.nxd_ip_version</span></span> |<span data-ttu-id="b06e6-966">NX_IP_VERSION_V4</span><span class="sxs-lookup"><span data-stu-id="b06e6-966">NX_IP_VERSION_V4</span></span>|
|<span data-ttu-id="b06e6-967">global_ipv4_address.nxd_ip_address.v4</span><span class="sxs-lookup"><span data-stu-id="b06e6-967">global_ipv4_address.nxd_ip_address.v4</span></span> |<span data-ttu-id="b06e6-968">0xC001A80A</span><span class="sxs-lookup"><span data-stu-id="b06e6-968">0xC001A80A</span></span>|

<span data-ttu-id="b06e6-969">アプリケーションで NetX Duo サービスにアドレスを渡すとき、*nxd_ip_version* フィールドでは、適切なパケット処理のために正しい IP バージョンを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-969">When an application passes an address to NetX Duo services, the *nxd_ip_version* field must specify the correct IP version for proper packet handling.</span></span>

<span data-ttu-id="b06e6-970">既存の NetX アプリケーションとの下位互換性のために、NetX Duo ではすべての NetX サービスをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-970">To be backward compatible with existing NetX applications, NetX Duo supports all NetX services.</span></span> <span data-ttu-id="b06e6-971">NetX Duo の内部では、実際の NetX Duo サービスに転送する前に ULONG 型の IPv4 アドレスが NXD_ADDRESS データ型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-971">Internally, NetX Duo converts the IPv4 address type ULONG to an NXD_ADDRESS data type before forwarding it to the actual NetX Duo service.</span></span>

<span data-ttu-id="b06e6-972">次の例は、NetX と NetX Duo のサービスの類似性と相違点を示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-972">The following example illustrates the similarity and the differences between services in NetX and NetX Duo.</span></span>

```c
/* Make a connection to the destination IPv4 address
   192.1.168.12 through an already created TCP socket bound
   to the well known HTTP port number 80. */

global_ipv4_address.nxd_ip_version = NX_IP_VERSION_V4;
global_ipv4_address.nxd_ip_address.v4 = 0xC001A80C;

nxd_tcp_client_socket_connect(&tcp_socket,
                              &global_ipv4_address,
                              port_number,
                              NX_WAIT_FOREVER);
```

<span data-ttu-id="b06e6-973">次に示すのは、同等の NetX API です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-973">The following is the equivalent NetX API:</span></span>

```c
ULONG         server_ip = 0xC001A80C;
NX_TCP_SOCKET tcp_socket;
UINT          port_number = 80;

nx_tcp_client_socket_connect(&tcp_socket,
                             server_ip,
                             port_number,
                             NX_WAIT_FOREVER); 
```

> [!IMPORTANT]
> <span data-ttu-id="b06e6-974">*アプリケーション開発者は、これらの API の nxd バージョンを使用することをお勧めします。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-974">*Application developers are encouraged to use the nxd version of these APIs*.</span></span>

### <a name="ipv6-default-routers"></a><span data-ttu-id="b06e6-975">IPv6 の既定のルーター</span><span class="sxs-lookup"><span data-stu-id="b06e6-975">IPv6 Default Routers</span></span>    
<span data-ttu-id="b06e6-976">IPv6 では、既定のルーターを使用して、オフリンクの宛先にパケットを転送します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-976">IPv6 uses a default router to forward packets to offlink destinations.</span></span> <span data-ttu-id="b06e6-977">NetX Duo サービス ***nxd_ipv6_default_router_add*** によって、アプリケーションで IPv6 ルーターを既定のルーター テーブルに追加できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-977">The NetX Duo service ***nxd_ipv6_default_router_add*** enables an application to add an IPv6 router to the default router table.</span></span> <span data-ttu-id="b06e6-978">NetX Duo によって提供されるその他の既定のルーター サービスについては、第 4 章「サービスの説明」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-978">See Chapter 4 "Description of Services" for more default router services offered by NetX Duo.</span></span>  

<span data-ttu-id="b06e6-979">IPv6 パケットを転送するとき、NetX Duo ではまず、パケットの宛先がオンリンクかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-979">When forwarding IPv6 packets, NetX Duo first checks if the packet destination is on-link.</span></span> <span data-ttu-id="b06e6-980">そうでない場合、NetX Duo は既定のルーティング テーブルを確認し、オフリンク パケットの転送先として有効なルーターを探します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-980">If not, NetX Duo checks the default routing table for a valid router to forward the off-link packet to.</span></span>  

<span data-ttu-id="b06e6-981">IPv6 の既定のルーター テーブルからルーターを削除するために、アプリケーションではサービス \***nxd_ipv6_default_router_delete** _ を使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-981">To remove a router from the IPv6 default router table, application shall use the service \***nxd_ipv6_default_router_delete** _.</span></span> <span data-ttu-id="b06e6-982">IPv6 の既定のルーター テーブルのエントリを取得するには、サービス _*_nxd_ipv6_default_router_entry_get_*\* を使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-982">To obtain entries of the IPv6 default router table, use the service _\*_nxd_ipv6_default_router_entry_get_\*\*.</span></span>

### <a name="ipv6-header"></a><span data-ttu-id="b06e6-983">IPv6 ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b06e6-983">IPv6 Header</span></span>    
<span data-ttu-id="b06e6-984">IPv6 ヘッダーには IPv4 ヘッダーからの変更点があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-984">The IPv6 header has been modified from the IPv4 header.</span></span> <span data-ttu-id="b06e6-985">パケットを割り当てるときに、呼び出し元でアプリケーション プロトコル (UDP、TCP など)、バッファー サイズ (バイト単位)、ホップ制限を指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-985">When allocating a packet, the caller specifies the application protocol (e.g., UDP, TCP), buffer size in bytes, and hop limit.</span></span>   

<span data-ttu-id="b06e6-986">図 9 に IPv6 ヘッダーの形式を、表にヘッダー コンポーネントの一覧を示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-986">Figure 9 shows the format of the IPv6 header and the table lists the header components.</span></span>

![IPv6 ヘッダー形式の図。](./media/user-guide/image18.png)

<span data-ttu-id="b06e6-988">**図 9. IPv6 ヘッダーの形式**</span><span class="sxs-lookup"><span data-stu-id="b06e6-988">**FIGURE 9. IPv6 Header Format**</span></span>

|<span data-ttu-id="b06e6-989">IP ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b06e6-989">IP header</span></span> | <span data-ttu-id="b06e6-990">目的</span><span class="sxs-lookup"><span data-stu-id="b06e6-990">Purpose</span></span> |
|---|---|
|<span data-ttu-id="b06e6-991">Version</span><span class="sxs-lookup"><span data-stu-id="b06e6-991">Version</span></span> |<span data-ttu-id="b06e6-992">IP バージョンの 4 ビット フィールド。</span><span class="sxs-lookup"><span data-stu-id="b06e6-992">4-bit field for IP version.</span></span> <span data-ttu-id="b06e6-993">IPv6 ネットワークの場合、このフィールドの値は 6 である必要があります。IPv4 ネットワークの場合は、4 である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-993">For IPv6 networks, the value in this field must be 6; For IPv4 networks it must be 4.</span></span>|
|<span data-ttu-id="b06e6-994">トラフィック クラス</span><span class="sxs-lookup"><span data-stu-id="b06e6-994">Traffic Class</span></span> |<span data-ttu-id="b06e6-995">トラフィック クラス情報を格納する 8 ビットフィールド。</span><span class="sxs-lookup"><span data-stu-id="b06e6-995">8-bit field that stores the traffic class information.</span></span> <span data-ttu-id="b06e6-996">このフィールドは、NetX Duo では使用しません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-996">This field is not used by NetX Duo.</span></span>|
|<span data-ttu-id="b06e6-997">フロー ラベル</span><span class="sxs-lookup"><span data-stu-id="b06e6-997">Flow Label</span></span> |<span data-ttu-id="b06e6-998">パケットが関連付けられているフロー (存在する場合) を一意に識別する 20 ビット フィールド。</span><span class="sxs-lookup"><span data-stu-id="b06e6-998">20-bit field to uniquely identify the flow, if any, that a packet is associated with.</span></span> <span data-ttu-id="b06e6-999">0 の値は、パケットが特定のフローに属していないことを示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-999">A value of zero indicates the packet does not belong to a particular flow.</span></span> <span data-ttu-id="b06e6-1000">このフィールドは、IPv4 の "*TOS*" フィールドに代わるものです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1000">This field replaces the *TOS* field in IPv4.</span></span>|
|<span data-ttu-id="b06e6-1001">ペイロード長</span><span class="sxs-lookup"><span data-stu-id="b06e6-1001">Payload Length</span></span> |<span data-ttu-id="b06e6-1002">IPv6 パケットの、IPv6 ベース ヘッダーに続く部分のデータ量をバイト単位で示す 16 ビット フィールド。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1002">16-bit field indicating the amount of data in bytes of the IPv6 packet following the IPv6 base header.</span></span> <span data-ttu-id="b06e6-1003">これには、すべてのカプセル化されたプロトコル ヘッダーとデータが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1003">This includes all encapsulated protocol header and data.</span></span>|
|<span data-ttu-id="b06e6-1004">次のヘッダー</span><span class="sxs-lookup"><span data-stu-id="b06e6-1004">Next Header</span></span> | <span data-ttu-id="b06e6-1005">IPv6 ベース ヘッダーに続く拡張ヘッダーの種類を示す 8 ビット フィールド。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1005">8-bit field indicating the type of the extension header that follows the IPv6 base header.</span></span> <span data-ttu-id="b06e6-1006">このフィールドは、IPv4 の "*プロトコル*" フィールドに代わるものです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1006">This field replaces the *Protocol* field in IPv4.</span></span>|
|<span data-ttu-id="b06e6-1007">ホップ制限</span><span class="sxs-lookup"><span data-stu-id="b06e6-1007">Hop Limit</span></span> |<span data-ttu-id="b06e6-1008">パケットが通過できるルーターの数を制限する 8 ビット フィールド。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1008">8-bit field that limits the number of routers the packet is allowed to go through.</span></span> <span data-ttu-id="b06e6-1009">このフィールドは、IPv4 の "*TTL*" フィールドに代わるものです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1009">This field replaces the *TTL* field in IPv4.</span></span>|
|<span data-ttu-id="b06e6-1010">ソースの住所</span><span class="sxs-lookup"><span data-stu-id="b06e6-1010">Source Address</span></span> |<span data-ttu-id="b06e6-1011">送信者の IPv6 アドレスを格納する 128 ビット フィールド。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1011">128-bit field that stores the IPv6 address of the sender.</span></span>|
|<span data-ttu-id="b06e6-1012">Destination Address (宛先アドレス)</span><span class="sxs-lookup"><span data-stu-id="b06e6-1012">Destination Address</span></span> |<span data-ttu-id="b06e6-1013">宛先の IPv6 アドレスを格納する 128 ビット フィールド。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1013">128-bit field that sores the IPv6 address of the destination.</span></span>|

### <a name="enabling-ipv6-in-netx-duo"></a><span data-ttu-id="b06e6-1014">NetX Duo での IPv6 の有効化</span><span class="sxs-lookup"><span data-stu-id="b06e6-1014">Enabling IPv6 in NetX Duo</span></span>    
<span data-ttu-id="b06e6-1015">NetX Duo では既定で IPv6 が有効です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1015">By default IPv6 is enabled in NetX Duo.</span></span> <span data-ttu-id="b06e6-1016">_nx_user.h\* の構成可能なオプション \***NX_DISABLE_IPV6** _ が定義されていない場合、NetX Duo で IPv6 サービスが有効になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1016">IPv6 services are enabled in NetX Duo if the configurable option ***NX_DISABLE_IPV6** _ in _nx_user.h* is not defined.</span></span> <span data-ttu-id="b06e6-1017">***NX_DISABLE_IPV6*** が定義されている場合、NetX Duo では IPv4 サービスのみが提供されます。また、IPv6 関連のモジュールとサービスのすべてが NetX Duo ライブラリに組み込まれるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1017">If ***NX_DISABLE_IPV6*** is defined, NetX Duo will only offer IPv4 services, and all the IPv6-related modules and services are not built into NetX Duo library.</span></span>

<span data-ttu-id="b06e6-1018">***nxd_ipv6_address_set*** は、アプリケーションでデバイスの IPv6 アドレスを構成するために提供されているサービスです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1018">The following service is provided for applications to configure the device IPv6 address: ***nxd_ipv6_address_set***</span></span>

<span data-ttu-id="b06e6-1019">デバイスの IPv6 アドレスを手動で設定するだけでなく、システムでステートレス アドレス自動構成を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1019">In addition to manually setting the device's IPv6 addresses, the system may also use Stateless Address Autoconfiguration.</span></span> <span data-ttu-id="b06e6-1020">このオプションを使用するために、アプリケーションでは \***nxd_ipv6_enable** _ を呼び出してデバイス上で IPv6 サービスを開始する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1020">To use this option, the application must call \***nxd_ipv6_enable** _ to start IPv6 services on the device.</span></span> <span data-ttu-id="b06e6-1021">さらに、ICMPv6 サービスは _*_nxd_icmp_enable_*_ を呼び出して開始する必要があります。これにより、ルーター要請、近隣探索、重複アドレス検出などのサービスを NetX Duo で実行できるようになります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1021">In addition, ICMPv6 services must be started by calling _*_nxd_icmp_enable_*_, which enables NetX Duo to perform services such as Router Solicitation, Neighbor Discovery, and Duplicate Address Detection.</span></span> <span data-ttu-id="b06e6-1022">_*_nx_icmp_enable_*_ では、IPv4 サービス用の ICMP しか開始されないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1022">Note that _*_nx_icmp_enable_*_ only starts ICMP for IPv4 services.</span></span> <span data-ttu-id="b06e6-1023">_*_nxd_icmp_enable_*_ は、IPv4 と IPv6 両対応の ICMP サービスを開始します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1023">_*_nxd_icmp_enable_*_ starts ICMP services for both IPv4 and IPv6.</span></span> <span data-ttu-id="b06e6-1024">システムで ICMPv6 サービスが不要な場合、ICMPv6 モジュールがシステムにリンクされないように _ *_nx_icmp_enable_*\* を使用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1024">If the system does not need ICMPv6 services, then _ *_nx_icmp_enable_*\* can be used so the ICMPv6 module is not linked into the system.</span></span>

<span data-ttu-id="b06e6-1025">次の例は、一般的な NetX Duo の IPv6 初期化手順を示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1025">The following example shows a typical NetX Duo IPv6 initialization procedure.</span></span>

```c
/* Assume ip_0 has been created and IPv4 services (such as ARP,
   ICMP, have been enabled. */
#define SECONDARY_INTERFACE 1

/* Enable IPv6 */
status = nxd_ipv6_enable(&ip_0);

if(status != NX_SUCCESS)
{
    /* nxd_ipv6_enable failed. */
}

/* Enable ICMPv6 */
status = nxd_icmp_enable(&ip_0);
if(status != NX_SUCCESS)
{
    /* nxd_icmp_enable failed. */
}

/* Configure the link local address on the primary interface. */
status = nxd_ipv6_address_set(&ip_0, 0, NX_NULL, 10, NX_NULL);

/* Configure ip_0 primary interface global address. */
ip_address.nxd_ip_version = NX_IP_VERSION_V6
ip_address.nxd_ip_address.v6[0] = 0x20010db8;
ip_address.nxd_ip_address.v6[1] = 0x0000f101;
ip_address.nxd_ip_address.v6[2] = 0;
ip_address.nxd_ip_address.v6[3] = 0x202;

/* Configure global address of the primary interface. */
status = nxd_ipv6_address_set(&ip_0, SECONDARY_INTERFACE,
                              &ip_address, 64, NX_NULL);
```                              

<span data-ttu-id="b06e6-1026">上位層プロトコル (TCP や UDP など) は、IPv6 の開始前または開始後に有効化できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1026">Upper layer protocols (such as TCP and UDP) can be enabled either before or after IPv6 starts.</span></span>

> [!IMPORTANT]  
> <span data-ttu-id="b06e6-1027">*IPv6 サービスは、IP スレッドが初期化されてデバイスが有効になった後でないと使用できません。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-1027">*IPv6 services are available only after IP thread is initialized and the device is enabled.*</span></span>

<span data-ttu-id="b06e6-1028">インターフェイスが有効になった (インターフェイス デバイス ドライバーでデータを送受信する準備ができて、有効なリンクローカル アドレスが取得された) 後、デバイスでは次のいずれかの方法でグローバル IPv6 アドレスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1028">After the interface is enabled (i.e.,the interface device driver is ready to send and receive data, and a valid link local address has been obtained), the device may obtain global IPv6 addresses by one of the these methods:</span></span>

- <span data-ttu-id="b06e6-1029">ステートレス アドレス自動構成</span><span class="sxs-lookup"><span data-stu-id="b06e6-1029">Stateless Address Auto Configuration;</span></span>  
- <span data-ttu-id="b06e6-1030">手動 IPv6 アドレス構成</span><span class="sxs-lookup"><span data-stu-id="b06e6-1030">Manual IPv6 address configuration;</span></span>  
- <span data-ttu-id="b06e6-1031">DHCPv6 (とオプションの DHCPv6 パッケージ) を使用したアドレス構成</span><span class="sxs-lookup"><span data-stu-id="b06e6-1031">Address configuration via DHCPv6 (with optional DHCPv6 package)</span></span>

<span data-ttu-id="b06e6-1032">最初の 2 つの方法について以下で説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1032">The first two methods are described below.</span></span> <span data-ttu-id="b06e6-1033">3 番目の方法 (DHCPv6) については、DHCP パッケージで説明しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1033">The 3rd method (DHCPv6) is described in the DHCP package.</span></span>

### <a name="stateless-address-autoconfiguration-using-router-solicitation"></a><span data-ttu-id="b06e6-1034">ルーター要請を使用したステートレス アドレス自動構成</span><span class="sxs-lookup"><span data-stu-id="b06e6-1034">Stateless Address Autoconfiguration Using Router Solicitation</span></span>      
<span data-ttu-id="b06e6-1035">NetX Duo デバイスは、プレフィックス情報を提供するルーターを使用して IPv6 ネットワークに接続するときに、そのインターフェイスを自動的に構成できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1035">NetX Duo devices can configure their interfaces automatically when connected to an IPv6 network with a router that supplies prefix information.</span></span> <span data-ttu-id="b06e6-1036">ステートレス アドレス自動構成を必要とするデバイスは、ルーター要請 (RS) メッセージを送出します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1036">Devices that require Stateless Address Autoconfiguration send out router solicitation (RS) messages.</span></span> <span data-ttu-id="b06e6-1037">ネットワーク上のルーターは、要請ルーター アドバタイズ (RA) メッセージで応答します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1037">Routers on the network respond with solicited router advertisement (RA) messages.</span></span> <span data-ttu-id="b06e6-1038">RA メッセージは、リンクに関連付けられたネットワーク アドレスを識別するプレフィックスをアドバタイズします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1038">RA messages advertise prefixes that identify the network addresses associated with a link.</span></span> <span data-ttu-id="b06e6-1039">次に、デバイスは、デバイスが接続されているネットワークの一意の識別子を生成します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1039">Devices then generate a unique identifier for the network the device is attached to.</span></span> <span data-ttu-id="b06e6-1040">アドレスは、プレフィックスとその一意識別子を組み合わせて形成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1040">The address is formed by combining the prefix and its unique identifier.</span></span> <span data-ttu-id="b06e6-1041">このようにして RA メッセージを受信すると、ホストはその IP アドレスを生成します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1041">In this manner on receiving the RA messages, hosts generate their IP address.</span></span> <span data-ttu-id="b06e6-1042">ルーターは、定期的な非要請 RA メッセージを送信する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1042">Routers may also send periodic unsolicited RA messages.</span></span> 

> [!WARNING]
> <span data-ttu-id="b06e6-1043">*NetX Duo を使用すると、アプリケーションで実行時にステートレス アドレス自動構成を有効または無効にできます。この機能を有効にするには、\*\*NX_IPV6_STATELESS_AUTOCONFIG_CONTROL*\* を定義して NetX Duo ライブラリをコンパイルする必要があります。この機能が有効になったら、アプリケーションで **nxd_ipv6_stateless_address_autoconfigure_enable** および **nxd_ipv6_stateless_address_autocofigure_disable** を使用して IPv6 ステートレス アドレス自動構成を有効または無効にできます。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-1043">*NetX Duo allows an application to enable or disable Stateless Address Autoconfiguration at run time. To enable this feature, NetX Duo library must be compiled with **NX_IPV6_STATELESS_AUTOCONFIG_CONTROL** defined. Once this feature is enabled, applications may use **nxd_ipv6_stateless_address_autoconfigure_enable** and **nxd_ipv6_stateless_address_autocofigure_disable** to enable or disable IPv6 stateless address autoconfiguration*.</span></span>

### <a name="manual-ipv6-address-configuration"></a><span data-ttu-id="b06e6-1044">手動 IPv6 アドレス構成</span><span class="sxs-lookup"><span data-stu-id="b06e6-1044">Manual IPv6 Address Configuration</span></span>     
<span data-ttu-id="b06e6-1045">特定の IPv6 アドレスが必要な場合、アプリケーションで ***nxd_ipv6_address_set*** を使用して IPv6 アドレスを手動で構成できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1045">If a specific IPv6 address is needed, the application may use ***nxd_ipv6_address_set*** to manually configure an IPv6 address.</span></span> <span data-ttu-id="b06e6-1046">ネットワーク インターフェイスは、複数の IPv6 アドレスを持つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1046">A network interface may have multiple IPv6 addresses.</span></span> <span data-ttu-id="b06e6-1047">ただし、ステートレス アドレス自動構成と手動構成のどちらで取得するかによらず、システムの IPv6 アドレスの総数は ***NX_MAX_IPV6_ADDRESSES*** を超えることができない点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1047">However keep in mind that the total number of IPv6 addresses in a system, either obtained through Stateless Address Autoconfiguration, or through the Manual Configuration, cannot exceed ***NX_MAX_IPV6_ADDRESSES***.</span></span>

<span data-ttu-id="b06e6-1048">次の例は、ip_0 のプライマリ インターフェイス (デバイス 0) でグローバル アドレスを手動で構成する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1048">The following example illustrates how to manually configure a global address on the primary interface (device 0) in ip_0:</span></span>

```c
NXD_ADDRESS global_address;
global_address.nxd_ip_version = NX_IP_VERSION_V6;
global_address.nxd_ip_address.v6[0] = 0x20010000;
global_address.nxd_ip_address.v6[1] = 0x00000000;
global_address.nxd_ip_address.v6[2] = 0x00000000;
global_address.nxd_ip_address.v6[3] = 0x0000ABCD;
```

<span data-ttu-id="b06e6-1049">ホストではこの後、次の NetX Duo サービスを呼び出して、このアドレスをそのグローバル IP アドレスとして割り当てます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1049">The host then calls the following NetX Duo service to assign this address as its global IP address:</span></span>

```c
status = nxd_ipv6_address_set(&ip_0, 0,  
                              &global_address, 64
                              NX_NULL);
```

### <a name="duplicate-address-detection-dad"></a><span data-ttu-id="b06e6-1050">重複アドレス検出 (DAD)</span><span class="sxs-lookup"><span data-stu-id="b06e6-1050">Duplicate Address Detection (DAD)</span></span>    
<span data-ttu-id="b06e6-1051">システムがその IPv6 アドレスを構成した後、そのアドレスは *TENTATIVE* (仮) とマークされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1051">After a system configures its IPv6 address, the address is marked as *TENTATIVE*.</span></span> <span data-ttu-id="b06e6-1052">RFC 4862 で説明されている重複アドレス検出 (DAD) が有効になっている場合、NetX Duo では、この仮アドレスを宛先にして近隣要請 (NS) メッセージを自動的に送信します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1052">If Duplicate Address Detection (DAD), described in RFC 4862, is enabled, NetX Duo automatically sends neighbor solicitation (NS) messages with this tentative address as the destination.</span></span> <span data-ttu-id="b06e6-1053">ネットワーク上のどのホストも所定の時間内にこれらの NS メッセージに応答しない場合、このアドレスはローカルリンク上で一意であると見なされ、その状態は VALID (有効) 状態に遷移します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1053">If no hosts on the network respond to these NS messages within a given period of time, the address is assumed to be unique on the local link, and its state transits to the VALID state.</span></span> <span data-ttu-id="b06e6-1054">この時点から、アプリケーションでこの IP アドレスを通信に使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1054">At this point the application may start using this IP address for communication.</span></span>  

<span data-ttu-id="b06e6-1055">DAD 機能は ICMPv6 モジュールの一部です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1055">The DAD functionality is part of the ICMPv6 module.</span></span> <span data-ttu-id="b06e6-1056">したがって、新しく構成したアドレスが DAD プロセスを通過するためには、先にアプリケーションで ICMPv6 サービスを有効にしておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1056">Therefore, the application must enable ICMPv6 services before a newly configured address can go through the DAD process.</span></span> <span data-ttu-id="b06e6-1057">または、(_*_nx_user.h_*_ として定義される) NetX Duo のライブラリ ビルド環境で \***NX_DISABLE_IPV6_DAD** _ オプションを定義して DAD プロセスを無効にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1057">Alternatively, the DAD process may be turned off by defining ***NX_DISABLE_IPV6_DAD** _ option in the NetX Duo library build environment (defined as _*_nx_user.h_\*_).</span></span> <span data-ttu-id="b06e6-1058">DAD プロセスの間、_*_NX_IPV6_DAD_TRANSMITS_*_ パラメーターは、NetX Duo から送信された NS メッセージのうち、アドレスが一意であることを確認するための応答を受信しなかった件数を判別します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1058">During the DAD process, the _*_NX_IPV6_DAD_TRANSMITS_*_ parameter determines the number of NS messages sent by NetX Duo without receiving a response to determine that the address is unique.</span></span> <span data-ttu-id="b06e6-1059">既定では、RFC 4862 の推奨のとおり、_ *_NX_IPV6_DAD_TRANSMITS_*\* は 3 に設定されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1059">By default and recommended by RFC 4862, _ *_NX_IPV6_DAD_TRANSMITS_*\* is set at 3.</span></span> <span data-ttu-id="b06e6-1060">このシンボルを 0 に設定すると、実質的に DAD が無効になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1060">Setting this symbol to zero effectively disables DAD.</span></span>

<span data-ttu-id="b06e6-1061">アプリケーションが IPv6 アドレスを割り当てるときに ICMPv6 または DAD が有効になっていない場合、DAD は実行されず、NetX Duo は直ちに IPv6 アドレスの状態を VALID に設定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1061">If ICMPv6 or DAD is not enabled at the time the application assigns an IPv6 address, DAD is not performed and NetX Duo sets the state of the IPv6 address to VALID immediately.</span></span>

<span data-ttu-id="b06e6-1062">NetX Duo は、そのリンクローカル アドレスとグローバル アドレスのどちらかまたは両方が有効になるまで、IPv6 ネットワーク上で通信できません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1062">NetX Duo cannot communicate on the IPv6 network until its link local and/or global address is valid.</span></span> <span data-ttu-id="b06e6-1063">有効なアドレスが取得された後、NetX Duo では、受信パケットの宛先アドレスを、その構成済み IPv6 アドレスまたは有効化されたマルチキャスト アドレスのいずれかと照合しようとします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1063">After a valid address is obtained, NetX Duo attempts to match the destination address of an incoming packet against one of its configured IPv6 address or an enabled multicast address.</span></span> <span data-ttu-id="b06e6-1064">一致が見つからない場合、パケットはドロップされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1064">If no matches are found, the packet is dropped.</span></span> 

> [!WARNING]  
> <span data-ttu-id="b06e6-1065">\*DAD プロセスの間、送信される DAD NS パケットの数は \***NX_IPV6_DAD_TRANSMITS** _(既定値は 3) によって定義されます。既定では、各 DAD NS メッセージの送信間に 1 秒の遅延があります。したがって、DAD が有効なシステムでは、IPv6 アドレスが割り当てられた後 (また、これが重複したアドレスではないという前提で)、IP アドレスが VALID 状態になって通信の準備ができるまでに約 3 秒の遅延があります。_</span><span class="sxs-lookup"><span data-stu-id="b06e6-1065">\*During the DAD process, the number of DAD NS packets to be transmitted is defined by \***NX_IPV6_DAD_TRANSMITS**_, which defaults to 3, and by default there is a one second delay between each DAD NS message is sent. Therefore, in a system with DAD enabled, after an IPv6 address is assigned (and assuming this is not a duplicated address), there is approximately 3 seconds delay before the IP address is in a VALID state and is ready for communication._</span></span>

<span data-ttu-id="b06e6-1066">アプリケーションでは、システムで IPv6 アドレスが変更されたときに通知を受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1066">Applications may want to receive notifications when IPv6 addresses in the system are changed.</span></span> <span data-ttu-id="b06e6-1067">IPv6 アドレスの変更通知機能を有効にするには、シンボル **NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY** を定義して NetX Duo ライブラリをビルドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1067">To enable the IPv6 address change notification feature, the NetX Duo library must be built with the symbol **NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY** defined.</span></span> <span data-ttu-id="b06e6-1068">この機能が有効になったら、アプリケーションで **_nxd_ipv6_address_change_notify_** サービスを使用してコールバック関数をインストールできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1068">Once the feature is enabled, applications may install the callback function by using the **_nxd_ipv6_address_change_notify_** service.</span></span>

<span data-ttu-id="b06e6-1069">IPv6 アドレスが変更されるか無効になると、ユーザーが指定したコールバック関数が次の情報を使用して呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1069">Once an IPv6 address is changed, or becomes invalid, the user-supplied callback function is invoked with the following information:</span></span>

| <span data-ttu-id="b06e6-1070">機能</span><span class="sxs-lookup"><span data-stu-id="b06e6-1070">Function</span></span>  | <span data-ttu-id="b06e6-1071">説明</span><span class="sxs-lookup"><span data-stu-id="b06e6-1071">Description</span></span>  |
|---|---|
|<span data-ttu-id="b06e6-1072">ip_ptr</span><span class="sxs-lookup"><span data-stu-id="b06e6-1072">ip_ptr</span></span> |<span data-ttu-id="b06e6-1073">IP インスタンスへのポインター</span><span class="sxs-lookup"><span data-stu-id="b06e6-1073">Pointer to the IP instance</span></span>|
|<span data-ttu-id="b06e6-1074">interface_index</span><span class="sxs-lookup"><span data-stu-id="b06e6-1074">interface_index</span></span> |<span data-ttu-id="b06e6-1075">この IPv6 アドレスが関連付けられているネットワーク インターフェイスのインデックス</span><span class="sxs-lookup"><span data-stu-id="b06e6-1075">Index to the network interface that this IPv6 address is associated with</span></span>
|<span data-ttu-id="b06e6-1076">ipv6_addr_index</span><span class="sxs-lookup"><span data-stu-id="b06e6-1076">ipv6_addr_index</span></span> |<span data-ttu-id="b06e6-1077">IPv6 アドレス テーブルのインデックス</span><span class="sxs-lookup"><span data-stu-id="b06e6-1077">Index to the IPv6 address table</span></span>|
|<span data-ttu-id="b06e6-1078">ipv6_address</span><span class="sxs-lookup"><span data-stu-id="b06e6-1078">ipv6_address</span></span> |<span data-ttu-id="b06e6-1079">IPv6 アドレスへのポインター。形式は、4 つの ULONG 整数の配列です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1079">Pointer to the IPv6 address, in the form of an array of four ULONG integers.</span></span> <span data-ttu-id="b06e6-1080">IPv6 アドレスはホストのバイト順で表されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1080">Pv6 addresses are presented in host byte order.</span></span>|

### <a name="ipv6-multicast-support-in-netx-duo"></a><span data-ttu-id="b06e6-1081">NetX Duo での IPv6 マルチキャストのサポート</span><span class="sxs-lookup"><span data-stu-id="b06e6-1081">IPv6 Multicast Support In NetX Duo</span></span>      
<span data-ttu-id="b06e6-1082">マルチキャスト アドレスは、インターネット上のホストの動的なグループを指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1082">Multicast addresses specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="b06e6-1083">マルチキャスト グループのメンバーは、いつでも参加し離脱することができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1083">Members of the multicast group may join and leave whenever they wish.</span></span> <span data-ttu-id="b06e6-1084">NetX Duo では、重複アドレス検出、近隣探索、ルーター発見など、IP マルチキャスト機能を必要とする複数の ICMPv6 プロトコルが実装されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1084">NetX Duo implements several ICMPv6 protocols, including Duplicate Address Detection, Neighbor Discovery, and Router Discovery, which require IP multicast capability.</span></span> <span data-ttu-id="b06e6-1085">したがって、NetX Duo では、基になるデバイス ドライバーでマルチキャスト操作をサポートすることを想定しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1085">Therefore, NetX Duo expects the underlying device driver to support multicast operations.</span></span>

<span data-ttu-id="b06e6-1086">マルチキャスト グループ (全ノード マルチキャスト アドレスや *要請ノード* マルチキャスト アドレスなど) に参加または離脱する必要がある場合、NetX Duo では、ドライバー コマンドをデバイス ドライバーに発行してマルチキャスト MAC アドレスに参加または離脱します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1086">When NetX Duo needs to join or leave a multicast group (such as the all-node multicast address, and the *solicited-node* multicast address), it issues a driver command to the device driver to join or leave a multicast MAC address.</span></span> <span data-ttu-id="b06e6-1087">マルチキャスト アドレスに参加するためのドライバー コマンドは \***NX_LINK_MULTICAST_JOIN** _ です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1087">The driver command for joining the multicast address is \***NX_LINK_MULTICAST_JOIN** _.</span></span> <span data-ttu-id="b06e6-1088">マルチキャスト アドレスを離脱するために、NetX Duo ではドライバー コマンド _*_NX_LINK_MULTICAST_LEAVE_*\* を発行します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1088">To leave a multicast address, NetX Duo issues the driver command _\*_NX_LINK_MULTICAST_LEAVE_\*\*.</span></span> <span data-ttu-id="b06e6-1089">ICMPv6 プロトコルが正しく機能するためには、デバイス ドライバーでこれら 2 つのコマンドを実装している必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1089">The device driver must implement these two commands for ICMPv6 protocols to work properly.</span></span>

<span data-ttu-id="b06e6-1090">アプリケーションでは、サービス ***nxd_ipv6_multicast_interface_join*** を使用して IPv6 マルチキャスト グループに参加できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1090">Applications may join an IPv6 multicast group by using the service \***nxd_ipv6_multicast_interface_join\*.**</span></span> <span data-ttu-id="b06e6-1091">このサービスは、マルチキャスト アドレスを IP スタックに登録し、指定されたデバイス ドライバーに IPv6 マルチキャスト アドレスを通知します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1091">This service registers the multicast address with the IP stack, and then notifies the specified device driver of the IPv6 multicast address.</span></span> <span data-ttu-id="b06e6-1092">マルチキャスト グループを離脱するために、アプリケーションではサービス ***nxd_ipv6_multicast_interface_leave*** を使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1092">To leave a multicast group, applications use the service ***nxd_ipv6_multicast_interface_leave.***</span></span>

### <a name="neighbor-discovery-nd"></a><span data-ttu-id="b06e6-1093">近隣探索 (ND)</span><span class="sxs-lookup"><span data-stu-id="b06e6-1093">Neighbor Discovery (ND)</span></span>    
<span data-ttu-id="b06e6-1094">近隣探索は IPv6 ネットワークのプロトコルであり、物理アドレスを IPv6 アドレス (グローバル アドレスまたはリンクローカル アドレス) にマップするためのものです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1094">Neighbor Discovery is a protocol in IPv6 networks for mapping physical addresses to the IPv6 addresses (global address or link-local address).</span></span> <span data-ttu-id="b06e6-1095">このマッピングは近隣探索キャッシュ (ND キャッシュ) に保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1095">This mapping is maintained in the Neighbor Discovery Cache (ND Cache).</span></span> <span data-ttu-id="b06e6-1096">ND プロセスは IPv4 の ARP プロセスに相当し、ND キャッシュは ARP テーブルに似ています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1096">The ND process is the equivalent of the ARP process in IPv4, and the ND Cache is similar to the ARP table.</span></span> <span data-ttu-id="b06e6-1097">IPv6 ノードは、近隣探索 (ND) プロトコルを使用して、その近隣の MAC アドレスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1097">An IPv6 node can obtain its neighbor's MAC address using the Neighbor Discovery (ND) protocol.</span></span> <span data-ttu-id="b06e6-1098">近隣要請 (NS) メッセージを全ノードまたは要請ノード マルチキャスト アドレスに送出し、対応する近隣アドバタイズ (NA) メッセージを待ちます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1098">It sends out a neighbor solicitation (NS) message to the all-node solicited node multicast address, and waits for a corresponding neighbor advertisement (NA) message.</span></span> <span data-ttu-id="b06e6-1099">このプロセスによって取得された MAC アドレスは、ND キャッシュに格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1099">The MAC address obtained through this process is stored in the ND Cache.</span></span>

<span data-ttu-id="b06e6-1100">各 IP インスタンスには 1 つの ND キャッシュがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1100">Each IP instance has one ND cache.</span></span> <span data-ttu-id="b06e6-1101">ND キャッシュはエントリの配列として保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1101">The ND Cache is maintained as an array of entries.</span></span> <span data-ttu-id="b06e6-1102">配列のサイズは、_*_nx_user.h_*\* にあるオプション \***NX_IPV6_NEIGHBOR_CACHE_SIZE** _ をコンパイル時に設定することによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1102">The size of the array is defined at compilation time by setting the option ***NX_IPV6_NEIGHBOR_CACHE_SIZE** _ which in _*_nx_user.h_\*\*.</span></span> <span data-ttu-id="b06e6-1103">IP インスタンスに接続されているすべてのインターフェイスが同じ ND キャッシュを共有することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1103">Note that all interfaces attached to an IP instance share the same ND cache.</span></span>

<span data-ttu-id="b06e6-1104">NetX Duo の起動時に ND キャッシュ全体が空になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1104">The entire ND Cache is empty when NetX Duo starts up.</span></span> <span data-ttu-id="b06e6-1105">システムが実行されると、NetX Duo によって ND キャッシュが自動的に更新され、ND プロトコルごとにエントリが追加および削除されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1105">As the system runs, NetX Duo automatically updates the ND Cache, adding and deleting entries as per ND protocol.</span></span> <span data-ttu-id="b06e6-1106">ただし、アプリケーションでは、次の NetX Duo サービスを使用してキャッシュ エントリを手動で追加および削除することによって ND キャッシュを更新することもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1106">However, an application may also update the ND Cache by manually adding and deleting cache entries using the following NetX Duo services:</span></span>

- <span data-ttu-id="b06e6-1107">***nxd_nd_cache_entry_delete***</span><span class="sxs-lookup"><span data-stu-id="b06e6-1107">***nxd_nd_cache_entry_delete***</span></span>  
- <span data-ttu-id="b06e6-1108">***nxd_nd_cache_entry_set***</span><span class="sxs-lookup"><span data-stu-id="b06e6-1108">***nxd_nd_cache_entry_set***</span></span>   
- <span data-ttu-id="b06e6-1109">***nxd_nd_cache_invalidate***</span><span class="sxs-lookup"><span data-stu-id="b06e6-1109">***nxd_nd_cache_invalidate***</span></span>

<span data-ttu-id="b06e6-1110">IPv6 パケットの送受信時に、NetX Duo によって ND キャッシュテーブルが自動的に更新されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1110">When sending and receiving IPv6 packets, NetX Duo automatically updates the ND Cache table.</span></span>

## <a name="internet-control-message-protocol-in-ipv6-icmpv6"></a><span data-ttu-id="b06e6-1111">IPv6 のインターネット制御メッセージ プロトコル (ICMPv6)</span><span class="sxs-lookup"><span data-stu-id="b06e6-1111">Internet Control Message Protocol in IPv6 (ICMPv6)</span></span>  

<span data-ttu-id="b06e6-1112">IPv6 での ICMPv6 の役割は、IPv6 アドレス マッピングとルーター発見をサポートするために大幅に拡張されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1112">The role of ICMPv6 in IPv6 has been greatly expanded to support IPv6 address mapping and router discovery.</span></span> <span data-ttu-id="b06e6-1113">さらに、NetX Duo の ICMPv6 では、エコー要求と応答、ICMPv6 エラー レポート、ICMPv6 リダイレクト メッセージをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1113">In addition, NetX Duo ICMPv6 supports echo request and response, ICMPv6 error reports, and ICMPv6 redirect messages.</span></span>

### <a name="icmpv6-enable"></a><span data-ttu-id="b06e6-1114">ICMPv6 有効化</span><span class="sxs-lookup"><span data-stu-id="b06e6-1114">ICMPv6 Enable</span></span>    
<span data-ttu-id="b06e6-1115">NetX Duo で ICMPv6 メッセージを処理する前に、アプリケーションで ***nxd_icmp_enable*** サービスを呼び出して、前述のように ICMPv6 処理を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1115">Before ICMPv6 messages can be processed by NetX Duo, the application must call the ***nxd_icmp_enable*** service to enable ICMPv6 processing as explained previously.</span></span> 

### <a name="icmpv6-messages"></a><span data-ttu-id="b06e6-1116">ICMPv6 メッセージ</span><span class="sxs-lookup"><span data-stu-id="b06e6-1116">ICMPv6 Messages</span></span>     
<span data-ttu-id="b06e6-1117">ICMPv6 ヘッダーの構造は ICMPv4 ヘッダーの構造に似ています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1117">The ICMPv6 header structure is similar to the ICMPv4 header structure.</span></span> <span data-ttu-id="b06e6-1118">次に示すように、基本の ICMPv6 ヘッダーには、種類、コード、チェックサムの 3 つのフィールドに加えて、可変長の ICMPv6 オプション データが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1118">As shown below, the basic ICMPv6 header contains the three fields, type, code, and checksum, plus variable length of ICMPv6 option data.</span></span> 

![基本的な ICMPv6 ヘッダーの図。](./media/user-guide/image19.png)

<span data-ttu-id="b06e6-1120">**図 10. 基本的な ICMPv6 ヘッダー**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1120">**FIGURE 10. Basic ICMPv6 Header**</span></span>

|<span data-ttu-id="b06e6-1121">フィールド</span><span class="sxs-lookup"><span data-stu-id="b06e6-1121">Field</span></span> |<span data-ttu-id="b06e6-1122">サイズ (バイト)</span><span class="sxs-lookup"><span data-stu-id="b06e6-1122">Size(bytes)</span></span> |<span data-ttu-id="b06e6-1123">説明</span><span class="sxs-lookup"><span data-stu-id="b06e6-1123">Description</span></span> |
|-----|-----|-----|
|     | <span data-ttu-id="b06e6-1124">1</span><span class="sxs-lookup"><span data-stu-id="b06e6-1124">1</span></span>   |<span data-ttu-id="b06e6-1125">ICMPv6 メッセージ型を識別します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1125">Identifies the ICMPv6 message type;</span></span> |
|     |     |<span data-ttu-id="b06e6-1126">1 宛先は到達不能です</span><span class="sxs-lookup"><span data-stu-id="b06e6-1126">1 Destination Unreachable</span></span> |
|     |     |<span data-ttu-id="b06e6-1127">2 パケットが大きすぎます</span><span class="sxs-lookup"><span data-stu-id="b06e6-1127">2 Packet Too Big</span></span> |
|     |     |<span data-ttu-id="b06e6-1128">3 時間超過</span><span class="sxs-lookup"><span data-stu-id="b06e6-1128">3 Time Exceeded</span></span> |
|     |     |<span data-ttu-id="b06e6-1129">4 パラメーターの問題</span><span class="sxs-lookup"><span data-stu-id="b06e6-1129">4 Parameter Problem</span></span> |
|     |     |<span data-ttu-id="b06e6-1130">128 エコー要求</span><span class="sxs-lookup"><span data-stu-id="b06e6-1130">128 Echo Request</span></span> |
|     |     |<span data-ttu-id="b06e6-1131">129 エコー応答</span><span class="sxs-lookup"><span data-stu-id="b06e6-1131">129 Echo Reply</span></span> |
|     |     |<span data-ttu-id="b06e6-1132">133 ルーター要請</span><span class="sxs-lookup"><span data-stu-id="b06e6-1132">133 Router Solicitation</span></span> |
|     |     |<span data-ttu-id="b06e6-1133">134 ルーター アドバタイズ</span><span class="sxs-lookup"><span data-stu-id="b06e6-1133">134 Router Advertisement</span></span> |
|     |     |<span data-ttu-id="b06e6-1134">135 近隣要請</span><span class="sxs-lookup"><span data-stu-id="b06e6-1134">135 Neighbor Solicitation</span></span> |
|     |     |<span data-ttu-id="b06e6-1135">136 近隣アドバタイズ</span><span class="sxs-lookup"><span data-stu-id="b06e6-1135">136 Neighbor Advertisement</span></span> |
|     |     |<span data-ttu-id="b06e6-1136">137 リダイレクト メッセージ</span><span class="sxs-lookup"><span data-stu-id="b06e6-1136">137 Redirect Message</span></span> |
|<span data-ttu-id="b06e6-1137">コード</span><span class="sxs-lookup"><span data-stu-id="b06e6-1137">Code</span></span> | <span data-ttu-id="b06e6-1138">1</span><span class="sxs-lookup"><span data-stu-id="b06e6-1138">1</span></span>   |<span data-ttu-id="b06e6-1139">ICMPv6 メッセージ型をさらに修飾します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1139">Further qualifies the ICMPv6 message type.</span></span> <span data-ttu-id="b06e6-1140">通常、エラーメッセージと共に使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1140">Generally used with error messages.</span></span> <span data-ttu-id="b06e6-1141">使用されない場合、0 に設定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1141">If not used, it is set to zero.</span></span> <span data-ttu-id="b06e6-1142">エコー要求/応答と NS メッセージでは使用しません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1142">Echo request/reply and NS messages do not use it.</span></span>|
|<span data-ttu-id="b06e6-1143">Checksum</span><span class="sxs-lookup"><span data-stu-id="b06e6-1143">Checksum</span></span> | <span data-ttu-id="b06e6-1144">2</span><span class="sxs-lookup"><span data-stu-id="b06e6-1144">2</span></span> |<span data-ttu-id="b06e6-1145">ICMP ヘッダーの 16 ビット チェックサム フィールド。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1145">16-bit checksum field for the ICMP Header.</span></span> <span data-ttu-id="b06e6-1146">これは、ICMPv6 ヘッダーを含む、ICMPv6 メッセージ全体の 16 ビット補数です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1146">This is a 16-bit complement of the entire ICMPv6 message, including the ICMPv6 header.</span></span> <span data-ttu-id="b06e6-1147">IPv6 送信元アドレス、宛先アドレス、パケット ペイロード長の擬似ヘッダーも含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1147">It also includes a pseudo-header of the IPv6 source address, destination address, and packet payload length.</span></span> |

<span data-ttu-id="b06e6-1148">近隣要請ヘッダーの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1148">An example Neighbor Solicitation header is shown below.</span></span>

![近隣要請ヘッダーの例を示す図。](./media/user-guide/image20.jpg)

<span data-ttu-id="b06e6-1150">**図 11. 近隣要請メッセージの ICMPv6 ヘッダー**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1150">**FIGURE 11. ICMPv6 Header for a Neighbor Solicitation Message**</span></span>

|<span data-ttu-id="b06e6-1151">フィールド</span><span class="sxs-lookup"><span data-stu-id="b06e6-1151">Field</span></span> |<span data-ttu-id="b06e6-1152">サイズ (バイト)</span><span class="sxs-lookup"><span data-stu-id="b06e6-1152">Size(bytes)</span></span> |<span data-ttu-id="b06e6-1153">説明</span><span class="sxs-lookup"><span data-stu-id="b06e6-1153">Description</span></span> |
|-----|-----|-----|
|<span data-ttu-id="b06e6-1154">Type</span><span class="sxs-lookup"><span data-stu-id="b06e6-1154">Type</span></span> | <span data-ttu-id="b06e6-1155">1</span><span class="sxs-lookup"><span data-stu-id="b06e6-1155">1</span></span>   |<span data-ttu-id="b06e6-1156">近隣要請メッセージの ICMPv6 メッセージ型を識別します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1156">Identifies the ICMPv6 message type for neighbor solicitation messages.</span></span> <span data-ttu-id="b06e6-1157">値は 135 です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1157">Value is 135.</span></span> |
|<span data-ttu-id="b06e6-1158">コード</span><span class="sxs-lookup"><span data-stu-id="b06e6-1158">Code</span></span> | <span data-ttu-id="b06e6-1159">1</span><span class="sxs-lookup"><span data-stu-id="b06e6-1159">1</span></span>   |<span data-ttu-id="b06e6-1160">使用しません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1160">Not used.</span></span> <span data-ttu-id="b06e6-1161">0 に設定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1161">Set to 0.</span></span> |
|<span data-ttu-id="b06e6-1162">Checksum</span><span class="sxs-lookup"><span data-stu-id="b06e6-1162">Checksum</span></span> | <span data-ttu-id="b06e6-1163">2</span><span class="sxs-lookup"><span data-stu-id="b06e6-1163">2</span></span>  |<span data-ttu-id="b06e6-1164">ICMPv6 ヘッダーの 16 ビット チェックサム フィールド。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1164">16-bit checksum field for the ICMPv6 header.</span></span> |
|<span data-ttu-id="b06e6-1165">予約されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1165">Reserved</span></span> | <span data-ttu-id="b06e6-1166">4</span><span class="sxs-lookup"><span data-stu-id="b06e6-1166">4</span></span>  |<span data-ttu-id="b06e6-1167">0 に設定される 4 つの予約済みバイト。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1167">4 reserved bytes set to 0.</span></span> |
|<span data-ttu-id="b06e6-1168">ターゲット アドレス</span><span class="sxs-lookup"><span data-stu-id="b06e6-1168">Target Address</span></span> | <span data-ttu-id="b06e6-1169">16</span><span class="sxs-lookup"><span data-stu-id="b06e6-1169">16</span></span>  |<span data-ttu-id="b06e6-1170">要請のターゲットの IPv6 アドレス。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1170">IPv6 address of target of the solicitation.</span></span> <span data-ttu-id="b06e6-1171">IPv6 アドレス解決の場合、これは、そのリンク層アドレスを解決する必要があるデバイスの実際のユニキャスト IP アドレスです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1171">For IPv6 address resolution, this is the actual unicast IP address of the device whose link layer address needs to be resolved.</span></span> |
|<span data-ttu-id="b06e6-1172">オプション</span><span class="sxs-lookup"><span data-stu-id="b06e6-1172">Options</span></span> | <span data-ttu-id="b06e6-1173">変数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1173">Variable</span></span> |<span data-ttu-id="b06e6-1174">近隣探索プロトコルによって指定されたオプションの情報。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1174">Optional information specified by the Neighbor Discovery Protocol.</span></span> |

### <a name="icmpv6-ping-request"></a><span data-ttu-id="b06e6-1175">ICMPv6 ping 要求</span><span class="sxs-lookup"><span data-stu-id="b06e6-1175">ICMPv6 Ping Request</span></span>
<span data-ttu-id="b06e6-1176">NetX Duo アプリケーションでは、***nxd_icmp_ping*** を使用して、パラメーターで指定された宛先 IP アドレスに基づいて IPv6 または IPv4 ping 要求を発行します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1176">In NetX Duo applications use ***nxd_icmp_ping*** to issue either IPv6 or IPv4 ping requests, based on the destination IP address specified in the parameters.</span></span>  

### <a name="icmpv6-ping-response"></a><span data-ttu-id="b06e6-1177">ICMPv6 ping 応答</span><span class="sxs-lookup"><span data-stu-id="b06e6-1177">ICMPv6 Ping Response</span></span>
<span data-ttu-id="b06e6-1178">ICMPv6 ping 応答は、外部の ICMPv6 ping 要求に応答して ICMPv6 コンポーネントによって内部的に生成される別の種類の ICMPv6 メッセージです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1178">An ICMPv6 ping response is another type of ICMPv6 message that is generated internally by the ICMPv6 component in response to an external ICMPv6 ping request.</span></span> <span data-ttu-id="b06e6-1179">ICMPv6 ping 応答には、確認応答に加えて、ICMPv6 ping 要求に指定されたユーザー データのコピーも含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1179">In additional to acknowledgement, the ICMPv6 ping response also contains a copy of the user data supplied in the ICMPv6 ping request.</span></span>  

### <a name="thread-suspension"></a><span data-ttu-id="b06e6-1180">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="b06e6-1180">Thread Suspension</span></span>
<span data-ttu-id="b06e6-1181">別のネットワーク メンバーに ping を試みている間、アプリケーション スレッドが一時停止する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1181">Application threads can suspend while attempting to ping another network member.</span></span> <span data-ttu-id="b06e6-1182">ping 応答を受信すると、一時停止した最初のスレッドに ping 応答メッセージが与えられ、そのスレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1182">After a ping response is received, the ping response message is given to the first thread suspended and that thread is resumed.</span></span> <span data-ttu-id="b06e6-1183">すべての NetX Duo サービスと同様に、ping 要求での一時停止にはオプションのタイムアウトがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1183">Like all NetX Duo services, suspending on a ping request has an optional timeout.</span></span>  

### <a name="other-icmpv6-messages"></a><span data-ttu-id="b06e6-1184">その他の ICMPv6 メッセージ</span><span class="sxs-lookup"><span data-stu-id="b06e6-1184">Other ICMPv6 Messages</span></span>
<span data-ttu-id="b06e6-1185">ICMPv6 メッセージは、次の機能のために必要です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1185">ICMPv6 messages are required for the following features:</span></span>  

- <span data-ttu-id="b06e6-1186">近隣探索</span><span class="sxs-lookup"><span data-stu-id="b06e6-1186">Neighbor Discovery</span></span>  
- <span data-ttu-id="b06e6-1187">ステートレス アドレス自動構成</span><span class="sxs-lookup"><span data-stu-id="b06e6-1187">Stateless Address Autoconfiguration</span></span> 
- <span data-ttu-id="b06e6-1188">ルートの検出</span><span class="sxs-lookup"><span data-stu-id="b06e6-1188">Router Discovery</span></span> 
- <span data-ttu-id="b06e6-1189">近隣の到達不可能性の検出</span><span class="sxs-lookup"><span data-stu-id="b06e6-1189">Neighbor Unreachability Detection</span></span>  

### <a name="neighbor-unreachability-router-and-prefix-discovery"></a><span data-ttu-id="b06e6-1190">近隣の到達不可能性、ルーター、プレフィックスの検出</span><span class="sxs-lookup"><span data-stu-id="b06e6-1190">Neighbor Unreachability, Router and Prefix Discovery</span></span>    
<span data-ttu-id="b06e6-1191">近隣の到達不可能性の検出、ルーター発見、プレフィックスの検出は、近隣探索プロトコルに基づいており、以下で説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1191">Neighbor Unreachability Detection, Router Discovery, and Prefix Discovery are based on the Neighbor Discovery protocol and are described below.</span></span> 

<span data-ttu-id="b06e6-1192">***近隣の到達不可能性の検出***: IPv6 デバイスでは、パケットの送信を希望するときに、その近隣探索 (ND) キャッシュから宛先のリンク層アドレスを検索します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1192">***Neighbor Unreachability Detection:*** An IPv6 device searches its Neighbor Discovery (ND) Cache for the destination link layer address when it wishes to send a packet.</span></span> <span data-ttu-id="b06e6-1193">"ネクスト ホップ" と呼ばれることもある直接の宛先は、同じリンク上の実際の宛先である場合もあれば、ルーターである場合もあります (宛先がオフリンクの場合)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1193">The immediate destination, sometimes referred to as the 'next hop,' may be the actual destination on the same link or it may be a router if the destination is off link.</span></span> <span data-ttu-id="b06e6-1194">ND キャッシュ エントリには、近隣の到達可能性のステータスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1194">An ND cache entry contains the status on a neighbor's reachability.</span></span>

<span data-ttu-id="b06e6-1195">REACHABLE ステータスは、近隣が到達可能と見なされていることを示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1195">A REACHABLE status indicates the neighbor is considered reachable.</span></span> <span data-ttu-id="b06e6-1196">近隣に送信したパケットが受信されたという確認を近隣が最近受信した場合、その近隣は到達可能です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1196">A neighbor is reachable if it has recently received confirmation that packets sent to the neighbor have been received.</span></span> <span data-ttu-id="b06e6-1197">NetX Duo での確認は、NetX Duo デバイスから送信された NS メッセージへの応答で近隣から NA メッセージを受信する形式になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1197">Confirmation in NetX Duo take the form of receiving an NA message from the neighbor in response to an NS message sent by the NetX Duo device.</span></span> <span data-ttu-id="b06e6-1198">また、アプリケーションで NetX Duo サービス ***nxd_nd_cache_entry_set*** を呼び出してキャッシュ レコードを手動で入力した場合、NetX Duo により近隣ステータスの状態が REACHABLE に変更されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1198">NetX Duo will also change the state of the neighbor status to REACHABLE if the application calls the NetX Duo service ***nxd_nd_cache_entry_set*** to manually enter a cache record.</span></span>

<span data-ttu-id="b06e6-1199">***ルーター発見***: IPv6 デバイスでは、ルーターを使用して、オフリンクの宛先に向けたすべてのパケットを転送します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1199">***Router Discovery:*** An IPv6 device uses a router to forward all packets intended for off link destinations.</span></span> <span data-ttu-id="b06e6-1200">ルーター アドバタイズ (RA) メッセージなど、ルーターによって送信される情報を使用して、デバイスのグローバル IPv6 アドレスを構成する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1200">It may also use information sent by the router, such as router advertisement (RA) messages, to configure its global IPv6 addresses.</span></span>

<span data-ttu-id="b06e6-1201">ネットワーク上のデバイスでは、全ルーターのマルチキャスト アドレス (FF01::2) にルーター要請 (RS) メッセージを送信することによってルーター発見プロセスを開始できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1201">A device on the network may initiate the Router Discovery process by sending a router solicitation (RS) message to the all-router multicast address (FF01::2).</span></span> <span data-ttu-id="b06e6-1202">または、全ノードのマルチキャスト アドレス (FF::1) でルーターからの定期的な RA を待機することもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1202">Or it can wait on the all-node multicast address (FF::1) for a periodic RA from the routers.</span></span>

<span data-ttu-id="b06e6-1203">RA メッセージには、そのネットワークの IPv6 アドレスを構成するためのプレフィックス情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1203">An RA message contains the prefix information for configuring an IPv6 address for that network.</span></span> <span data-ttu-id="b06e6-1204">NetX Duo では、ルーターの要請は既定で有効になっており、_*_nx_user.h_*\* で構成オプション \***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _ を設定することによって無効化できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1204">In NetX Duo, router solicitation is by default enabled and can be disabled by setting the configuration option ***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _ in _*_nx_user.h_\*\*.</span></span> <span data-ttu-id="b06e6-1205">ルーター要請パラメーターの設定の詳細については、「NetX Duo のインストールと使用」の章の「構成オプション」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1205">See Configuration Options in the "Installation and Use of NetX Duo" chapter for more details on setting Router Solicitation parameters.</span></span> 

<span data-ttu-id="b06e6-1206">***プレフィックスの検出***: IPv6 デバイスでは、プレフィックスの検出を使用して、どのターゲット ホストであればルーターを経由しなくても直接アクセスできるかを学習します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1206">***Prefix Discovery***: An IPv6 device uses prefix discovery to learn which target hosts are accessible directly without going through a router.</span></span> <span data-ttu-id="b06e6-1207">この情報は、ルーターからの RA メッセージを通じて IPv6 デバイスに提供されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1207">This information is made available to the IPv6 device from RA messages from the router.</span></span> <span data-ttu-id="b06e6-1208">IPv6 デバイスでは、プレフィックス情報をプレフィックス テーブルに格納します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1208">The IPv6 device stores the prefix information in a prefix table.</span></span> <span data-ttu-id="b06e6-1209">プレフィックスの検出では、IPv6 デバイス プレフィックス テーブルのプレフィックスをターゲット アドレスと照合します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1209">Prefix discovery is matching a prefix from the IPv6 device prefix table to a target address.</span></span> <span data-ttu-id="b06e6-1210">プレフィックスのすべてのビットがターゲット アドレスの最上位ビットに一致する場合、プレフィックスはターゲット アドレスに一致します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1210">A prefix matches a target address if all the bits in the prefix match the most significant bits of the target address.</span></span> <span data-ttu-id="b06e6-1211">複数のプレフィックスが 1 つのアドレスをカバーしている場合、最も長いプレフィックスが選択されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1211">If more than one prefix covers an address, the longest prefix is selected.</span></span>

### <a name="icmpv6-error-messages"></a><span data-ttu-id="b06e6-1212">ICMPv6 エラー メッセージ</span><span class="sxs-lookup"><span data-stu-id="b06e6-1212">ICMPv6 Error Messages</span></span>    
<span data-ttu-id="b06e6-1213">NetX Duo では、次の ICMPv6 エラー メッセージがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1213">The following ICMPv6 error messages are supported in NetX Duo:</span></span>  

- <span data-ttu-id="b06e6-1214">宛先は到達不能です</span><span class="sxs-lookup"><span data-stu-id="b06e6-1214">Destination Unreachable</span></span>  
- <span data-ttu-id="b06e6-1215">パケットが大きすぎます</span><span class="sxs-lookup"><span data-stu-id="b06e6-1215">Packet Too Big</span></span>  
- <span data-ttu-id="b06e6-1216">時間超過</span><span class="sxs-lookup"><span data-stu-id="b06e6-1216">Time Exceed</span></span>  
- <span data-ttu-id="b06e6-1217">パラメーターの問題</span><span class="sxs-lookup"><span data-stu-id="b06e6-1217">Parameter Problem</span></span>  

## <a name="user-datagram-protocol-udp"></a><span data-ttu-id="b06e6-1218">ユーザー データグラム プロトコル (UDP)</span><span class="sxs-lookup"><span data-stu-id="b06e6-1218">User Datagram Protocol (UDP)</span></span>

<span data-ttu-id="b06e6-1219">ユーザー データグラム プロトコル (UDP) は、ネットワーク メンバー間で最も単純な形式のデータ転送を提供します (RFC 768)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1219">The User Datagram Protocol (UDP) provides the simplest form of data transfer between network members (RFC 768).</span></span> <span data-ttu-id="b06e6-1220">UDP データ パケットは、ベスト エフォート方式でネットワーク メンバー間で送信されます。つまり、パケット受信者による確認応答用メカニズムは組み込まれていません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1220">UDP data packets are sent from one network member to another in a best effort fashion; i.e., there is no built-in mechanism for acknowledgement by the packet recipient.</span></span> <span data-ttu-id="b06e6-1221">さらに、UDP パケットを送信する場合、事前に接続を確立する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1221">In addition, sending a UDP packet does not require any connection to be established in advance.</span></span> <span data-ttu-id="b06e6-1222">このため、UDP パケット転送は非常に効率的です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1222">Because of this, UDP packet transmission is very efficient.</span></span>

<span data-ttu-id="b06e6-1223">NetX アプリケーションを NetX Duo に移行する開発者にとって、NetX と NetX Duo の間で UDP 機能にはいくつかの基本的な変更があるだけです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1223">For developers migrating their NetX applications to NetX Duo there are only a few basic changes in UDP functionality between NetX and NetX Duo.</span></span> <span data-ttu-id="b06e6-1224">これは、IPv6 が主に関係しているのは、基になる IP 層であるからです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1224">This is because IPv6 is primarily concerned with the underlying IP layer.</span></span> <span data-ttu-id="b06e6-1225">すべての NetX Duo UDP サービスは、IPv4 または IPv6 いずれかの接続に使用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1225">All NetX Duo UDP services can be used for either IPv4 or IPv6 connectivity.</span></span>

### <a name="udp-header"></a><span data-ttu-id="b06e6-1226">UDP ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b06e6-1226">UDP Header</span></span>       
<span data-ttu-id="b06e6-1227">UDP は、送信時にアプリケーションのデータの前に単純なパケット ヘッダーを配置し、受信時にパケットから同様の UDP ヘッダーを削除してから、受信した UDP パケットをアプリケーションに配信します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1227">UDP places a simple packet header in front of the application's data on transmission, and removes a similar UDP header from the packet on reception before delivering a received UDP packet to the application.</span></span> <span data-ttu-id="b06e6-1228">UDP はパケットを送受信するために IP プロトコルを使用します。つまり、パケットがネットワーク上にあるときに UDP ヘッダーの前に IP ヘッダーが存在することを意味します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1228">UDP utilizes the IP protocol for sending and receiving packets, which means there is an IP header in front of the UDP header when the packet is on the network.</span></span> <span data-ttu-id="b06e6-1229">図 12 は、UDP ヘッダーの形式を示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1229">Figure 12 shows the format of the UDP header.</span></span>

![UDP ヘッダー形式の図。](./media/user-guide/image21.png)

### <a name="figure-12-udp-header"></a><span data-ttu-id="b06e6-1231">図 12.</span><span class="sxs-lookup"><span data-stu-id="b06e6-1231">FIGURE 12.</span></span> <span data-ttu-id="b06e6-1232">UDP ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b06e6-1232">UDP Header</span></span>

> [!NOTE]
> <span data-ttu-id="b06e6-1233">*UDP/IP 実装のすべてのヘッダーは、\*\*ビッグ エンディアン*\* 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-1233">*All headers in the UDP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="b06e6-1234">次に、UDP ヘッダー形式について説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1234">The following describes the UDP header format:</span></span>

|<span data-ttu-id="b06e6-1235">ヘッダー フィールド</span><span class="sxs-lookup"><span data-stu-id="b06e6-1235">Header Field</span></span> |<span data-ttu-id="b06e6-1236">目的</span><span class="sxs-lookup"><span data-stu-id="b06e6-1236">Purpose</span></span> |
|---|---|
|<span data-ttu-id="b06e6-1237">**16 ビットの送信元ポート番号**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1237">**16-bit source port number**</span></span> |<span data-ttu-id="b06e6-1238">このフィールドには、UDP パケットの送信元のポートが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1238">This field contains the port on which the UDP packet is being sent from.</span></span> <span data-ttu-id="b06e6-1239">有効な UDP ポートの範囲は 1 ～ 0xFFFF です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1239">Valid UDP ports range from 1 through 0xFFFF.</span></span> |
|<span data-ttu-id="b06e6-1240">**16 ビットの宛先ポート番号**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1240">**16-bit destination port number**</span></span> |<span data-ttu-id="b06e6-1241">このフィールドには、パケットの送信先の UDP ポートが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1241">This field contains the UDP port to which the packet is being sent to.</span></span> <span data-ttu-id="b06e6-1242">有効な UDP ポートの範囲は 1 ～ 0xFFFF です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1242">Valid UDP ports range from 1 through 0xFFFF.</span></span> |
|<span data-ttu-id="b06e6-1243">**16 ビットの UDP の長さ**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1243">**16-bit UDP length**</span></span> |<span data-ttu-id="b06e6-1244">このフィールドには、UDP ヘッダーのサイズを含む、UDP パケットのバイト数が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1244">This field contains the number of bytes in the UDP packet, including the size of the UDP header.</span></span> |
|<span data-ttu-id="b06e6-1245">**16 ビットの UDP チェックサム**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1245">**16-bit UDP checksum**</span></span> |<span data-ttu-id="b06e6-1246">このフィールドには、UDP ヘッダー、パケット データ領域、擬似 IP ヘッダーなど、パケットの 16 ビットのチェックサムが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1246">This field contains the 16-bit checksum for the packet, including the UDP header, the packet data area, and the pseudo IP header.</span></span> |

### <a name="udp-enable"></a><span data-ttu-id="b06e6-1247">UDP 有効化</span><span class="sxs-lookup"><span data-stu-id="b06e6-1247">UDP Enable</span></span>   
<span data-ttu-id="b06e6-1248">UDP パケット転送が可能になる前に、アプリケーションはまず、***nx_udp_enable*** サービスを呼び出して UDP を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1248">Before UDP packet transmission is possible, the application must first enable UDP by calling the ***nx_udp_enable*** service.</span></span> <span data-ttu-id="b06e6-1249">有効にすると、アプリケーションは UDP パケットを送信および受信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1249">After enabled, the application is free to send and receive UDP packets.</span></span>  

### <a name="udp-socket-create"></a><span data-ttu-id="b06e6-1250">UDP ソケットの作成</span><span class="sxs-lookup"><span data-stu-id="b06e6-1250">UDP Socket Create</span></span>    
<span data-ttu-id="b06e6-1251">UDP ソケットは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1251">UDP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="b06e6-1252">サービスの初期のタイプ、有効期限、および受信キューの深さは、***nx_udp_socket_create*** サービスによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1252">The initial type of service, time to live, and receive queue depth are defined by the ***nx_udp_socket_create*** service.</span></span> <span data-ttu-id="b06e6-1253">アプリケーションの UDP ソケットの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1253">There are no limits on the number of UDP sockets in an application.</span></span>

### <a name="udp-checksum"></a><span data-ttu-id="b06e6-1254">UDP チェックサム</span><span class="sxs-lookup"><span data-stu-id="b06e6-1254">UDP Checksum</span></span>   
<span data-ttu-id="b06e6-1255">パケット データに対する UDP ヘッダー チェックサムの計算は、IPv6 プロトコルでは必須ですが、IPv4 プロトコルではオプションです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1255">IPv6 protocol requires a UDP header checksum computation on packet data, whereas in the IPv4 protocol it is optional.</span></span>  

<span data-ttu-id="b06e6-1256">UDP は、IP 擬似ヘッダー (送信元 IP アドレス、宛先 IP アドレス、プロトコル/長さ IP ワードで構成される)、UDP ヘッダー、および UDP パケット データを対象とする、1 の補数の 16 ビット チェックサムを指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1256">UDP specifies a one's complement 16-bit checksum that covers the IP pseudo header (consisting of the source IP address, destination IP address, and the protocol/length IP word), the UDP header, and the UDP packet data.</span></span> <span data-ttu-id="b06e6-1257">IPv4 と IPv6 で UDP パケット ヘッダーのチェックサムに関して唯一異なる点は、送信元と宛先の IP アドレスが IPv4 では 32 ビットであるのに対し IPv6 では 128 ビットであることです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1257">The only differences between IPv4 and IPv6 UDP packet header checksums is that the source and destination IP addresses are 32 bit in IPv4 while in IPv6 they are 128 bit.</span></span> <span data-ttu-id="b06e6-1258">計算された UDP チェックサムが 0 の場合は、すべて 1 として格納されます (0xFFFF)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1258">If the calculated UDP checksum is 0, it is stored as all ones (0xFFFF).</span></span> <span data-ttu-id="b06e6-1259">送信ソケットの UDP チェックサム ロジックが無効になっている場合、チェックサムが計算されなかったことを示すために、UDP チェックサム フィールドに 0 が配置されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1259">If the sending socket has the UDP checksum logic disabled, a zero is placed in the UDP checksum field to indicate the checksum was not calculated.</span></span>

<span data-ttu-id="b06e6-1260">UDP チェックサムが受信側によって計算されたチェックサムと一致しない場合、UDP パケットは単純に破棄されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1260">If the UDP checksum does not match the computed checksum by the receiver, the UDP packet is simply discarded.</span></span>

<span data-ttu-id="b06e6-1261">IPv4 ネットワークでは、UDP チェックサムは省略可能です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1261">On the IPv4 network, UDP checksum is optional.</span></span> <span data-ttu-id="b06e6-1262">NetX Duo を使用すると、アプリケーションは、ソケットごとに UDP チェックサムの計算を有効または無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1262">NetX Duo allows an application to enable or disable UDP checksum calculation on a per-socket basis.</span></span> <span data-ttu-id="b06e6-1263">既定では、UDP ソケット チェックサム ロジックが有効になっています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1263">By default, the UDP socket checksum logic is enabled.</span></span> <span data-ttu-id="b06e6-1264">アプリケーションは、\***nx_udp_socket_checksum_disable** _ サービスを呼び出すことによって、特定の UDP ソケットのチェックサム ロジックを無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1264">The application can disable checksum logic for a particular UDP socket by calling the \***nx_udp_socket_checksum_disable** _ service.</span></span> <span data-ttu-id="b06e6-1265">ただし、IPv6 ネットワークでは、UDP チェックサムは必須です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1265">On the IPv6 network, however, UDP checksum is mandatory.</span></span> <span data-ttu-id="b06e6-1266">したがって、サービス _ *_nx_udp_socket_checksum_disable_*\* は、IPv6 ネットワーク経由でパケットを送信するときに UDP チェックサム ロジックを無効にしません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1266">Therefore, the service _ *_nx_udp_socket_checksum_disable_*\* would not disable UDP checksum logic when sending a packet through the IPv6 network.</span></span>

<span data-ttu-id="b06e6-1267">特定のイーサネット コントローラーは、その場で UDP チェックサムを生成することができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1267">Certain Ethernet controllers are able to generate the UDP checksum on the fly.</span></span> <span data-ttu-id="b06e6-1268">システムがハードウェア チェックサム計算機能を使用できる場合、チェックサム ロジックを使用せずに NetX Duo ライブラリをビルドできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1268">If the system is able to use hardware checksum computation feature, the NetX Duo library can be built without the checksum logic.</span></span> <span data-ttu-id="b06e6-1269">UDP ソフトウェア チェックサムを無効にするには、シンボル ***NX_DISABLE_UDP_TX_CHECKSUM** _ および _*_NX_DISABLE_UDP_RX_CHECKSUM_\*_ (第 2 章で説明) を定義して NetX Duo ライブラリをビルドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1269">To disable UDP software checksum, the NetX Duo library must be built with the following symbols defined: ***NX_DISABLE_UDP_TX_CHECKSUM** _ and _*_NX_DISABLE_UDP_RX_CHECKSUM_\*_ (described in Chapter two).</span></span> <span data-ttu-id="b06e6-1270">構成オプションによって UDP チェックサム ロジックが NetX Duo から完全に削除されますが、_ *_nx_udp_socket_checksum_disable_*\* サービスを呼び出すと、アプリケーションでソケット単位で IPv4 UDP チェックサム処理を無効化できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1270">The configuration options remove UDP checksum logic from NetX Duo entirely, while calling the _ *_nx_udp_socket_checksum_disable_*\* service allows the application to disable IPv4 UDP checksum processing on a per socket basis.</span></span>

### <a name="udp-ports-and-binding"></a><span data-ttu-id="b06e6-1271">UDP ポートとバインド</span><span class="sxs-lookup"><span data-stu-id="b06e6-1271">UDP Ports and Binding</span></span>      
<span data-ttu-id="b06e6-1272">UDP ポートは、UDP プロトコルの論理エンド ポイントです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1272">A UDP port is a logical end point in the UDP protocol.</span></span> <span data-ttu-id="b06e6-1273">NetX Duo の UDP コンポーネントには、1 ～ 0xFFFF の範囲で、65,535 の有効なポートがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1273">There are 65,535 valid ports in the UDP component of NetX Duo, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="b06e6-1274">UDP データを送受信するには、まず、アプリケーションで UDP ソケットを作成してから、目的のポートにバインドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1274">To send or receive UDP data, the application must first create a UDP socket, then bind it to a desired port.</span></span> <span data-ttu-id="b06e6-1275">UDP ソケットをポートにバインドした後、アプリケーションはそのソケットでデータを送受信できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1275">After binding a UDP socket to a port, the application may send and receive data on that socket.</span></span>

### <a name="udp-fast-pathtrade"></a><span data-ttu-id="b06e6-1276">UDP Fast Path&trade;</span><span class="sxs-lookup"><span data-stu-id="b06e6-1276">UDP Fast Path&trade;</span></span>   
<span data-ttu-id="b06e6-1277">UDP Fast Path&trade; は、NetX Duo UDP 実装を介した低パケット オーバーヘッド パスの名前です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1277">The UDP Fast Path&trade; is the name for a low packet overhead path through the NetX Duo UDP implementation.</span></span> <span data-ttu-id="b06e6-1278">UDP パケットを送信するには、***nx_udp_socket_send** _ と _*_nx_ip_packet_send_\*_ の関数を呼び出して、最終的にネットワーク ドライバーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1278">Sending a UDP packet requires just a few function calls: ***nx_udp_socket_send** _, _*_nx_ip_packet_send_\*_, and the eventual call to the network driver.</span></span> <span data-ttu-id="b06e6-1279">_*_nx_udp_socket_send_*_ は、既存の NetX アプリケーション向けに NetX Duo で使用でき、IPv4 パケットにのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1279">_*_nx_udp_socket_send_*_ is available in NetX Duo for existing NetX applications and is only applicable for IPv4 packets.</span></span> <span data-ttu-id="b06e6-1280">ただし、推奨される方法は、以下で説明する _ *_nxd_udp_socket_send_*\* サービスを使用することです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1280">The preferred method, however, is to use _ *_nxd_udp_socket_send_*\* service discussed below.</span></span> <span data-ttu-id="b06e6-1281">UDP パケット受信では、UDP パケットは適切な UDP ソケット受信キューに配置されるか、ネットワーク ドライバーの受信割り込み処理からの単一の関数呼び出しで、中断されたアプリケーション スレッドに配信されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1281">On UDP packet reception, the UDP packet is either placed on the appropriate UDP socket receive queue or delivered to a suspended application thread in a single function call from the network driver's receive interrupt processing.</span></span> <span data-ttu-id="b06e6-1282">UDP パケットを送受信するための高度に最適化されたロジックは、UDP Fast Path テクノロジの本質です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1282">This highly optimized logic for sending and receiving UDP packets is the essence of UDP Fast Path technology.</span></span>  

### <a name="udp-packet-send"></a><span data-ttu-id="b06e6-1283">UDP パケット送信</span><span class="sxs-lookup"><span data-stu-id="b06e6-1283">UDP Packet Send</span></span>    
<span data-ttu-id="b06e6-1284">IPv6 または IPv4 ネットワーク経由での UDP データの送信は、\***nxd_udp_socket_send** _ 関数を呼び出すことによって簡単に実現できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1284">Sending UDP data over IPv6 or IPv4 networks is easily accomplished by calling the \***nxd_udp_socket_send** _ function.</span></span> <span data-ttu-id="b06e6-1285">呼び出し元では、NXD_ADDRESS ポインター パラメーターの _nx_ip_version\* フィールドで IP バージョンを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1285">The caller must set the IP version in the _nx_ip_version\* field of the NXD_ADDRESS pointer parameter.</span></span> <span data-ttu-id="b06e6-1286">NetX Duo では、宛先 IPv4/IPv6 アドレスに基づいて、送信される UDP パケットの最適な送信元アドレスが決定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1286">NetX Duo will determine the best source address for transmitted UDP packets based on the destination IPv4/IPv6 address.</span></span> <span data-ttu-id="b06e6-1287">このサービスは、パケット データの前に UDP ヘッダーを配置し、内部 IP 送信ルーチンを使用してネットワークに送信します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1287">This service places a UDP header in front of the packet data and sends it out onto the network using an internal IP send routine.</span></span> <span data-ttu-id="b06e6-1288">UDP パケットの送信では、すべての UDP パケット転送が直ちに処理されるため、スレッドが中断されることはありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1288">There is no thread suspension on sending UDP packets because all UDP packet transmissions are processed immediately.</span></span> 

<span data-ttu-id="b06e6-1289">マルチキャストまたはブロードキャストの宛先で、NetX Duo デバイスに選択できる IP アドレスが複数ある場合に、アプリケーションで使用する送信元 IP アドレスを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1289">For multicast or broadcast destinations, the application should specify the source IP address to use if the NetX Duo device has multiple IP addresses to choose from.</span></span> <span data-ttu-id="b06e6-1290">これは、サービス ***nxd_udp_socket_source_send*** を使用して行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1290">This can be done with the services ***nxd_udp_socket_source_send.***</span></span>

> [!IMPORTANT]    
> <span data-ttu-id="b06e6-1291">*マルチキャストまたはブロードキャスト パケットの送信に **nx_udp_socket_send** が使用されている場合、最初の有効化されたインターフェイスの IP アドレスが送信元アドレスとして使用されます*。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1291">*If **nx_udp_socket_send** is used for transmitting multicast or broadcast packets, the IP address of the first enabled interface is used as source address*.</span></span>

> [!NOTE] 
> <span data-ttu-id="b06e6-1292">*このソケットに対して UDP チェックサム ロジックが有効になっている場合、チェックサム操作は、UDP または IP のデータ構造へのアクセスをブロックすることなく、呼び出し元のスレッドのコンテキストで実行されます*。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1292">*If UDP checksum logic is enabled for this socket, the checksum operation is performed in the context of the calling thread, without blocking access to the UDP or IP data structures*.</span></span> 

> [!WARNING]    
> <span data-ttu-id="b06e6-1293">*NX_PACKET 構造に存在する UDP ペイロード データは、長いワード境界に配置する必要があります。アプリケーションでは、プリペンド ポインターと NetX Duo のデータ開始ポインターの間に十分な領域を残して、UDP、IP、および物理メディアのヘッダーを配置する必要があります*。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1293">*The UDP payload data residing in the NX_PACKET structure should reside on a long-word boundary. The application needs to leave sufficient space between the prepend pointer and the data start pointer for NetX Duo to place the UDP, IP, and physical media headers*.</span></span>

### <a name="udp-packet-receive"></a><span data-ttu-id="b06e6-1294">UDP パケット受信</span><span class="sxs-lookup"><span data-stu-id="b06e6-1294">UDP Packet Receive</span></span>    
<span data-ttu-id="b06e6-1295">アプリケーション スレッドでは、***nx_udp_socket_receive*** を呼び出して、特定のソケットから UDP パケットを受信する場合があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1295">Application threads may receive UDP packets from a particular socket by calling ***nx_udp_socket_receive***.</span></span> <span data-ttu-id="b06e6-1296">ソケット受信関数は、ソケットの受信キューで最も古いパケットを配信します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1296">The socket receive function delivers the oldest packet on the socket's receive queue.</span></span> <span data-ttu-id="b06e6-1297">受信キューにパケットがない場合、呼び出し元のスレッドは、パケットが到着するまで (オプションのタイムアウトで) 中断できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1297">If there are no packets on the receive queue, the calling thread can suspend (with an optional timeout) until a packet arrives.</span></span>

<span data-ttu-id="b06e6-1298">UDP 受信パケット処理 (通常はネットワーク ドライバーの受信割り込みハンドラーから呼び出されます) は、パケットを UDP ソケットの受信キューに配置するか、パケットを待機している最初に中断されたスレッドに配信する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1298">The UDP receive packet processing (usually called from the network driver's receive interrupt handler) is responsible for either placing the packet on the UDP socket's receive queue or delivering it to the first suspended thread waiting for a packet.</span></span> <span data-ttu-id="b06e6-1299">パケットがキューに置かれている場合は、受信処理によって、ソケットに関連付けられている最大受信キューの深さも確認されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1299">If the packet is queued, the receive processing also checks the maximum receive queue depth associated with the socket.</span></span> <span data-ttu-id="b06e6-1300">新しくキューに入れられたパケットがキューの深さを超えると、キュー内の最も古いパケットが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1300">If this newly queued packet exceeds the queue depth, the oldest packet in the queue is discarded.</span></span>

### <a name="udp-receive-notify"></a><span data-ttu-id="b06e6-1301">UDP 受信通知</span><span class="sxs-lookup"><span data-stu-id="b06e6-1301">UDP Receive Notify</span></span>   
<span data-ttu-id="b06e6-1302">アプリケーション スレッドが複数のソケットから受信したデータを処理する必要がある場合は、***nx_udp_socket_receive_notify*** 関数を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1302">If the application thread needs to process received data from more than one socket, the ***nx_udp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="b06e6-1303">この関数は、ソケットの受信パケット コールバック関数を登録します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1303">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="b06e6-1304">ソケットでパケットが受信されるたびに、コールバック関数が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1304">Whenever a packet is received on the socket, the callback function is executed.</span></span>

<span data-ttu-id="b06e6-1305">コールバック関数の内容はアプリケーション固有です。ただし、最も高い可能性としては、対応するソケットでパケットが使用可能になったことを処理スレッドに通知するロジックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1305">The contents of the callback function is applicationspecific; however, it would most likely contain logic to inform the processing thread that a packet is now available on the corresponding socket.</span></span>

### <a name="peer-address-and-port"></a><span data-ttu-id="b06e6-1306">ピア アドレスとポート</span><span class="sxs-lookup"><span data-stu-id="b06e6-1306">Peer Address and Port</span></span>   
<span data-ttu-id="b06e6-1307">UDP パケットを受信すると、アプリケーションでは、サービス ***nx_udp_packet_info_extract*** を使用して、送信者の IP アドレスとポート番号を見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1307">On receiving a UDP packet, application may find the sender's IP address and port number by using the service ***nx_udp_packet_info_extract***.</span></span> <span data-ttu-id="b06e6-1308">正常に返された場合、このサービスは、送信者の IP アドレス、送信者のポート番号、およびパケットの受信に使用されたローカル インターフェイスに関する情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1308">On successful return, this service provides information on the sender's IP address, sender's port number, and the local interface through which the packet was received.</span></span>  

### <a name="thread-suspension"></a><span data-ttu-id="b06e6-1309">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="b06e6-1309">Thread Suspension</span></span>   
<span data-ttu-id="b06e6-1310">前述のように、特定の UDP ポートで UDP パケットを受信しようとしている間に、アプリケーション スレッドが中断されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1310">As mentioned previously, application threads can suspend while attempting to receive a UDP packet on a particular UDP port.</span></span> <span data-ttu-id="b06e6-1311">そのポートでパケットが受信されると、最初に中断されたスレッドに渡され、そのスレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1311">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="b06e6-1312">UDP 受信パケットで中断する場合は、オプションのタイムアウトを使用できます。これは、ほとんどの NetX Duo サービスで利用可能な機能です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1312">An optional timeout is available when suspending on a UDP receive packet, a feature available for most NetX Duo services.</span></span>  

### <a name="udp-socket-statistics-and-errors"></a><span data-ttu-id="b06e6-1313">UDP ソケットの統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b06e6-1313">UDP Socket Statistics and Errors</span></span>     
<span data-ttu-id="b06e6-1314">有効にすると、NetX Duo UDP ソケット ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1314">If enabled, the NetX Duo UDP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b06e6-1315">次の統計およびエラー レポートは、IP/UDP インスタンスごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1315">The following statistics and error reports are maintained for each IP/UDP instance:</span></span>

- <span data-ttu-id="b06e6-1316">送信された UDP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1316">Total UDP Packets Sent</span></span>  
- <span data-ttu-id="b06e6-1317">送信された UDP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1317">Total UDP Bytes Sent</span></span>  
- <span data-ttu-id="b06e6-1318">受信した UDP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1318">Total UDP Packets Received</span></span>   
- <span data-ttu-id="b06e6-1319">受信した UDP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1319">Total UDP Bytes Received</span></span>  
- <span data-ttu-id="b06e6-1320">無効な UDP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1320">Total UDP Invalid Packets</span></span>  
- <span data-ttu-id="b06e6-1321">ドロップされた UDP 受信パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1321">Total UDP Receive Packets Dropped</span></span>  
- <span data-ttu-id="b06e6-1322">UDP 受信チェックサム エラーの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1322">Total UDP Receive Checksum Errors</span></span>  
- <span data-ttu-id="b06e6-1323">送信された UDP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1323">UDP Socket Packets Sent</span></span>  
- <span data-ttu-id="b06e6-1324">送信された UDP ソケット バイト数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1324">UDP Socket Bytes Sent</span></span>  
- <span data-ttu-id="b06e6-1325">受信した UDP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1325">UDP Socket Packets Received</span></span>   
- <span data-ttu-id="b06e6-1326">受信した UDP ソケット バイト数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1326">UDP Socket Bytes Received</span></span>  
- <span data-ttu-id="b06e6-1327">キューに登録された UDP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1327">UDP Socket Packets Queued</span></span>  
- <span data-ttu-id="b06e6-1328">ドロップされた UDP ソケット受信パケット数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1328">UDP Socket Receive Packets Dropped</span></span>  
- <span data-ttu-id="b06e6-1329">UDP ソケット チェックサム エラー</span><span class="sxs-lookup"><span data-stu-id="b06e6-1329">UDP Socket Checksum Errors</span></span>  

<span data-ttu-id="b06e6-1330">これらのすべての統計およびエラー レポートをアプリケーションで使用するには、すべての UDP ソケットで集められた UDP 統計は ***nx_udp_info_get** _ サービスを使用し、指定された UDP ソケットの UDP 統計情報は _ *_nx_udp_socket_info_get_** サービスを使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1330">All these statistics and error reports are available to the application with the ***nx_udp_info_get** _ service for UDP statistics amassed over all UDP sockets, and the _ *_nx_udp_socket_info_get_** service for UDP statistics on the specified UDP socket.</span></span>

### <a name="udp-socket-control-block-nx_udp_socket"></a><span data-ttu-id="b06e6-1331">UDP ソケット制御ブロック NX_UDP_SOCKET</span><span class="sxs-lookup"><span data-stu-id="b06e6-1331">UDP Socket Control Block NX_UDP_SOCKET</span></span>
<span data-ttu-id="b06e6-1332">各 UDP ソケットの特性は、関連付けられている NX_UDP_SOCKET 制御ブロックにあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1332">The characteristics of each UDP socket are found in the associated NX_UDP_SOCKET control block.</span></span> <span data-ttu-id="b06e6-1333">これには、IP データ構造へのリンク、送信パスと受信パスのネットワーク インターフェイス、バインドされたポート、受信パケット キューなどの有用な情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1333">It contains useful information such as the link to the IP data structure, the network interface for the sending and receiving paths, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="b06e6-1334">この構造体は ***nx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1334">This structure is defined in the ***nx_api.h*** file.</span></span>

## <a name="transmission-control-protocol-tcp"></a><span data-ttu-id="b06e6-1335">伝送制御プロトコル (TCP)</span><span class="sxs-lookup"><span data-stu-id="b06e6-1335">Transmission Control Protocol (TCP)</span></span>

<span data-ttu-id="b06e6-1336">伝送制御プロトコル (TCP) は、2 つのネットワーク メンバー間で信頼性の高いストリーム データ転送を提供します (RFC 793)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1336">The Transmission Control Protocol (TCP) provides reliable stream data transfer between two network members (RFC 793).</span></span> <span data-ttu-id="b06e6-1337">1 つのネットワーク メンバーから送信されたすべてのデータは、受信側メンバーによって検証され、確認されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1337">All data sent from one network member are verified and acknowledged by the receiving member.</span></span> <span data-ttu-id="b06e6-1338">また、この 2 つのメンバーは、データ転送の前に接続を確立している必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1338">In addition, the two members must have established a connection prior to any data transfer.</span></span> <span data-ttu-id="b06e6-1339">これにより、信頼性の高いデータ転送が行われるようになります。ただし、前述の UDP データ転送よりもかなり多くのオーバーヘッドが必要になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1339">All this results in reliable data transfer; however, it does require substantially more overhead than the previously described UDP data transfer.</span></span>

<span data-ttu-id="b06e6-1340">IPv6 が主に関係しているのは基になる IP 層であるため、注記のある点を除き、NetX と NetX Duo の間で TCP プロトコルの API サービスに変更はありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1340">Except where noted, there are no changes in TCP protocol API services between NetX and NetX Duo because IPv6 is primarily concerned with the underlying IP layer.</span></span> <span data-ttu-id="b06e6-1341">すべての NetX Duo TCP サービスは、IPv4 または IPv6 いずれかの接続に使用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1341">All NetX Duo TCP services can be used for either IPv4 or IPv6 connections.</span></span>

### <a name="tcp-header"></a><span data-ttu-id="b06e6-1342">TCP ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b06e6-1342">TCP Header</span></span>   
<span data-ttu-id="b06e6-1343">送信時には、TCP ヘッダーがユーザーが提供するデータの前に配置されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1343">On transmission, TCP header is placed in front of the data from the user.</span></span> <span data-ttu-id="b06e6-1344">受信時には、TCP ヘッダーが受信パケットから削除され、アプリケーションで使用できるユーザー データだけが残ります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1344">On reception, TCP header is removed from the incoming packet, leaving only the user data available to the application.</span></span> <span data-ttu-id="b06e6-1345">TCP は IP プロトコルを使用してパケットを送受信します。これは、パケットがネットワーク上にあるときに、TCP ヘッダーの前に IP ヘッダーがあることを意味します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1345">TCP utilizes the IP protocol to send and receive packets, which means there is an IP header in front of the TCP header when the packet is on the network.</span></span> <span data-ttu-id="b06e6-1346">図 13 は、TCP ヘッダーの形式を示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1346">Figure 13 shows the format of the TCP header.</span></span>

![TCP ヘッダー形式の図。](./media/user-guide/image22.png)

### <a name="figure-13-tcp-header"></a><span data-ttu-id="b06e6-1348">図 13.</span><span class="sxs-lookup"><span data-stu-id="b06e6-1348">FIGURE 13.</span></span> <span data-ttu-id="b06e6-1349">TCP ヘッダー</span><span class="sxs-lookup"><span data-stu-id="b06e6-1349">TCP Header</span></span>

<span data-ttu-id="b06e6-1350">次に、TCP ヘッダー形式について説明します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1350">The following describes the TCP header format:</span></span>

|<span data-ttu-id="b06e6-1351">ヘッダー&nbsp;フィールド</span><span class="sxs-lookup"><span data-stu-id="b06e6-1351">Header&nbsp;Field</span></span> |<span data-ttu-id="b06e6-1352">目的</span><span class="sxs-lookup"><span data-stu-id="b06e6-1352">Purpose</span></span> |
|------|------|
| <span data-ttu-id="b06e6-1353">**16 ビットの送信元ポート番号**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1353">**16-bit source port number**</span></span> | <span data-ttu-id="b06e6-1354">このフィールドには、TCP パケットが送信されるポートが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1354">This field contains the port the TCP packet is being sent out on.</span></span> <span data-ttu-id="b06e6-1355">有効な TCP ポートの範囲は 1 ～ 0xFFFF です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1355">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="b06e6-1356">**16 ビットの宛先ポート**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1356">**16-bit destination port**</span></span> | <span data-ttu-id="b06e6-1357">このフィールドには、パケット送信先の TCP ポートが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1357">This field contains the TCP port the packet is being sent to.</span></span> <span data-ttu-id="b06e6-1358">有効な TCP ポートの範囲は 1 ～ 0xFFFF です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1358">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="b06e6-1359">**32 ビットのシーケンス番号**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1359">**32-bit sequence number**</span></span> | <span data-ttu-id="b06e6-1360">このフィールドには、接続のこちら側から送信されるデータのシーケンス番号が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1360">This field contains the sequence number for data sent from this end of the connection.</span></span> <span data-ttu-id="b06e6-1361">元のシーケンスは、2 つの TCP ノード間の最初の接続シーケンス中に確立されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1361">The original sequence is established during the initial connection sequence between two TCP nodes.</span></span> <span data-ttu-id="b06e6-1362">その時点以降のすべてのデータ転送で、送信されたバイト数ずつシーケンス番号がインクリメントされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1362">Every data transfer from that point results in an increment of the sequence number by the amount bytes sent.</span></span> |
| <span data-ttu-id="b06e6-1363">**32 ビットの確認応答番号**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1363">**32-bit acknowledgement number**</span></span> | <span data-ttu-id="b06e6-1364">このフィールドには、接続のこちら側で受信した最後のバイトに対応するシーケンス番号が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1364">This field contains the sequence number corresponding to the last byte received by this side of the connection.</span></span> <span data-ttu-id="b06e6-1365">これは、以前に送信されたデータが、接続の反対側で正常に受信されたかどうかを判断するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1365">This is used to determine whether or not data previously sent has successfully been received by the other end of the connection.</span></span> |
| <span data-ttu-id="b06e6-1366">**4 ビットのヘッダー長**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1366">**4-bit header length**</span></span> | <span data-ttu-id="b06e6-1367">このフィールドには、TCP ヘッダー内の 32 ビット ワードの数が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1367">This field contains the number of 32-bit words in the TCP header.</span></span> <span data-ttu-id="b06e6-1368">TCP ヘッダーにオプションが存在しない場合、このフィールドは 5 です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1368">If no options are present in the TCP header, this field is 5.</span></span> |
| <span data-ttu-id="b06e6-1369">**6 ビットのコード ビット**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1369">**6-bit code bits**</span></span> |<span data-ttu-id="b06e6-1370">このフィールドには、接続に関連付けられたさまざまな制御情報を示すために使用される 6 つの異なるコード ビットが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1370">This field contains the six different code bits used to indicate various control information associated with the connection.</span></span> <span data-ttu-id="b06e6-1371">制御ビットは次のように定義されています。<br \> - URG (21): 緊急データが存在します<br \> - ACK (20): 確認応答番号が無効です<br \> - PSH (19): このデータをすぐに処理する<br \> - RST (18): 接続をリセットする<br \> - SYN (17): シーケンス番号を同期する (接続の確立に使用されます)<br \> - FIN (16): 送信元で送信を終了しました (接続を閉じるために使用されます)</span><span class="sxs-lookup"><span data-stu-id="b06e6-1371">The control bits are defined as follows:<br \> - URG (21): Urgent data presen<br \> - ACK (20): Acknowledgement number is valid<br \> - PSH (19): Handle this data immediately<br \> - RST (18): Reset the connection<br \> - SYN (17): Synchronize sequence numbers (used to establish connection)<br \> - FIN (16): Sender is finished with transmit (used to close connection)</span></span> |
|<span data-ttu-id="b06e6-1372">**16 ビットのウィンドウ**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1372">**16-bit window**</span></span> |<span data-ttu-id="b06e6-1373">このフィールドはフロー制御に使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1373">This field is used for flow control.</span></span> <span data-ttu-id="b06e6-1374">これには、ソケットが現在受信できるバイト数が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1374">It contains the amount of bytes the socket can currently receive.</span></span> <span data-ttu-id="b06e6-1375">これは基本的にフロー制御に使用されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1375">This basically is used for flow control.</span></span> <span data-ttu-id="b06e6-1376">送信元は、送信するデータが受信側の公開されたウィンドウに適合することを確認する責任があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1376">The sender is responsible for making sure the data to send will fit into the receiver's advertised window.</span></span> |
|<span data-ttu-id="b06e6-1377">**16 ビットの TCP チェックサム**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1377">**16-bit TCP checksum**</span></span> |<span data-ttu-id="b06e6-1378">このフィールドには、TCP ヘッダー、パケット データ領域、擬似 IP ヘッダーなど、パケットの 16 ビットのチェックサムが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1378">This field contains the 16-bit checksum for the packet including the TCP header, the packet data area, and the pseudo IP header.</span></span> |
|<span data-ttu-id="b06e6-1379">**16 ビットの緊急ポインター**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1379">**16-bit urgent pointer**</span></span> |<span data-ttu-id="b06e6-1380">このフィールドには、緊急データの最後のバイトの正のオフセットが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1380">This field contains the positive offset of the last byte of the urgent data.</span></span> <span data-ttu-id="b06e6-1381">このフィールドは、ヘッダーに URG コード ビットが設定されている場合にのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1381">This field is only valid if the URG code bit is set in the header.</span></span> |

> [!NOTE]  
> <span data-ttu-id="b06e6-1382">*TCP/IP 実装のすべてのヘッダーは、\*\*ビッグ エンディアン*\* 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-1382">*All headers in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address*.</span></span>

### <a name="tcp-enable"></a><span data-ttu-id="b06e6-1383">TCP 有効化</span><span class="sxs-lookup"><span data-stu-id="b06e6-1383">TCP Enable</span></span>       
<span data-ttu-id="b06e6-1384">TCP 接続とパケット転送を可能にするには、まず、アプリケーションで ***nx_tcp_enable*** サービスを呼び出して TCP を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1384">Before TCP connections and packet transmissions are possible, the application must first enable TCP by calling the ***nx_tcp_enable*** service.</span></span> <span data-ttu-id="b06e6-1385">有効にすると、アプリケーションはすべての TCP サービスに自由にアクセスできるようになります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1385">After enabled, the application is free to access all TCP services.</span></span>  

### <a name="tcp-socket-create"></a><span data-ttu-id="b06e6-1386">TCP ソケットの作成</span><span class="sxs-lookup"><span data-stu-id="b06e6-1386">TCP Socket Create</span></span>    
<span data-ttu-id="b06e6-1387">TCP ソケットは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1387">TCP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="b06e6-1388">サービスの初期のタイプ、有効期限、およびウィンドウ サイズは、***nx_tcp_socket_create*** サービスによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1388">The initial type of service, time to live, and window size are defined by the ***nx_tcp_socket_create*** service.</span></span> <span data-ttu-id="b06e6-1389">アプリケーションの TCP ソケットの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1389">There are no limits on the number of TCP sockets in an application.</span></span>  

### <a name="tcp-checksum"></a><span data-ttu-id="b06e6-1390">TCP チェックサム</span><span class="sxs-lookup"><span data-stu-id="b06e6-1390">TCP Checksum</span></span>     
<span data-ttu-id="b06e6-1391">TCP は、IP 擬似ヘッダー (送信元 IP アドレス、宛先 IP アドレス、プロトコル/長さ IP ワードで構成される)、TCP ヘッダー、および TCP パケット データを対象とする、1 の補数の 16 ビット チェックサムを指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1391">TCP specifies a one's complement 16-bit checksum that covers the IP pseudo header, (consisting of the source IP address, destination IP address, and the protocol/length IP word), the TCP header, and the TCP packet data.</span></span> <span data-ttu-id="b06e6-1392">IPv4 と IPv6 で TCP パケット ヘッダーのチェックサムに関して唯一異なる点は、送信元と宛先の IP アドレスが IPv4 では 32 ビット、IPv6 では 128 ビットであることです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1392">The only difference between IPv4 and IPv6 TCP packet header checksums is that the source and destination IP addresses are 32 bit in IPv4 and 128 bit in IPv6.</span></span> 

<span data-ttu-id="b06e6-1393">特定のネットワーク コントローラーでは、ハードウェアで TCP チェックサムの計算と検証を実行できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1393">Certain network controllers are able to perform TCP checksum computation and validation in hardware.</span></span> <span data-ttu-id="b06e6-1394">このようなシステムでは、実行時のオーバーヘッドを減らすために、アプリケーションでは、可能な限りハードウェア チェックサム ロジックを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1394">For such systems, applications may want to use hardware checksum logic as much as possible to reduce runtime overhead.</span></span> <span data-ttu-id="b06e6-1395">アプリケーションでは、***NX_DISABLE_TCP_TX_CHECKSUM** _ と _*_NX_DISABLE_TCP_RX_CHECKSUM_\*\* を定義することによって、NetX ライブラリからの TCP チェックサム計算ロジックをビルド時に完全に無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1395">Applications may disable TCP checksum computation logic from the NetX Duo library altogether at build time by defining ***NX_DISABLE_TCP_TX_CHECKSUM** _ and _*_NX_DISABLE_TCP_RX_CHECKSUM_\*\*.</span></span> <span data-ttu-id="b06e6-1396">このようにして、TCP チェックサム コードはコンパイルされません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1396">This way, the TCP checksum code is not compiled in.</span></span> <span data-ttu-id="b06e6-1397">ただし、オプションの NetX Duo IPsec パッケージがインストールされており、TCP 接続がセキュリティで保護されたチャネルを通過することが必要である場合は、注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1397">However one should exercise caution if the optional NetX Duo IPsec package is installed, and the TCP connection may need to traverse through a secure channel.</span></span> <span data-ttu-id="b06e6-1398">この場合、TCP 接続に属するパケット内のデータは既に暗号化されており、ネットワーク ドライバーに存在するほとんどのハードウェア TCP チェックサム モジュールは、暗号化された TCP ペイロードから正確なチェックサム値を生成できません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1398">In this case, data in packets belonging to the TCP connection is already encrypted, and most hardware TCP checksum modules present in the network driver are unable to generate correct checksum value from the encrypted TCP payload.</span></span>

<span data-ttu-id="b06e6-1399">この問題に対処するために、アプリケーションでは、TCP チェックサム ロジックをライブラリで使用可能な状態に保ち、インターフェイス機能を使用します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1399">To address this issue, application shall keep the TCP checksum logic available in the library and use the interface capability feature.</span></span> <span data-ttu-id="b06e6-1400">インターフェイス機能が有効になっていれば、TCP モジュールは、ドライバーでもチェックサム値を計算できる場合に、TCP チェックサムを適切に処理する方法を認識しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1400">With interface capability feature enabled, the TCP module knows how to properly handle the TCP checksum if the driver is also able to compute the checksum value:</span></span>

1) <span data-ttu-id="b06e6-1401">TCP パケットが IPsec プロセスの配下にない場合、ネットワーク インターフェイス ハードウェアでチェックサムを計算できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1401">If the TCP packet is not subject to IPsec process, the network interface hardware is able to compute the checksum.</span></span> <span data-ttu-id="b06e6-1402">したがって、TCP モジュールではチェックサムの計算を試みません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1402">Therefore the TCP module does not attempt to compute the checksum;</span></span>

2) <span data-ttu-id="b06e6-1403">IPsec パッケージがインストールされており、TCP パケットが IPsec プロセスの配下にある場合、TCP モジュールでは、パケットを IPsec 層に送信する前にソフトウェアでチェックサムを計算します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1403">If IPsec package is installed, and the TCP packet is subject to IPsec process, the TCP module computes checksum in software before sending the packet to IPsec layer.</span></span>

### <a name="tcp-port"></a><span data-ttu-id="b06e6-1404">[TCP ポート]</span><span class="sxs-lookup"><span data-stu-id="b06e6-1404">TCP Port</span></span>     
<span data-ttu-id="b06e6-1405">TCP ポートは、TCP プロトコルの論理接続ポイントです。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1405">A TCP port is a logical connection point in the TCP protocol.</span></span> <span data-ttu-id="b06e6-1406">NetX Duo の TCP コンポーネントには、1 ～ 0xFFFF の範囲で、65,535 の有効なポートがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1406">There are 65,535 valid ports in the TCP component of NetX Duo, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="b06e6-1407">1 つのポートのデータを任意の他の宛先ポートに送信できる UDP とは異なり、TCP ポートは特定のもう 1 つの TCP ポートに接続されており、この接続が確立されたときにのみ、接続を構成する 2 つのポート間でのみデータ転送が行われます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1407">Unlike UDP in which data from one port can be sent to any other destination port, a TCP port is connected to another specific TCP port, and only when this connection is established can any data transfer take place—and only between the two ports making up the connection.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b06e6-1408">*TCP ポートは、UDP ポートと完全に分離されています。たとえば、UDP ポート番号 1 は TCP ポート番号 1 とは関係ありません*。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1408">*TCP ports are completely separate from UDP ports; e.g., UDP port number 1 has no relation to TCP port number 1*.</span></span>

### <a name="client-server-model"></a><span data-ttu-id="b06e6-1409">クライアントサーバー モデル</span><span class="sxs-lookup"><span data-stu-id="b06e6-1409">Client-Server Model</span></span>     
<span data-ttu-id="b06e6-1410">データ転送に TCP を使用するには、最初に 2 つの TCP ソケット間に接続を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1410">To use TCP for data transfer, a connection must first be established between the two TCP sockets.</span></span> <span data-ttu-id="b06e6-1411">接続の確立は、クライアントサーバー形式で行われます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1411">The establishment of the connection is done in a client-server fashion.</span></span> <span data-ttu-id="b06e6-1412">接続のクライアント側は接続を開始する側であり、サーバー側は、クライアント接続要求を待機してからすべての処理を実行します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1412">The client side of the connection is the side that initiates the connection, while the server side simply waits for client connection requests before any processing is done.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b06e6-1413">*マルチホーム デバイスの場合、接続に使用する送信元アドレスと、接続の宛先 IP アドレスに基づいたネクスト ホップ アドレスが NetX Duo によって自動的に決定されます。TCP はユニキャスト (例: 非ブロードキャスト) 宛先アドレスへのパケット送信に制限されているため、送信元 IPv6 アドレスを選択するための "ヒント" は NetX Duo には必要ありません。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-1413">*For multihome devices, NetX Duo automatically determines the source address to use for the connection, and the next hop address based on the destination IP address of the connection. Because TCP is limited to sending packets to unicast (e.g.nonbroadcast) destination addresses, NetX Duo does not require a "hint" for choosing the source IPv6 address*.</span></span>

### <a name="tcp-socket-state-machine"></a><span data-ttu-id="b06e6-1414">TCP ソケットの状態機械</span><span class="sxs-lookup"><span data-stu-id="b06e6-1414">TCP Socket State Machine</span></span>      
<span data-ttu-id="b06e6-1415">2 つの TCP ソケット (クライアント 1 つとサーバー 1 つ) 間の接続は複雑で、状態機械方式で管理されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1415">The connection between two TCP sockets (one client and one server) is complex and is managed in a state machine manner.</span></span> <span data-ttu-id="b06e6-1416">各 TCP ソケットは、CLOSED 状態で開始されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1416">Each TCP socket starts in a CLOSED state.</span></span> <span data-ttu-id="b06e6-1417">接続イベントを通じて、各ソケットの状態機械が ESTABLISHED 状態に移行します。この状態で、TCP でのデータ転送の大部分が行われます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1417">Through connection events each socket's state machine migrates into the ESTABLISHED state, which is where the bulk of the data transfer in TCP takes place.</span></span> <span data-ttu-id="b06e6-1418">接続の一方の側がデータを送信する必要がなくなった場合、接続は切断されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1418">When one side of the connection no longer wishes to send data, it disconnects.</span></span> <span data-ttu-id="b06e6-1419">もう一方の側が切断すると、最終的に TCP ソケットは CLOSED 状態に戻ります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1419">After the other side disconnects, eventually the TCP socket returns to the CLOSED state.</span></span> <span data-ttu-id="b06e6-1420">このプロセスは、TCP クライアントとサーバーが接続を確立して閉じるたびに繰り返されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1420">This process repeats each time a TCP client and server establish and close a connection.</span></span> <span data-ttu-id="b06e6-1421">図 14 は、TCP 状態機械のさまざまな状態を示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1421">Figure 14 shows the various states of the TCP state machine.</span></span>

### <a name="tcp-client-connection"></a><span data-ttu-id="b06e6-1422">TCP クライアント接続</span><span class="sxs-lookup"><span data-stu-id="b06e6-1422">TCP Client Connection</span></span>       
<span data-ttu-id="b06e6-1423">前述のように、TCP 接続のクライアント側は、TCP サーバーへの接続要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1423">As mentioned previously, the client side of the TCP connection initiates a connection request to a TCP server.</span></span> <span data-ttu-id="b06e6-1424">接続要求を行う前に、クライアントの IP インスタンスで TCP を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1424">Before a connection request can be made, TCP must be enabled on the client IP instance.</span></span> <span data-ttu-id="b06e6-1425">さらに、***nx_tcp_socket_create** _ サービスを使用して次にクライアントの TCP ソケットを作成し、_ *_nx_tcp_client_socket_bind_** サービスを介してポートにバインドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1425">In addition, the client TCP socket must next be created with the ***nx_tcp_socket_create** _ service and bound to a port via the _ *_nx_tcp_client_socket_bind_** service.</span></span>

<span data-ttu-id="b06e6-1426">クライアント ソケットをバインドした後、***nxd_tcp_client_socket_connect*** サービスを使用して、TCP サーバーとの接続を確立します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1426">After the client socket is bound, the ***nxd_tcp_client_socket_connect*** service is used to establish a connection with a TCP server.</span></span> <span data-ttu-id="b06e6-1427">接続試行を開始するには、ソケットが CLOSED 状態になっている必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1427">Note the socket must be in a CLOSED state to initiate a connection attempt.</span></span> <span data-ttu-id="b06e6-1428">接続を確立するには、まず、NetX Duo で SYN パケットを発行し、サーバーからの SYN ACK パケットを待機します。これは、接続要求の受け入れを示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1428">Establishing the connection starts with NetX Duo issuing a SYN packet and then waiting for a SYN ACK packet back from the server, which signifies acceptance of the connection request.</span></span> <span data-ttu-id="b06e6-1429">SYN ACK を受信した後、NetX Duo は ACK パケットで応答し、ESTABLISHED 状態にクライアント ソケットを昇格させます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1429">After the SYN ACK is received, NetX Duo responds with an ACK packet and promotes the client socket to the ESTABLISHED state.</span></span>

![TCP 状態機械の状態の図。](./media/user-guide/image24.png)   

<span data-ttu-id="b06e6-1431">**図 14. TCP 状態機械の状態**</span><span class="sxs-lookup"><span data-stu-id="b06e6-1431">**FIGURE 14. States of the TCP State Machine**</span></span>


> [!WARNING]
> <span data-ttu-id="b06e6-1432">*アプリケーションでは、IPv4 と IPv6 のどちらの TCP 接続にも **nxd_tcp_client_socket_connect** を使用してください。IPv4 TCP 接続については、アプリケーションで **nx_tcp_client_socket_connect** を引き続き使用できますが、\*\*nx_tcp_client_socket_connect*\* は最終的には非推奨になる予定のため、開発者には **nxd_tcp_client_socket_connect** の使用を推奨しています。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-1432">*Applications should use **nxd_tcp_client_socket_connect** for either IPv4 and IPv6 TCP connections. Applications can still use **nx_tcp_client_socket_connect** for IPv4 TCP connections, but developers are encouraged to use **nxd_tcp_client_socket_connect** since **nx_tcp_client_socket_connect** will eventually be deprecated*.</span></span>

<span data-ttu-id="b06e6-1433">*同様に、\*\*nxd_tcp_socket_peer_info_get*\* は IPv4 と IPv6 のどちらの TCP 接続でも機能します。ただし、レガシ アプリケーションでは **nx_tcp_socket_peer_info_get** を引き続き使用できます。開発者には、今後は **nxd_tcp_socket_peer_info_get** を使用することを推奨しています。\*</span><span class="sxs-lookup"><span data-stu-id="b06e6-1433">*Similarly, **nxd_tcp_socket_peer_info_get** works with either IPv4 or IPv6 TCP connections. However, **nx_tcp_socket_peer_info_get** is still available for legacy applications. Developers are encouraged to use **nxd_tcp_socket_peer_info_get** going forward*.</span></span>

### <a name="tcp-client-disconnection"></a><span data-ttu-id="b06e6-1434">TCP クライアント切断</span><span class="sxs-lookup"><span data-stu-id="b06e6-1434">TCP Client Disconnection</span></span>    
<span data-ttu-id="b06e6-1435">接続の終了は、***nx_tcp_socket_disconnect*** の呼び出しで行われます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1435">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="b06e6-1436">中断が指定されていない場合、クライアント ソケットは RST パケットをサーバー ソケットに送信し、ソケットを CLOSED 状態にします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1436">If no suspension is specified, the client socket sends a RST packet to the server socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="b06e6-1437">それ以外の場合、中断が要求されると、次のように完全な TCP 切断プロトコルが実行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1437">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</span></span> 

- <span data-ttu-id="b06e6-1438">サーバーが以前に切断要求を開始した場合 (クライアント ソケットが既に FIN パケットを受信していて、ACK で応答し、CLOSE WAIT 状態にある場合)、NetX Duo ではクライアントの TCP ソケットの状態が LAST ACK 状態に昇格され、FIN パケットが送信されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1438">If the server previously initiated a disconnect request (the client socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX Duo promotes the client TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="b06e6-1439">次に、サーバーからの ACK を待機してから切断を完了し、CLOSED 状態に入ります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1439">It then waits for an ACK from the server before completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="b06e6-1440">一方、クライアントが最初に切断要求を開始する場合 (サーバーが切断されていない状態で、ソケットがまだ ESTABLISHED 状態である場合)、NetX Duo では FIN パケットが送信されて切断が開始し、サーバーからの FIN と ACK の受信を待機してから切断を完了してソケットが CLOSED 状態になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1440">If on the other hand, the client is the first to initiate a disconnect request (the server has not disconnected and the socket is still in the ESTABLISHED state), NetX Duo sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the server before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="b06e6-1441">ソケットの送信キューにパケットが残っている場合、NetX Duo は指定されたタイムアウトの間中断して、パケットが確認されるようにします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1441">If there are still packets on the socket transmit queue, NetX Duo suspends for the specified timeout to allow the packets to be acknowledged.</span></span> <span data-ttu-id="b06e6-1442">タイムアウトが経過すると、NetX Duo はクライアント ソケットの送信キューを空にします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1442">If the timeout expires, NetX Duo empties the transmit queue of the client socket.</span></span> 

<span data-ttu-id="b06e6-1443">クライアント ソケットからポートのバインドを解除するために、アプリケーションは ***nx_tcp_client_socket_unbind*** を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1443">To unbind the port from the client socket, the application calls ***nx_tcp_client_socket_unbind***.</span></span> <span data-ttu-id="b06e6-1444">ソケットは、ポートが解放される前に、CLOSED 状態であるか、切断処理中 (つまり、TIMED WAIT 状態) である必要があります。それ以外の場合は、エラーが返されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1444">The socket must be in a CLOSED state or in the process of disconnecting (i.e., TIMED WAIT state) before the port is released; otherwise, an error is returned.</span></span>

<span data-ttu-id="b06e6-1445">最後に、アプリケーションがクライアント ソケットを必要としなくなった場合は、***nx_tcp_socket_delete*** を呼び出してソケットを削除します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1445">Finally, if the application no longer needs the client socket, it calls ***nx_tcp_socket_delete*** to delete the socket.</span></span>

### <a name="tcp-server-connection"></a><span data-ttu-id="b06e6-1446">TCP サーバー接続</span><span class="sxs-lookup"><span data-stu-id="b06e6-1446">TCP Server Connection</span></span>      
<span data-ttu-id="b06e6-1447">TCP 接続のサーバー側はパッシブです。つまり、サーバーは、クライアントが接続要求を開始するのを待機します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1447">The server side of a TCP connection is passive; i.e., the server waits for a client to initiate connection request.</span></span> <span data-ttu-id="b06e6-1448">クライアント接続を受け入れるには、まず、サービス \***nx_tcp_enable** _ を呼び出して、IP インスタンスで TCP を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1448">To accept a client connection, TCP must first be enabled on the IP instance by calling the service \***nx_tcp_enable** _.</span></span> <span data-ttu-id="b06e6-1449">次に、アプリケーションは _ *_nx_tcp_socket_create_*\* サービスを使用して TCP ソケットを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1449">Next, the application must create a TCP socket using the _ *_nx_tcp_socket_create_*\* service.</span></span>  

<span data-ttu-id="b06e6-1450">また、サーバー ソケットを、接続要求をリッスンするように設定する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1450">The server socket must also be set up for listening for connection requests.</span></span> <span data-ttu-id="b06e6-1451">これは、***nx_tcp_server_socket_listen*** サービスを使用して行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1451">This is achieved by using the ***nx_tcp_server_socket_listen*** service.</span></span> <span data-ttu-id="b06e6-1452">このサービスは、サーバー ソケットを LISTEN 状態にし、指定されたサーバー ポートをソケットにバインドします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1452">This service places the server socket in the LISTEN state and binds the specified server port to the socket.</span></span>

> [!NOTE] 
> <span data-ttu-id="b06e6-1453">*ソケット リッスン コールバック ルーチンを設定するには、アプリケーションで **nx_tcp_server_socket_listen** サービスの tcp_listen_callback 引数に適切なコールバック関数を指定します。このサーバー ポートで新しい接続が要求されるたびに、このアプリケーション コールバック関数が NetX Duo によって実行されます。コールバックでの処理は、アプリケーションで制御されます。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-1453">*To set a socket listen callback routine the application specifies the appropriate callback function for the tcp_listen_callback argument of the **nx_tcp_server_socket_listen** service. This application callback function is then executed by NetX Duo whenever a new connection is requested on this server port. The processing in the callback is under application control.*</span></span>

<span data-ttu-id="b06e6-1454">クライアント接続要求を受け入れるために、アプリケーションは \***nx_tcp_server_socket_accept** _ サービスを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1454">To accept client connection requests, the application calls the \***nx_tcp_server_socket_accept** _ service.</span></span> <span data-ttu-id="b06e6-1455">受け入れサービスを呼び出すには、サーバー ソケットが LISTEN 状態または SYN RECEIVED 状態のいずれかである必要があります (つまり、サーバーが LISTEN 状態であり、接続を要求しているクライアントから SYN パケットを受信した状態)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1455">The server socket must either be in a LISTEN state or a SYN RECEIVED state (i.e., the server is in the LISTEN state and has received a SYN packet from a client requesting a connection) to call the accept service.</span></span> <span data-ttu-id="b06e6-1456">_ *_nx_tcp_server_socket_accept_*\* から返される正常の状態は、接続が設定されており、サーバー ソケットが ESTABLISHED 状態であることを示します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1456">A successful return status from _ *_nx_tcp_server_socket_accept_*\* indicates the connection has been set up and the server socket is in the ESTABLISHED state.</span></span>

<span data-ttu-id="b06e6-1457">サーバー ソケットに有効な接続がある状態になったら、追加のクライアント接続要求が、*listen_queue_size によって指定された深さまでキューに登録され、*  \***nx_tcp_server_socket_listen** _ サービスに渡されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1457">After the server socket has a valid connection, additional client connection requests are queued up to the depth specified by the *listen_queue_size, passed into the* \***nx_tcp_server_socket_listen** _ service.</span></span> <span data-ttu-id="b06e6-1458">サーバー ポートで以降の接続を処理するには、アプリケーションは使用可能なソケット (つまり、CLOSED 状態のソケット) を使用して _ *_nx_tcp_server_socket_relisten_*\* を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1458">In order to process subsequent connections on a server port, the application must call _ *_nx_tcp_server_socket_relisten_*\* with an available socket (i.e., a socket in a CLOSED state).</span></span> <span data-ttu-id="b06e6-1459">ソケットに関連付けられている以前の接続が終了し、ソケットが CLOSED 状態になっている場合は、同じサーバー ソケットを使用できることに注意します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1459">Note that the same server socket could be used if the previous connection associated with the socket is now finished and the socket is in the CLOSED state.</span></span>

### <a name="tcp-server-disconnection"></a><span data-ttu-id="b06e6-1460">TCP サーバー切断</span><span class="sxs-lookup"><span data-stu-id="b06e6-1460">TCP Server Disconnection</span></span>     
<span data-ttu-id="b06e6-1461">接続の終了は、***nx_tcp_socket_disconnect*** の呼び出しで行われます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1461">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="b06e6-1462">中断が指定されていない場合、サーバー ソケットは RST パケットをクライアント ソケットに送信し、ソケットを CLOSED 状態にします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1462">If no suspension is specified, the server socket sends a RST packet to the client socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="b06e6-1463">それ以外の場合、中断が要求されると、次のように完全な TCP 切断プロトコルが実行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1463">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</span></span>

- <span data-ttu-id="b06e6-1464">クライアントが以前に切断要求を開始した場合 (サーバー ソケットが既に FIN パケットを受信していて、ACK で応答し、CLOSE WAIT 状態にある場合)、NetX Duo は TCP ソケット状態を LAST ACK 状態に昇格し、FIN パケットを送信します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1464">If the client previously initiated a disconnect request (the server socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX Duo promotes the TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="b06e6-1465">次に、クライアントからの ACK を待機してから切断を完了し、CLOSED 状態に入ります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1465">It then waits for an ACK from the client before  completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="b06e6-1466">一方、サーバーが最初に切断要求を開始する場合 (クライアントが切断されていない状態で、ソケットがまだ ESTABLISHED 状態である場合)、NetX Duo は FIN パケットを送信して切断を開始し、クライアントからの FIN と ACK の受信を待機してから切断を完了してソケットを CLOSED 状態にします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1466">If on the other hand, the server is the first to initiate a disconnect request (the client has not disconnected and the socket is still in the ESTABLISHED state), NetX Duo sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the client before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="b06e6-1467">ソケットの送信キューにパケットが残っている場合、NetX Duo は指定されたタイムアウトの間中断して、それらのパケットが確認されるようにします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1467">If there are still packets on the socket transmit queue, NetX Duo suspends for the specified timeout to allow those packets to be acknowledged.</span></span> <span data-ttu-id="b06e6-1468">タイムアウトが経過すると、NetX Duo はサーバー ソケットの送信キューをフラッシュします。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1468">If the timeout expires, NetX Duo flushes the transmit queue of the server socket.</span></span>

<span data-ttu-id="b06e6-1469">切断処理が完了し、サーバー ソケットが CLOSED 状態になった後、このソケットとサーバー ポートの関連付けを終了するために、アプリケーションでは \***nx_tcp_server_socket_unaccept** _ サービスを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1469">After the disconnect processing is complete and the server socket is in the CLOSED state, the application must call the \***nx_tcp_server_socket_unaccept** _ service to end the association of this socket with the server port.</span></span> <span data-ttu-id="b06e6-1470">このサービスは、_*_nx_tcp_socket_disconnect_*_ または _*_nx_tcp_server_socket_accept_*_ がエラー状態を返す場合でも、アプリケーションによって呼び出される必要があることに注意します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1470">Note this service must be called by the application even if _*_nx_tcp_socket_disconnect_*_ or _*_nx_tcp_server_socket_accept_*_ return an error status.</span></span> <span data-ttu-id="b06e6-1471">_*_nx_tcp_server_socket_unaccept_*_ が返された後、ソケットをクライアントまたはサーバー ソケットとして使用したり、不要になった場合は削除することもできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1471">After the _*_nx_tcp_server_socket_unaccept_*_ returns, the socket can be used as a client or server socket, or even deleted if it is no longer needed.</span></span> <span data-ttu-id="b06e6-1472">同じサーバー ポートで別のクライアント接続を受け入れる必要がある場合は、このソケットで _ *_nx_tcp_server_socket_relisten_*\* サービスを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1472">If accepting another client connection on the same server port is desired, the _ *_nx_tcp_server_socket_relisten_*\* service should be called on this socket.</span></span>

<span data-ttu-id="b06e6-1473">次のコード セグメントは、一般的な TCP サーバーで使用される一連の呼び出しを示しています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1473">The following code segment illustrates the sequence of calls a typical TCP server uses:</span></span>

```c
/* Set up a previously created TCP socket to
   listen on port 12 */
nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1)
{
    /* Wait for a client socket connection request
       for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP
       client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on
       the port. */
    nx_tcp_server_socket_unaccept(&server_socket);
    /* Set up server socket to relisten on the
       same port for the next client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a><span data-ttu-id="b06e6-1474">MSS 検証</span><span class="sxs-lookup"><span data-stu-id="b06e6-1474">MSS Validation</span></span>      
<span data-ttu-id="b06e6-1475">最大セグメント サイズ (MSS) は、基になる IP レイヤーによって断片化されることなく TCP ホストが受信できる最大バイト数です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1475">The Maximum Segment Size (MSS) is the maximum amount of bytes a TCP host can receive without being fragmented by the underlying IP layer.</span></span> <span data-ttu-id="b06e6-1476">TCP 接続の確立フェーズでは、両端でそれぞれの TCP MSS 値が交換されます。これにより、送信側は、受信側の MSS よりも大きい TCP データ セグメントを送信しません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1476">During TCP connection establishment phase, both ends exchanges its own TCP MSS value, so that the sender does not send a TCP data segment that is larger than the receiver's MSS.</span></span> <span data-ttu-id="b06e6-1477">NetX Duo TCP モジュールは、接続を確立する前に、必要に応じてピアの公開済み MSS 値を検証します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1477">NetX Duo TCP module will optionally validate its peer's advertised MSS value before establishing a connection.</span></span> <span data-ttu-id="b06e6-1478">既定では、NetX Duo はこのようなチェックを有効にしません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1478">By default NetX Duo does not enable such a check.</span></span> <span data-ttu-id="b06e6-1479">MSS 検証を実行するアプリケーションでは、NetX Duo ライブラリをビルドするときに ***NX_ENABLE_TCP_MSS_CHECK** _ を定義する必要があり、最小値は _*_NX_TCP_MSS_MINIMUM_\*_ で定義します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1479">Applications wishing to perform MSS validation shall define ***NX_ENABLE_TCP_MSS_CHECK** _ when building the NetX Duo library, and the minimum value shall be defined in _*_NX_TCP_MSS_MINIMUM_\*_.</span></span> <span data-ttu-id="b06e6-1480">_ *_NX_TCP_MSS_MINIMUM_*\* の下にある MSS 値を持つ受信 TCP 接続はドロップされます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1480">Incoming TCP connections with MSS values below _ *_NX_TCP_MSS_MINIMUM_*\* are dropped.</span></span>

### <a name="stop-listening-on-a-server-port"></a><span data-ttu-id="b06e6-1481">サーバー ポートでのリッスン停止</span><span class="sxs-lookup"><span data-stu-id="b06e6-1481">Stop Listening on a Server Port</span></span>    
<span data-ttu-id="b06e6-1482">以前に ***nx_tcp_server_socket_listen** _ サービスの呼び出しで指定されたサーバー ポートでクライアント接続要求をリッスンする必要がなくなった場合、アプリケーションでは、単純に _ *_nx_tcp_server_socket_unlisten_** サービスを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1482">If the application no longer wishes to listen for client connection requests on a server port that was previously specified by a call to the ***nx_tcp_server_socket_listen** _ service, the application simply calls the _ *_nx_tcp_server_socket_unlisten_** service.</span></span> <span data-ttu-id="b06e6-1483">このサービスは、接続を待機しているソケットをすべて CLOSED 状態に戻し、キューに置かれたクライアント接続要求パケットをすべて解放します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1483">This service places any socket waiting for a connection back in the CLOSED state and releases any queued client connection request packets.</span></span> 

### <a name="tcp-window-size"></a><span data-ttu-id="b06e6-1484">TCP ウィンドウ サイズ</span><span class="sxs-lookup"><span data-stu-id="b06e6-1484">TCP Window Size</span></span>   
<span data-ttu-id="b06e6-1485">接続のセットアップ フェーズとデータ転送フェーズの両方で、各ポートは、ウィンドウ サイズと呼ばれる処理可能なデータの量を報告します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1485">During both the setup and data transfer phases of the connection, each port reports the amount of data it can handle, which is called its window size.</span></span> <span data-ttu-id="b06e6-1486">データが受信されて処理されると、このウィンドウ サイズは動的に調整されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1486">As data are received and processed, this window size is adjusted dynamically.</span></span> <span data-ttu-id="b06e6-1487">TCP では、送信側は受信側のウィンドウに収まる量のデータのみを送信できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1487">In TCP, a sender can only send an amount of data that fits into the receiver's window.</span></span> <span data-ttu-id="b06e6-1488">基本的に、ウィンドウ サイズは、接続の各方向でのデータ転送のフロー制御を提供します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1488">In essence, the window size provides flow control for data transfer in each direction of the connection.</span></span>   

### <a name="tcp-packet-send"></a><span data-ttu-id="b06e6-1489">TCP パケット送信</span><span class="sxs-lookup"><span data-stu-id="b06e6-1489">TCP Packet Send</span></span>     
<span data-ttu-id="b06e6-1490">TCP データの送信は、***nx_tcp_socket_send*** 関数を呼び出すことによって簡単に実現できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1490">Sending TCP data is easily accomplished by calling the ***nx_tcp_socket_send*** function.</span></span> <span data-ttu-id="b06e6-1491">送信されるデータのサイズがソケットの MSS 値または、現在のピアの受信ウィンドウ サイズ (どちらか小さいほう) より大きい場合は、TCP 内部ロジックによって、伝送のための最小 (MSS、ピア受信ウィンドウ) に収まるデータに切り分けられます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1491">If the size of the data being transmitted is larger than the MSS value of the socket or the current peer receive window size, whichever is smaller, TCP internal logic carves off the data that fits into min (MSS, peer receive Window) for transmission.</span></span> <span data-ttu-id="b06e6-1492">その後、このサービスによってパケットの前に TCP ヘッダーが作成されます (チェックサムの計算も含まれます)。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1492">This service then builds a TCP header in front of the packet (including the checksum calculation).</span></span> <span data-ttu-id="b06e6-1493">受信側のウィンドウ サイズが 0 でない場合、呼び出し元は受信側のウィンドウ サイズいっぱいまでデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1493">If the receiver's window size is not zero, the caller will send as much data as it can to fill up the receiver window size.</span></span> <span data-ttu-id="b06e6-1494">受信ウィンドウが 0 になった場合、呼び出し元は中断し、受信側のウィンドウ サイズがこのパケットの送信に十分な大きさになるまで待機することがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1494">If the receive window becomes zero, the caller may suspend and wait for the receiver's window size to increase enough for this packet to be sent.</span></span> <span data-ttu-id="b06e6-1495">任意の時点で、同じソケットを介してデータを送信しようとしている間に、複数のスレッドが中断されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1495">At any given time, multiple threads may suspend while trying to send data through the same socket.</span></span> 

> [!WARNING]  
> <span data-ttu-id="b06e6-1496">*NX_PACKET 構造に存在する TCP データは、長いワード境界に配置する必要があります。さらに、プリペンド ポインターとデータの開始ポインターの間に、TCP、IP、および物理メディアのヘッダーを配置するために十分な領域がある必要があります*。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1496">*The TCP data residing in the NX_PACKET structure should reside on a long-word boundary. In addition, there needs to be sufficient space between the prepend pointer and the data start pointer to place the TCP, IP, and physical media headers*.</span></span>

### <a name="tcp-packet-retransmit"></a><span data-ttu-id="b06e6-1497">TCP パケットの再送信</span><span class="sxs-lookup"><span data-stu-id="b06e6-1497">TCP Packet Retransmit</span></span>      
<span data-ttu-id="b06e6-1498">以前に送信された TCP パケットは、接続の相手側から ACK が返されるまで、実際には内部的に格納されていました。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1498">Previously transmitted TCP packets sent actually stored internally until an ACK is returned from the other side of the connection.</span></span> <span data-ttu-id="b06e6-1499">転送されたデータがタイムアウト期間内に確認されない場合、保存されているパケットは再送信され、次のタイムアウト期間が設定されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1499">If transmitted data is not acknowledged within the timeout period, the stored packet is re-sent and the next timeout period is set.</span></span> <span data-ttu-id="b06e6-1500">ACK を受信すると、内部送信キューの確認応答番号によってカバーされるすべてのパケットが最終的に解放されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1500">When an ACK is received, all packets covered by the acknowledgement number in the internal transmit queue are finally released.</span></span>  

> [!WARNING]   
> <span data-ttu-id="b06e6-1501">*nx_tcp_socket_send() が NX_SUCCESS で戻った後、アプリケーションでは、パケットを再利用したり、パケットの内容を変更したりしてはなりません。送信されたパケットは、データがもう一方の端で確認された後、最終的に NetX Duo の内部処理によって解放されます。*</span><span class="sxs-lookup"><span data-stu-id="b06e6-1501">*Application shall not reuse the packet or alter the contents of the packet after nx_tcp_socket_send() returns with NX_SUCCESS. The transmitted packet is eventually released by NetX Duo internal processing after the data is acknowledged by the other end*.</span></span>

### <a name="tcp-keepalive"></a><span data-ttu-id="b06e6-1502">TCP Keepalive</span><span class="sxs-lookup"><span data-stu-id="b06e6-1502">TCP Keepalive</span></span>     
<span data-ttu-id="b06e6-1503">TCP Keepalive 機能を使用すると、ピアが適切に終了せずに切断したかどうか (ピアがクラッシュした場合など) をソケットで検出したり、アイドル状態が長く、特定のネットワーク監視機能が接続を終了するのを防いだりできます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1503">TCP Keepalive feature allows a socket to detect whether or not its peer disconnects without proper termination (for example, the peer crashed), or to prevent certain network monitoring facilities to terminate a connection for long periods of idle.</span></span> <span data-ttu-id="b06e6-1504">TCP Keepalive は、データのない TCP フレームを定期的に送信し、シーケンス番号を現在のシーケンス番号よりも 1 小さい値に設定することによって機能します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1504">TCP Keepalive works by periodically sending a TCP frame with no data, and the sequence number set to one less than the current sequence number.</span></span> <span data-ttu-id="b06e6-1505">このような TCP Keepalive フレームを受け取ると、受信者は、まだ稼動している場合は、現在のシーケンス番号に対して ACK で応答します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1505">On receiving such TCP Keepalive frame, the recipient, if still alive, responses with an ACK for its current sequence number.</span></span> <span data-ttu-id="b06e6-1506">これで、Keepalive トランザクションが完了します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1506">This completes the keepalive transaction.</span></span>  

<span data-ttu-id="b06e6-1507">既定では、Keepalive 機能は有効になっていません。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1507">By default the keepalive feature is not enabled.</span></span> <span data-ttu-id="b06e6-1508">この機能を使用するには、NetX Duo ライブラリを \***NX_ENABLE_TCP_KEEPALIVE** _ を定義してビルドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1508">To use this feature, NetX Duo library must be built with \***NX_ENABLE_TCP_KEEPALIVE** _ defined.</span></span> <span data-ttu-id="b06e6-1509">シンボル _ *_NX_TCP_KEEPALIVE_INITIAL_*\* は、Keepalive フレームが開始されるまでの非アクティブな秒数を指定します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1509">The symbol _ *_NX_TCP_KEEPALIVE_INITIAL_*\* specifies the number of seconds of inactivity before the keepalive frame is initiated.</span></span>  

### <a name="tcp-packet-receive"></a><span data-ttu-id="b06e6-1510">TCP パケット受信</span><span class="sxs-lookup"><span data-stu-id="b06e6-1510">TCP Packet Receive</span></span>   
<span data-ttu-id="b06e6-1511">TCP の受信パケット処理 (IP ヘルパー スレッドから呼び出されます) は、さまざまな接続および切断アクションだけでなく、確認応答処理も送信します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1511">The TCP receive packet processing (called from the IP helper thread) is responsible for handling various connection and disconnection actions as well as transmit acknowledge processing.</span></span> <span data-ttu-id="b06e6-1512">さらに、TCP 受信パケット処理は、受信データを持つパケットを適切な TCP ソケットの受信キューに格納したり、パケットを待機している最初の中断されたスレッドにパケットを配信したりする役割を担います。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1512">In addition, the TCP receive packet processing is responsible for placing packets with receive data on the appropriate TCP socket's receive queue or delivering the packet to the first suspended thread waiting for a packet.</span></span>

### <a name="tcp-receive-notify"></a><span data-ttu-id="b06e6-1513">TCP 受信通知</span><span class="sxs-lookup"><span data-stu-id="b06e6-1513">TCP Receive Notify</span></span>     
<span data-ttu-id="b06e6-1514">アプリケーション スレッドが複数のソケットから受信したデータを処理する必要がある場合は、***nx_tcp_socket_receive_notify*** 関数を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1514">If the application thread needs to process received data from more than one socket, the ***nx_tcp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="b06e6-1515">この関数は、ソケットの受信パケット コールバック関数を登録します。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1515">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="b06e6-1516">ソケットでパケットが受信されるたびに、コールバック関数が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1516">Whenever a packet is received on the socket, the callback function is executed.</span></span>  

<span data-ttu-id="b06e6-1517">コールバック関数の内容はアプリケーション固有です。ただし、最も高い可能性として、関数には、パケットが対応するソケットで使用可能であることを処理スレッドに通知するロジックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1517">The contents of the callback function are applicationspecific; however, the function would most likely contain logic to inform the processing thread that a packet is available on the corresponding socket.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="b06e6-1518">スレッドの中断</span><span class="sxs-lookup"><span data-stu-id="b06e6-1518">Thread Suspension</span></span>      
<span data-ttu-id="b06e6-1519">前述のように、特定の TCP ポートからデータを受信しようとしている間に、アプリケーション スレッドが中断されることがあります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1519">As mentioned previously, application threads can suspend while attempting to receive data from a particular TCP port.</span></span> <span data-ttu-id="b06e6-1520">そのポートでパケットが受信されると、最初に中断されたスレッドに渡され、そのスレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1520">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="b06e6-1521">TCP 受信パケットで中断する場合は、オプションのタイムアウトを使用できます。これは、ほとんどの NetX Duo サービスで利用可能な機能です。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1521">An optional timeout is available when suspending on a TCP receive packet, a feature available for most NetX Duo services.</span></span>  

<span data-ttu-id="b06e6-1522">スレッドの中断は、接続 (クライアントとサーバーの両方)、クライアント バインド、および切断サービスでも使用できます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1522">Thread suspension is also available for connection (both client and server), client binding, and disconnection services.</span></span>  

### <a name="tcp-socket-statistics-and-errors"></a><span data-ttu-id="b06e6-1523">TCP ソケットの統計情報とエラー</span><span class="sxs-lookup"><span data-stu-id="b06e6-1523">TCP Socket Statistics and Errors</span></span>     
<span data-ttu-id="b06e6-1524">有効にすると、NetX Duo TCP ソケット ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1524">If enabled, the NetX Duo TCP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="b06e6-1525">次の統計およびエラー レポートは、IP/TCP インスタンスごとに保持されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1525">The following statistics and error reports are maintained for each IP/TCP instance:</span></span>   

- <span data-ttu-id="b06e6-1526">送信された TCP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1526">Total TCP Packets Sent</span></span>  
- <span data-ttu-id="b06e6-1527">送信された TCP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1527">Total TCP Bytes Sent</span></span>  
- <span data-ttu-id="b06e6-1528">受信した TCP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1528">Total TCP Packets Received</span></span>   
- <span data-ttu-id="b06e6-1529">受信した TCP バイトの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1529">Total TCP Bytes Received</span></span>   
- <span data-ttu-id="b06e6-1530">無効な TCP パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1530">Total TCP Invalid Packets</span></span>   
- <span data-ttu-id="b06e6-1531">ドロップされた TCP 受信パケットの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1531">Total TCP Receive Packets Dropped</span></span>    
- <span data-ttu-id="b06e6-1532">TCP 受信チェックサム エラーの合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1532">Total TCP Receive Checksum Errors</span></span>   
- <span data-ttu-id="b06e6-1533">TCP 接続の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1533">Total TCP Connections</span></span>   
- <span data-ttu-id="b06e6-1534">TCP 切断の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1534">Total TCP Disconnections</span></span>   
- <span data-ttu-id="b06e6-1535">ドロップされた TCP 接続の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1535">Total TCP Connections Dropped</span></span>    
- <span data-ttu-id="b06e6-1536">TCP パケットの再送信の合計数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1536">Total TCP Packet Retransmits</span></span>   
- <span data-ttu-id="b06e6-1537">送信された TCP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1537">TCP Socket Packets Sent</span></span>   
- <span data-ttu-id="b06e6-1538">送信された TCP ソケット バイト数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1538">TCP Socket Bytes Sent</span></span>   
- <span data-ttu-id="b06e6-1539">受信した TCP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1539">TCP Socket Packets Received</span></span>   
- <span data-ttu-id="b06e6-1540">受信した TCP ソケット バイト数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1540">TCP Socket Bytes Received</span></span>   
- <span data-ttu-id="b06e6-1541">TCP ソケット パケットの再送信数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1541">TCP Socket Packet Retransmits</span></span>    
- <span data-ttu-id="b06e6-1542">キューに登録された TCP ソケット パケット数</span><span class="sxs-lookup"><span data-stu-id="b06e6-1542">TCP Socket Packets Queued</span></span>    
- <span data-ttu-id="b06e6-1543">TCP ソケット チェックサム エラー</span><span class="sxs-lookup"><span data-stu-id="b06e6-1543">TCP Socket Checksum Errors</span></span>    
- <span data-ttu-id="b06e6-1544">TCP ソケットの状態</span><span class="sxs-lookup"><span data-stu-id="b06e6-1544">TCP Socket State</span></span>    
- <span data-ttu-id="b06e6-1545">TCP ソケット送信キューの深さ</span><span class="sxs-lookup"><span data-stu-id="b06e6-1545">TCP Socket Transmit Queue Depth</span></span>    
- <span data-ttu-id="b06e6-1546">TCP ソケット送信ウィンドウ サイズ</span><span class="sxs-lookup"><span data-stu-id="b06e6-1546">TCP Socket Transmit Window Size</span></span>    
- <span data-ttu-id="b06e6-1547">TCP ソケット受信ウィンドウ サイズ</span><span class="sxs-lookup"><span data-stu-id="b06e6-1547">TCP Socket Receive Window Size</span></span>    

<span data-ttu-id="b06e6-1548">これらのすべての統計およびエラー レポートは、合計 TCP 統計情報については ***nx_tcp_info_get** _ サービスを使用し、ソケットごとの TCP 統計情報については _ *_nx_tcp_socket_info_get_** サービスを使用すると、アプリケーションで使用可能になります。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1548">All these statistics and error reports are available to the application with the ***nx_tcp_info_get** _ service for total TCP statistics and the _ *_nx_tcp_socket_info_get_** service for TCP statistics per socket.</span></span>

### <a name="tcp-socket-control-block-nx_tcp_socket"></a><span data-ttu-id="b06e6-1549">TCP ソケット制御ブロック NX_TCP_SOCKET</span><span class="sxs-lookup"><span data-stu-id="b06e6-1549">TCP Socket Control Block NX_TCP_SOCKET</span></span>      
<span data-ttu-id="b06e6-1550">各 TCP ソケットの特性は、関連付けられている *NX_TCP_SOCKET* 制御ブロックにあります。これには、IP データ構造へのリンク、ネットワーク接続インターフェイス、バインドされたポート、受信パケット キューなどの有用な情報が格納されます。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1550">The characteristics of each TCP socket are found in the associated *NX_TCP_SOCKET* control block, which contains useful information such as the link to the IP data structure, the network connection interface, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="b06e6-1551">この構造体は ***nx_api.h*** ファイルで定義されています。</span><span class="sxs-lookup"><span data-stu-id="b06e6-1551">This structure is defined in the ***nx_api.h*** file.</span></span>