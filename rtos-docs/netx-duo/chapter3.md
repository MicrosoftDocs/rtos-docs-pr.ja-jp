---
title: 第 3 章 - Azure RTOS NetX Duo の機能コンポーネント
description: この章では、機能の観点から見た高パフォーマンスの Azure RTOS NetX Duo TCP/IP スタックについて説明します。
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 32af483db1f97b45bfe3d334b8c79d984dedc8470a37ce1d4164331549b6954c
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/07/2021
ms.locfileid: "116788964"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx-duo"></a>第 3 章 - Azure RTOS NetX Duo の機能コンポーネント

この章では、機能の観点から見た高パフォーマンスの Azure RTOS NetX Duo TCP/IP スタックについて説明します。 

## <a name="execution-overview"></a>実行の概要

NetX Duo アプリケーション内のプログラム実行には、初期化、アプリケーション インターフェイス呼び出し、内部 IP スレッド、IP の定期的なタイマー、およびネットワーク ドライバーの 5 種類があります。

> [!NOTE]
> *NetX Duo は、ThreadX の存在を前提としており、スレッドの実行、中断、定期的なタイマー、および相互排他設備に依存します。*

### <a name="initialization"></a>初期化

サービス ***nx_system_initialize** _ を他の NetX Duo サービスが呼び出される前に呼び出す必要があります。 システムの初期化は、ThreadX _ *_tx_application_define_** 関数から、またはアプリケーション スレッドから呼び出すことができます。

***nx_system_initialize** _ が返されると、パケット プールと IP インスタンスを作成する準備がシステムで整います。 IP インスタンスを作成するには既定のパケット プールが必要であるため、IP インスタンスを作成する前に少なくとも 1 つの NetX Duo パケット プールが存在している必要があります。 ThreadX 初期化関数 _ *_tx_application_define_** とアプリケーション スレッドから、パケット プールと IP インスタンスを作成できます。

内部的には、IP インスタンスの作成は 2 段階で行われます。第 1 段階は、***tx_application_define*** から、またはアプリケーション スレッドのコンテキストから、呼び出し元のコンテキスト内で行われます。 これには、IP データ構造の設定やさまざまな IP リソースの作成が含まれます (内部 IP スレッドを含む)。 2 番目の段階は、内部 IP スレッドからの初期実行時に実行されます。 ここで、IP 作成の第 1 段階で提供されるネットワーク ドライバーが最初に呼び出されます。 内部 IP スレッドからネットワーク ドライバーを呼び出すと、ドライバーは、I/O を実行して初期化処理中に一時停止できます。

初期化処理からネットワーク ドライバーが返されると、IP の作成が完了します。

NetX Duo での IPv6 の初期化には、追加の NetX Duo サービスがいくつか必要です。 これらについては、この章の後半の「[NetX Duo での IPv6](#ipv6-in-netx-duo)」セクションで詳しく説明します。

> [!NOTE]
> *NetX Duo サービス **nx_ip_status_check** は、IP インスタンスとそのプライマリ インターフェイスのステータスに関する情報を取得するために使用できます。そのようなステータス情報には、リンクが初期化、有効化されているかどうか、また IP アドレスが解決されているかどうかが含まれます。この情報は、新しく作成された IP インスタンスを使用する必要があるアプリケーション スレッドを同期するために使用されます。マルチホーム システムについては、「[マルチホーム サポート](#multihome-support)」を参照してください。**nx_ip_interface_status_check** は、指定されたインターフェイスに関する 3 つの情報を取得するために使用できます。*

### <a name="application-interface-calls"></a>アプリケーション インターフェイスの呼び出し

アプリケーションからの呼び出しは、ほとんどの場合、ThreadX RTOS で実行されているアプリケーション スレッドから作成されます。 ただし、一部の初期化、作成、および有効化のサービスは ***tx_application_define*** から呼び出すことができます。 「[第 4 章 - Azure RTOS NetX Duo サービスの説明](chapter4.md)」の「許可元」セクションでは、それぞれの NetX Duo サービスをどこから呼び出すことができるかを示しています。

ほとんどの場合、チェックサムの計算などの負荷の高いアクティビティは、他のスレッドの IP インスタンスへのアクセスをブロックすることなく、呼び出し元スレッドのコンテキスト内で実行されます。 たとえば、送信時に、基になる IP 送信関数を呼び出す前に、***nx_udp_socket_send** _ サービス内で UDP チェックサム計算が実行されます。 受信したパケットでは、_ *_nx_udp_socket_receive_** サービスで UDP チェックサムが計算され、アプリケーション スレッドで実行されます。 これにより、優先度の低いスレッドで負荷の高いチェックサム計算が行われることが原因で、優先順位の高いスレッドのネットワーク要求が停止されるのを防ぐことができます。

IP アドレスやポート番号などの値は、ホストのバイト順で API に渡されます。 内部的には、これらの値はホストのバイト順で格納もされます。 これにより、開発者はデバッガーを使用して値を簡単に表示できます。 これらの値は、送信のためにフレーム内にプログラミングされた場合、ネットワークのバイト順に変換されます。

### <a name="internal-ip-thread"></a>内部 IP スレッド

前述のように、NetX Duo の各 IP インスタンスには独自のスレッドがあります。 内部 IP スレッドの優先順位とスタック サイズは、***nx_ip_create*** サービスで定義されます。 内部 IP スレッドは、実行可能モードで作成されます。 IP スレッドの優先順位が呼び出し元のスレッドよりも高い場合、IP 作成呼び出しの内部でプリエンプションが発生する可能性があります。

内部 IP スレッドのエントリ ポイントは、内部関数 _ ***nx_ip_thread_entry*** にあります。 開始されると、内部 IP スレッドでは最初にネットワーク ドライバーの初期化が完了されます。これは、アプリケーション固有のネットワーク ドライバーに対する 3 回の呼び出しで構成されます。 最初の呼び出しでは、ネットワーク ドライバーを IP インスタンスに接続した後、初期化呼び出しを実行します。これにより、ネットワーク ドライバーは初期化プロセスを実行できます。 ネットワーク ドライバーが初期化から戻されると (ハードウェアが適切に設定されるのを待機している間に停止される場合があります)、内部 IP スレッドはネットワーク ドライバーを再度呼び出して、リンクを有効にします。 ネットワーク ドライバーがリンク有効化の呼び出しから戻されると、内部 IP スレッドは永久ループに入り、この IP インスタンスの処理を必要とするさまざまなイベントを確認します。 このループで処理されるイベントには、遅延 IP パケット受信、IP パケット フラグメント アセンブリ、ICMP ping 処理、IGMP 処理、TCP パケット キュー処理、TCP 周期処理、IP フラグメント アセンブリ タイムアウト、および IGMP 周期処理が含まれます。 イベントには、アドレス解決アクティビティ、IPv4 での ARP パケット処理と ARP 定期処理、重複アドレス検出、ルーター要請、IPv6 での近隣探索も含まれます。

> [!CAUTION]
> *リッスンや切断のコールバックを含む NetX Duo コールバック関数は、元の呼び出し元スレッドではなく、内部 IP スレッドから呼び出されます。アプリケーションは、NetX Duo コールバック関数内で中断しないように注意する必要があります。*

### <a name="ip-periodic-timers"></a>IP の定期的なタイマー

各 IP インスタンスには、ThreadX の定期的なタイマーが 2 つ使用されています。 1 つ目は、ARP、IGMP、TCP タイムアウト用の 1 秒のタイマーで、IP フラグメントの再アセンブル処理にも使用されます。 2 つ目のタイマーは、TCP 再送信タイムアウトと IPv6 関連操作に使用される 100 ミリ秒タイマーです。

### <a name="network-driver"></a>ネットワーク ドライバー

NetX Duo の各 IP インスタンスには、プライマリ インターフェイスがあります。これは、***nx_ip_create*** サービスで指定されているデバイス ドライバーによって識別されます。 ネットワーク ドライバーでは、パケットの送信、パケットの受信、状態と制御の要求など、さまざまな NetX Duo 要求が処理されます。 

マルチホーム システムの場合、IP インスタンスは複数のインターフェイスを持ち、それぞれのインターフェイスでこれらのタスクを実行するネットワーク ドライバーが関連付けられています。

ネットワーク ドライバーでは、メディアで発生している非同期イベントも処理する必要があります。 メディアからの非同期イベントには、パケットの受信、パケット送信の完了、および状態の変更が含まれます。 NetX Duo では、さまざまなイベントを処理するいくつかのアクセス関数がネットワーク ドライバーに提供されます。 これらの関数は、ネットワーク ドライバーの割り込みサービスのルーチン部分から呼び出されるように設計されています。 IPv4 ネットワークの場合、ネットワーク ドライバーは、受信したすべての ARP パケットを ***_nx_arp_packet_deferred_receive*** 内部関数に転送する必要があります。 すべての RARP パケットは * **_nx_rarp_packet_deferred_receive** _ 内部関数に転送される必要があります。 IP パケットには 2 つのオプションがあります。 IP パケットの高速ディスパッチが必要な場合は、受信 IP パケットを _ *_ _nx_ip_packet_receive_* _ に転送してすぐに処理する必要があります。 これにより、IP パケットを処理する際の NetX Duo のパフォーマンスが大幅に向上します。 それ以外の場合は、IP パケットを _ *_ _nx_ip_packet_deferred_receive_** に転送する必要があります。 このサービスでは、IP パケットが遅延処理キューに配置されます。このキューでパケットは内部 IP スレッドによって処理されます。これにより、ISR 処理時間が最短になります。

また、ネットワーク ドライバーでは、割り込み処理を遅延させて、IP スレッドのコンテキストから実行することもできます。 このモードの ISR では、必要な情報が保存され、内部関数 ***_nx_ip_driver_deferred_processing*** が呼び出されて、割り込みコントローラーが確認されます。 このサービスでは、割り込みを発生させるイベントのプロセスを完了するために、デバイス ドライバーへのコールバックをスケジュールするように、IP スレッドに通知されます。

一部のネットワーク コントローラーでは、貴重な CPU リソースを消費することなく、ハードウェアで TCP/IP ヘッダー チェックサムの計算と検証が実行されるようにできます。 ハードウェア機能を利用するために、NetX Duo では、さまざまなソフトウェア チェックサム計算をコンパイル時に有効または無効にするオプションに加えて、デバイス ドライバーが IP 層と通信できる場合に、チェックサム計算を実行時に有効または無効にするオプションを提供しています。 NetX Duo ネットワーク ドライバーの記述の詳細については、「[第 5 章 - Azure RTOS NetX Duo ネットワーク ドライバー](chapter5.md)」を参照してください。

### <a name="multihome-support"></a>マルチホーム サポート

NetX Duo では、単一の IP インスタンスを使用して複数の物理デバイスに接続されたシステムがサポートされます。 各物理インターフェイスは、IP インスタンス内のインターフェイス制御ブロックに割り当てられます。 マルチホーム システムを使用するアプリケーションでは、***NX_MAX_PHSYCIAL_INTERFACES** _ の値をシステムに接続されている物理デバイスの数に定義し、NetX Duo ライブラリをリビルドする必要があります。 既定では _ *_NX_MAX_PHYSICAL_INTERFACES_** が 1 に設定され、IP インスタンスに 1 つのインターフェイス制御ブロックが作成されます。

NetX Duo アプリケーションでは、***nx_ip_create** _ サービスを使用して、プライマリ デバイス用の単一の IP インスタンスが作成されます。 追加のネットワーク デバイスごとに、アプリケーションで _ *_nx_ip_interface_attach_** サービスを使用して、デバイスが IP インスタンスに接続されます。

各ネットワーク インターフェイス構造には、IP 制御ブロックに含まれるネットワーク インターフェイスに関するネットワーク情報のサブセットが含まれています。これには、インターフェイス IPv4 アドレス、サブネット マスク、IP MTU サイズ、および MAC レイヤー アドレス情報が含まれます。

> [!NOTE]
> *マルチホーム サポートが有効な NetX Duo には、以前のバージョンの NetX Duo との下位互換性があります。明示的なインターフェイス情報を受け取らないサービスは、既定でプライマリ ネットワーク デバイスに設定されます。*

IP インスタンスの一覧で、プライマリ インターフェイスはインデックス 0 になります。 IP インスタンスに接続されているそれ以降の各デバイスには、次のインデックスが割り当てられます。

IP インスタンスが有効になっているすべての上位層プロトコルサービス (TCP、UDP、ICMP、IGMP を含む) は、接続されているすべてのデバイスで使用できます。

ほとんどの場合、NetX Duo ではパケットの送信時に使用する最適な送信元アドレスを決定できます。 送信元アドレスの選択は、宛先アドレスに基づいています。 NetX Duo サービスは、宛先アドレスによって最適な送信元アドレスを特定できない場合に、使用する特定の送信元アドレスをアプリケーションで指定できるように追加されています。 例として、アプリケーションが IPv4 ブロードキャストまたはマルチキャストの宛先アドレスにパケットを送信する必要があるマルチホーム システムの場合を考えます。

マルチホーム アプリケーションの開発に特化したサービスには、次のものがあります。

- *nx_igmp_multicast_interface_join*
- *nx_igmp_multicast_interface_leave*
- *nx_ip_driver_interface_direct_command*
- *nx_ip_interface_address_get*
- *nx_ip_interface_address_mapping_configure*
- *nx_ip_interface_address_set*  
- *nx_ip_interface_attach*
- *nx_ip_interface_capability_get* 
- *nx_ip_interface_capability_set*
- *nx_ip_interface_detach*
- *nx_ip_interface_info_get*
- *nx_ip_interface_mtu_set*
- *nx_ip_interface_physical_address_get*
- *nx_ip_interface_physical_address_set*
- *nx_ip_interface_status_check*
- *nx_ip_raw_packet_source_send*
- *nx_ipv4_multicast_interface_join*
- *nx_ipv4_multicast_interface_leave*
- *nx_udp_socket_source_send*
- *nxd_ipv6_multicast_interface_join*
- *nxd_ipv6_multicast_interface_leave* 
- *nxd_udp_socket_source_send*
- *nxd_icmp_source_ping*
- *nxd_ip_raw_packet_source_send*
- *nxd_udp_socket_source_send*

これらのサービスについては、[NetX Duo サービスの説明](chapter4.md)に関するページで詳しく説明しています。

### <a name="loopback-interface"></a>ループバック インターフェイス

ループバック インターフェイスは、物理リンクがアタッチされていない特殊なネットワーク インターフェイスです。 ループバック インターフェイスを使用すると、アプリケーションで IPv4 ループバック アドレス 127.0.0.1 を使用して通信できます。論理ループバック インターフェイスを利用するには、構成可能なオプション ***NX_DISABLE_LOOPBACK_INTERFACE*** が設定されていないことを確認してください。

### <a name="interface-control-blocks"></a>インターフェイス制御ブロック

IP インスタンス内のインターフェイス制御ブロックの数は、物理インターフェイスの数 (***NX_MAX_PHYSICAL_INTERFACES** _ によって定義されます) に、ループバック インターフェイス (有効になっている場合) を加算したものです。 インターフェイスの合計数は、_*_NX_MAX_IP_INTERFACES_** で定義されています。

## <a name="protocol-layering"></a>プロトコルのレイヤー化

NetX Duo によって実装される TCP/IP は、レイヤー化されたプロトコルです。これは、より複雑なプロトコルが、より単純な基盤となるプロトコルの上に構築されることを意味します。 TCP/IP では、最下位層のプロトコルは "*リンク レベル*" にあり、ネットワーク ドライバーによって処理されます。 このレベルは、通常、イーサネットを対象としていますが、ファイバー、シリアル、または事実上すべての物理メディアである可能性もあります。

リンク層の上には "*ネットワーク層*" があります。 TCP/IP では、これは IP です。基本的には、ネットワーク全体で、ベストエフォート方式で単純なパケットを送受信する役割を担います。 ICMP や IGMP などの管理の種類のプロトコルは、通常、送信と受信のために IP に依存している場合でも、ネットワーク層として分類されます。

"*トランスポート層*" は、ネットワーク層の上に置かれます。 この層は、ネットワーク上でホスト間のデータ フローを管理する役割を担います。 NetX Duo でサポートされる転送サービスには、UDP と TCP の 2 種類があります。 UDP サービスは、コネクションレス方式で 2 つのホスト間でデータをベストエフォートで送受信します。一方、TCP は、2 つのホスト エンティティ間に信頼性の高い接続指向サービスを提供します。

このレイヤー化は、実際のネットワーク データ パケットに反映されます。 TCP/IP の各層には、ヘッダーと呼ばれる情報のブロックが含まれています。 データ (および場合によってはプロトコル情報) をヘッダーで囲むこの手法は、一般にデータのカプセル化と呼ばれます。 図 1 は、NetX Duo のレイヤー化の例を示し、図 2 は、送信される UDP データのデータ カプセル化を示しています。

![プロトコルのレイヤー化](./media/user-guide/image12.jpg)

**図 1. プロトコルのレイヤー化**

## <a name="packet-pools"></a>パケット プール

パケットを高速かつ決定論的な方法で割り当てることは、常に、リアルタイム ネットワーク アプリケーションの課題です。 これを念頭に置いて、NetX Duo では、固定サイズのネットワーク パケットの複数のプールを作成および管理する機能が提供されています。

NetX Duo のパケット プールは固定サイズのメモリ ブロックで構成されているため、内部断片化の問題は発生しません。 もちろん、断片化によって本質的に非決定論的な動作が発生します。 さらに、NetX Duo パケットを割り当てて解放するために必要な時間は、単純なリンクリスト操作と同等です。 さらに、使用可能な一覧の先頭でパケットの割り当てと割り当て解除が行われます。 これにより、可能なリンク リストの処理が最速になります。

![UDP データのカプセル化](./media/user-guide/image13.png)

**図 2. UDP データのカプセル化**

通常、固定サイズのパケット プールの主な欠点は、柔軟性の欠如です。 最悪の場合の受信パケットも処理できる最適なパケット ペイロード サイズを判断することは、困難な作業です。 NetX Duo パケットは、"パケット チェーン" と呼ばれるオプションの機能を使用してこの問題に対処します。 実際のネットワーク パケットは、互いにリンクされた 1 つ以上の NetX Duo パケットで構成されている可能性があります。 また、パケット ヘッダーはパケットの先頭へのポインターを保持します。 プロトコルが追加されると、このポインターは単純に後方に移動されて、新しいヘッダーがデータの前に直接書き込まれます。 柔軟なパケット テクノロジを使用しない場合、スタックは別のバッファーを割り当て、新しいヘッダーを使用して新しいバッファーにデータをコピーする必要があります。これは、負荷の高い処理です。

各パケットのペイロード サイズは特定のパケット プールに対して固定されているため、ペイロード サイズを超えるアプリケーション データでは、複数のパケットが連結されている必要があります。 パケットにユーザー データを入力する場合は、アプリケーションでサービス ***nx_packet_data_append*** を使用します。 このサービスによって、アプリケーション データがパケットに移動されます。 パケットがユーザー データを保持するのに十分でない場合は、ユーザー データを格納するための追加のパケットが割り当てられます。 パケット チェーンを使用するには、ドライバーがチェーン化されたパケットとの間で送受信できる必要があります。

パケット チェーン機能を使用する必要のない組み込みシステムの場合、***NX_DISABLE_PACKET_CHAIN** _ で NetX Duo ライブラリをビルドして、パケット チェーン ロジックを削除することができます。 注意点として、IP の断片化と再アセンブリの機能では、チェーン化パケット機能を利用することが必要な場合があります。 したがって、_*_NX_DISABLE_PACKET_CHAIN_*_ を定義するには _ *_NX_DISABLE_FRAGMENTATION_** も定義する必要があります。 

各 NetX Duo パケット メモリ プールは、パブリック リソースです。 NetX Duo では、パケット プールの使用方法に関する制約はありません。 

### <a name="packet-pool-memory-area"></a>パケット プールのメモリ領域

パケット プールのメモリ領域は、作成時に指定されます。 ThreadX オブジェクトと NetX Duo オブジェクトの他のメモリ領域と同様に、ターゲットのアドレス空間内のどこにでも配置できます。 

アプリケーションに非常に高い柔軟性が提供されるため、これは重要な機能です。 たとえば、ネットワーク バッファー用に高速メモリ領域がある通信製品を考えます。 このメモリ領域を NetX Duo パケット メモリ プール内に作成することで、この領域を簡単に利用できます。

### <a name="creating-packet-pools"></a>パケット プールの作成

パケット プールは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。 NetX Duo アプリケーションのパケット メモリ プールの数に制限はありません。

### <a name="dual-packet-pool"></a>デュアル パケット プール

通常、既定の IP パケット プールのペイロード サイズは、最大でネットワーク インターフェイス MTU のサイズのフレームを収容するのに十分な大きさです。 通常の操作中、IP スレッドでは、ARP、TCP 制御メッセージ、IGMP メッセージ、ICMPv6 メッセージなどのメッセージを送信する必要があります。 これらのメッセージでは、IP インスタンス内の既定のパケットプールから割り当てられたパケットを使用します。 メモリの制約があり、パケット プールに使用できるメモリの量が限られているシステムでは、(MTU サイズに合わせた大きなペイロード サイズの) 1 つのパケット プールを使用するのは最適なソリューションではない場合があります。 NetX Duo を使用すると、アプリケーションでは、ペイロード サイズが比較的小さい補助パケット プールをインストールできます。 補助パケット プールがインストールされると、IP ヘルパー スレッドでは、送信するメッセージのサイズに応じて、既定のパケット プールまたは補助プールのどちらかからパケットを割り当てます。 補助パケット プールの場合、200 バイトのペイロード サイズは、IP ヘルパー スレッドで送信するほとんどのメッセージに十分です。

既定では、NetX Duo ライブラリはデュアル パケット プールを有効にせずにビルドされます。 この機能を有効にするには、***NX_DUAL_PACKET_POOL_ENABLE** _ を定義してライブラリをビルドします。 これ以降、_*_nx_ip_auxiliary_packet_pool_set_** を呼び出して補助パケット プールを設定できます。

複数のパケット プールを作成するオプションもあります。 たとえば、送信パケット プールは、予想されるメッセージ サイズに最適なペイロード サイズで作成されます。 受信パケットのサイズは予測できないため、ドライバーでは、ドライバー MTU に設定されたペイロード サイズで受信パケット プールが作成されます。

### <a name="packet-header-nx_packet"></a>パケット ヘッダー NX_PACKET   
既定では、NetX Duo ではパケット ペイロード領域の直前にパケット ヘッダーが配置されます。 パケット メモリ プールは基本的に一連のパケットで、ヘッダーの直後にパケット ペイロードが続きます。 パケット ヘッダー (***NX_PACKET***) とパケット プールのレイアウトを図 3 に示します。

ゼロ コピー操作を実行できるネットワーク デバイス ドライバーでは、通常、パケット ペイロード領域の開始アドレスが DMA ロジックにプログラミングされます。 特定の DMA エンジンでは、ペイロード領域にアラインメントの要件があります。 ペイロード領域の開始アドレスを、DMA エンジンまたはキャッシュ操作に合わせて適切に整列させるために、ユーザーはシンボル ***NX_PACKET_ALIGNMENT*** を定義できます。

> [!WARNING]
> *パケットの伝送が完了したら、ネットワーク ドライバーで **nx_packet_transmit_release** 関数を使用することが重要です。この関数によって、パケットが使用可能なプールに実際に戻される前に、TCP 出力キューに含まれていないことが確認されます。*

![パケット ヘッダーとパケット プールのレイアウト](./media/user-guide/image14.jpg)

**図 3. パケット ヘッダーとパケット プールのレイアウト**

パケット ヘッダーのフィールドは次のように定義されています。 この表は、*NX_PACKET* 構造のすべてのメンバーの包括的な一覧ではないことに注意してください。

|パケット ヘッダー | 目的 |
|---|---|
|***nx_packet_pool_owner***|このフィールドは、この特定のパケットを所有するパケット プールを指します。 パケットが解放されると、この特定のプールに解放されます。 各パケット内のプール所有権に基づいて、データグラムが複数のパケット プールの複数のパケットにまたがる場合があります。|
|***nx_packet_next** _|このフィールドは、同じフレーム内の次のパケットを指します。 NULL の場合、フレームに含まれる追加のパケットはありません。 このフィールドは、パケット全体が再アセンブル可能になるまでの間、断片化されたパケットを保持するためにも使用されます。 _*_NX_DISABLE_PACKET_CHAIN_** が定義されている場合、削除されます。|
|***nx_packet_last** _|このフィールドは、同じネットワーク パケット内の最後のパケットを指します。 NULL の場合、このパケットはネットワーク パケット全体を表します。 _*_NX_DISABLE_PACKET_CHAIN_** が定義されている場合、このフィールドは削除されます。|
|***nx_packet_length** _| このフィールドには、ネットワーク パケット全体の合計バイト数が含まれます。これには、_nx_packet_next* メンバーによって連結されているすべてのパケットの合計バイト数が含まれます。|
|***nx_packet_ip_interface***| このフィールドは、インターフェイス ドライバーによって、また発信パケットのために NetX Duo によって受信されるときにパケットに割り当てられるインターフェイス制御ブロックです。 インターフェイス制御ブロックはインターフェイスを記述します。たとえば、ネットワーク アドレス、MAC アドレス、IP アドレス、およびのインターフェイスの状態 (リンクが有効、物理マッピングが必要、など) を表します。|
|***nx_packet_data_start** _| このフィールドは、このパケットの物理ペイロード領域の開始位置を示します。 NX_PACKET ヘッダーの直後に配置する必要はありませんが、これが _ *_nx_packet_pool_create_** サービスの既定の設定です。|
|***nx_packet_data_end** _|このフィールドは、このパケットの物理ペイロード領域の最後を指しています。 このフィールドと _nx_packet_data_start* フィールドの差は、ペイロード サイズを表します。|
|***nx_packet_prepend_ptr** _|このフィールドは、パケット データ (プロトコル ヘッダーまたは実際のデータ) が、パケット ペイロード領域内の既存のパケット データ (存在する場合) の前に追加される場所を指します。 _nx_packet_data_start* ポインターの位置以上で、*nx_packet_append_ptr* ポインター以下である必要があります。|
> [!CAUTION]
> *NetX Duo では、パフォーマンス上の理由から、パケットが伝送のために NetX Duo サービスに渡されるときに、プリペンド ポインターがロング ワード単位で揃えたアドレスを指していることを前提としています。*

| パケット ヘッダー | 目的 |
|---|---|
|***nx_packet_append_ptr** _|このフィールドは、現在パケット ペイロード領域にあるデータの末尾を指します。 これは、_nx_packet_prepend_ptr* と *nx_packet_data_end* によって示されるメモリ位置の間にある必要があります。 このフィールドと *nx_packet_prepend_ptr* フィールドの差は、このパケット内のデータの量を表します。|
|***nx_packet_packet_pad** _|このフィールドでは、必要なアラインメント要件を達成するために、4 バイト ワードの埋め込みの長さを定義します。 _*_NX_PACKET_HEADER_PAD_*_ が定義されていない場合、このフィールドは削除されます。 _nx_packet_header_pad* を定義する代わりに _*_NX_PACKET_ALIGNMENT_*_ を使用することもできます。|

### <a name="packet-header-offsets"></a>パケット ヘッダーのオフセット

ヘッダーのサイズを格納するのに十分な領域を確保するために、パケット ヘッダーのサイズが定義されています。 ***nx_packet_allocate*** サービスは、パケットを割り当て、指定されたパケットの種類に従ってパケット内のプリペンド ポインターを調整するために使用されます。 パケットの種類によって、プロトコルのデータの前にプロトコル ヘッダー (UDP、TCP、ICMP など) を挿入するために必要なオフセットが NetX Duo に示されます。

パケット内の IP ヘッダーと物理層 (イーサネット) ヘッダーを考慮するために、NetX Duo で次の種類が定義されています。 後者の場合は、必要な 4 バイトのアラインメントを考慮して、16 バイトであると想定されます。 IPv4 ネットワークのパケットを割り当てるために、アプリケーション向けに NetX Duo で IPv4 パケットが引き続き定義されています。 IPv6 を有効にして NetX Duo ライブラリをビルドする場合、汎用のパケットの種類 (NX_IP_PACKET など) は IPv6 バージョンにマップされることに注意してください。 IPv6 を有効にせずに NetX Duo ライブラリをビルドする場合、これらの汎用のパケットの種類は IPv4 バージョンにマップされます。

次の表は、IPv6 を有効にして定義されたシンボルを示しています。

|**パケットの種類** |**Value** |
|---|---|
|NX_IPv6_PACKET (NX_IP_PACKET) | 0x38 |
|NX_UDPv6_PACKET (NX_UDP_PACKET) |0x40 |
|NX_TCPv6_PACKET (NX_TCP_PACKET) |0x4c |
|NX_IPv4_PACKET |0x24 |
|NX_IPv4_UDP_PACKET |0x2c |
|NX_IPv4_TCP_PACKET |0x38 |

次の表は、IPv6 を無効にして定義されたシンボルを示しています。

|**パケットの種類** |**Value** |
|---|---|
|NX_IPv4_PACKET (NX_IP_PACKET) |0x24 |
|NX_IPv4_UDP_PACKET (NX_UDP_PACKET) |0x2c |
|NX_IPv4_TCP_PACKET (NX_TCP_PACKET) |0x38 |

*NX_IPSEC_ENABLE* が定義されている場合、これらの値は変わることに注意してください。 IPsec を使用するアプリケーションについては、NetX Duo IPsec ユーザー ガイドで詳細を参照してください。

### <a name="pool-capacity"></a>プールの容量

パケット プール内のパケット数は、ペイロード サイズと、パケット プール作成サービスに渡されるメモリ領域内の合計バイト数と相関しています。 プールの容量は、パケット サイズ (NX_PACKET ヘッダーのサイズ、ペイロード サイズ、適切なアラインメントなど) で、指定されたメモリ領域の合計バイト数を除算して計算されます。

### <a name="payload-area-alignment"></a>ペイロード領域の整列

NetX Duo のパケット プール設計では、ゼロ コピーをサポートしています。 デバイス ドライバー レベルでは、ドライバーはデータ受信のために、ペイロード領域をバッファー記述子に直接割り当てることができます。 DMA エンジンまたはキャッシュ同期メカニズムで、ペイロード領域の開始アドレスに特定のアラインメント要件があることが要求される場合があります。 これは、必要なアラインメント要件 (バイト単位) を ***NX_PACKET_ALIGNMENT*** で定義することで実現できます。 パケット プールを作成するとき、ペイロード領域の開始アドレスはこの値に整列されます。 既定では、開始アドレスは 4 バイトで整列されます。

### <a name="thread-suspension"></a>スレッドの中断

空のプールからのパケットを待機している間に、アプリケーション スレッドが停止する場合があります。 パケットがプールに返されると、停止されていたスレッドにこのパケットが割り当てられ、再開されます。

同じパケット プールで複数のスレッドが停止された場合、それらは停止された順序で再開されます (FIFO)。

### <a name="pool-statistics-and-errors"></a>プールの統計情報とエラー

有効にすると、NetX Duo パケット管理ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計情報とエラー レポートがパケット プール向けに保持されます。

- プール内の合計パケット数
- プール内の空きパケット数
- パケット割り当ての合計
- プールの空の割り当て要求
- プールの空の割り当て保留
- 無効なパケットの解放

これらの統計情報およびエラー レポートはすべて、プール内の合計パケット数と空きパケット数を除いて、***NX_DISABLE_PACKET_INFO** _ が定義されていない限り、NetX Duo ライブラリに組み込まれています。 このデータは、アプリケーションで _ *_nx_packet_pool_info_get_** サービスと共に使用できます。

### <a name="packet-pool-control-block-nx_packet_pool"></a>パケット プール制御ブロック NX_PACKET_POOL

各パケット メモリ プールの特性は、その制御ブロックに含まれています。 ここには、空きパケットのリンク リスト、空きパケットの数、このプール内のパケットのペイロード サイズなどの有用な情報が含まれています。 この構造体は ***nx_api.h*** ファイルで定義されています。

パケット プール制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。

## <a name="ipv4-protocol"></a>IPv4 プロトコル

NetX Duo のインターネット プロトコル (IP) コンポーネントは、インターネット上で IPv4 パケットを送受信する役割を担います。 このコンポーネントは、NetX Duo では、基盤となるネットワーク ドライバーを使用して、TCP、UDP、ICMP、および IGMP メッセージの送信および受信を最終的に担います。

NetX Duo では、IPv4 プロトコル (RFC 791) と IPv6 プロトコル (RFC 2460) の両方をサポートしています。 このセクションでは、IPv4 について説明します。 IPv6 については次のセクションで説明します。

### <a name="ipv4-addresses"></a>IPv4 アドレス

インターネット上の各ホストには、IP アドレスと呼ばれる 32 ビットの一意の識別子があります。 図 4 に示すように、IPv4 アドレスには 5 つのクラスがあります。 5 つの IPv4 アドレス クラスの範囲は次のとおりです。

|クラス|Range|
|---|---|
|A |0.0.0.0 ～ 127.255.255.255|
|B |128.0.0.0 ～ 191.255.255.255|
|C |192.0.0.0 ～ 223.255.255.255|
|D |224.0.0.0 ～ 239.255.255.255|
|E |240.0.0.0 ～ 247.255.255.255|

![IPv4 アドレス構造の図。](./media/user-guide/ipv4-address-structure.png)

### <a name="figure-4-ipv4-address-structure"></a>図 4. IPv4 アドレス構造

アドレス指定には、"*ユニキャスト*"、"*ブロードキャスト*"、"*マルチキャスト*" の 3 つの種類があります。 ユニキャスト アドレスは、インターネット上の特定のホストを識別する IPv4 アドレスです。 ユニキャスト アドレスには、送信元または宛先の IPv4 アドレスを指定できます。 ブロードキャスト アドレスは、特定のネットワークまたはサブネットワーク上のすべてのホストを識別し、宛先アドレスとしてのみ使用できます。 ブロードキャスト アドレスは、アドレスのホスト ID 部分を 1 に設定することによって指定します。 マルチキャスト アドレス (クラス D) は、インターネット上のホストの動的なグループを指定します。 マルチキャスト グループのメンバーは、いつでも参加し離脱することができます。

> [!IMPORTANT]
> *UDP over IPv4 のようなコネクションレス プロトコルでのみ、ブロードキャストと、マルチキャスト グループの制限付きブロードキャスト機能を利用できます。*

> [!IMPORTANT]
> *マクロ *IP_ADDRESS* は ***nx_api.h** _ で定義されています。 これにより、ピリオドではなくコンマを使用して IPv4 アドレスを簡単に指定できます。 たとえば、図 4 に示すように、_IP_ADDRESS(128,0,0,0)* では最初のクラス B アドレスが指定されます。*

### <a name="ipv4-gateway-address"></a>IPv4 ゲートウェイ アドレス

ネットワーク ゲートウェイは、ネットワーク上のホストが、ローカル ドメインの外部の宛先に送信するパケットをリレーするのを支援します。 宛先が近隣ノードのいずれかなのか、または、事前にプログラミングされた静的ルーティング テーブルを使用するのか、といった、宛先となるネクスト ホップに関するいくつかの情報が各ノードにあります。 ただし、これらのアプローチが失敗した場合、ノードはパケットを既定のゲートウェイに転送する必要があります。ここには、パケットを宛先にルーティングする方法について、より適切な情報があります。 既定のゲートウェイは、IP インスタンスに接続されている物理インターフェイスの 1 つを介して直接アクセスできる必要があることに注意してください。 アプリケーションは ***nx_ip_gateway_address_set** _ を呼び出して、IPv4 の既定のゲートウェイ アドレスを構成します。 現在の IPv4 ゲートウェイ設定を取得するには、サービス _*_nx_ip_gateway_address_get_*_ を使用します。 アプリケーションでは、サービス _ *_nx_ip_gateway_address_clear_** を使用してゲートウェイ設定をクリアします。

### <a name="ipv4-header"></a>IPv4 ヘッダー

インターネット上で送信されるすべての IPv4 パケットについて、IPv4 ヘッダーが必要です。 上位レベルのプロトコル (UDP、TCP、ICMP、または IGMP) がパケットを送信するために IPv4 コンポーネントを呼び出すと、IP 送信モジュールによってデータの前に IPv4 ヘッダーが配置されます。 逆に、IP パケットをネットワークから受信した場合、IP コンポーネントでは、上位レベルのプロトコルにパケットを配信する前に IPv4 ヘッダーを削除します。 図 5 は、IP ヘッダーの形式を示しています。

![IPv4 ヘッダーの形式](./media/user-guide/ipv4-header-format.png)

### <a name="figure-5-ipv4-header-format"></a>図 5. IPv4 ヘッダーの形式

> [!IMPORTANT]
> *TCP/IP 実装のすべてのヘッダーは、**ビッグ エンディアン** 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに配置されます。たとえば、IP ヘッダーの 4 ビットのバージョンと 4 ビットのヘッダー長は、ヘッダーの最初のバイトに配置する必要があります。*

IPv4 ヘッダーのフィールドは次のように定義されています。

|IPv4 &nbsp;ヘッダー&nbsp; のフィールド |目的 |
|---|---|
|***4 ビットのバージョン*** |このフィールドには、このヘッダーが表す IP のバージョンが含まれています。 NetX Duo でサポートされている IP バージョン 4 では、このフィールドの値は 4 です。 |
|***4 ビットのヘッダー長*** |このフィールドは、IP ヘッダー内の 32 ビット ワードの数を指定します。 オプションのワードが存在しない場合、このフィールドの値は 5 になります。 |
|***8 ビットのサービスの種類 (TOS)*** |このフィールドは、この IP パケットに要求されるサービスの種類を指定します。 有効な要求を次に示します。<br />- 通常: 0x00 <br />- 最小遅延: 0x00<br />- 最大データ: 0x08<br />- 最大信頼性: 0x04<br />- 最小コスト: 0x02 |
|***16 ビットの合計長*** |このフィールドには、IP ヘッダーを含む IP データグラムの合計長がバイト単位で表示されます。 IP データグラムは、TCP/IP インターネットで検出された情報の基本単位です。 これには、データに加えて、宛先と送信元のアドレスが含まれます。 これは 16 ビットのフィールドであるため、IP データグラムの最大サイズは 65,535 バイトです。|
|***16 ビットの ID*** |このフィールドは、ホストから送信された各 IP データグラムを一意に識別するために使用される番号です。 通常、この番号は IP データグラムの送信後にインクリメントされます。 これは、受信した IP パケット フラグメントをアセンブルする場合に特に便利です。|
|***3 ビットのフラグ*** |このフィールドには IP の断片化に関する情報が含まれています。 ビット 14 は "フラグメント禁止" ビットです。 このビットが設定されている場合、発信 IP データグラムは断片化されません。 ビット 13 は "フラグメント継続" ビットです。 このビットが設定されている場合は、断片化が継続されます。 このビットがクリアされている場合、これは IP パケットの最後のフラグメントです。|
|***13 ビットのフラグメント オフセット*** |このフィールドには、フラグメント オフセットの上位 13 ビットが含まれます。 このため、フラグメント オフセットは 8 バイト境界でのみ許可されます。 断片化された IP データグラムの最初のフラグメントには、"フラグメント継続" ビットが設定され、オフセットは 0 になります。|
|***8 ビットの Time to Live (TTL)*** |このフィールドには、このデータグラムが通過できるルーターの数が含まれます。これによって基本的に、データグラムの有効期間が制限されます。|
|***8 ビットのプロトコル***|このフィールドでは、IP データグラムを使用しているプロトコルを指定します。 有効なプロトコルとその値の一覧を次に示します。<br />- ICMP: 0x01 <br />- IGMP: 0x02<br />- TCP: 0X06<br />- UDP: 0X11 |
|***16 ビットのチェックサム*** |このフィールドには、IP ヘッダーのみを対象とする 16 ビットのチェックサムが含まれています。 上位レベルのプロトコルには、IP ペイロードに対応する追加のチェックサムがあります。 |
|***32 ビットの送信元 IP アドレス*** |このフィールドには送信者の IP アドレスが含まれ、常にホスト アドレスです。 |
|***32 ビットの宛先 IP アドレス*** |このフィールドには、アドレスがブロードキャストまたはマルチキャスト アドレスの場合、単一または複数の受信側の IP アドレスが含まれます。 |

### <a name="creating-ip-instances"></a>IP インスタンスの作成

IP インスタンスは、アプリケーション スレッドによる初期化中またはランタイムに作成されます。 アプリケーションで IPv6 ネットワークのみを使用する意図の場合でも、***nx_ip_create*** サービスによって、内部 IP スレッドの初期 IPv4 アドレス、ネットワーク マスク、既定のパケット プール、メディア ドライバー、メモリと優先順位が定義されます。 IPv4 アドレスが無効なアドレス (0.0.0.0) に設定されている IP インスタンスをアプリケーションで初期化する場合は、後で RARP や、DHCP または同様のプロトコルを使用して、インターフェイス アドレスが手動構成によって解決されることを前提としています。

複数のネットワーク インターフェイスがあるシステムでは、***nx_ip_create** _ を呼び出すときにプライマリ インターフェイスが指定されます。 _*_nx_ip_interface_attach_** を呼び出すことによって、追加の各インターフェイスを同じ IP インスタンスにアタッチできます。 このサービスでは、ネットワーク インターフェイスに関する情報 (IP アドレス、ネットワーク マスクなど) をインターフェイス制御ブロックに格納し、ドライバー インスタンスを IP インスタンスのインターフェイス制御ブロックに関連付けます。 ドライバーでは、データ パケットが受信されたら、IP 受信ロジックに転送する前に、インターフェイス情報を NX_PACKET 構造体に格納する必要があります。 IP インスタンスは、インターフェイスをアタッチする前に既に作成されている必要があることに注意します。

***nx_ip_create** _ を呼び出した後、IPv6 サービスは開始されません。 IPv6 サービスを使用するアプリケーションでは、サービス _ *_nx_ipv6_enable_** を呼び出して IPv6 を開始する必要があります。

IPv6 ネットワークでは、IP インスタンスの各インターフェイスが複数の IPv6 グローバル アドレスを持つ場合があります。 IPv6 アドレス割り当てに DHCPv6 を使用することに加えて、デバイスではステートレス アドレス自動構成も使用できます。 詳細については、この章の後半の「IP 制御ブロック」および「IPv6 アドレス解決」のセクションで説明します。

### <a name="ip-send"></a>IP 送信

NetX Duo の IP 送信処理は非常に合理化されています。 パケット内のプリペンド ポインターは、IP ヘッダーを格納するために後方に移動されます。 IP ヘッダーが完了し (呼び出し元のプロトコル レイヤーで指定されたすべてのオプションが使用されます)、IP チェックサムがインラインで計算され (IPv4 パケットの場合のみ)、関連付けられているネットワーク ドライバーにパケットがディスパッチされます。 また、発信の断片化は、IP 送信処理内からも調整されます。

IPv4 で宛先 IP アドレスに物理マッピングが必要な場合、NetX Duo で ARP 要求が開始されます。 IPv6 は、IPv6 アドレスから物理アドレスへのマッピングに近隣探索を使用します。

> [!NOTE]
> *IPv4 接続では、キューに格納されているパケットの数が ARP キューの深さ (シンボル **NX_ARP_MAX_QUEUE_DEPTH** によって定義されている) を超えない限り、IP アドレス解決 (つまり、物理マッピング) を必要とするパケットは ARP キューにエンキューされます。キューの深さに達した場合、NetX Duo ではキューの最も古いパケットが削除され、エンキューされた残りのアドレスの解決を待機し続けます。一方、ARP エントリが解決されない場合、ARP エントリの保留中のパケットは、ARP エントリのタイムアウト時に解放されます。*

複数のネットワーク インターフェイスがあるシステムでは、NetX Duo は宛先 IP アドレスに基づいてインターフェイスを選択します。 選択プロセスには、次の手順が適用されます。

1. 送信者によって発信インターフェイスが指定され、そのインターフェイスが有効である場合は、そのインターフェイスを使用します。
2. 宛先アドレスが IPv4 ブロードキャストまたはマルチキャストの場合、最初の有効化された物理インターフェイスが使用されます。
3. 宛先アドレスが静的ルーティング テーブルで見つかった場合は、そのゲートウェイに関連付けられているインターフェイスが使用されます。
4. 宛先がオンリンクの場合は、オンリンク インターフェイスが使用されます。
5. 宛先アドレスがリンクローカル アドレス (169.254.0.0/16) である場合、最初の有効なインターフェイスが使用されます。
6. 既定のゲートウェイが構成されている場合は、既定のゲートウェイに関連付けられているインターフェイスを使用してパケットを転送します。
7. 最後に、有効なインターフェイス IP アドレスの 1 つがリンクローカル アドレス (169.254.0.0/16) である場合、このインターフェイスが送信元アドレスとして送信に使用されます。
8. 上記のすべてが失敗した場合、出力パケットはドロップされます。

### <a name="ip-receive"></a>IP 受信

IP 受信処理は、ネットワーク ドライバーまたは内部 IP スレッドから呼び出されます (遅延受信パケット キューのパケットを処理するため)。 IP 受信処理では、プロトコル フィールドを調べて、適切なプロトコル コンポーネントにパケットをディスパッチしようとします。 パケットが実際にディスパッチされる前に、IP ヘッダーの前にプリペンド ポインターを移動することで、IP ヘッダーが削除されます。

IP 受信処理では、断片化された IP パケットも検出されて、断片化が有効になっている場合に再アセンブルするために必要な手順が実行されます。 断片化が必要でも有効になっていない場合、パケットはドロップされます。

NetX Duo では、パケットに指定されたインターフェイスに基づいて、適切なネットワーク インターフェイスが決定されます。 パケット インターフェイスが NULL の場合、NetX Duo では既定でプライマリ インターフェイスに設定されます。 これは、NetX Duo のレガシ イーサネット ドライバーとの互換性を保証するために行われます。

### <a name="raw-ip-send"></a>生 IP 送信

生 IP パケットは、NetX Duo によって直接はサポート (および処理) されない上位層プロトコル ペイロードを含む IP フレームです。 生のパケットを使用すると、開発者は独自の IP ベースのアプリケーションを定義できます。 生 IP パケット処理が _*_nx_ip_raw_packet_enabled_*_ サービスで有効になっている場合、アプリケーションでは ***nxd_ip_raw_packet_send** _ サービスを使用して生 IP パケットを直接送信できます。 IPv6 ネットワークでユニキャスト パケットを送信するとき、NetX Duo では、パケットの送出に使用する最適な送信元 IPv6 アドレスを、宛先アドレスに基づいて自動的に決定します。 宛先アドレスがマルチキャスト (または IPv4 の場合のブロードキャスト) アドレスの場合でも、NetX Duo では既定で最初の (プライマリ) インターフェイスが設定されます。 そのため、このようなパケットをセカンダリ インターフェイスで送信するには、アプリケーションで _ *_nx_ip_raw_packet_source_send_** サービスを使用して、発信パケットに使用する送信元アドレスを指定する必要があります。

### <a name="raw-ip-receive"></a>生 IP 受信

生 IP パケット処理が有効になっている場合、アプリケーションは ***nx_ip_raw_packet_receive** _ サービスを通じて生 IP パケットを受信する可能性があります。 すべての受信パケットは、IP ヘッダーで指定されたプロトコルに従って処理されます。 プロトコルで UDP、TCP、IGMP、ICMP のいずれかが指定されている場合、NetX Duo ではパケット プロトコルの種類に適したハンドラーを使用してパケットを処理します。 プロトコルがこれらのプロトコルのいずれかではなく、生 IP 受信が有効になっている場合、受信パケットは生パケット キューに格納されて、アプリケーションで _*_nx_ip_raw_packet_receive_** サービスを介して受信されるのを待機します。また、生 IP パケットを待機している間に、オプションのタイムアウトでアプリケーション スレッドが停止されることもあります。生パケット キューに入れることができるパケットの数には制限があります。最大値は ***NX_IP_RAW_MAX_QUEUE_DEPTH**_ で定義され、その既定値は 20 です。 アプリケーションでは、_ *_nx_ip_raw_receive_queue_max_set_** サービスを呼び出して最大値を変更できます。

代わりに、NetX Duo ライブラリを ***NX_ENABLE_IP_RAW_PACKET_FILTER*** でビルドすることもできます。 この動作モードでは、アプリケーションは、未処理のプロトコルの種類であるパケットを受信するたびに呼び出されるコールバック関数を提供します。 IP 受信ロジックでは、パケットをユーザー定義の生パケット受信フィルター ルーチンに転送します。 フィルター ルーチンでは、将来のプロセスのために生パケットを保持するかどうかを決定します。 コールバック ルーチンからの戻り値は、パケットが生パケット受信フィルターによって処理されたかどうかを示します。 パケットがコールバック関数によって処理される場合、アプリケーションでパケットが不要になったらパケットを解放する必要があります。 それ以外の場合、パケットの解放は NetX Duo の責任です。 生パケット フィルター関数の使用方法の詳細については、**_nx_ip_raw_packet_filter_set_** を参照してください。

> [!NOTE]
> *NetX Duo の BSD ラッパー関数では、生パケット フィルター関数を使用して BSD 生ソケットを処理します。 そのため、BSD ラッパーで生ソケットをサポートするためには、***NX_ENABLE_IP_RAW_PACKET_FILTER** _ を定義して NetX Duo ライブラリをビルドする必要があります。またアプリケーションでは、_*_nx_ip_raw_packet_filter_set_*_ を使用してその独自の生パケット フィルター関数をインストールしてはなりません。_

### <a name="default-packet-pool"></a>既定のパケット プール

各 IP インスタンスには、作成時に既定のパケット プールが割り当てられます。 このパケット プールは、ARP、RARP、ICMP、IGMP、各種 TCP 制御パケット (SYN、ACK など)、近隣探索、ルーター発見、重複アドレスの検出にパケットを割り当てるために使用されます。 NetX Duo がパケットを割り当てる必要があるときに既定のパケット プールが空の場合、NetX Duo で特定の操作を中止することが必要になる場合があり、可能な場合はエラー メッセージを返します。

### <a name="ip-helper-thread"></a>IP ヘルパー スレッド

各 IP インスタンスには、ヘルパー スレッドがあります。 このスレッドは、すべての遅延パケット処理とすべての周期処理を担います。 IP ヘルパー スレッドは ***nx_ip_create*** で作成されます。ここで、スレッドのスタックと優先順位が指定されます。 IP ヘルパー スレッドでの最初の処理は、IP 作成サービスに関連付けられているネットワーク ドライバーの初期化を完了することである点に注意してください。 ネットワーク ドライバーの初期化が完了すると、ヘルパー スレッドはパケットと定期的な要求を処理するために無限ループを開始します。

> [!IMPORTANT]
> *IP ヘルパー スレッド内で予期しない動作が見られた場合、最初のデバッグ手順は、IP 作成サービス中にスタック サイズを増やすことです。スタックが小さすぎる場合に、IP ヘルパー スレッドによってメモリが上書きされている可能性があります。これにより、通常とは異なる問題が発生することがあります。*

### <a name="thread-suspension"></a>スレッドの中断

生 IP パケットを受信しようとしているときに、アプリケーション スレッドが中断されることがあります。 生のパケットを受信すると、中断された最初のスレッドに新しいパケットが渡され、そのスレッドが再開されます。 パケットを受信するためのすべての NetX Duo サービスには、省略可能な中断タイムアウトがあります。 パケットが受信されるか、タイムアウトが経過すると、適切な完了ステータスでアプリケーション スレッドが再開されます。

### <a name="ip-statistics-and-errors"></a>IP の統計情報とエラー

有効にした場合、NetX Duo では、アプリケーションに役立つ可能性のあるいくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP インスタンスごとに保持されます。

- 送信された IP パケットの合計数
- 送信された IP バイトの合計数
- 受信した IP パケットの合計数
- 受信した IP バイトの合計数
- 無効な IP パケットの合計数
- ドロップされた IP 受信パケットの合計数
- IP 受信チェックサム エラーの合計数
- ドロップされた IP 送信パケットの合計数
- 送信された IP フラグメントの合計数
- 受信した IP フラグメントの合計数

これらの統計およびエラー レポートはすべて、***nx_ip_info_get*** サービスを使用してアプリケーションで利用できます。

### <a name="ip-control-block-nx_ip"></a>IP 制御ブロック NX_IP

各 IP インスタンスの特性は、制御ブロックにあります。 これには、各ネットワーク デバイスの IP アドレスとネットワーク マスク、近隣 IP および物理ハードウェア アドレス マッピングのテーブルなどの有用な情報が含まれています。 この構造体は ***nx_api.h** _ ファイルで定義されています。 IPv6 が有効になっている場合、これには IPv6 アドレスの配列も含まれ、その数はユーザーが構成可能なオプション _*_NX_MAX_IPV6_ADDRESSES_** で指定されます。 既定値では、物理ネットワーク インターフェイスはそれぞれ 3 つの IPv6 アドレスを持つことができます。

IP インスタンス制御ブロックは、メモリ内の任意の場所に配置できますが、最も一般的なのは、制御ブロックを任意の関数のスコープ外に定義してグローバルな構造体にすることです。

### <a name="static-ipv4-routing"></a>静的 IPv4 ルーティング

静的ルーティング機能を使用すると、アプリケーションでは、特定のネットワーク外の宛先 IP アドレスに対して IPv4 ネットワークとネクスト ホップ アドレスを指定できます。 静的ルーティングが有効になっている場合、NetX Duo は静的ルーティング テーブルを検索し、送信するパケットの宛先アドレスと一致するエントリを検索します。 一致するものが見つからない場合、NetX Duo は物理インターフェイスの一覧を検索し、宛先 IP アドレスとネットワーク マスクに基づいて、送信元 IP アドレスとネクスト ホップ アドレスを選択します。 IP インスタンスに接続されているネットワーク ドライバーのどの IP アドレスとも宛先が一致しない場合、NetX Duo は、既定のゲートウェイに直接接続されているインターフェイスを選択し、送信元アドレスとしてインターフェイスの IP アドレスを使用し、ネクスト ホップとして既定のゲートウェイを使用します。

***nx_ip_static_route_add** _ と _ *_nx_ip_static_route_delete_** サービスをそれぞれ使用して、静的ルーティング テーブルのエントリを追加および削除できます。 静的ルーティングを使用するには、***NX_ENABLE_IP_STATIC_ROUTING*** を定義して、ホスト アプリケーションでこの機能を有効にする必要があります。

> [!NOTE]
> *静的ルーティング テーブルにエントリを追加するときに、NetX Duo では、指定された宛先アドレスに一致するエントリがテーブル内に既に存在するかどうかを確認します。存在する場合は、ネットワーク マスクの中で、より小さいネットワーク (長いプレフィックス) のエントリを優先します。*

### <a name="ipv4-forwarding"></a>IPv4 転送

受信 IPv4 パケットの宛先がこのノードではなく、IPv4 転送機能が有効になっている場合、NetX Duo は他のインターフェイスを介してパケットを転送しようとします。  

### <a name="ip-fragmentation"></a>IP の断片化

ネットワーク デバイスには、発信パケットのサイズに制限がある場合があります。 この制限は、最大転送単位 (MTU) と呼ばれます。 IP の MTU は、IP パケットを断片化せずにリンク レイヤー ドライバーで送信できる最大 IP フレーム サイズです。 デバイス ドライバーの初期化フェーズでは、ドライバー モジュールはサービス ***nx_ip_interface_mtu_set*** を介して IP の MTU サイズを構成する必要があります。

推奨されませんが、アプリケーションでは、デバイスでサポートされている基になる IP MTU よりも大きいデータグラムが生成される場合があります。 このような IP データグラムを送信する前に、IP レイヤーはこれらのパケットを断片化する必要があります。 断片化された IP フレームを受信する場合、受信側は同じ断片化 ID を持つ断片化されたすべての IP フレームを格納し、順番に再アセンブルする必要があります。 IP 受信ロジックがすべてのフラグメントを収集して元の IP フレームを時間内に復元できない場合は、すべてのフラグメントが解放されます。 このようなパケット損失を検出して回復する作業は、上位層プロトコルが担います。

IP の断片化は、IPv4 と IPv6 両方のパケットに適用されます。

IP の断片化と再アセンブリの操作をサポートするために、システム デザイナーは、***nx_ip_fragment_enable*** サービスを使用して NetX Duo の IP の断片化機能を有効にする必要があります。 この機能が有効になっていない場合は、断片化された受信 IP パケットだけでなく、ネットワーク ドライバーの MTU を超えるパケットも破棄されます。

> [!NOTE]
> *IP 断片化ロジックは、NetX Duo ライブラリをビルドするときに、***NX_DISABLE_FRAGMENTATION** _ を定義することで完全に削除できます。 これにより、NetX Duo のコード サイズを減らすことができます。 この状況では、IPv4 と IPv6 両方の断片化/再アセンブリ関数が無効になっていることに注意してください。_

> [!NOTE]
> ***NX_DISABLE_CHAINED_PACKET** が定義されている場合、IP の断片化を無効にする必要があります。*

> [!NOTE]
> *IPv6 ネットワークでは、データグラムのサイズが最小 MTU サイズを超える場合でも、ルーターはデータグラムを断片化しません。したがって、送信元と宛先の間で最小 MTU を決定すること、また IP データグラムのサイズがパスの MTU を超えないようにすることは送信側デバイスの責任です。NetX Duo では、シンボル **NX_ENABLE_IPV6_PATH_MTU_DISCOVERY** を定義して NetX Duo ライブラリをビルドすることで、IPv6 PATH MTU 検出を有効にすることができます。*

## <a name="address-resolution-protocol-arp-in-ipv4"></a>IPv4 のアドレス解決プロトコル (ARP)

アドレス解決プロトコル (ARP) は、32 ビットの IPv4 アドレスを、基になる物理メディアの IP アドレスに動的にマッピングする役割を担います (RFC 826)。 イーサネットは最も一般的な物理メディアであり、48 ビットのアドレスをサポートしています。 ARP の必要性は、***nx_ip_create** _ サービスに提供されるネットワーク ドライバーによって決まります。 物理マッピングが必要な場合、ネットワーク ドライバーでは _ *_nx_interface_address_mapping_needed_** サービスを使用して、ドライバー インターフェイスを適切に構成する必要があります。

### <a name="arp-enable"></a>ARP 有効化

ARP を正常に機能させるには、最初に ***nx_arp_enable*** サービスを使用してアプリケーションで有効化する必要があります。 このサービスでは、ARP 有効化サービスに提供されるメモリからの ARP キャッシュ領域の作成など、ARP 処理用にさまざまなデータ構造が設定されます。

### <a name="arp-cache"></a>ARP キャッシュ

ARP キャッシュは、内部 ARP マッピング データ構造の配列として表示できます。 各内部構造によって、IP アドレスと物理ハードウェア アドレスの間の関係を維持することができます。 さらに、各データ構造にリンク ポインターがあるため、複数のリンク リストに含めることができます。

ARP テーブルにマッピングが存在する場合、アプリケーションでは、サービス ***nx_arp_ip_address_find** _ を使用してハードウェア MAC アドレスを指定することにより、ARP キャッシュから IP アドレスを検索できます。 同様に、サービス _ *_nx_arp_hardware_address_find_** では、指定された IP アドレスの MAC アドレスが返されます。

### <a name="arp-dynamic-entries"></a>ARP 動的エントリ

既定では、ARP 有効化サービスは、ARP キャッシュ内のすべてのエントリを、使用可能な動的 ARP エントリの一覧に配置します。 マップされていない IP アドレスへの送信要求が検出されると、このリストから動的 ARP エントリが NetX Duo によって割り当てられます。 割り当てが完了すると、ARP エントリがセットアップされ、ARP 要求が物理メディアに送信されます。

動的エントリは、サービス ***nx_arp_dynamic_entry_set*** で作成することもできます。

> [!IMPORTANT]
> *すべての動的 ARP エントリが使用されている場合、最も長く使用されていない ARP エントリが新しいマッピングに置き換えられます。*

### <a name="arp-static-entries"></a>ARP 静的エントリ

アプリケーションでは、***nx_arp_static_entry_create** _ サービスを使用して静的 ARP マッピングを設定することもできます。 このサービスは、動的 ARP エントリ リストから ARP エントリを割り当て、アプリケーションから提供されたマッピング情報を使用して静的リストに配置します。 静的 ARP エントリは、再利用またはエージングの対象になりません。 アプリケーションでは、サービス _*_nx_arp_static_entry_delete_*_ を使用して静的エントリを削除できます。 ARP テーブル内のすべての静的エントリを削除するために、アプリケーションでサービス _*_nx_arp_static_entries_delete_** が使用されることがあります。

### <a name="automatic-arp-entry"></a>自動 ARP 入力

NetX Duo は、ARP 要求に対するピアの応答後に、ピアの IP/MAC マッピングを記録します。 NetX Duo には、ネットワークからの要請されていない ARP 要求に基づいて、ピア IP/MAC アドレスのマッピングを記録する自動 ARP 入力機能も実装されています。 この機能を使用すると、ARP テーブルにピア情報が入力されるため、ARP 要求/応答サイクルを実行するために必要な遅延を減らすことができます。 ただし、自動 ARP を有効にした場合の欠点は、ローカル リンク上に多数のノードがあるビジー状態のネットワークでは、ARP テーブルがすぐにいっぱいになる傾向があることです。これが最終的には ARP エントリの置換につながります。

この機能は、既定で有効になっています。 無効にするには、定義されたシンボル ***NX_DISABLE_ARP_AUTO_ENTRY*** を使用して NetX Duo ライブラリをコンパイルする必要があります。</p>

### <a name="arp-messages"></a>ARP メッセージ

前に説明したように、IP アドレスにマッピングが必要であることが IP タスクによって検出されると、ARP 要求メッセージが送信されます。 ARP 要求は、対応する ARP 応答を受信するまで、(***NX_ARP_UPDATE_RATE** _ 秒ごとに) 定期的に送信されます。 ARP の試行が破棄される前に、合計で _ *_NX_ARP_MAXIMUM_RETRIES_** 回の ARP 要求が行われます。 ARP 応答を受信すると、関連付けられている物理アドレス情報がキャッシュ内の ARP エントリに格納されます。

マルチホーム システムの場合、NetX Duo では、指定された宛先アドレスに基づいて ARP 要求と応答を送信するインターフェイスが決定されます。

> [!NOTE]
> *送信 IP パケットは、NetX Duo が ARP 応答を待機している間、キューに登録されます。キューに置かれる発信 IP パケットの数は、定数 **NX_ARP_MAX_QUEUE_DEPTH** によって定義されます。*

NetX Duo は、ローカル IPv4 ネットワーク上の他のノードからの ARP 要求にも応答します。 ARP 要求を受信するインターフェイスの現在の IP アドレスと一致する外部 ARP 要求が行われると、NetX Duo は、現在の物理アドレスを含む ARP 応答メッセージを構築します。

イーサネットの ARP 要求と応答の形式を図 6 に示し、次に説明します。

| **要求/応答&nbsp;フィールド**         | **目的**            |
| ---------------------------------- | ---------------------- |
| ***イーサネットの宛先アドレス*** | この 6 バイトのフィールドには、ARP 応答の宛先アドレスが格納され、ARP 要求の場合はブロードキャスト (すべて) になります。 このフィールドは、ネットワーク ドライバーによって設定されます。 
| ***イーサネットの送信元アドレス***      | この 6 バイトのフィールドには、ARP 要求または応答の送信者のアドレスが格納され、ネットワーク ドライバーによって設定されます。 |
| ***フレームの種類*** | この 2 バイトのフィールドには、存在するイーサネット フレームの種類が格納されます。ARP 要求と応答の場合、これは 0x0806 に相当します。 これは、ネットワーク ドライバーで設定される最後のフィールドです。 |
| ***ハードウェアの種類*** | この 2 バイトのフィールドには、ハードウェアの種類が格納されます。イーサネットの場合は 0x0001 です。 |
| ***プロトコルの種類*** | この 2 バイトのフィールドには、プロトコルの種類が格納されます。IP アドレスの場合は 0x0800 です。 |
| ***ハードウェア サイズ*** | この 1 バイトのフィールドには、ハードウェア アドレスのサイズが格納されます。イーサネット アドレスの場合は 6 です。 |

![ARP パケット形式の図。](./media/user-guide/arp-packet-format.png)

**図 6. ARP パケット形式**

| 要求/応答&nbsp;フィールド | 目的 |
|---|---|
| ***プロトコル サイズ*** | この 1 バイトのフィールドには IP アドレスのサイズが格納されます。IP アドレスの場合は 4 です。 |
| ***操作コード*** | この 2 バイトのフィールドには、この ARP パケットに対する操作が格納されます。 ARP 要求は 0x0001 の値で指定され、ARP 応答は 0x0002 の値で表されます。 |
| ***送信者のイーサネット アドレス*** | この 6 バイトのフィールドには、送信者のイーサネット アドレスが格納されます。 |
| ***送信者の IP アドレス*** | この 4 バイトのフィールドには、送信者の IP アドレスが格納されます。 |
| ***ターゲット イーサネット アドレス*** | この 6 バイトのフィールドには、ターゲットのイーサネット アドレスが格納されます。 |
| ***ターゲット IP アドレス*** | この 4 バイトのフィールドには、ターゲットの IP アドレスが格納されます。 |

> [!NOTE]
> *ARP の要求と応答は、イーサネットレベルのパケットです。その他のすべての TCP/IP パケットは、IP パケット ヘッダーによってカプセル化されます。*

> [!NOTE]
> *TCP/IP 実装のすべての ARP メッセージは、**ビッグ エンディアン** 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

### <a name="arp-aging"></a>ARP のエージング

NetX では、動的 ARP 入力の自動無効化がサポートされています。 ***NX_ARP_EXPIRATION_RATE** _ は、物理マッピングに対して確立された IP アドレスが有効な秒数を指定します。 有効期限が切れると、ARP キャッシュから ARP エントリが削除されます。 対応する IP アドレスへの送信を次に試行したときに、新しい ARP 要求が発生します。 _ *_NX_ARP_EXPIRATION_RATE_** を 0 に設定すると、ARP のエージングが無効になります。これは既定の構成です。

### <a name="arp-defend"></a>ARP の防御

ARP 要求または ARP 応答パケットが受信され、送信元の IP アドレスが同じで、このノードの IP アドレスと競合している場合、NetX Duo によってそのアドレスに対する ARP 要求が防御として送信されます。 競合する ARP パケットが 10 秒以内に複数回受信された場合、NetX Duo はそれ以上の防御パケットを送信しません。 既定の間隔は 10 秒で、***NX_ARP_DEFEND_INTERVAL** _ で再定義できます。 この動作は、RFC5227 の 2.4(c) で指定されたポリシーに従います。 Windows XP では ARP プローブの応答として ARP アナウンスが無視されるため、ユーザーは _ *_NX_ARP_DEFEND_BY_REPLY_** を定義して、追加の防御として ARP 応答を送信できます。

### <a name="arp-statistics-and-errors"></a>ARP の統計情報とエラー

有効にすると、NetX Duo ARP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP の ARP 処理ごとに保持されます。

- 送信された ARP 要求の合計数
- 受信した ARP 要求の合計数
- 送信された ARP 応答の合計数 
- 受信した ARP 応答の合計数 
- ARP 動的エントリの合計数 
- ARP 静的エントリの合計数 
- ARP 期限切れエントリの合計数 
- ARP 無効メッセージの合計数 

これらの統計およびエラー レポートはすべて、***nx_arp_info_get*** サービスを使用してアプリケーションで利用できます。

## <a name="reverse-address-resolution-protocol-rarp-in-ipv4"></a>IPv4 の逆アドレス解決プロトコル (RARP)

逆アドレス解決プロトコル (RARP) は、ホストの 32 ビット IP アドレスのネットワーク割り当てを要求するためのプロトコルです (RFC 903)。 これは RARP 要求によって行われ、ネットワーク メンバーが RARP 応答でホスト ネットワーク インターフェイスに IP アドレスを割り当てるまで定期的に継続されます。 アプリケーションは、サービス ***nx_ip_create*** を使用して、IP インスタンスを IP アドレス 0 で作成します。 RARP がアプリケーションで有効化されている場合は、RARP プロトコルを使用して、IP アドレスが 0 のインターフェイスを介してアクセス可能なネットワーク サーバーから IP アドレスを要求できます。

### <a name="rarp-enable"></a>RARP 有効化

RARP を使用するには、アプリケーションで IP アドレスが 0 の IP インスタンスを作成してから、サービス ***nx_rarp_enable*** を使用して RARP を有効にする必要があります。 マルチホーム システムの場合は、IP インスタンスに関連付けられている少なくとも 1 つのネットワーク デバイスの IP アドレスが 0 である必要があります。 RARP の処理では、ネットワークに指定された IP アドレスを持つ有効な RARP 応答を受信するまで、IP アドレスを必要とする NetX Duo システムの RARP 要求メッセージが定期的に送信されます。 この時点で、RARP 処理は完了します。

RARP は、有効化された後ですべてのインターフェイス アドレスが解決されると、自動的に無効になります。 アプリケーションは、サービス ***nx_rarp_disable*** を使用して、RARP を強制的に終了させることができます。

### <a name="rarp-request"></a>RARP 要求

RARP 要求パケットの形式は、[図 6](#arp-messages) に示されている ARP パケットとほぼ同じです。唯一の違いは、フレームの種類フィールドが 0x8035 で、*操作コード* フィールドが 3 で RARP 要求が指定されていることです。 前述のように、ネットワークで割り当てられた IP アドレスを持つ RARP 応答を受信するまで、RARP 要求は定期的に送信されます (***NX_RARP_UPDATE_RATE*** 秒ごと)。

> [!NOTE]
> *TCP/IP 実装のすべての RARP メッセージは、**ビッグ エンディアン** 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

### <a name="rarp-reply"></a>RARP 応答

RARP 応答メッセージはネットワークから受信され、このホストに対するネットワーク割り当て IP アドレスが格納されています。 RARP 応答パケットの形式は、図 6 に示されている ARP パケットとほぼ同じです。 唯一の違いは、フレームの種類フィールドが 0x8035 で、*操作コード* フィールドは 4 で、RARP 応答を指定することです。 受信後に、IP アドレスが IP インスタンスで設定され、RARP の定期的な要求は無効になり、IP インスタンスで通常のネットワーク操作ができるようになります。

マルチホーム ホストでは、要求元のネットワーク インターフェイスに IP アドレスが適用されます。 まだ IP アドレスの割り当てを要求している他のネットワーク インターフェイスがある場合、すべてのインターフェイス IP アドレス要求が解決されるまで、定期的に RARP サービスが続行されます。

> [!NOTE]
> *アプリケーションでは、RARP 処理が完了するまで IP インスタンスを使用しないようにします。**nx_ip_status_check** は、アプリケーションで RARP の完了を待機するために使用される場合があります。マルチホーム システムの場合、要求しているインターフェイスで RARP 処理が完了するまで、アプリケーションによってそのインターフェイスが使用されないようにします。セカンダリ デバイスの IP アドレスの状態は、**nx_ip_interface_status_check** サービスを使用して確認できます。*

### <a name="rarp-statistics-and-errors"></a>RARP の統計情報とエラー

有効にすると、NetX Duo RARP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP の RARP 処理ごとに保持されます。

- 送信された RARP 要求の合計数
- 受信した RARP 応答の合計数
- RARP 無効メッセージの合計数

これらの統計およびエラー レポートはすべて、***nx_rarp_info_get*** サービスを使用してアプリケーションで利用できます。

## <a name="internet-control-message-protocol-icmp"></a>インターネット制御メッセージ プロトコル (ICMP)

IPv4 のインターネット制御メッセージ プロトコル (ICMP) は、IP ネットワークのメンバー間でエラーおよび制御情報を渡すことに制限されています。 IPv6 のインターネット制御メッセージ プロトコル (ICMPv6) も、エラーおよび制御情報を処理します。ICMPv6 は、重複アドレス検出 (DAD) やステートレス アドレス自動構成などのアドレス解決プロトコルに必要です。

他のほとんどのアプリケーション レイヤー (TCP/IP など) メッセージと同様に、ICMP および IPv6 メッセージは ICMP (または IPv6) プロトコルの指定を使用して IP ヘッダーでカプセル化されます。

### <a name="icmp-statistics-and-errors"></a>ICMP の統計情報とエラー

有効にした場合、NetX Duo では、アプリケーションに役立つ可能性のあるいくつかの ICMP 統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP の ICMP 処理ごとに保持されます。 

- 送信された ICMP ping の合計数  
- ICMP ping タイムアウトの合計数 
- 中断された ICMP ping スレッドの合計数 
- 受信した ICMP ping 応答の合計数 
- ICMP チェックサム エラーの合計数 
- 未処理の ICMP メッセージの合計数 

これらの統計およびエラー レポートはすべて、***nx_icmp_info_get*** サービスを使用してアプリケーションで利用できます。

## <a name="icmpv4-services-in-netx-duo"></a>NetX Duo の ICMPv4 サービス

### <a name="icmpv4-enable"></a>ICMPv4 有効化

NetX Duo で ICMPv4 メッセージを処理する前に、アプリケーションは ***nx_icmp_enable*** サービスを呼び出して ICMPv4 処理を有効にする必要があります。 この処理が完了すると、アプリケーションは ping 要求とフィールド受信 ping パケットを発行できるようになります。  

### <a name="icmpv4-echo-request"></a>ICMPv4 エコー要求

エコー要求は、通常、ホスト IP アドレスによって識別される、ネットワークにある特定ノードの存在を確認するために使用される ICMPv4 メッセージの 1 つの種類です。 一般的な ping コマンドは、ICMP エコー要求/エコー応答メッセージを使用して実装されます。 特定のホストが存在する場合、そのネットワーク スタックは ping の要求と応答を ping 応答と共に処理します。 図 7 では、ICMPv4 ping メッセージの形式について詳しく説明します。

![ICMPv4 ping メッセージ](./media/user-guide/icmpv4-ping-message.png)  

**図 7. ICMPv4 ping メッセージ**

> [!NOTE]
> *TCP/IP 実装のすべての ICMPv4 メッセージは、**ビッグ エンディアン** 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

次に、ICMPv4 ヘッダー形式について説明します。

|ヘッダー フィールド |目的 |
|---|---|
|**Type** |このフィールドでは、ICMPv4 メッセージを指定します (ビット 31 ～ 24)。 最も一般的なものを次に示します。<br />-  0: エコー応答<br />- 3: 宛先は到達不能です<br />- 8: エコー要求<br />- 11: 時間超過<br />- 12: パラメーターの問題 |
|"**コード**" |このフィールドは、タイプ フィールドに固有のコンテキストです (ビット 23 ～ 16)。 エコー要求または応答の場合、コードは 0 に設定されます。|
|**チェックサム** |このフィールドには、タイプ フィールドで始まる ICMPv4 ヘッダー全体を含めた、ICMPv4 メッセージの 1 の補数和の 16 ビット チェックサムが格納されます。 チェックサムを生成する前に、チェックサム フィールドはクリアされます。|
|**[識別]** | このフィールドには、ホストを識別する ID 値が格納されています。ホストは、ECHO REPLY のエコー要求から抽出された ID を使用する必要があります (ビット 31 ～ 16)。|
|**Sequence number** |このフィールドには、ID 値が格納されています。ホストは、ECHO REPLY のエコー要求から抽出された ID を使用する必要があります (ビット 31 ～ 16)。 識別子フィールドとは異なり、この値は同じホストからの後続のエコー要求で変更されます (ビット 15 ～ 0)。|

### <a name="icmpv4-echo-response"></a>ICMPv4 エコー応答    
ping 応答は、外部の ping 要求に応答して ICMP コンポーネントによって内部的に生成される別の種類の ICMP メッセージです。 ping 応答には、確認応答に加えて、ping 要求に指定されたユーザー データのコピーも含まれます。

### <a name="icmpv4-error-messages"></a>ICMPv4 エラー メッセージ   
NetX Duo では、次の ICMPv4 エラー メッセージがサポートされています。 
- 宛先は到達不能です 
- 時間超過 
- パラメーターの問題

## <a name="internet-group-management-protocol-igmp"></a>インターネット グループ管理プロトコル (IGMP)

インターネット グループ管理プロトコル (IGMP) は、受信または参加を意図している近隣やそのルーターと通信するデバイスに、IPv4 マルチキャスト グループを提供します (RFC 1112 および RFC 2236)。 マルチキャスト グループは、基本的にはネットワーク メンバーの動的なコレクションであり、クラス D の IP アドレスで表されます。 マルチキャスト グループのメンバーは、いつでも離脱することができ、新しいメンバーはいつでも参加できます。 グループへの参加と離脱に関係する調整は、IGMP の役割です。

> [!NOTE]
> *IGMP は IPv4 マルチキャスト グループ専用に設計されています。IPv6 ネットワークでは使用できません。*

### <a name="igmp-enable"></a>IGMP 有効化     
NetX Duo でマルチキャスト アクティビティを実行する前に、アプリケーションで ***nx_igmp_enable*** サービスを呼び出す必要があります。 このサービスによって、マルチキャスト要求に対する準備の基本的な IGMP 初期化が実行されます。

### <a name="multicast-ipv4-addressing"></a>マルチキャスト IPv4 アドレス指定  
前述のように、マルチキャスト アドレスは、[図 4](#ipv4-addresses) に示すように、実際にはクラス D の IP アドレスです。 クラス D アドレスの下位 28 ビットは、マルチキャスト グループ ID に対応しています。 あらかじめ定義されているマルチキャスト アドレスがいくつかあります。ただし、IGMP 処理には、"*すべてのホスト アドレス*" (244.0.0.1) が特に重要です。 "*すべてのホスト アドレス*" は、ルーターが、すべてのマルチキャスト メンバーを照会して、所属するマルチキャスト グループを報告するために使用されます。  

### <a name="physical-address-mapping-in-ipv4"></a>IPv4 での物理アドレスのマッピング
クラス D マルチキャスト アドレスは、01.00.5e.00.00.00 から 01.00.5e.7f.ff.ff の範囲内の物理イーサネット アドレスに直接マップされます。 IP マルチキャスト アドレスの下位 23 ビットは、イーサネット アドレスの下位 23 ビットに直接マップされます。

### <a name="multicast-group-join"></a>マルチキャスト グループ参加
特定のマルチキャスト グループに参加する必要があるアプリケーションでは、***nx_igmp_multicast_join*** サービスを呼び出して参加することができます。 このサービスは、このマルチキャスト グループに参加する要求の数を追跡します。 これがマルチキャスト グループに参加するアプリケーションの最初の要求である場合は、このホストがグループに参加することを示す IGMP レポートがプライマリ ネットワークに送信されます。 次に、ネットワーク ドライバーを呼び出して、このマルチキャスト グループのイーサネット アドレスを持つパケットをリッスンするように設定します。

マルチホーム システムでは、特定のインターフェイスを介してマルチキャスト グループにアクセスできる場合、アプリケーションではサービス ***nx_igmp_multicast_interface_join** _ を、プライマリ ネットワーク上のマルチキャスト グループに限定された _*_nx_igmp_multicast_join_** の代わりに使用します。

### <a name="multicast-group-leave"></a>マルチキャスト グループ脱退   
以前に参加したマルチキャスト グループを離脱する必要があるアプリケーションでは、***nx_igmp_multicast_leave*** サービスを呼び出すことによってこれを行うことができます。 このサービスは、グループへの参加回数に関連付けられた内部カウントを減らします。 グループに対する未処理の参加要求がない場合、このマルチキャスト グループのイーサネット アドレスを持つパケットのリッスンを無効にするために、ネットワーク ドライバーが呼び出されます。

### <a name="multicast-loopback"></a>マルチキャスト ループバック    
アプリケーションでは、同じノードのいずれかのソースから送信されたマルチキャスト トラフィックを受信したい場合があります。 これには、サービス ***nx_igmp_loopback_enable*** を使用して、IP マルチキャスト コンポーネントでループバックが有効になっている必要があります。

### <a name="igmp-report-message"></a>IGMP レポート メッセージ      
アプリケーションがマルチキャスト グループに参加すると、IGMP レポート メッセージがネットワーク経由で送信され、ホストが特定のマルチキャスト グループに参加することが示されます。 IGMP レポート メッセージの形式を図 8 に示します。 マルチキャスト グループ アドレスは、IGMP レポート メッセージのグループ メッセージと宛先 IP アドレスの両方に使用されます。

上の図 (図 8) では、IGMP ヘッダーには、バージョン/タイプ フィールド、最大応答

![IGMP レポート メッセージの図。](./media/user-guide/image17.jpg)

**図 8. IGMP レポート メッセージ**

時間、チェックサム フィールド、およびマルチキャスト グループ アドレス フィールドが含まれています。 IGMPv1 メッセージの場合、最大応答時間フィールドは、IGMPv1 プロトコルの一部ではないため、常に 0 に設定されます。 最大応答時間フィールドは、IGMPv2 プロトコルで定義されているように、ホストがクエリ タイプとして IGMP メッセージを受信したときに設定され、ホストが別のホストのレポート タイプのメッセージを受信したときにクリアされます。

次に、IGMP ヘッダー形式について説明します。

|ヘッダー フィールド|目的|
|---|---|
|**[バージョン]** |このフィールドでは、IGMP バージョンを指定します (ビット 31 ～ 28)。|
|**Type** |このフィールドでは、IGMP メッセージのタイプを指定します (ビット 27 ～ 24)。|
|**最大応答時間** |IGMP v1 では使用されません。 IGMP v2 では、このフィールドは最大応答時間として機能します。|
|**チェックサム** |このフィールドには、IGMP バージョンで始まる IGMP メッセージの 1 の補数和の 16 ビット チェックサムが格納されます (ビット 0 ～ 15)。|
|**グループ アドレス** |32 ビット クラス D グループ IP アドレス|

IGMP レポート メッセージは、マルチキャスト ルーターによって送信される IGMP クエリ メッセージに応答して送信されます。 マルチキャスト ルーターは、クエリ メッセージを定期的に送信して、まだグループ メンバーシップが必要なホストを確認します。 クエリ メッセージの形式は、図 8 に示す IGMP レポート メッセージと同じです。 唯一の違いは、IGMP タイプが 1 で、グループ アドレス フィールドが 0 に設定されていることです。 IGMP クエリ メッセージは、マルチキャスト ルーターによって "*すべてのホスト*" の IP アドレスに送信されます。 グループ メンバーシップを引き続き維持するホストは、別の IGMP レポート メッセージを送信することによって応答します。

> [!NOTE]
> *TCP/IP 実装のすべてのメッセージは、**ビッグ エンディアン** 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

### <a name="igmp-statistics-and-errors"></a>IGMP の統計情報とエラー    
<th><p>有効にすると、NetX Duo IGMP ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP の IGMP 処理ごとに保持されます。 

- 送信された IGMP レポートの合計数 
- 受信した IGMP クエリの合計数 
- IGMP チェックサム エラーの合計数 
- 現在参加している IGMP グループの合計数 

これらの統計およびエラー レポートはすべて、***nx_igmp_info_get*** サービスを使用してアプリケーションで利用できます。 

### <a name="multicast-without-igmp"></a>IGMP なしのマルチキャスト  
IPv4 マルチキャスト トラフィックを想定しているアプリケーションでは、サービス ***nx_ipv4_multicast_interface_join*** を使用すると、IGMP メッセージを呼び出さなくてもマルチキャスト グループ アドレスに参加できます。 このサービスは、IPv4 レイヤーと、基になるインターフェイス ドライバーに対し、指定された IPv4 マルチキャスト アドレスからのパケットを受け入れるように指示します。 ただし、このグループに関して送信または処理されている IGMP グループ管理メッセージはありません。

グループからトラフィックを受信することを希望しなくなったアプリケーションでは、サービス ***nx_ipv4_multicast_interface_leave*** を使用できます。

## <a name="ipv6-in-netx-duo"></a>NetX Duo での IPv6

### <a name="ipv6-addresses"></a>IPv6 アドレス   
IPv6 アドレスは 128 ビットです。 IPv6 アドレスのアーキテクチャについては、RFC 4291 で説明されています。 アドレスは、最上位ビットを含むプレフィックスと、下位ビットを含むホスト アドレスに分けられます。 プレフィックスはアドレスの種類を示し、IPv4 ネットワークのネットワーク アドレスにほぼ相当します。

IPv6 には、ユニキャスト、エニーキャスト (NetX Duo ではサポートされていません)、マルチキャストの 3 種類のアドレス仕様があります。 ユニキャスト アドレスは、インターネット上の特定のホストを識別する IP アドレスです。 ユニキャスト アドレスには、送信元または宛先の IP アドレスを指定できます。 マルチキャスト アドレスは、インターネット上のホストの動的なグループを指定します。 マルチキャスト グループのメンバーは、いつでも参加し離脱することができます。

IPv6 には、IPv4 のブロードキャスト メカニズムに相当するものはありません。 すべてのホストにパケットを送信する機能は、リンクローカルの "すべてのホスト" マルチキャスト グループにパケットを送信することによって実現できます。

IPv6 では、マルチキャスト アドレスを利用して、近隣探索、ルーター発見、ステートレス アドレス自動構成の各手順を実行します。

IPv6 のユニキャスト アドレスは 2 種類あります。1 つはリンクローカル アドレスで、これは通常、よく知られたリンクローカル プレフィックスをインターフェイス MAC アドレスと組み合わせて構築されます。もう 1 つはグローバル IP アドレスで、これにはプレフィックス部分とホスト ID 部分もあります。 グローバル アドレスは、手動で構成することも、ステートレス アドレス自動構成または DHCPv6 によって構成することもできます。 NetX Duo では、リンクローカル アドレスとグローバル アドレスの両方をサポートしています。

IPv4 と IPv6 の両形式に対応するために、NetX Duo では、IPv4 および IPv6 アドレスを保持するための新しいデータ型 NXD_ADDRESS を提供しています。 この構造体の定義を次に示します。 アドレス フィールドは、IPv4 および IPv6 アドレスの和集合です。

```c
typedef struct NXD_ADDRESS_STRUCT
{
    ULONG nxd_ip_version;
    union
    {
        ULONG v4;
        ULONG v6[4];
    } nxd_ip_address;
} NXD_ADDRESS;
```

NXD_ADDRESS 構造体では、最初の要素 *nxd_ip_version* は IPv4 または IPv6 バージョンを示します。 サポートされている値は NX_IP_VERSION_V4 または NX_IP_VERSION_V6 です。 *nxd_ip_version* は、*nxd_ip_address* 和集合のどのフィールドを IP アドレスとして使用するかを示します。 NetX Duo API サービスでは通常、ULONG (32 ビット) IP アドレスの代わりに、NXD_ADDRESS 構造体へのポインターを入力引数に取ります。

### <a name="link-local-addresses"></a>リンクローカル アドレス     
リンクローカル アドレスは、ローカル ネットワーク上でのみ有効です。 デバイスは、有効なリンクローカル アドレスが割り当てられた後に、同じネットワーク上の別のデバイスとの間でパケットを送受信できます。 アプリケーションでリンクローカル アドレスを割り当てるには、プレフィックス長パラメーターを 10 に設定して NetX Duo サービス ***nxd_ipv6_address_set*** を呼び出します。 アプリケーションでは、リンクローカル アドレスをサービスに提供できます。または、単純に NX_NULL をリンクローカル アドレスとして使用し、デバイスの MAC アドレスに基づいて NetX Duo にリンクローカル アドレスを構築させることができます。

次の例では、プライマリ デバイス (インデックス 0) で、その MAC アドレスを使用してプレフィックス長 10 のリンクローカル アドレスを構成するよう、NetX Duo に指示しています。

```c
nxd_ipv6_address_set(ip_ptr, 0, NX_NULL, 10, NX_NULL);
```
上記の例では、インターフェイスの MAC アドレスが 54:32:10:1A:BC:67 の場合、対応するリンクローカル アドレスは次のようになります。

```c
FE80::5632:10FF:FE1A:BC67
```
IPv6 アドレスのホスト ID 部分 (**5632:10FF:FE1A:BC67**) は、6 バイトの MAC アドレスで構成され、次の変更が加えられます。

- MAC アドレスのバイト 3 とバイト 4 の間に **0xFFFE** を挿入する
- MAC アドレスの最初のバイトの最下位から 2 番目のビット (U/L ビット) を 1 に設定する

IPv6 アドレスのホスト部分をそのインターフェイス MAC アドレスから構築する方法の詳細については、RFC 2464 (イーサネット ネットワーク経由での IPv6 パケットの送信) を参照してください。

IPv6 には、1 つ以上のホストにマルチキャスト メッセージを送信するための特殊なマルチキャスト アドレスがいくつかあります。

| グループ  | Address   | 説明  |
|---|---|---|
|すべてのノード グループ |**FF02::1** |ローカル ネットワーク上のすべてのホスト|
|すべてのルーター グループ |**FF02::2** |ローカル ネットワーク上のすべてのルーター|
|要請ノード |**FF02::1:FF00:0/104** |以下で説明|

要請ノード マルチキャスト アドレスのターゲットは、すべての IPv6 ホストではなくローカル リンク上の特定のホストです。 104 ビットのプレフィックス **FF02::1:FF00:0/104** と、ターゲット IPv6 アドレスの最後の 24 ビットで構成されます。 たとえば、IPv6 アドレスが **205B:209D:D028::F058:D1C8:1024** の場合、要請ノード マルチキャスト アドレスは **FF02::1:FFC8:1024** です。

> [!IMPORTANT]
> *2 連コロン表記は、間にあるビットがすべてゼロであることを示します。**FF02::1:FF00:0/104** を完全に展開すると、次のようになります。* **FF02:0000:0000:0000:0000:0001:FF00:0000**

### <a name="global-addresses"></a>グローバル アドレス    
IPv6 グローバル アドレスの例は **2001:0123:4567:89AB:CDEF::1** です。NetX Duo では、IPv6 アドレスを NXD_ADDRESS 構造体に格納します。 下記の例で、NXD_ADDRESS の **global_ipv6_address** 変数にはユニキャスト IPv6 アドレスが含まれています。 次の例は、そのプライマリ デバイスの固有 IPv6 グローバル アドレスを作成する NetX Duo デバイスを示しています。

```c
NXD_ADDRESS global_ipv6_address;
UINT        primary_interface_index = 0;

global_ipv6_address.nxd_ip_version = NX_IP_VERSION_V6;
global_ipv6_address.nxd_ip_address.v6[0] = 0x20010123;
global_ipv6_address.nxd_ip_address.v6[1] = 0x456789AB;
global_ipv6_address.nxd_ip_address.v6[2] = 0xCDEF0000;
global_ipv6_address.nxd_ip_address.v6[3] = 0x00000001;

status = nxd_ipv6_address_set(
            &ip_0,
            primary_interface_index,
            &global_ipv6_address,
            64,
            NX_NULL);
```
この IPv6 アドレスのプレフィックスは **2001:0123:4567:89AB** であることに注意してください。これは 64 ビット長で、イーサネットのグローバル ユニキャスト IPv6 アドレスに共通のプレフィックス長です。

NXD_ADDRESS 構造体には IPv4 アドレスも保持されます。 global_ipv4_address に格納される IP アドレス **192.1.168.10** (**0xC001A80A**) のメモリ レイアウトは次のようになります。

|フィールド |値 |
|---|---|
|global_ipv4_address.nxd_ip_version |NX_IP_VERSION_V4|
|global_ipv4_address.nxd_ip_address.v4 |0xC001A80A|

アプリケーションで NetX Duo サービスにアドレスを渡すとき、*nxd_ip_version* フィールドでは、適切なパケット処理のために正しい IP バージョンを指定する必要があります。

既存の NetX アプリケーションとの下位互換性のために、NetX Duo ではすべての NetX サービスをサポートしています。 NetX Duo の内部では、実際の NetX Duo サービスに転送する前に ULONG 型の IPv4 アドレスが NXD_ADDRESS データ型に変換されます。

次の例は、NetX と NetX Duo のサービスの類似性と相違点を示しています。

```c
/* Make a connection to the destination IPv4 address
   192.1.168.12 through an already created TCP socket bound
   to the well known HTTP port number 80. */

global_ipv4_address.nxd_ip_version = NX_IP_VERSION_V4;
global_ipv4_address.nxd_ip_address.v4 = 0xC001A80C;

nxd_tcp_client_socket_connect(&tcp_socket,
                              &global_ipv4_address,
                              port_number,
                              NX_WAIT_FOREVER);
```

次に示すのは、同等の NetX API です。

```c
ULONG         server_ip = 0xC001A80C;
NX_TCP_SOCKET tcp_socket;
UINT          port_number = 80;

nx_tcp_client_socket_connect(&tcp_socket,
                             server_ip,
                             port_number,
                             NX_WAIT_FOREVER); 
```

> [!IMPORTANT]
> *アプリケーション開発者は、これらの API の nxd バージョンを使用することをお勧めします。*

### <a name="ipv6-default-routers"></a>IPv6 の既定のルーター    
IPv6 では、既定のルーターを使用して、オフリンクの宛先にパケットを転送します。 NetX Duo サービス ***nxd_ipv6_default_router_add*** によって、アプリケーションで IPv6 ルーターを既定のルーター テーブルに追加できます。 NetX Duo によって提供されるその他の既定のルーター サービスについては、第 4 章「サービスの説明」を参照してください。  

IPv6 パケットを転送するとき、NetX Duo ではまず、パケットの宛先がオンリンクかどうかを確認します。 そうでない場合、NetX Duo は既定のルーティング テーブルを確認し、オフリンク パケットの転送先として有効なルーターを探します。  

IPv6 の既定のルーター テーブルからルーターを削除するために、アプリケーションではサービス ***nxd_ipv6_default_router_delete** _ を使用します。 IPv6 の既定のルーター テーブルのエントリを取得するには、サービス _*_nxd_ipv6_default_router_entry_get_** を使用します。

### <a name="ipv6-header"></a>IPv6 ヘッダー    
IPv6 ヘッダーには IPv4 ヘッダーからの変更点があります。 パケットを割り当てるときに、呼び出し元でアプリケーション プロトコル (UDP、TCP など)、バッファー サイズ (バイト単位)、ホップ制限を指定します。   

図 9 に IPv6 ヘッダーの形式を、表にヘッダー コンポーネントの一覧を示します。

![IPv6 ヘッダー形式の図。](./media/user-guide/image18.png)

**図 9. IPv6 ヘッダーの形式**

|IP ヘッダー | 目的 |
|---|---|
|Version |IP バージョンの 4 ビット フィールド。 IPv6 ネットワークの場合、このフィールドの値は 6 である必要があります。IPv4 ネットワークの場合は、4 である必要があります。|
|トラフィック クラス |トラフィック クラス情報を格納する 8 ビットフィールド。 このフィールドは、NetX Duo では使用しません。|
|フロー ラベル |パケットが関連付けられているフロー (存在する場合) を一意に識別する 20 ビット フィールド。 0 の値は、パケットが特定のフローに属していないことを示します。 このフィールドは、IPv4 の "*TOS*" フィールドに代わるものです。|
|ペイロード長 |IPv6 パケットの、IPv6 ベース ヘッダーに続く部分のデータ量をバイト単位で示す 16 ビット フィールド。 これには、すべてのカプセル化されたプロトコル ヘッダーとデータが含まれます。|
|次のヘッダー | IPv6 ベース ヘッダーに続く拡張ヘッダーの種類を示す 8 ビット フィールド。 このフィールドは、IPv4 の "*プロトコル*" フィールドに代わるものです。|
|ホップ制限 |パケットが通過できるルーターの数を制限する 8 ビット フィールド。 このフィールドは、IPv4 の "*TTL*" フィールドに代わるものです。|
|ソースの住所 |送信者の IPv6 アドレスを格納する 128 ビット フィールド。|
|Destination Address (宛先アドレス) |宛先の IPv6 アドレスを格納する 128 ビット フィールド。|

### <a name="enabling-ipv6-in-netx-duo"></a>NetX Duo での IPv6 の有効化    
NetX Duo では既定で IPv6 が有効です。 _nx_user.h* の構成可能なオプション ***NX_DISABLE_IPV6** _ が定義されていない場合、NetX Duo で IPv6 サービスが有効になります。 ***NX_DISABLE_IPV6*** が定義されている場合、NetX Duo では IPv4 サービスのみが提供されます。また、IPv6 関連のモジュールとサービスのすべてが NetX Duo ライブラリに組み込まれるわけではありません。

***nxd_ipv6_address_set*** は、アプリケーションでデバイスの IPv6 アドレスを構成するために提供されているサービスです。

デバイスの IPv6 アドレスを手動で設定するだけでなく、システムでステートレス アドレス自動構成を使用することもできます。 このオプションを使用するために、アプリケーションでは ***nxd_ipv6_enable** _ を呼び出してデバイス上で IPv6 サービスを開始する必要があります。 さらに、ICMPv6 サービスは _*_nxd_icmp_enable_*_ を呼び出して開始する必要があります。これにより、ルーター要請、近隣探索、重複アドレス検出などのサービスを NetX Duo で実行できるようになります。 _*_nx_icmp_enable_*_ では、IPv4 サービス用の ICMP しか開始されないことに注意してください。 _*_nxd_icmp_enable_*_ は、IPv4 と IPv6 両対応の ICMP サービスを開始します。 システムで ICMPv6 サービスが不要な場合、ICMPv6 モジュールがシステムにリンクされないように _ *_nx_icmp_enable_** を使用できます。

次の例は、一般的な NetX Duo の IPv6 初期化手順を示しています。

```c
/* Assume ip_0 has been created and IPv4 services (such as ARP,
   ICMP, have been enabled. */
#define SECONDARY_INTERFACE 1

/* Enable IPv6 */
status = nxd_ipv6_enable(&ip_0);

if(status != NX_SUCCESS)
{
    /* nxd_ipv6_enable failed. */
}

/* Enable ICMPv6 */
status = nxd_icmp_enable(&ip_0);
if(status != NX_SUCCESS)
{
    /* nxd_icmp_enable failed. */
}

/* Configure the link local address on the primary interface. */
status = nxd_ipv6_address_set(&ip_0, 0, NX_NULL, 10, NX_NULL);

/* Configure ip_0 primary interface global address. */
ip_address.nxd_ip_version = NX_IP_VERSION_V6
ip_address.nxd_ip_address.v6[0] = 0x20010db8;
ip_address.nxd_ip_address.v6[1] = 0x0000f101;
ip_address.nxd_ip_address.v6[2] = 0;
ip_address.nxd_ip_address.v6[3] = 0x202;

/* Configure global address of the primary interface. */
status = nxd_ipv6_address_set(&ip_0, SECONDARY_INTERFACE,
                              &ip_address, 64, NX_NULL);
```                              

上位層プロトコル (TCP や UDP など) は、IPv6 の開始前または開始後に有効化できます。

> [!IMPORTANT]  
> *IPv6 サービスは、IP スレッドが初期化されてデバイスが有効になった後でないと使用できません。*

インターフェイスが有効になった (インターフェイス デバイス ドライバーでデータを送受信する準備ができて、有効なリンクローカル アドレスが取得された) 後、デバイスでは次のいずれかの方法でグローバル IPv6 アドレスを取得できます。

- ステートレス アドレス自動構成  
- 手動 IPv6 アドレス構成  
- DHCPv6 (とオプションの DHCPv6 パッケージ) を使用したアドレス構成

最初の 2 つの方法について以下で説明します。 3 番目の方法 (DHCPv6) については、DHCP パッケージで説明しています。

### <a name="stateless-address-autoconfiguration-using-router-solicitation"></a>ルーター要請を使用したステートレス アドレス自動構成      
NetX Duo デバイスは、プレフィックス情報を提供するルーターを使用して IPv6 ネットワークに接続するときに、そのインターフェイスを自動的に構成できます。 ステートレス アドレス自動構成を必要とするデバイスは、ルーター要請 (RS) メッセージを送出します。 ネットワーク上のルーターは、要請ルーター アドバタイズ (RA) メッセージで応答します。 RA メッセージは、リンクに関連付けられたネットワーク アドレスを識別するプレフィックスをアドバタイズします。 次に、デバイスは、デバイスが接続されているネットワークの一意の識別子を生成します。 アドレスは、プレフィックスとその一意識別子を組み合わせて形成されます。 このようにして RA メッセージを受信すると、ホストはその IP アドレスを生成します。 ルーターは、定期的な非要請 RA メッセージを送信する場合もあります。 

> [!WARNING]
> *NetX Duo を使用すると、アプリケーションで実行時にステートレス アドレス自動構成を有効または無効にできます。この機能を有効にするには、**NX_IPV6_STATELESS_AUTOCONFIG_CONTROL** を定義して NetX Duo ライブラリをコンパイルする必要があります。この機能が有効になったら、アプリケーションで **nxd_ipv6_stateless_address_autoconfigure_enable** および **nxd_ipv6_stateless_address_autocofigure_disable** を使用して IPv6 ステートレス アドレス自動構成を有効または無効にできます。*

### <a name="manual-ipv6-address-configuration"></a>手動 IPv6 アドレス構成     
特定の IPv6 アドレスが必要な場合、アプリケーションで ***nxd_ipv6_address_set*** を使用して IPv6 アドレスを手動で構成できます。 ネットワーク インターフェイスは、複数の IPv6 アドレスを持つ場合があります。 ただし、ステートレス アドレス自動構成と手動構成のどちらで取得するかによらず、システムの IPv6 アドレスの総数は ***NX_MAX_IPV6_ADDRESSES*** を超えることができない点に注意してください。

次の例は、ip_0 のプライマリ インターフェイス (デバイス 0) でグローバル アドレスを手動で構成する方法を示しています。

```c
NXD_ADDRESS global_address;
global_address.nxd_ip_version = NX_IP_VERSION_V6;
global_address.nxd_ip_address.v6[0] = 0x20010000;
global_address.nxd_ip_address.v6[1] = 0x00000000;
global_address.nxd_ip_address.v6[2] = 0x00000000;
global_address.nxd_ip_address.v6[3] = 0x0000ABCD;
```

ホストではこの後、次の NetX Duo サービスを呼び出して、このアドレスをそのグローバル IP アドレスとして割り当てます。

```c
status = nxd_ipv6_address_set(&ip_0, 0,  
                              &global_address, 64
                              NX_NULL);
```

### <a name="duplicate-address-detection-dad"></a>重複アドレス検出 (DAD)    
システムがその IPv6 アドレスを構成した後、そのアドレスは *TENTATIVE* (仮) とマークされます。 RFC 4862 で説明されている重複アドレス検出 (DAD) が有効になっている場合、NetX Duo では、この仮アドレスを宛先にして近隣要請 (NS) メッセージを自動的に送信します。 ネットワーク上のどのホストも所定の時間内にこれらの NS メッセージに応答しない場合、このアドレスはローカルリンク上で一意であると見なされ、その状態は VALID (有効) 状態に遷移します。 この時点から、アプリケーションでこの IP アドレスを通信に使用できるようになります。  

DAD 機能は ICMPv6 モジュールの一部です。 したがって、新しく構成したアドレスが DAD プロセスを通過するためには、先にアプリケーションで ICMPv6 サービスを有効にしておく必要があります。 または、(_*_nx_user.h_*_ として定義される) NetX Duo のライブラリ ビルド環境で ***NX_DISABLE_IPV6_DAD** _ オプションを定義して DAD プロセスを無効にすることもできます。 DAD プロセスの間、_*_NX_IPV6_DAD_TRANSMITS_*_ パラメーターは、NetX Duo から送信された NS メッセージのうち、アドレスが一意であることを確認するための応答を受信しなかった件数を判別します。 既定では、RFC 4862 の推奨のとおり、_ *_NX_IPV6_DAD_TRANSMITS_** は 3 に設定されています。 このシンボルを 0 に設定すると、実質的に DAD が無効になります。

アプリケーションが IPv6 アドレスを割り当てるときに ICMPv6 または DAD が有効になっていない場合、DAD は実行されず、NetX Duo は直ちに IPv6 アドレスの状態を VALID に設定します。

NetX Duo は、そのリンクローカル アドレスとグローバル アドレスのどちらかまたは両方が有効になるまで、IPv6 ネットワーク上で通信できません。 有効なアドレスが取得された後、NetX Duo では、受信パケットの宛先アドレスを、その構成済み IPv6 アドレスまたは有効化されたマルチキャスト アドレスのいずれかと照合しようとします。 一致が見つからない場合、パケットはドロップされます。 

> [!WARNING]  
> *DAD プロセスの間、送信される DAD NS パケットの数は ***NX_IPV6_DAD_TRANSMITS** _(既定値は 3) によって定義されます。既定では、各 DAD NS メッセージの送信間に 1 秒の遅延があります。したがって、DAD が有効なシステムでは、IPv6 アドレスが割り当てられた後 (また、これが重複したアドレスではないという前提で)、IP アドレスが VALID 状態になって通信の準備ができるまでに約 3 秒の遅延があります。_

アプリケーションでは、システムで IPv6 アドレスが変更されたときに通知を受け取ることができます。 IPv6 アドレスの変更通知機能を有効にするには、シンボル **NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY** を定義して NetX Duo ライブラリをビルドする必要があります。 この機能が有効になったら、アプリケーションで **_nxd_ipv6_address_change_notify_** サービスを使用してコールバック関数をインストールできます。

IPv6 アドレスが変更されるか無効になると、ユーザーが指定したコールバック関数が次の情報を使用して呼び出されます。

| 機能  | 説明  |
|---|---|
|ip_ptr |IP インスタンスへのポインター|
|interface_index |この IPv6 アドレスが関連付けられているネットワーク インターフェイスのインデックス
|ipv6_addr_index |IPv6 アドレス テーブルのインデックス|
|ipv6_address |IPv6 アドレスへのポインター。形式は、4 つの ULONG 整数の配列です。 IPv6 アドレスはホストのバイト順で表されます。|

### <a name="ipv6-multicast-support-in-netx-duo"></a>NetX Duo での IPv6 マルチキャストのサポート      
マルチキャスト アドレスは、インターネット上のホストの動的なグループを指定します。 マルチキャスト グループのメンバーは、いつでも参加し離脱することができます。 NetX Duo では、重複アドレス検出、近隣探索、ルーター発見など、IP マルチキャスト機能を必要とする複数の ICMPv6 プロトコルが実装されています。 したがって、NetX Duo では、基になるデバイス ドライバーでマルチキャスト操作をサポートすることを想定しています。

マルチキャスト グループ (全ノード マルチキャスト アドレスや *要請ノード* マルチキャスト アドレスなど) に参加または離脱する必要がある場合、NetX Duo では、ドライバー コマンドをデバイス ドライバーに発行してマルチキャスト MAC アドレスに参加または離脱します。 マルチキャスト アドレスに参加するためのドライバー コマンドは ***NX_LINK_MULTICAST_JOIN** _ です。 マルチキャスト アドレスを離脱するために、NetX Duo ではドライバー コマンド _*_NX_LINK_MULTICAST_LEAVE_** を発行します。 ICMPv6 プロトコルが正しく機能するためには、デバイス ドライバーでこれら 2 つのコマンドを実装している必要があります。

アプリケーションでは、サービス ***nxd_ipv6_multicast_interface_join*** を使用して IPv6 マルチキャスト グループに参加できます。 このサービスは、マルチキャスト アドレスを IP スタックに登録し、指定されたデバイス ドライバーに IPv6 マルチキャスト アドレスを通知します。 マルチキャスト グループを離脱するために、アプリケーションではサービス ***nxd_ipv6_multicast_interface_leave*** を使用します。

### <a name="neighbor-discovery-nd"></a>近隣探索 (ND)    
近隣探索は IPv6 ネットワークのプロトコルであり、物理アドレスを IPv6 アドレス (グローバル アドレスまたはリンクローカル アドレス) にマップするためのものです。 このマッピングは近隣探索キャッシュ (ND キャッシュ) に保持されます。 ND プロセスは IPv4 の ARP プロセスに相当し、ND キャッシュは ARP テーブルに似ています。 IPv6 ノードは、近隣探索 (ND) プロトコルを使用して、その近隣の MAC アドレスを取得できます。 近隣要請 (NS) メッセージを全ノードまたは要請ノード マルチキャスト アドレスに送出し、対応する近隣アドバタイズ (NA) メッセージを待ちます。 このプロセスによって取得された MAC アドレスは、ND キャッシュに格納されます。

各 IP インスタンスには 1 つの ND キャッシュがあります。 ND キャッシュはエントリの配列として保持されます。 配列のサイズは、_*_nx_user.h_** にあるオプション ***NX_IPV6_NEIGHBOR_CACHE_SIZE** _ をコンパイル時に設定することによって定義されます。 IP インスタンスに接続されているすべてのインターフェイスが同じ ND キャッシュを共有することに注意してください。

NetX Duo の起動時に ND キャッシュ全体が空になります。 システムが実行されると、NetX Duo によって ND キャッシュが自動的に更新され、ND プロトコルごとにエントリが追加および削除されます。 ただし、アプリケーションでは、次の NetX Duo サービスを使用してキャッシュ エントリを手動で追加および削除することによって ND キャッシュを更新することもできます。

- ***nxd_nd_cache_entry_delete***  
- ***nxd_nd_cache_entry_set***   
- ***nxd_nd_cache_invalidate***

IPv6 パケットの送受信時に、NetX Duo によって ND キャッシュテーブルが自動的に更新されます。

## <a name="internet-control-message-protocol-in-ipv6-icmpv6"></a>IPv6 のインターネット制御メッセージ プロトコル (ICMPv6)  

IPv6 での ICMPv6 の役割は、IPv6 アドレス マッピングとルーター発見をサポートするために大幅に拡張されています。 さらに、NetX Duo の ICMPv6 では、エコー要求と応答、ICMPv6 エラー レポート、ICMPv6 リダイレクト メッセージをサポートしています。

### <a name="icmpv6-enable"></a>ICMPv6 有効化    
NetX Duo で ICMPv6 メッセージを処理する前に、アプリケーションで ***nxd_icmp_enable*** サービスを呼び出して、前述のように ICMPv6 処理を有効にする必要があります。 

### <a name="icmpv6-messages"></a>ICMPv6 メッセージ     
ICMPv6 ヘッダーの構造は ICMPv4 ヘッダーの構造に似ています。 次に示すように、基本の ICMPv6 ヘッダーには、種類、コード、チェックサムの 3 つのフィールドに加えて、可変長の ICMPv6 オプション データが含まれます。 

![基本的な ICMPv6 ヘッダーの図。](./media/user-guide/image19.png)

**図 10. 基本的な ICMPv6 ヘッダー**

|フィールド |サイズ (バイト) |説明 |
|-----|-----|-----|
|     | 1   |ICMPv6 メッセージ型を識別します。 |
|     |     |1 宛先は到達不能です |
|     |     |2 パケットが大きすぎます |
|     |     |3 時間超過 |
|     |     |4 パラメーターの問題 |
|     |     |128 エコー要求 |
|     |     |129 エコー応答 |
|     |     |133 ルーター要請 |
|     |     |134 ルーター アドバタイズ |
|     |     |135 近隣要請 |
|     |     |136 近隣アドバタイズ |
|     |     |137 リダイレクト メッセージ |
|コード | 1   |ICMPv6 メッセージ型をさらに修飾します。 通常、エラーメッセージと共に使用されます。 使用されない場合、0 に設定されます。 エコー要求/応答と NS メッセージでは使用しません。|
|Checksum | 2 |ICMP ヘッダーの 16 ビット チェックサム フィールド。 これは、ICMPv6 ヘッダーを含む、ICMPv6 メッセージ全体の 16 ビット補数です。 IPv6 送信元アドレス、宛先アドレス、パケット ペイロード長の擬似ヘッダーも含まれます。 |

近隣要請ヘッダーの例を次に示します。

![近隣要請ヘッダーの例を示す図。](./media/user-guide/image20.jpg)

**図 11. 近隣要請メッセージの ICMPv6 ヘッダー**

|フィールド |サイズ (バイト) |説明 |
|-----|-----|-----|
|Type | 1   |近隣要請メッセージの ICMPv6 メッセージ型を識別します。 値は 135 です。 |
|コード | 1   |使用しません。 0 に設定されます。 |
|Checksum | 2  |ICMPv6 ヘッダーの 16 ビット チェックサム フィールド。 |
|予約されています。 | 4  |0 に設定される 4 つの予約済みバイト。 |
|ターゲット アドレス | 16  |要請のターゲットの IPv6 アドレス。 IPv6 アドレス解決の場合、これは、そのリンク層アドレスを解決する必要があるデバイスの実際のユニキャスト IP アドレスです。 |
|オプション | 変数 |近隣探索プロトコルによって指定されたオプションの情報。 |

### <a name="icmpv6-ping-request"></a>ICMPv6 ping 要求
NetX Duo アプリケーションでは、***nxd_icmp_ping*** を使用して、パラメーターで指定された宛先 IP アドレスに基づいて IPv6 または IPv4 ping 要求を発行します。  

### <a name="icmpv6-ping-response"></a>ICMPv6 ping 応答
ICMPv6 ping 応答は、外部の ICMPv6 ping 要求に応答して ICMPv6 コンポーネントによって内部的に生成される別の種類の ICMPv6 メッセージです。 ICMPv6 ping 応答には、確認応答に加えて、ICMPv6 ping 要求に指定されたユーザー データのコピーも含まれます。  

### <a name="thread-suspension"></a>スレッドの中断
別のネットワーク メンバーに ping を試みている間、アプリケーション スレッドが一時停止する可能性があります。 ping 応答を受信すると、一時停止した最初のスレッドに ping 応答メッセージが与えられ、そのスレッドが再開されます。 すべての NetX Duo サービスと同様に、ping 要求での一時停止にはオプションのタイムアウトがあります。  

### <a name="other-icmpv6-messages"></a>その他の ICMPv6 メッセージ
ICMPv6 メッセージは、次の機能のために必要です。  

- 近隣探索  
- ステートレス アドレス自動構成 
- ルートの検出 
- 近隣の到達不可能性の検出  

### <a name="neighbor-unreachability-router-and-prefix-discovery"></a>近隣の到達不可能性、ルーター、プレフィックスの検出    
近隣の到達不可能性の検出、ルーター発見、プレフィックスの検出は、近隣探索プロトコルに基づいており、以下で説明します。 

***近隣の到達不可能性の検出***: IPv6 デバイスでは、パケットの送信を希望するときに、その近隣探索 (ND) キャッシュから宛先のリンク層アドレスを検索します。 "ネクスト ホップ" と呼ばれることもある直接の宛先は、同じリンク上の実際の宛先である場合もあれば、ルーターである場合もあります (宛先がオフリンクの場合)。 ND キャッシュ エントリには、近隣の到達可能性のステータスが含まれます。

REACHABLE ステータスは、近隣が到達可能と見なされていることを示します。 近隣に送信したパケットが受信されたという確認を近隣が最近受信した場合、その近隣は到達可能です。 NetX Duo での確認は、NetX Duo デバイスから送信された NS メッセージへの応答で近隣から NA メッセージを受信する形式になります。 また、アプリケーションで NetX Duo サービス ***nxd_nd_cache_entry_set*** を呼び出してキャッシュ レコードを手動で入力した場合、NetX Duo により近隣ステータスの状態が REACHABLE に変更されます。

***ルーター発見***: IPv6 デバイスでは、ルーターを使用して、オフリンクの宛先に向けたすべてのパケットを転送します。 ルーター アドバタイズ (RA) メッセージなど、ルーターによって送信される情報を使用して、デバイスのグローバル IPv6 アドレスを構成する場合もあります。

ネットワーク上のデバイスでは、全ルーターのマルチキャスト アドレス (FF01::2) にルーター要請 (RS) メッセージを送信することによってルーター発見プロセスを開始できます。 または、全ノードのマルチキャスト アドレス (FF::1) でルーターからの定期的な RA を待機することもできます。

RA メッセージには、そのネットワークの IPv6 アドレスを構成するためのプレフィックス情報が含まれています。 NetX Duo では、ルーターの要請は既定で有効になっており、_*_nx_user.h_** で構成オプション ***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _ を設定することによって無効化できます。 ルーター要請パラメーターの設定の詳細については、「NetX Duo のインストールと使用」の章の「構成オプション」を参照してください。 

***プレフィックスの検出***: IPv6 デバイスでは、プレフィックスの検出を使用して、どのターゲット ホストであればルーターを経由しなくても直接アクセスできるかを学習します。 この情報は、ルーターからの RA メッセージを通じて IPv6 デバイスに提供されます。 IPv6 デバイスでは、プレフィックス情報をプレフィックス テーブルに格納します。 プレフィックスの検出では、IPv6 デバイス プレフィックス テーブルのプレフィックスをターゲット アドレスと照合します。 プレフィックスのすべてのビットがターゲット アドレスの最上位ビットに一致する場合、プレフィックスはターゲット アドレスに一致します。 複数のプレフィックスが 1 つのアドレスをカバーしている場合、最も長いプレフィックスが選択されます。

### <a name="icmpv6-error-messages"></a>ICMPv6 エラー メッセージ    
NetX Duo では、次の ICMPv6 エラー メッセージがサポートされています。  

- 宛先は到達不能です  
- パケットが大きすぎます  
- 時間超過  
- パラメーターの問題  

## <a name="user-datagram-protocol-udp"></a>ユーザー データグラム プロトコル (UDP)

ユーザー データグラム プロトコル (UDP) は、ネットワーク メンバー間で最も単純な形式のデータ転送を提供します (RFC 768)。 UDP データ パケットは、ベスト エフォート方式でネットワーク メンバー間で送信されます。つまり、パケット受信者による確認応答用メカニズムは組み込まれていません。 さらに、UDP パケットを送信する場合、事前に接続を確立する必要はありません。 このため、UDP パケット転送は非常に効率的です。

NetX アプリケーションを NetX Duo に移行する開発者にとって、NetX と NetX Duo の間で UDP 機能にはいくつかの基本的な変更があるだけです。 これは、IPv6 が主に関係しているのは、基になる IP 層であるからです。 すべての NetX Duo UDP サービスは、IPv4 または IPv6 いずれかの接続に使用できます。

### <a name="udp-header"></a>UDP ヘッダー       
UDP は、送信時にアプリケーションのデータの前に単純なパケット ヘッダーを配置し、受信時にパケットから同様の UDP ヘッダーを削除してから、受信した UDP パケットをアプリケーションに配信します。 UDP はパケットを送受信するために IP プロトコルを使用します。つまり、パケットがネットワーク上にあるときに UDP ヘッダーの前に IP ヘッダーが存在することを意味します。 図 12 は、UDP ヘッダーの形式を示しています。

![UDP ヘッダー形式の図。](./media/user-guide/image21.png)

### <a name="figure-12-udp-header"></a>図 12. UDP ヘッダー

> [!NOTE]
> *UDP/IP 実装のすべてのヘッダーは、**ビッグ エンディアン** 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

次に、UDP ヘッダー形式について説明します。

|ヘッダー フィールド |目的 |
|---|---|
|**16 ビットの送信元ポート番号** |このフィールドには、UDP パケットの送信元のポートが格納されます。 有効な UDP ポートの範囲は 1 ～ 0xFFFF です。 |
|**16 ビットの宛先ポート番号** |このフィールドには、パケットの送信先の UDP ポートが格納されます。 有効な UDP ポートの範囲は 1 ～ 0xFFFF です。 |
|**16 ビットの UDP の長さ** |このフィールドには、UDP ヘッダーのサイズを含む、UDP パケットのバイト数が格納されます。 |
|**16 ビットの UDP チェックサム** |このフィールドには、UDP ヘッダー、パケット データ領域、擬似 IP ヘッダーなど、パケットの 16 ビットのチェックサムが格納されます。 |

### <a name="udp-enable"></a>UDP 有効化   
UDP パケット転送が可能になる前に、アプリケーションはまず、***nx_udp_enable*** サービスを呼び出して UDP を有効にする必要があります。 有効にすると、アプリケーションは UDP パケットを送信および受信できるようになります。  

### <a name="udp-socket-create"></a>UDP ソケットの作成    
UDP ソケットは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。 サービスの初期のタイプ、有効期限、および受信キューの深さは、***nx_udp_socket_create*** サービスによって定義されます。 アプリケーションの UDP ソケットの数に制限はありません。

### <a name="udp-checksum"></a>UDP チェックサム   
パケット データに対する UDP ヘッダー チェックサムの計算は、IPv6 プロトコルでは必須ですが、IPv4 プロトコルではオプションです。  

UDP は、IP 擬似ヘッダー (送信元 IP アドレス、宛先 IP アドレス、プロトコル/長さ IP ワードで構成される)、UDP ヘッダー、および UDP パケット データを対象とする、1 の補数の 16 ビット チェックサムを指定します。 IPv4 と IPv6 で UDP パケット ヘッダーのチェックサムに関して唯一異なる点は、送信元と宛先の IP アドレスが IPv4 では 32 ビットであるのに対し IPv6 では 128 ビットであることです。 計算された UDP チェックサムが 0 の場合は、すべて 1 として格納されます (0xFFFF)。 送信ソケットの UDP チェックサム ロジックが無効になっている場合、チェックサムが計算されなかったことを示すために、UDP チェックサム フィールドに 0 が配置されます。

UDP チェックサムが受信側によって計算されたチェックサムと一致しない場合、UDP パケットは単純に破棄されます。

IPv4 ネットワークでは、UDP チェックサムは省略可能です。 NetX Duo を使用すると、アプリケーションは、ソケットごとに UDP チェックサムの計算を有効または無効にすることができます。 既定では、UDP ソケット チェックサム ロジックが有効になっています。 アプリケーションは、***nx_udp_socket_checksum_disable** _ サービスを呼び出すことによって、特定の UDP ソケットのチェックサム ロジックを無効にすることができます。 ただし、IPv6 ネットワークでは、UDP チェックサムは必須です。 したがって、サービス _ *_nx_udp_socket_checksum_disable_** は、IPv6 ネットワーク経由でパケットを送信するときに UDP チェックサム ロジックを無効にしません。

特定のイーサネット コントローラーは、その場で UDP チェックサムを生成することができます。 システムがハードウェア チェックサム計算機能を使用できる場合、チェックサム ロジックを使用せずに NetX Duo ライブラリをビルドできます。 UDP ソフトウェア チェックサムを無効にするには、シンボル ***NX_DISABLE_UDP_TX_CHECKSUM** _ および _*_NX_DISABLE_UDP_RX_CHECKSUM_*_ (第 2 章で説明) を定義して NetX Duo ライブラリをビルドする必要があります。 構成オプションによって UDP チェックサム ロジックが NetX Duo から完全に削除されますが、_ *_nx_udp_socket_checksum_disable_** サービスを呼び出すと、アプリケーションでソケット単位で IPv4 UDP チェックサム処理を無効化できます。

### <a name="udp-ports-and-binding"></a>UDP ポートとバインド      
UDP ポートは、UDP プロトコルの論理エンド ポイントです。 NetX Duo の UDP コンポーネントには、1 ～ 0xFFFF の範囲で、65,535 の有効なポートがあります。 UDP データを送受信するには、まず、アプリケーションで UDP ソケットを作成してから、目的のポートにバインドする必要があります。 UDP ソケットをポートにバインドした後、アプリケーションはそのソケットでデータを送受信できます。

### <a name="udp-fast-pathtrade"></a>UDP Fast Path&trade;   
UDP Fast Path&trade; は、NetX Duo UDP 実装を介した低パケット オーバーヘッド パスの名前です。 UDP パケットを送信するには、***nx_udp_socket_send** _ と _*_nx_ip_packet_send_*_ の関数を呼び出して、最終的にネットワーク ドライバーを呼び出します。 _*_nx_udp_socket_send_*_ は、既存の NetX アプリケーション向けに NetX Duo で使用でき、IPv4 パケットにのみ使用できます。 ただし、推奨される方法は、以下で説明する _ *_nxd_udp_socket_send_** サービスを使用することです。 UDP パケット受信では、UDP パケットは適切な UDP ソケット受信キューに配置されるか、ネットワーク ドライバーの受信割り込み処理からの単一の関数呼び出しで、中断されたアプリケーション スレッドに配信されます。 UDP パケットを送受信するための高度に最適化されたロジックは、UDP Fast Path テクノロジの本質です。  

### <a name="udp-packet-send"></a>UDP パケット送信    
IPv6 または IPv4 ネットワーク経由での UDP データの送信は、***nxd_udp_socket_send** _ 関数を呼び出すことによって簡単に実現できます。 呼び出し元では、NXD_ADDRESS ポインター パラメーターの _nx_ip_version* フィールドで IP バージョンを設定する必要があります。 NetX Duo では、宛先 IPv4/IPv6 アドレスに基づいて、送信される UDP パケットの最適な送信元アドレスが決定されます。 このサービスは、パケット データの前に UDP ヘッダーを配置し、内部 IP 送信ルーチンを使用してネットワークに送信します。 UDP パケットの送信では、すべての UDP パケット転送が直ちに処理されるため、スレッドが中断されることはありません。 

マルチキャストまたはブロードキャストの宛先で、NetX Duo デバイスに選択できる IP アドレスが複数ある場合に、アプリケーションで使用する送信元 IP アドレスを指定する必要があります。 これは、サービス ***nxd_udp_socket_source_send*** を使用して行うことができます。

> [!IMPORTANT]    
> *マルチキャストまたはブロードキャスト パケットの送信に **nx_udp_socket_send** が使用されている場合、最初の有効化されたインターフェイスの IP アドレスが送信元アドレスとして使用されます*。

> [!NOTE] 
> *このソケットに対して UDP チェックサム ロジックが有効になっている場合、チェックサム操作は、UDP または IP のデータ構造へのアクセスをブロックすることなく、呼び出し元のスレッドのコンテキストで実行されます*。 

> [!WARNING]    
> *NX_PACKET 構造に存在する UDP ペイロード データは、長いワード境界に配置する必要があります。アプリケーションでは、プリペンド ポインターと NetX Duo のデータ開始ポインターの間に十分な領域を残して、UDP、IP、および物理メディアのヘッダーを配置する必要があります*。

### <a name="udp-packet-receive"></a>UDP パケット受信    
アプリケーション スレッドでは、***nx_udp_socket_receive*** を呼び出して、特定のソケットから UDP パケットを受信する場合があります。 ソケット受信関数は、ソケットの受信キューで最も古いパケットを配信します。 受信キューにパケットがない場合、呼び出し元のスレッドは、パケットが到着するまで (オプションのタイムアウトで) 中断できます。

UDP 受信パケット処理 (通常はネットワーク ドライバーの受信割り込みハンドラーから呼び出されます) は、パケットを UDP ソケットの受信キューに配置するか、パケットを待機している最初に中断されたスレッドに配信する役割を担います。 パケットがキューに置かれている場合は、受信処理によって、ソケットに関連付けられている最大受信キューの深さも確認されます。 新しくキューに入れられたパケットがキューの深さを超えると、キュー内の最も古いパケットが破棄されます。

### <a name="udp-receive-notify"></a>UDP 受信通知   
アプリケーション スレッドが複数のソケットから受信したデータを処理する必要がある場合は、***nx_udp_socket_receive_notify*** 関数を使用する必要があります。 この関数は、ソケットの受信パケット コールバック関数を登録します。 ソケットでパケットが受信されるたびに、コールバック関数が実行されます。

コールバック関数の内容はアプリケーション固有です。ただし、最も高い可能性としては、対応するソケットでパケットが使用可能になったことを処理スレッドに通知するロジックが含まれています。

### <a name="peer-address-and-port"></a>ピア アドレスとポート   
UDP パケットを受信すると、アプリケーションでは、サービス ***nx_udp_packet_info_extract*** を使用して、送信者の IP アドレスとポート番号を見つけることができます。 正常に返された場合、このサービスは、送信者の IP アドレス、送信者のポート番号、およびパケットの受信に使用されたローカル インターフェイスに関する情報を提供します。  

### <a name="thread-suspension"></a>スレッドの中断   
前述のように、特定の UDP ポートで UDP パケットを受信しようとしている間に、アプリケーション スレッドが中断されることがあります。 そのポートでパケットが受信されると、最初に中断されたスレッドに渡され、そのスレッドが再開されます。 UDP 受信パケットで中断する場合は、オプションのタイムアウトを使用できます。これは、ほとんどの NetX Duo サービスで利用可能な機能です。  

### <a name="udp-socket-statistics-and-errors"></a>UDP ソケットの統計情報とエラー     
有効にすると、NetX Duo UDP ソケット ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP/UDP インスタンスごとに保持されます。

- 送信された UDP パケットの合計数  
- 送信された UDP バイトの合計数  
- 受信した UDP パケットの合計数   
- 受信した UDP バイトの合計数  
- 無効な UDP パケットの合計数  
- ドロップされた UDP 受信パケットの合計数  
- UDP 受信チェックサム エラーの合計数  
- 送信された UDP ソケット パケット数  
- 送信された UDP ソケット バイト数  
- 受信した UDP ソケット パケット数   
- 受信した UDP ソケット バイト数  
- キューに登録された UDP ソケット パケット数  
- ドロップされた UDP ソケット受信パケット数  
- UDP ソケット チェックサム エラー  

これらのすべての統計およびエラー レポートをアプリケーションで使用するには、すべての UDP ソケットで集められた UDP 統計は ***nx_udp_info_get** _ サービスを使用し、指定された UDP ソケットの UDP 統計情報は _ *_nx_udp_socket_info_get_** サービスを使用します。

### <a name="udp-socket-control-block-nx_udp_socket"></a>UDP ソケット制御ブロック NX_UDP_SOCKET
各 UDP ソケットの特性は、関連付けられている NX_UDP_SOCKET 制御ブロックにあります。 これには、IP データ構造へのリンク、送信パスと受信パスのネットワーク インターフェイス、バインドされたポート、受信パケット キューなどの有用な情報が含まれています。 この構造体は ***nx_api.h*** ファイルで定義されています。

## <a name="transmission-control-protocol-tcp"></a>伝送制御プロトコル (TCP)

伝送制御プロトコル (TCP) は、2 つのネットワーク メンバー間で信頼性の高いストリーム データ転送を提供します (RFC 793)。 1 つのネットワーク メンバーから送信されたすべてのデータは、受信側メンバーによって検証され、確認されます。 また、この 2 つのメンバーは、データ転送の前に接続を確立している必要があります。 これにより、信頼性の高いデータ転送が行われるようになります。ただし、前述の UDP データ転送よりもかなり多くのオーバーヘッドが必要になります。

IPv6 が主に関係しているのは基になる IP 層であるため、注記のある点を除き、NetX と NetX Duo の間で TCP プロトコルの API サービスに変更はありません。 すべての NetX Duo TCP サービスは、IPv4 または IPv6 いずれかの接続に使用できます。

### <a name="tcp-header"></a>TCP ヘッダー   
送信時には、TCP ヘッダーがユーザーが提供するデータの前に配置されます。 受信時には、TCP ヘッダーが受信パケットから削除され、アプリケーションで使用できるユーザー データだけが残ります。 TCP は IP プロトコルを使用してパケットを送受信します。これは、パケットがネットワーク上にあるときに、TCP ヘッダーの前に IP ヘッダーがあることを意味します。 図 13 は、TCP ヘッダーの形式を示しています。

![TCP ヘッダー形式の図。](./media/user-guide/image22.png)

### <a name="figure-13-tcp-header"></a>図 13. TCP ヘッダー

次に、TCP ヘッダー形式について説明します。

|ヘッダー&nbsp;フィールド |目的 |
|------|------|
| **16 ビットの送信元ポート番号** | このフィールドには、TCP パケットが送信されるポートが格納されます。 有効な TCP ポートの範囲は 1 ～ 0xFFFF です。 |
| **16 ビットの宛先ポート** | このフィールドには、パケット送信先の TCP ポートが格納されます。 有効な TCP ポートの範囲は 1 ～ 0xFFFF です。 |
| **32 ビットのシーケンス番号** | このフィールドには、接続のこちら側から送信されるデータのシーケンス番号が格納されます。 元のシーケンスは、2 つの TCP ノード間の最初の接続シーケンス中に確立されます。 その時点以降のすべてのデータ転送で、送信されたバイト数ずつシーケンス番号がインクリメントされます。 |
| **32 ビットの確認応答番号** | このフィールドには、接続のこちら側で受信した最後のバイトに対応するシーケンス番号が格納されます。 これは、以前に送信されたデータが、接続の反対側で正常に受信されたかどうかを判断するために使用されます。 |
| **4 ビットのヘッダー長** | このフィールドには、TCP ヘッダー内の 32 ビット ワードの数が格納されます。 TCP ヘッダーにオプションが存在しない場合、このフィールドは 5 です。 |
| **6 ビットのコード ビット** |このフィールドには、接続に関連付けられたさまざまな制御情報を示すために使用される 6 つの異なるコード ビットが含まれています。 制御ビットは次のように定義されています。<br \> - URG (21): 緊急データが存在します<br \> - ACK (20): 確認応答番号が無効です<br \> - PSH (19): このデータをすぐに処理する<br \> - RST (18): 接続をリセットする<br \> - SYN (17): シーケンス番号を同期する (接続の確立に使用されます)<br \> - FIN (16): 送信元で送信を終了しました (接続を閉じるために使用されます) |
|**16 ビットのウィンドウ** |このフィールドはフロー制御に使用されます。 これには、ソケットが現在受信できるバイト数が格納されます。 これは基本的にフロー制御に使用されます。 送信元は、送信するデータが受信側の公開されたウィンドウに適合することを確認する責任があります。 |
|**16 ビットの TCP チェックサム** |このフィールドには、TCP ヘッダー、パケット データ領域、擬似 IP ヘッダーなど、パケットの 16 ビットのチェックサムが格納されます。 |
|**16 ビットの緊急ポインター** |このフィールドには、緊急データの最後のバイトの正のオフセットが格納されます。 このフィールドは、ヘッダーに URG コード ビットが設定されている場合にのみ有効です。 |

> [!NOTE]  
> *TCP/IP 実装のすべてのヘッダーは、**ビッグ エンディアン** 形式であることが想定されています。この形式では、ワードの最上位バイトが最も小さいバイト アドレスに格納されます。*

### <a name="tcp-enable"></a>TCP 有効化       
TCP 接続とパケット転送を可能にするには、まず、アプリケーションで ***nx_tcp_enable*** サービスを呼び出して TCP を有効にする必要があります。 有効にすると、アプリケーションはすべての TCP サービスに自由にアクセスできるようになります。  

### <a name="tcp-socket-create"></a>TCP ソケットの作成    
TCP ソケットは、アプリケーション スレッドによって、初期化中にまたは実行時に作成されます。 サービスの初期のタイプ、有効期限、およびウィンドウ サイズは、***nx_tcp_socket_create*** サービスによって定義されます。 アプリケーションの TCP ソケットの数に制限はありません。  

### <a name="tcp-checksum"></a>TCP チェックサム     
TCP は、IP 擬似ヘッダー (送信元 IP アドレス、宛先 IP アドレス、プロトコル/長さ IP ワードで構成される)、TCP ヘッダー、および TCP パケット データを対象とする、1 の補数の 16 ビット チェックサムを指定します。 IPv4 と IPv6 で TCP パケット ヘッダーのチェックサムに関して唯一異なる点は、送信元と宛先の IP アドレスが IPv4 では 32 ビット、IPv6 では 128 ビットであることです。 

特定のネットワーク コントローラーでは、ハードウェアで TCP チェックサムの計算と検証を実行できます。 このようなシステムでは、実行時のオーバーヘッドを減らすために、アプリケーションでは、可能な限りハードウェア チェックサム ロジックを使用することができます。 アプリケーションでは、***NX_DISABLE_TCP_TX_CHECKSUM** _ と _*_NX_DISABLE_TCP_RX_CHECKSUM_** を定義することによって、NetX ライブラリからの TCP チェックサム計算ロジックをビルド時に完全に無効にすることができます。 このようにして、TCP チェックサム コードはコンパイルされません。 ただし、オプションの NetX Duo IPsec パッケージがインストールされており、TCP 接続がセキュリティで保護されたチャネルを通過することが必要である場合は、注意が必要です。 この場合、TCP 接続に属するパケット内のデータは既に暗号化されており、ネットワーク ドライバーに存在するほとんどのハードウェア TCP チェックサム モジュールは、暗号化された TCP ペイロードから正確なチェックサム値を生成できません。

この問題に対処するために、アプリケーションでは、TCP チェックサム ロジックをライブラリで使用可能な状態に保ち、インターフェイス機能を使用します。 インターフェイス機能が有効になっていれば、TCP モジュールは、ドライバーでもチェックサム値を計算できる場合に、TCP チェックサムを適切に処理する方法を認識しています。

1) TCP パケットが IPsec プロセスの配下にない場合、ネットワーク インターフェイス ハードウェアでチェックサムを計算できます。 したがって、TCP モジュールではチェックサムの計算を試みません。

2) IPsec パッケージがインストールされており、TCP パケットが IPsec プロセスの配下にある場合、TCP モジュールでは、パケットを IPsec 層に送信する前にソフトウェアでチェックサムを計算します。

### <a name="tcp-port"></a>[TCP ポート]     
TCP ポートは、TCP プロトコルの論理接続ポイントです。 NetX Duo の TCP コンポーネントには、1 ～ 0xFFFF の範囲で、65,535 の有効なポートがあります。 1 つのポートのデータを任意の他の宛先ポートに送信できる UDP とは異なり、TCP ポートは特定のもう 1 つの TCP ポートに接続されており、この接続が確立されたときにのみ、接続を構成する 2 つのポート間でのみデータ転送が行われます。

> [!IMPORTANT]
> *TCP ポートは、UDP ポートと完全に分離されています。たとえば、UDP ポート番号 1 は TCP ポート番号 1 とは関係ありません*。

### <a name="client-server-model"></a>クライアントサーバー モデル     
データ転送に TCP を使用するには、最初に 2 つの TCP ソケット間に接続を確立する必要があります。 接続の確立は、クライアントサーバー形式で行われます。 接続のクライアント側は接続を開始する側であり、サーバー側は、クライアント接続要求を待機してからすべての処理を実行します。

> [!IMPORTANT]
> *マルチホーム デバイスの場合、接続に使用する送信元アドレスと、接続の宛先 IP アドレスに基づいたネクスト ホップ アドレスが NetX Duo によって自動的に決定されます。TCP はユニキャスト (例: 非ブロードキャスト) 宛先アドレスへのパケット送信に制限されているため、送信元 IPv6 アドレスを選択するための "ヒント" は NetX Duo には必要ありません。*

### <a name="tcp-socket-state-machine"></a>TCP ソケットの状態機械      
2 つの TCP ソケット (クライアント 1 つとサーバー 1 つ) 間の接続は複雑で、状態機械方式で管理されます。 各 TCP ソケットは、CLOSED 状態で開始されます。 接続イベントを通じて、各ソケットの状態機械が ESTABLISHED 状態に移行します。この状態で、TCP でのデータ転送の大部分が行われます。 接続の一方の側がデータを送信する必要がなくなった場合、接続は切断されます。 もう一方の側が切断すると、最終的に TCP ソケットは CLOSED 状態に戻ります。 このプロセスは、TCP クライアントとサーバーが接続を確立して閉じるたびに繰り返されます。 図 14 は、TCP 状態機械のさまざまな状態を示しています。

### <a name="tcp-client-connection"></a>TCP クライアント接続       
前述のように、TCP 接続のクライアント側は、TCP サーバーへの接続要求を開始します。 接続要求を行う前に、クライアントの IP インスタンスで TCP を有効にする必要があります。 さらに、***nx_tcp_socket_create** _ サービスを使用して次にクライアントの TCP ソケットを作成し、_ *_nx_tcp_client_socket_bind_** サービスを介してポートにバインドする必要があります。

クライアント ソケットをバインドした後、***nxd_tcp_client_socket_connect*** サービスを使用して、TCP サーバーとの接続を確立します。 接続試行を開始するには、ソケットが CLOSED 状態になっている必要があることに注意してください。 接続を確立するには、まず、NetX Duo で SYN パケットを発行し、サーバーからの SYN ACK パケットを待機します。これは、接続要求の受け入れを示します。 SYN ACK を受信した後、NetX Duo は ACK パケットで応答し、ESTABLISHED 状態にクライアント ソケットを昇格させます。

![TCP 状態機械の状態の図。](./media/user-guide/image24.png)   

**図 14. TCP 状態機械の状態**


> [!WARNING]
> *アプリケーションでは、IPv4 と IPv6 のどちらの TCP 接続にも **nxd_tcp_client_socket_connect** を使用してください。IPv4 TCP 接続については、アプリケーションで **nx_tcp_client_socket_connect** を引き続き使用できますが、**nx_tcp_client_socket_connect** は最終的には非推奨になる予定のため、開発者には **nxd_tcp_client_socket_connect** の使用を推奨しています。*

*同様に、**nxd_tcp_socket_peer_info_get** は IPv4 と IPv6 のどちらの TCP 接続でも機能します。ただし、レガシ アプリケーションでは **nx_tcp_socket_peer_info_get** を引き続き使用できます。開発者には、今後は **nxd_tcp_socket_peer_info_get** を使用することを推奨しています。*

### <a name="tcp-client-disconnection"></a>TCP クライアント切断    
接続の終了は、***nx_tcp_socket_disconnect*** の呼び出しで行われます。 中断が指定されていない場合、クライアント ソケットは RST パケットをサーバー ソケットに送信し、ソケットを CLOSED 状態にします。 それ以外の場合、中断が要求されると、次のように完全な TCP 切断プロトコルが実行されます。 

- サーバーが以前に切断要求を開始した場合 (クライアント ソケットが既に FIN パケットを受信していて、ACK で応答し、CLOSE WAIT 状態にある場合)、NetX Duo ではクライアントの TCP ソケットの状態が LAST ACK 状態に昇格され、FIN パケットが送信されます。 次に、サーバーからの ACK を待機してから切断を完了し、CLOSED 状態に入ります。

- 一方、クライアントが最初に切断要求を開始する場合 (サーバーが切断されていない状態で、ソケットがまだ ESTABLISHED 状態である場合)、NetX Duo では FIN パケットが送信されて切断が開始し、サーバーからの FIN と ACK の受信を待機してから切断を完了してソケットが CLOSED 状態になります。

ソケットの送信キューにパケットが残っている場合、NetX Duo は指定されたタイムアウトの間中断して、パケットが確認されるようにします。 タイムアウトが経過すると、NetX Duo はクライアント ソケットの送信キューを空にします。 

クライアント ソケットからポートのバインドを解除するために、アプリケーションは ***nx_tcp_client_socket_unbind*** を呼び出します。 ソケットは、ポートが解放される前に、CLOSED 状態であるか、切断処理中 (つまり、TIMED WAIT 状態) である必要があります。それ以外の場合は、エラーが返されます。

最後に、アプリケーションがクライアント ソケットを必要としなくなった場合は、***nx_tcp_socket_delete*** を呼び出してソケットを削除します。

### <a name="tcp-server-connection"></a>TCP サーバー接続      
TCP 接続のサーバー側はパッシブです。つまり、サーバーは、クライアントが接続要求を開始するのを待機します。 クライアント接続を受け入れるには、まず、サービス ***nx_tcp_enable** _ を呼び出して、IP インスタンスで TCP を有効にする必要があります。 次に、アプリケーションは _ *_nx_tcp_socket_create_** サービスを使用して TCP ソケットを作成する必要があります。  

また、サーバー ソケットを、接続要求をリッスンするように設定する必要もあります。 これは、***nx_tcp_server_socket_listen*** サービスを使用して行うことができます。 このサービスは、サーバー ソケットを LISTEN 状態にし、指定されたサーバー ポートをソケットにバインドします。

> [!NOTE] 
> *ソケット リッスン コールバック ルーチンを設定するには、アプリケーションで **nx_tcp_server_socket_listen** サービスの tcp_listen_callback 引数に適切なコールバック関数を指定します。このサーバー ポートで新しい接続が要求されるたびに、このアプリケーション コールバック関数が NetX Duo によって実行されます。コールバックでの処理は、アプリケーションで制御されます。*

クライアント接続要求を受け入れるために、アプリケーションは ***nx_tcp_server_socket_accept** _ サービスを呼び出します。 受け入れサービスを呼び出すには、サーバー ソケットが LISTEN 状態または SYN RECEIVED 状態のいずれかである必要があります (つまり、サーバーが LISTEN 状態であり、接続を要求しているクライアントから SYN パケットを受信した状態)。 _ *_nx_tcp_server_socket_accept_** から返される正常の状態は、接続が設定されており、サーバー ソケットが ESTABLISHED 状態であることを示します。

サーバー ソケットに有効な接続がある状態になったら、追加のクライアント接続要求が、*listen_queue_size によって指定された深さまでキューに登録され、*  ***nx_tcp_server_socket_listen** _ サービスに渡されます。 サーバー ポートで以降の接続を処理するには、アプリケーションは使用可能なソケット (つまり、CLOSED 状態のソケット) を使用して _ *_nx_tcp_server_socket_relisten_** を呼び出す必要があります。 ソケットに関連付けられている以前の接続が終了し、ソケットが CLOSED 状態になっている場合は、同じサーバー ソケットを使用できることに注意します。

### <a name="tcp-server-disconnection"></a>TCP サーバー切断     
接続の終了は、***nx_tcp_socket_disconnect*** の呼び出しで行われます。 中断が指定されていない場合、サーバー ソケットは RST パケットをクライアント ソケットに送信し、ソケットを CLOSED 状態にします。 それ以外の場合、中断が要求されると、次のように完全な TCP 切断プロトコルが実行されます。

- クライアントが以前に切断要求を開始した場合 (サーバー ソケットが既に FIN パケットを受信していて、ACK で応答し、CLOSE WAIT 状態にある場合)、NetX Duo は TCP ソケット状態を LAST ACK 状態に昇格し、FIN パケットを送信します。 次に、クライアントからの ACK を待機してから切断を完了し、CLOSED 状態に入ります。

- 一方、サーバーが最初に切断要求を開始する場合 (クライアントが切断されていない状態で、ソケットがまだ ESTABLISHED 状態である場合)、NetX Duo は FIN パケットを送信して切断を開始し、クライアントからの FIN と ACK の受信を待機してから切断を完了してソケットを CLOSED 状態にします。

ソケットの送信キューにパケットが残っている場合、NetX Duo は指定されたタイムアウトの間中断して、それらのパケットが確認されるようにします。 タイムアウトが経過すると、NetX Duo はサーバー ソケットの送信キューをフラッシュします。

切断処理が完了し、サーバー ソケットが CLOSED 状態になった後、このソケットとサーバー ポートの関連付けを終了するために、アプリケーションでは ***nx_tcp_server_socket_unaccept** _ サービスを呼び出す必要があります。 このサービスは、_*_nx_tcp_socket_disconnect_*_ または _*_nx_tcp_server_socket_accept_*_ がエラー状態を返す場合でも、アプリケーションによって呼び出される必要があることに注意します。 _*_nx_tcp_server_socket_unaccept_*_ が返された後、ソケットをクライアントまたはサーバー ソケットとして使用したり、不要になった場合は削除することもできます。 同じサーバー ポートで別のクライアント接続を受け入れる必要がある場合は、このソケットで _ *_nx_tcp_server_socket_relisten_** サービスを呼び出す必要があります。

次のコード セグメントは、一般的な TCP サーバーで使用される一連の呼び出しを示しています。

```c
/* Set up a previously created TCP socket to
   listen on port 12 */
nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1)
{
    /* Wait for a client socket connection request
       for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP
       client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on
       the port. */
    nx_tcp_server_socket_unaccept(&server_socket);
    /* Set up server socket to relisten on the
       same port for the next client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a>MSS 検証      
最大セグメント サイズ (MSS) は、基になる IP レイヤーによって断片化されることなく TCP ホストが受信できる最大バイト数です。 TCP 接続の確立フェーズでは、両端でそれぞれの TCP MSS 値が交換されます。これにより、送信側は、受信側の MSS よりも大きい TCP データ セグメントを送信しません。 NetX Duo TCP モジュールは、接続を確立する前に、必要に応じてピアの公開済み MSS 値を検証します。 既定では、NetX Duo はこのようなチェックを有効にしません。 MSS 検証を実行するアプリケーションでは、NetX Duo ライブラリをビルドするときに ***NX_ENABLE_TCP_MSS_CHECK** _ を定義する必要があり、最小値は _*_NX_TCP_MSS_MINIMUM_*_ で定義します。 _ *_NX_TCP_MSS_MINIMUM_** の下にある MSS 値を持つ受信 TCP 接続はドロップされます。

### <a name="stop-listening-on-a-server-port"></a>サーバー ポートでのリッスン停止    
以前に ***nx_tcp_server_socket_listen** _ サービスの呼び出しで指定されたサーバー ポートでクライアント接続要求をリッスンする必要がなくなった場合、アプリケーションでは、単純に _ *_nx_tcp_server_socket_unlisten_** サービスを呼び出します。 このサービスは、接続を待機しているソケットをすべて CLOSED 状態に戻し、キューに置かれたクライアント接続要求パケットをすべて解放します。 

### <a name="tcp-window-size"></a>TCP ウィンドウ サイズ   
接続のセットアップ フェーズとデータ転送フェーズの両方で、各ポートは、ウィンドウ サイズと呼ばれる処理可能なデータの量を報告します。 データが受信されて処理されると、このウィンドウ サイズは動的に調整されます。 TCP では、送信側は受信側のウィンドウに収まる量のデータのみを送信できます。 基本的に、ウィンドウ サイズは、接続の各方向でのデータ転送のフロー制御を提供します。   

### <a name="tcp-packet-send"></a>TCP パケット送信     
TCP データの送信は、***nx_tcp_socket_send*** 関数を呼び出すことによって簡単に実現できます。 送信されるデータのサイズがソケットの MSS 値または、現在のピアの受信ウィンドウ サイズ (どちらか小さいほう) より大きい場合は、TCP 内部ロジックによって、伝送のための最小 (MSS、ピア受信ウィンドウ) に収まるデータに切り分けられます。 その後、このサービスによってパケットの前に TCP ヘッダーが作成されます (チェックサムの計算も含まれます)。 受信側のウィンドウ サイズが 0 でない場合、呼び出し元は受信側のウィンドウ サイズいっぱいまでデータを送信します。 受信ウィンドウが 0 になった場合、呼び出し元は中断し、受信側のウィンドウ サイズがこのパケットの送信に十分な大きさになるまで待機することがあります。 任意の時点で、同じソケットを介してデータを送信しようとしている間に、複数のスレッドが中断されることがあります。 

> [!WARNING]  
> *NX_PACKET 構造に存在する TCP データは、長いワード境界に配置する必要があります。さらに、プリペンド ポインターとデータの開始ポインターの間に、TCP、IP、および物理メディアのヘッダーを配置するために十分な領域がある必要があります*。

### <a name="tcp-packet-retransmit"></a>TCP パケットの再送信      
以前に送信された TCP パケットは、接続の相手側から ACK が返されるまで、実際には内部的に格納されていました。 転送されたデータがタイムアウト期間内に確認されない場合、保存されているパケットは再送信され、次のタイムアウト期間が設定されます。 ACK を受信すると、内部送信キューの確認応答番号によってカバーされるすべてのパケットが最終的に解放されます。  

> [!WARNING]   
> *nx_tcp_socket_send() が NX_SUCCESS で戻った後、アプリケーションでは、パケットを再利用したり、パケットの内容を変更したりしてはなりません。送信されたパケットは、データがもう一方の端で確認された後、最終的に NetX Duo の内部処理によって解放されます。*

### <a name="tcp-keepalive"></a>TCP Keepalive     
TCP Keepalive 機能を使用すると、ピアが適切に終了せずに切断したかどうか (ピアがクラッシュした場合など) をソケットで検出したり、アイドル状態が長く、特定のネットワーク監視機能が接続を終了するのを防いだりできます。 TCP Keepalive は、データのない TCP フレームを定期的に送信し、シーケンス番号を現在のシーケンス番号よりも 1 小さい値に設定することによって機能します。 このような TCP Keepalive フレームを受け取ると、受信者は、まだ稼動している場合は、現在のシーケンス番号に対して ACK で応答します。 これで、Keepalive トランザクションが完了します。  

既定では、Keepalive 機能は有効になっていません。 この機能を使用するには、NetX Duo ライブラリを ***NX_ENABLE_TCP_KEEPALIVE** _ を定義してビルドする必要があります。 シンボル _ *_NX_TCP_KEEPALIVE_INITIAL_** は、Keepalive フレームが開始されるまでの非アクティブな秒数を指定します。  

### <a name="tcp-packet-receive"></a>TCP パケット受信   
TCP の受信パケット処理 (IP ヘルパー スレッドから呼び出されます) は、さまざまな接続および切断アクションだけでなく、確認応答処理も送信します。 さらに、TCP 受信パケット処理は、受信データを持つパケットを適切な TCP ソケットの受信キューに格納したり、パケットを待機している最初の中断されたスレッドにパケットを配信したりする役割を担います。

### <a name="tcp-receive-notify"></a>TCP 受信通知     
アプリケーション スレッドが複数のソケットから受信したデータを処理する必要がある場合は、***nx_tcp_socket_receive_notify*** 関数を使用する必要があります。 この関数は、ソケットの受信パケット コールバック関数を登録します。 ソケットでパケットが受信されるたびに、コールバック関数が実行されます。  

コールバック関数の内容はアプリケーション固有です。ただし、最も高い可能性として、関数には、パケットが対応するソケットで使用可能であることを処理スレッドに通知するロジックが含まれています。 

### <a name="thread-suspension"></a>スレッドの中断      
前述のように、特定の TCP ポートからデータを受信しようとしている間に、アプリケーション スレッドが中断されることがあります。 そのポートでパケットが受信されると、最初に中断されたスレッドに渡され、そのスレッドが再開されます。 TCP 受信パケットで中断する場合は、オプションのタイムアウトを使用できます。これは、ほとんどの NetX Duo サービスで利用可能な機能です。  

スレッドの中断は、接続 (クライアントとサーバーの両方)、クライアント バインド、および切断サービスでも使用できます。  

### <a name="tcp-socket-statistics-and-errors"></a>TCP ソケットの統計情報とエラー     
有効にすると、NetX Duo TCP ソケット ソフトウェアによって、アプリケーションに役立つ可能性のある、いくつかの統計とエラーが追跡されます。 次の統計およびエラー レポートは、IP/TCP インスタンスごとに保持されます。   

- 送信された TCP パケットの合計数  
- 送信された TCP バイトの合計数  
- 受信した TCP パケットの合計数   
- 受信した TCP バイトの合計数   
- 無効な TCP パケットの合計数   
- ドロップされた TCP 受信パケットの合計数    
- TCP 受信チェックサム エラーの合計数   
- TCP 接続の合計数   
- TCP 切断の合計数   
- ドロップされた TCP 接続の合計数    
- TCP パケットの再送信の合計数   
- 送信された TCP ソケット パケット数   
- 送信された TCP ソケット バイト数   
- 受信した TCP ソケット パケット数   
- 受信した TCP ソケット バイト数   
- TCP ソケット パケットの再送信数    
- キューに登録された TCP ソケット パケット数    
- TCP ソケット チェックサム エラー    
- TCP ソケットの状態    
- TCP ソケット送信キューの深さ    
- TCP ソケット送信ウィンドウ サイズ    
- TCP ソケット受信ウィンドウ サイズ    

これらのすべての統計およびエラー レポートは、合計 TCP 統計情報については ***nx_tcp_info_get** _ サービスを使用し、ソケットごとの TCP 統計情報については _ *_nx_tcp_socket_info_get_** サービスを使用すると、アプリケーションで使用可能になります。

### <a name="tcp-socket-control-block-nx_tcp_socket"></a>TCP ソケット制御ブロック NX_TCP_SOCKET      
各 TCP ソケットの特性は、関連付けられている *NX_TCP_SOCKET* 制御ブロックにあります。これには、IP データ構造へのリンク、ネットワーク接続インターフェイス、バインドされたポート、受信パケット キューなどの有用な情報が格納されます。 この構造体は ***nx_api.h*** ファイルで定義されています。