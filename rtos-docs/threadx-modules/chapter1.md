---
title: 1 章 - 概要
author: philmea
description: この記事では、Azure RTOS ThreadX モジュールの概要を示します
ms.author: philmea
ms.date: 07/15/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 0c9698086468d7bb41c33ebe9fa9d1ebb61b5f1f
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104810313"
---
# <a name="chapter-1-overview"></a><span data-ttu-id="7766e-103">1 章: 概要</span><span class="sxs-lookup"><span data-stu-id="7766e-103">Chapter 1: Overview</span></span>

<span data-ttu-id="7766e-104">ThreadX Module コンポーネントは、アプリケーションの常駐部分とは別に構築されたモジュールを、アプリケーションが動的に読み込むためのインフラストラクチャを提供します。</span><span class="sxs-lookup"><span data-stu-id="7766e-104">The ThreadX Module component provides an infrastructure for applications to dynamically load modules that are built separately from the resident portion of the application.</span></span> <span data-ttu-id="7766e-105">これは、アプリケーション コードのサイズが使用可能なメモリを超えている場合に特に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="7766e-105">This is especially useful in situations where the application code size exceeds available memory.</span></span> <span data-ttu-id="7766e-106">また、コア イメージのデプロイ後に新しい機能を追加する必要がある場合にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="7766e-106">It can also help when new features are required to be added after the core image is deployed.</span></span> <span data-ttu-id="7766e-107">さらに、モジュールの動的な読み込みは、部分的なファームウェアの更新が必要な場合に使用できます。</span><span class="sxs-lookup"><span data-stu-id="7766e-107">In addition, dynamically loading modules can be used when partial firmware updates are required.</span></span>

<span data-ttu-id="7766e-108">読み込まれたモジュールのメモリ保護は、モジュール プリアンブルに指定されているプロパティに応じて省略可能です。</span><span class="sxs-lookup"><span data-stu-id="7766e-108">Memory protection for the loaded module is optional, based on the properties specified in the module preamble.</span></span> <span data-ttu-id="7766e-109">メモリ保護を指定すると、プロセッサのメモリ管理ハードウェアは、モジュールのすべてのスレッドに対してモジュールのコードとデータ メモリへのアクセスのみを許可するように構成されます。</span><span class="sxs-lookup"><span data-stu-id="7766e-109">When memory protection is specified, the processor's memory management hardware is configured such that all threads of the module are only allowed access to the module's code and data memory.</span></span> <span data-ttu-id="7766e-110">無関係なメモリ アクセスや実行は必ずメモリ障害を招き、問題の原因のモジュール スレッドは終了します。</span><span class="sxs-lookup"><span data-stu-id="7766e-110">Any extraneous memory access or execution will result in a memory fault and the offending module thread will be terminated.</span></span> <span data-ttu-id="7766e-111">アプリケーションによってメモリ障害通知コールバックが登録されている場合、これはアプリケーションにメモリ障害を通知するためにも呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="7766e-111">If the application registers a memory fault notification callback, this will also be called to alert the application of the memory fault.</span></span>

<span data-ttu-id="7766e-112">ThreadX Module コンポーネントでは、アプリケーションに依存することによって、モジュールを読み込むことができるメモリ領域を提供します。</span><span class="sxs-lookup"><span data-stu-id="7766e-112">The ThreadX Module component relies on the application to provide a memory area where modules can be loaded.</span></span> <span data-ttu-id="7766e-113">各モジュールの命令領域は、インプレース実行される場合もあれば、RAM モジュールのメモリ領域にコピーされて実行される場合もあります。</span><span class="sxs-lookup"><span data-stu-id="7766e-113">The instruction area of each module may execute in place or be copied into the RAM module memory area for execution.</span></span> <span data-ttu-id="7766e-114">すべての場合において、モジュールのデータ メモリの要件はモジュールのメモリ領域から割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="7766e-114">In all cases, the module data memory requirements are allocated from the module memory area.</span></span>

<span data-ttu-id="7766e-115">同時に読み込むことができるモジュールの数に制限は (使用可能なメモリの量を除き) ありませんが、常駐する Module Manager コードのコピーは 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="7766e-115">There are no limits on the number of modules that can be loaded at the same time (aside from the amount of memory available), while there is only one copy of the resident Module Manager code.</span></span> <span data-ttu-id="7766e-116">図 1 は、Module Manager とモジュール自体の関係を示しています。</span><span class="sxs-lookup"><span data-stu-id="7766e-116">Figure 1 illustrates the relationship of the Module Manager and the modules themselves.</span></span>

![モジュールと Module Manager の関係](media/image2.png)

<span data-ttu-id="7766e-118">**図 1** モジュールと Module Manager</span><span class="sxs-lookup"><span data-stu-id="7766e-118">**Figure 1** Modules and Module Manager</span></span>

<span data-ttu-id="7766e-119">各モジュールには、独自のメモリ領域が必要です。これを定義するのは、アプリケーションの責任です。</span><span class="sxs-lookup"><span data-stu-id="7766e-119">Each module must have its own memory area, which is the application's responsibility to define.</span></span> <span data-ttu-id="7766e-120">モジュールと Module Manager は、モジュールによって要求された ThreadX サービスに対応する事前定義された要求 ID によって、ソフトウェア ディスパッチ関数をとおしてやり取りします。</span><span class="sxs-lookup"><span data-stu-id="7766e-120">The Module and the Module Manager interact through a software dispatch function via pre-defined request IDs that correspond to ThreadX services requested by the module.</span></span> <span data-ttu-id="7766e-121">また、モジュールは、単一スレッドのエントリ ポイントと、必要なスタック サイズ、優先度、モジュール ID、コールバック スレッド スタックのサイズや優先度などを提供する必要があります。この情報は、各モジュールのプリアンブルで定義されます。</span><span class="sxs-lookup"><span data-stu-id="7766e-121">In addition, the module is required to provide a single thread entry point as well as the required stack size, priority, module ID, callback thread stack size/priority, etc. This information is defined in each module's preamble.</span></span>

<span data-ttu-id="7766e-122">Module Manager は、初期モジュール スレッドを作成し、その実行を開始する責任があります。</span><span class="sxs-lookup"><span data-stu-id="7766e-122">The Module Manager is responsible for creating the initial module thread and initiating its execution.</span></span> <span data-ttu-id="7766e-123">いったんモジュールの初期スレッドが実行されたら、モジュールによって行われるすべての ThreadX API 要求を処理するのは Module Manager の責任です。</span><span class="sxs-lookup"><span data-stu-id="7766e-123">Once the module's initial thread is executing, the Module Manager is responsible for fielding all ThreadX API requests made by the module.</span></span> <span data-ttu-id="7766e-124">モジュールには ThreadX API へのフル アクセス権があり、これにはモジュールの中で追加スレッドを作成する機能が含まれます。</span><span class="sxs-lookup"><span data-stu-id="7766e-124">A module has full access to the ThreadX API, including the ability to create additional threads within the module.</span></span>  
  
<span data-ttu-id="7766e-125">モジュールのソース コードの名前付け規則は簡単です。Module Manager のすべてのソース ファイルには ***txm_module_manager_\**** という名前が付けられ、モジュールのみに関連付けられているすべてのファイルは名前の "**_manager_ *_" 部分が省略されます。メイン インクルード ファイル _* _txm_module.h_** は、マネージャーとモジュールのソース コードによって共有されます。</span><span class="sxs-lookup"><span data-stu-id="7766e-125">The module source code naming conventions are straightforward: all Module Manager source files are named ***txm_module_manager_\**** and all files associated exclusively with the module omit the "**_manager_*_" portion of the name. The main include file _*_txm_module.h_** is shared by the manager and module source code.</span></span>
