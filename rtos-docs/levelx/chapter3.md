---
title: Azure RTOS LevelX NAND のサポート
description: 一般に、ファイル システムのような大規模なデータ ストレージでは、LevelX 内で NAND フラッシュ メモリが使用されます。
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3286e4ea7f16b28ff55fc95a87a1e0c313ec4240
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811084"
---
# <a name="chapter-3---azure-rtos-levelx-nand-support"></a>第 3 章 - Azure RTOS LevelX NAND のサポート

一般に、ファイル システムのような大規模なデータ ストレージでは、NAND フラッシュ メモリが使用されます。 NAND メモリは "*ブロック*" で構成されます。 各 NAND ブロック内には、一連の "*ページ*" があります。 NAND ブロックは消去可能です。つまり、NAND ブロック内のすべてのページが消去されます (すべて 1 に設定されます)。 各 NAND ブロック ページには、Azure RTOS LevelX でブックキーピング、不良ブロックの管理、エラーの検出に使用される一連の "*予備バイト*" があります。 NAND ブロック ページは、さまざまなサイズで使用できます。 最も一般的なページ サイズは次のとおりです。 

| **ページ サイズ** | **予備バイト** |
| ------------- | --------------- |
| 256           | 8               |
| 512           | 16              |
| 2048          | 64              |

NAND メモリは、直接アクセスされないという点で、NOR メモリとは異なります。つまり、プロセッサやメモリなどから NAND メモリを直接読み取ることはできません。 制限された回数の消去後にのみ、NAND メモリに書き込むことができます。 また、書き込み要求で設定されたビットがクリアされる場合に、無制限の回数書き込むことができるという点でも NOR メモリと異なります。 最後に、各ページに関連付けられている予備バイトは、NAND フラッシュに固有のものです。 次の表に、一般的な予備バイトの構成を示します。

| **予備バイト** | **バイト番号** | **Configuration**     |
| ------------------------- | -------------- | --------------------- |
| 8                         | バイト 0-2:     | ECC バイト             |
|                           | バイト 3、4、6、7: | LevelX セクター マッピング |
|                           | バイト 5:        | 不良ブロック フラグ        |
| 16                        | バイト 0-3、6-7: | ECC バイト             |
|                           | バイト 8-11:    | LevelX セクター マッピング |
|                           | バイト 12-15:   | 未使用                |
|                           | バイト 5:        | 不良ブロック フラグ        |
| 64                        | バイト 0:        | 不良ブロック フラグ        |
|                           | バイト 2-5:     | LevelX セクター マッピング |
|                           | バイト 6-39:    | 未使用                |
|                           | バイト 40-63:   | ECC バイト             |

LevelX では、各 NAND ページの予備の 4 バイトを利用して、物理 NAND ページにマップされた論理セクターが追跡されます。 これらの 4 バイトは、LevelX 専用の形式で 32 ビット符号なし整数を実装するために使用されます。 32 ビット フィールドの上位ビット (ビット 31) は、論理セクターとページのマッピングが有効であることを示すために使用されます。 このビットが 0 の場合は、このページの情報が無効になります。 次のビット (ビット 30) は、このページが廃止されるプロセス内にあり、新しいセクターが書き込まれていることを示すために使用されます。 ビット 29 は、マッピング エントリの書き込みが完了したことを示すために使用されます。 ビット 29 が 0 の場合、マッピング エントリの書き込みは完了です。 ビット 29 が設定されている場合、マッピング エントリは書き込み処理中でした。 ビット 30 と 29 は、新しいフラッシュ ページを更新するときのパワー ロスの可能性から回復するために使用されます。 最後に、下位 29 ビット (28-0) にページの論理セクター番号が格納されます。

**LevelX マッピング エントリ**

| ビット | 意味 |
| ------ | ------- |
| 31     | 有効なフラグ。 設定され、論理セクターがすべて 1 ではない場合、マッピングが有効であることを示します。 |
| 30     | 廃止されたフラグ。 クリアすると、このマッピングは廃止されるか、廃止のプロセスに入れられます。 |
| 29     | このビットが 0 の場合、マッピング エントリの書き込みが完了します。 |
| 0-28   | この物理ページにマップされている論理セクター (すべて 1 ではない場合)。 |

LevelX では、ブロック消去カウントの各 NAND ブロックの最初のページ、およびブロックがいっぱいになったときのマップされたページのリストも利用されます。 LevelX の NAND ブロックの最初のページの形式を次に示します。

| LevelX ブロック ページ 0 形式 |
|:--------------------------:|
| [ブロック消去カウント]        |
| [ページ 1 セクター マッピング]    |
| ...                        |
| [ページ "n" セクター マッピング]  |
| [0xF0F0F0F0]               |

> [!NOTE]
> ページ マッピング情報は、ブロックがいっぱいになったときにのみ書き込まれます。つまり、ブロックのページがすべて書き込まれています。 これにより、実行時に空きページと論理セクターのマッピングを迅速に検索できます。

## <a name="nand-bad-block-support"></a>NAND 不良ブロックのサポート

NAND メモリには、NOR メモリよりも多くの不良ブロックがある可能性があります。 この原因の大部分は、NAND の製造元が不良ブロックを許可し、このような不良ブロックを回避するようにソフトウェアに要求することで、利益を上げることができるためです。 LevelX では、単に不良ブロックに関するマッピングを行うだけで、NAND の不良ブロック管理が処理されます。

また、LevelX では、基になる LevelX ドライバーで新しい ECC コードを計算するために利用したり、ページの各 256 バイト セクション内でページが読み取られる際に 1 ビットのエラー修正を実行したりするために、256 バイトのハミング エラー修正コード (ECC) 用の API も提供されています。

## <a name="nand-driver-requirements"></a>NAND ドライバーの要件

LevelX には、基になるフラッシュ パーツとハードウェアの実装に固有の基になる NAND フラッシュ ドライバーが必要です。 ドライバーは、API ***lx_nand_flash_open*** を使用した初期化中に、LevelX に指定されます。 LevelX ドライバーのプロトタイプは次のとおりです。

```c
INT nand_driver_initialize(LX_NAND_FLASH *instance);
```

*Instance* パラメーターには、LevelX NAND コントロール ブロックが指定されます。 ドライバー初期化関数では、関連する LevelX インスタンスの他のすべてのドライバー レベル サービスが設定されます。 次の一覧に、各 LevelX NAND インスタンスに必要なサービスを示します。

- ページの読み取り
- ページの書き込み
- ブロック消去
- ブロック消去の確認
- ページ消去の確認
- ブロック状態の取得
- ブロック状態の設定
- ブロック追加バイトの取得
- ブロック追加バイトの設定
- システム エラー ハンドラー

## <a name="driver-initialization"></a>ドライバーの初期化

これらのサービスは、ドライバーの初期化関数内の **LX_NAND_FLASH** インスタンスに関数ポインターを設定することで設定されます。 ドライバー初期化関数では、ブロックの合計数、1 ブロックあたりのページ数、1 ページあたりのバイト数、1 ページをメモリに読み込むのに十分な大きさの RAM 領域が指定されます。 また、ドライバー初期化関数では、**LX_SUCCESS** が返される前に、追加のデバイスまたは実装固有の初期化処理 (あるいは両方) も実行されます。

## <a name="driver-read-page"></a>ドライバーの読み取りページ

LevelX NAND ドライバーの "ページの読み取り" サービスでは、NAND フラッシュの特定のブロック内で特定のページが読み取られます。 すべてのエラー チェックと修正ロジックは、ドライバー サービスの役割です。 成功した場合、LevelX NAND ドライバーから **LX_SUCCESS** が返されます。 成功しなかった場合、LevelX NAND ドライバーから **LX_ERROR** が返されます。 LevelX NAND ドライバーの "ページの読み取り" サービスのプロトタイプは次のとおりです。

```c
INT nand_driver_read_page(
    ULONG block,
    ULONG page,
    ULONG *destination, 
    ULONG words);
```

ここでは、*block* と *page* で読み取られるページが識別され、*destination* と *words* でページのコンテンツが配置される場所と読み取られる 32 ビットのワード数が指定されます。

## <a name="driver-write-page"></a>ドライバーの書き込みページ

LevelX NAND ドライバーの "ページの書き込み" サービスでは、特定のページが NAND フラッシュの指定したブロックに書き込まれます。 すべてのエラー チェックと ECC 計算は、ドライバー サービスの役割です。 成功した場合、LevelX NAND ドライバーから **LX_SUCCESS** が返されます。 成功しなかった場合、LevelX NAND ドライバーから **LX_ERROR** が返されます。 LevelX NAND ドライバーの "ページの書き込み" サービスのプロトタイプは次のとおりです。

```c
INT nand_driver_write_page(
    ULONG block, 
    ULONG page,
    ULONG *source, 
    ULONG words);
```

ここでは、*block* と *page* で書き込まれるページが識別され、*source* と *words* で書き込み元と書き込まれる 32 ビットのワード数が指定されます。

> [!NOTE]
> LevelX では、フラッシュ ページへの書き込み時に、ドライバーに依存して低レベルのエラー検出が行われます。一般に、書き込みに成功したことを確認するために、ページが読み取られ、書き込みバッファーと比較されます。

## <a name="driver-block-erase"></a>ドライバー ブロック消去

LevelX NAND ドライバーの "ブロック消去" サービスでは、NOR フラッシュの指定したブロックが消去されます。 成功した場合、LevelX NAND ドライバーから **LX_SUCCESS** が返されます。 成功しなかった場合、LevelX NAND ドライバーから **LX_ERROR** が返されます。 LevelX NAND ドライバーの "ブロック消去" サービスのプロトタイプは次のとおりです。

```c
INT nand_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

ここでは、*block* で消去するブロックが識別されます。 *erase_count* パラメーターは、診断のために提供されています。 たとえば、消去数が特定のしきい値を超えた場合、ドライバーは、アプリケーション ソフトウェアの別の部分を警告することがあります。

> [!NOTE]
> LevelX では、ブロックの消去時に、ドライバーに依存して低レベルのエラー検出が行われます。一般に、ブロックのすべてのページがすべて 1 であることが確認されます。

## <a name="driver-block-erased-verify"></a>ドライバー ブロック消去の確認

LevelX NAND ドライバーの "ブロック消去の確認" サービスでは、NAND フラッシュの指定したブロックが消去されていることが確認されます。 消去されている場合、LevelX NAND ドライバーから **LX_SUCCESS** が返されます。 ブロックが消去されていない場合、LevelX NAND ドライバーから **LX_ERROR** が返されます。 LevelX NAND ドライバーの "ブロック消去の確認" サービスのプロトタイプは次のとおりです。

```c
INT nand_driver_block_erased_verify(ULONG block);
```

ここでは、*block* で消去されていることを確認するブロックが指定されます。

> [!NOTE]
> LevelX では、ドライバーに依存して、すべてのページと各ページのすべてのバイト (予備バイトとデータ バイトを含む) が消去されている (すべて 1 が含まれている) ことが確認されます。

## <a name="driver-page-erased-verify"></a>ドライバー ページ消去の確認

LevelX NAND ドライバーの "ブロック消去の確認" サービスでは、NAND フラッシュの指定したブロックの指定したページが消去されていることが確認されます。 消去されている場合、LevelX NAND ドライバーから **LX_SUCCESS** が返されます。 ページが消去されていない場合、LevelX NAND ドライバーから **LX_ERROR** が返されます。 LevelX NAND ドライバーの "ページ消去の確認" サービスのプロトタイプは次のとおりです。

```c
INT nand_driver_page_erased_verify(
    ULONG block,  
    ULONG page);
```
ここでは、*block* でブロックが指定され、*page* で消去されていることを確認するページが指定されます。

> [!NOTE]
> LevelX では、ドライバーに依存して、指定したページのすべてのバイト (予備バイトとデータ バイトを含む) が消去されている (すべて 1 が含まれている) ことが確認されます。

## <a name="driver-block-status-get"></a>ドライバー ブロック状態の取得

LevelX NAND ドライバーの "ブロック状態の取得" サービスでは、NAND フラッシュの指定したブロックの不良ブロック フラグが取得されます。 成功した場合、LevelX NAND ドライバーから **LX_SUCCESS** が返されます。 成功しなかった場合、LevelX NAND ドライバーから **LX_ERROR** が返されます。 LevelX NAND ドライバーの "ブロック状態の取得" サービスのプロトタイプは次のとおりです。

```c
INT nand_driver_block_status_get(
    ULONG block,  
    UCHAR *bad_block_byte);
```

ここでは、*block* でブロックが指定され、*bad_block_byte* で不良ブロック フラグの宛先が指定されます。

## <a name="driver-block-status-set"></a>ドライバー ブロック状態の設定

LevelX NAND ドライバーの "ブロック状態の設定" サービスでは、NAND フラッシュの指定したブロックの不良ブロック フラグが設定されます。 成功した場合、LevelX NAND ドライバーから **LX_SUCCESS** が返されます。 成功しなかった場合、LevelX NAND ドライバーから **LX_ERROR** が返されます。 LevelX NAND ドライバーの "ブロック状態の設定" サービスのプロトタイプは次のとおりです。

```c
INT nand_driver_block_status_set(
    ULONG block,
    UCHAR bad_block_byte);
```

ここでは、*block* でブロックが指定され、*bad_block_byte* で不良ブロック フラグの値が指定されます。

## <a name="driver-block-extra-bytes-get"></a>ドライバー ブロック追加バイトの取得

LevelX NAND ドライバーの "ブロック追加バイトの取得" サービスでは、NAND フラッシュの特定のブロックの特定のページに関連付けられた追加バイトが取得されます。 成功した場合、LevelX NAND ドライバーから **LX_SUCCESS** が返されます。 成功しなかった場合、LevelX NAND ドライバーから **LX_ERROR** が返されます。 LevelX NAND ドライバーの "ブロック追加バイトの取得" サービスのプロトタイプは次のとおりです。

```c
INT nand_driver_block_extra_bytes_get(
    ULONG block,  
    ULONG page, 
    UCHAR *destination, 
    UINT size);
```

ここでは、*block* でブロックが指定され、*page* で特定のページが指定され、*destination* で追加バイトの宛先が指定されます。 *size* パラメーターには、取得する追加バイトの数が指定されます。

## <a name="driver-block-extra-bytes-set"></a>ドライバー ブロック追加バイトの設定

LevelX NAND ドライバーの "ブロック追加バイトの設定" サービスでは、NAND フラッシュの特定のブロックの特定のページに追加バイトが設定されます。 成功した場合、LevelX NAND ドライバーから **LX_SUCCESS** が返されます。 成功しなかった場合、LevelX NAND ドライバーから **LX_ERROR** が返されます。 LevelX NAND ドライバーの "ブロック追加バイトの設定" サービスのプロトタイプは次のとおりです。

```c
INT nand_driver_block_extra_bytes_set(
    ULONG block,  
    ULONG page, 
    UCHAR *source, 
    UINT size);
```

ここでは、*block* でブロックが指定され、*page* で特定のページが指定され、*source* で追加バイトのソースが指定されます。 *size* パラメーターには、設定する追加バイトの数が指定されます。

## <a name="driver-system-error"></a>ドライバー システム エラー

LevelX NAND ドライバーの "システム エラー ハンドラー" サービスでは、LevelX で検出されたシステム エラーの処理が設定されます。 このルーチンでの処理は、アプリケーションに依存します。 成功した場合、LevelX NAND ドライバーから **LX_SUCCESS** が返されます。 成功しなかった場合、LevelX NAND ドライバーから **LX_ERROR** が返されます。 LevelX NAND ドライバーの "システム エラー" サービスのプロトタイプは次のとおりです。

```c
INT nand_driver_system_error(
    UINT error_code,  
    ULONG block, 
    ULONG page);
```

ここでは、*block* でブロックが指定され、*page* で *error_code* が表すエラーが発生した特定のページが指定されます。

## <a name="nand-simulated-driver"></a>NAND シミュレート済みドライバー

LevelX では、単純に RAM を使用して NAND フラッシュ部分の操作をシミュレートするシミュレート済み NAND フラッシュ ドライバーが提供されます。 既定では、NAND のシミュレート済みドライバーで、1 ブロックあたり 16 ページで、1 ページあたり 2048 バイトの NAND フラッシュ ブロックが 8 つ提供されます。

シミュレート済み NAND フラッシュ ドライバー初期化関数は、***lx_nand_flash_simulator_initialize** _ であり、_*_lx_nand_flash_simulator.c_** で定義されます。 このドライバーでは、特定の NAND フラッシュ ドライバーを作成するための便利なテンプレートも提供されます。

## <a name="nand-filex-integration"></a>NAND FileX の統合

前述のように、LevelX の操作では FileX が使用されません。 LevelX で提供される論理セクターに生データを格納または取得するために、すべての LevelX API は、アプリケーション ソフトウェアから直接呼び出される場合があります。 ただし、LevelX では FileX もサポートされています。

ファイル ***fx_nand_flash_simulated_driver.c*** には、NAND フラッシュのシミュレーションで使用する FileX ドライバーの例が含まれています。 このドライバーの興味深い点は、2048 バイトのページを使用することで、一般に FileX で使用される 512 バイトの論理セクターと、LevelX シミュレーターへの単一の論理セクターの読み取り/書き込み要求が結合されることです。 これにより、NAND フラッシュ メモリをより効率的に使用できます。 LevelX 用の NAND フラッシュ FileX ドライバーでは、カスタム FileX ドライバーを作成するための効果的な出発点が提供されます。  
  
> [!NOTE]
> FileX NAND フラッシュの形式は、NAND フラッシュで提供されるものよりも小さいセクターの 1 つの完全なブロック サイズである必要があります。 これにより、消耗レベルの処理中に最適なパフォーマンスを得ることができます。 LevelX の消耗平準化アルゴリズムでは、次のような書き込みパフォーマンスを向上させるための追加の手法があります。

1. すべての書き込みが、正確に 1 つ以上のクラスターのサイズになり、正確なクラスター境界で開始されることを確認します。
1. API の FileX ***fx_file_allocate*** クラスを使用して大きなファイル書き込み操作を実行する前に、クラスターを事前に割り当てます。
1. リリース セクター情報を受信するために FileX ドライバーが有効になっていること、およびセクターをリリースするためにドライバーに対して行われた要求が、***lx_nor_flash_sector_release*** を呼び出すことによってドライバーで処理されていることを確認します。
1. ***lx_nand_flash_defragment*** を定期的に使用して、可能な限り多くの NAND ブロックを解放し、書き込みパフォーマンスを向上させることができます。
1. ***lx_nand_flash_extended_cache_enable*** API を使用すると、パフォーマンスを向上させるためにさまざまな NAND ブロック リソースの RAM キャッシュが提供されます。
